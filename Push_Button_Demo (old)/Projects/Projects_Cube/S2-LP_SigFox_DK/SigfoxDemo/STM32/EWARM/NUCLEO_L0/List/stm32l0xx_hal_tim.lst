###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  13:02:33
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_tim.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW6F55.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_tim.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal_tim.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal_tim.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + TIM Time Base Initialization
      9            *           + TIM Time Base Start
     10            *           + TIM Time Base Start Interruption
     11            *           + TIM Time Base Start DMA
     12            *           + TIM Output Compare/PWM Initialization
     13            *           + TIM Output Compare/PWM Channel Configuration
     14            *           + TIM Output Compare/PWM  Start
     15            *           + TIM Output Compare/PWM  Start Interruption
     16            *           + TIM Output Compare/PWM Start DMA
     17            *           + TIM Input Capture Initialization
     18            *           + TIM Input Capture Channel Configuration
     19            *           + TIM Input Capture Start
     20            *           + TIM Input Capture Start Interruption
     21            *           + TIM Input Capture Start DMA
     22            *           + TIM One Pulse Initialization
     23            *           + TIM One Pulse Channel Configuration
     24            *           + TIM One Pulse Start
     25            *           + TIM Encoder Interface Initialization
     26            *           + TIM Encoder Interface Start
     27            *           + TIM Encoder Interface Start Interruption
     28            *           + TIM Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + TIM OCRef clear configuration
     31            *           + TIM External Clock configuration
     32            @verbatim
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include:
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output
     45                 (#) Synchronization circuit to control the timer with external signals and to interconnect
     46                      several timers together.
     47                 (#) Supports incremental encoder for positioning purposes
     48          
     49                      ##### How to use this driver #####
     50            ==============================================================================
     51              [..]
     52               (#) Initialize the TIM low level resources by implementing the following functions
     53                   depending on the selected feature:
     54                     (++) Time Base : HAL_TIM_Base_MspInit()
     55                     (++) Input Capture : HAL_TIM_IC_MspInit()
     56                     (++) Output Compare : HAL_TIM_OC_MspInit()
     57                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     58                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     59                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     60          
     61               (#) Initialize the TIM low level resources :
     62                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     63                  (##) TIM pins configuration
     64                      (+++) Enable the clock for the TIM GPIOs using the following function:
     65                       __HAL_RCC_GPIOx_CLK_ENABLE();
     66                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     67          
     68               (#) The external Clock can be configured, if needed (the default clock is the
     69                   internal clock from the APBx), using the following function:
     70                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     71                   any start function.
     72          
     73               (#) Configure the TIM in the desired functioning mode using one of the
     74                 Initialization function of this driver:
     75                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     76                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
     77                      Output Compare signal.
     78                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
     79                      PWM signal.
     80                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
     81                      external signal.
     82                 (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
     83                      in One Pulse Mode.
     84                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     85          
     86               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     87                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     88                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     89                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     90                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     91                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     92                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     93          
     94               (#) The DMA Burst is managed with the two following functions:
     95                   HAL_TIM_DMABurst_WriteStart()
     96                   HAL_TIM_DMABurst_ReadStart()
     97          
     98              *** Callback registration ***
     99            =============================================
    100          
    101            The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
    102            allows the user to configure dynamically the driver callbacks.
    103          
    104            Use Function @ref HAL_TIM_RegisterCallback() to register a callback.
    105            @ref HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
    106            the Callback ID and a pointer to the user callback function.
    107          
    108            Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default
    109            weak function.
    110            @ref HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
    111            and the Callback ID.
    112          
    113            These functions allow to register/unregister following callbacks:
    114              (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    115              (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    116              (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    117              (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    118              (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    119              (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    120              (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    121              (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    122              (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    123              (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    124              (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    125              (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    126              (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    127              (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    128              (+) TriggerCallback                   : TIM Trigger Callback.
    129              (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    130              (+) IC_CaptureCallback                : TIM Input Capture Callback.
    131              (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    132              (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    133              (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    134              (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    135              (+) ErrorCallback                     : TIM Error Callback.
    136          
    137          By default, after the Init and when the state is HAL_TIM_STATE_RESET
    138          all interrupt callbacks are set to the corresponding weak functions:
    139            examples @ref HAL_TIM_TriggerCallback(), @ref HAL_TIM_ErrorCallback().
    140          
    141            Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
    142            functionalities in the Init / DeInit only when these callbacks are null
    143            (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    144              keep and use the user MspInit / MspDeInit callbacks(registered beforehand)
    145          
    146              Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    147              Exception done MspInit / MspDeInit that can be registered / unregistered
    148              in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    149              thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
    150            In that case first register the MspInit/MspDeInit user callbacks
    151                using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.
    152          
    153                When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
    154                not defined, the callback registration feature is not available and all callbacks
    155                are set to the corresponding weak functions.
    156          
    157            @endverbatim
    158            ******************************************************************************
    159              * @attention
    160            *
    161            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    162            * All rights reserved.</center></h2>
    163            *
    164            * This software component is licensed by ST under BSD 3-Clause license,
    165            * the "License"; You may not use this file except in compliance with the
    166            * License. You may obtain a copy of the License at:
    167            *                        opensource.org/licenses/BSD-3-Clause
    168            *
    169            ******************************************************************************
    170            */
    171          
    172          /* Includes ------------------------------------------------------------------*/
    173          #include "stm32l0xx_hal.h"
    174          
    175          /** @addtogroup STM32L0xx_HAL_Driver
    176            * @{
    177            */
    178          
    179          /** @defgroup TIM TIM
    180            * @brief TIM HAL module driver
    181            * @{
    182            */
    183          
    184          #ifdef HAL_TIM_MODULE_ENABLED
    185          
    186          /* Private typedef -----------------------------------------------------------*/
    187          /* Private define ------------------------------------------------------------*/
    188          /* Private macro -------------------------------------------------------------*/
    189          /* Private variables ---------------------------------------------------------*/
    190          /* Private function prototypes -----------------------------------------------*/
    191          /** @addtogroup TIM_Private_Functions
    192            * @{
    193            */
    194          static void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure);
    195          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    196          static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    197          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    198          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    199          static void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    200          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    201          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    202                                        uint32_t TIM_ICFilter);
    203          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    204          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    205                                        uint32_t TIM_ICFilter);
    206          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    207                                        uint32_t TIM_ICFilter);
    208          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);
    209          static void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
    210                                        uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
    211          static void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState);
    212          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    213          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);
    214          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    215          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);
    216          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    217                                               TIM_SlaveConfigTypeDef *sSlaveConfig);
    218          /**
    219            * @}
    220            */
    221          /* Exported functions --------------------------------------------------------*/
    222          
    223          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    224            * @{
    225            */
    226          
    227          /** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
    228           *  @brief    Time Base functions
    229           *
    230          @verbatim
    231            ==============================================================================
    232                        ##### Time Base functions #####
    233            ==============================================================================
    234            [..]
    235              This section provides functions allowing to:
    236              (+) Initialize and configure the TIM base.
    237              (+) De-initialize the TIM base.
    238              (+) Start the Time Base.
    239              (+) Stop the Time Base.
    240              (+) Start the Time Base and enable interrupt.
    241              (+) Stop the Time Base and disable interrupt.
    242              (+) Start the Time Base and enable DMA transfer.
    243              (+) Stop the Time Base and disable DMA transfer.
    244          
    245          @endverbatim
    246            * @{
    247            */
    248          /**
    249            * @brief  Initializes the TIM Time base Unit according to the specified
    250            *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
    251            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    252            *         requires a timer reset to avoid unexpected direction
    253            *         due to DIR bit readonly in center aligned mode.
    254            *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
    255            * @param  htim TIM Base handle
    256            * @retval HAL status
    257            */

   \                                 In section .text, align 2, keep-with-next
    258          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    259          {
   \                     HAL_TIM_Base_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    260            /* Check the TIM handle allocation */
    261            if (htim == NULL)
   \        0x4   0xD101             BNE      ??HAL_TIM_Base_Init_0
    262            {
    263              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD10             POP      {R4,PC}
    264            }
    265          
    266            /* Check the parameters */
    267            assert_param(IS_TIM_INSTANCE(htim->Instance));
    268            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    269            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    270            assert_param(IS_TIM_PERIOD(htim->Init.Period));
    271            assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
    272            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    273          
    274            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \        0xA   0x2039             MOVS     R0,#+57
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD104             BNE      ??HAL_TIM_Base_Init_1
    275            {
    276              /* Allocate lock resource and initialize it */
    277              htim->Lock = HAL_UNLOCKED;
   \       0x12   0x2138             MOVS     R1,#+56
   \       0x14   0x5460             STRB     R0,[R4, R1]
    278          
    279          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    280              /* Reset interrupt callbacks to legacy weak callbacks */
    281              TIM_ResetCallback(htim);
    282          
    283              if (htim->Base_MspInitCallback == NULL)
    284              {
    285                htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
    286              }
    287              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    288              htim->Base_MspInitCallback(htim);
    289          #else
    290              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    291              HAL_TIM_Base_MspInit(htim);
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x....'....        BL       HAL_TIM_Base_MspInit
    292          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    293            }
    294          
    295            /* Set the TIM state */
    296            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x2139             MOVS     R1,#+57
   \       0x20   0x5460             STRB     R0,[R4, R1]
    297          
    298            /* Set the Time Base configuration */
    299            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x22   0x1D21             ADDS     R1,R4,#+4
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x....'....        BL       TIM_Base_SetConfig
    300          
    301            /* Initialize the TIM state*/
    302            htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x....             B.N      ??Subroutine2_0
    303          
    304            return HAL_OK;
    305          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6A00             LDR      R0,[R0, #+32]
   \        0x4   0x....             LDR      R1,??DataTable9  ;; 0x1111
   \        0x6   0x4001             ANDS     R1,R1,R0
   \        0x8   0xD105             BNE      ??Subroutine2_0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x4388             BICS     R0,R0,R1
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \                     ??Subroutine2_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x2139             MOVS     R1,#+57
   \       0x1A   0x5460             STRB     R0,[R4, R1]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
    306          
    307          /**
    308            * @brief  DeInitializes the TIM Base peripheral
    309            * @param  htim TIM Base handle
    310            * @retval HAL status
    311            */

   \                                 In section .text, align 2, keep-with-next
    312          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    313          {
   \                     HAL_TIM_Base_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    314            /* Check the parameters */
    315            assert_param(IS_TIM_INSTANCE(htim->Instance));
    316          
    317            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x2139             MOVS     R1,#+57
   \        0x8   0x5460             STRB     R0,[R4, R1]
    318          
    319            /* Disable the TIM Peripheral Clock */
    320            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable8  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0xD105             BNE      ??HAL_TIM_Base_DeInit_0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x4388             BICS     R0,R0,R1
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
    321          
    322          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    323            if (htim->Base_MspDeInitCallback == NULL)
    324            {
    325              htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
    326            }
    327            /* DeInit the low level hardware */
    328            htim->Base_MspDeInitCallback(htim);
    329          #else
    330            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    331            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       HAL_TIM_Base_MspDeInit
    332          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    333          
    334            /* Change TIM state */
    335            htim->State = HAL_TIM_STATE_RESET;
   \       0x26   0x....             B.N      ?Subroutine4
    336          
    337            /* Release Lock */
    338            __HAL_UNLOCK(htim);
    339          
    340            return HAL_OK;
    341          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x2239             MOVS     R2,#+57
   \        0x4   0x54A0             STRB     R0,[R4, R2]
   \        0x6   0x2138             MOVS     R1,#+56
   \        0x8   0x5460             STRB     R0,[R4, R1]
   \        0xA   0xBD10             POP      {R4,PC}          ;; return
    342          
    343          /**
    344            * @brief  Initializes the TIM Base MSP.
    345            * @param  htim TIM Base handle
    346            * @retval None
    347            */

   \                                 In section .text, align 2
    348          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    349          {
    350            /* Prevent unused argument(s) compilation warning */
    351            UNUSED(htim);
    352          
    353            /* NOTE : This function should not be modified, when the callback is needed,
    354                      the HAL_TIM_Base_MspInit could be implemented in the user file
    355             */
    356          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    357          
    358          /**
    359            * @brief  DeInitializes TIM Base MSP.
    360            * @param  htim TIM Base handle
    361            * @retval None
    362            */

   \                                 In section .text, align 2
    363          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    364          {
    365            /* Prevent unused argument(s) compilation warning */
    366            UNUSED(htim);
    367          
    368            /* NOTE : This function should not be modified, when the callback is needed,
    369                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    370             */
    371          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    372          
    373          
    374          /**
    375            * @brief  Starts the TIM Base generation.
    376            * @param  htim TIM Base handle
    377            * @retval HAL status
    378            */

   \                                 In section .text, align 2, keep-with-next
    379          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    380          {
    381            uint32_t tmpsmcr;
    382          
    383            /* Check the parameters */
    384            assert_param(IS_TIM_INSTANCE(htim->Instance));
    385          
    386            /* Set the TIM state */
    387            htim->State = HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Start: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \        0x2   0x2239             MOVS     R2,#+57
   \        0x4   0x5481             STRB     R1,[R0, R2]
    388          
    389            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    390            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x688A             LDR      R2,[R1, #+8]
    391            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x0752             LSLS     R2,R2,#+29
   \        0xE   0x0F52             LSRS     R2,R2,#+29
   \       0x10   0x2A06             CMP      R2,#+6
   \       0x12   0xD004             BEQ      ??HAL_TIM_Base_Start_0
    392            {
    393              __HAL_TIM_ENABLE(htim);
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0x6812             LDR      R2,[R2, #+0]
   \       0x18   0x430A             ORRS     R2,R2,R1
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0x601A             STR      R2,[R3, #+0]
    394            }
    395          
    396            /* Change the TIM state*/
    397            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Start_0: (+1)
   \       0x1E   0x....             B.N      ?Subroutine5
    398          
    399            /* Return function status */
    400            return HAL_OK;
    401          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x2239             MOVS     R2,#+57
   \        0x2   0x5481             STRB     R1,[R0, R2]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
    402          
    403          /**
    404            * @brief  Stops the TIM Base generation.
    405            * @param  htim TIM Base handle
    406            * @retval HAL status
    407            */

   \                                 In section .text, align 2, keep-with-next
    408          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    409          {
    410            /* Check the parameters */
    411            assert_param(IS_TIM_INSTANCE(htim->Instance));
    412          
    413            /* Set the TIM state */
    414            htim->State = HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Stop: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \        0x2   0x2239             MOVS     R2,#+57
   \        0x4   0x5481             STRB     R1,[R0, R2]
    415          
    416            /* Disable the Peripheral */
    417            __HAL_TIM_DISABLE(htim);
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x6A09             LDR      R1,[R1, #+32]
   \        0xA   0x....             LDR      R2,??DataTable8  ;; 0x1111
   \        0xC   0x400A             ANDS     R2,R2,R1
   \        0xE   0xD105             BNE      ??HAL_TIM_Base_Stop_0
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x6809             LDR      R1,[R1, #+0]
   \       0x14   0x2201             MOVS     R2,#+1
   \       0x16   0x4391             BICS     R1,R1,R2
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0x6011             STR      R1,[R2, #+0]
    418          
    419            /* Change the TIM state*/
    420            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E                      REQUIRE ?Subroutine5
   \       0x1E                      ;; // Fall through to label ?Subroutine5
    421          
    422            /* Return function status */
    423            return HAL_OK;
    424          }
    425          
    426          /**
    427            * @brief  Starts the TIM Base generation in interrupt mode.
    428            * @param  htim TIM Base handle
    429            * @retval HAL status
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    432          {
    433            uint32_t tmpsmcr;
    434          
    435            /* Check the parameters */
    436            assert_param(IS_TIM_INSTANCE(htim->Instance));
    437          
    438            /* Enable the TIM Update interrupt */
    439            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Start_IT: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x68C2             LDR      R2,[R0, #+12]
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x60C2             STR      R2,[R0, #+12]
    440          
    441            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    442            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \        0xA   0x6882             LDR      R2,[R0, #+8]
    443            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \        0xC   0x0752             LSLS     R2,R2,#+29
   \        0xE   0x0F52             LSRS     R2,R2,#+29
   \       0x10   0x2A06             CMP      R2,#+6
   \       0x12   0xD002             BEQ      ??HAL_TIM_Base_Start_IT_0
    444            {
    445              __HAL_TIM_ENABLE(htim);
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0x4311             ORRS     R1,R1,R2
   \       0x18   0x6001             STR      R1,[R0, #+0]
    446            }
    447          
    448            /* Return function status */
    449            return HAL_OK;
   \                     ??HAL_TIM_Base_Start_IT_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x4770             BX       LR               ;; return
    450          }
    451          
    452          /**
    453            * @brief  Stops the TIM Base generation in interrupt mode.
    454            * @param  htim TIM Base handle
    455            * @retval HAL status
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    458          {
    459            /* Check the parameters */
    460            assert_param(IS_TIM_INSTANCE(htim->Instance));
    461            /* Disable the TIM Update interrupt */
    462            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x43C9             MVNS     R1,R1            ;; #-2
   \        0x6   0x68C2             LDR      R2,[R0, #+12]
   \        0x8   0x400A             ANDS     R2,R2,R1
   \        0xA   0x60C2             STR      R2,[R0, #+12]
    463          
    464            /* Disable the Peripheral */
    465            __HAL_TIM_DISABLE(htim);
   \        0xC   0x6A02             LDR      R2,[R0, #+32]
   \        0xE   0x....             LDR      R3,??DataTable9  ;; 0x1111
   \       0x10   0x4013             ANDS     R3,R3,R2
   \       0x12   0xD102             BNE      ??HAL_TIM_Base_Stop_IT_0
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0x4011             ANDS     R1,R1,R2
   \       0x18   0x6001             STR      R1,[R0, #+0]
    466          
    467            /* Return function status */
    468            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x4770             BX       LR               ;; return
    469          }
    470          
    471          /**
    472            * @brief  Starts the TIM Base generation in DMA mode.
    473            * @param  htim TIM Base handle
    474            * @param  pData The source Buffer address.
    475            * @param  Length The length of data to be transferred from memory to peripheral.
    476            * @retval HAL status
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    479          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0013             MOVS     R3,R2
    480            uint32_t tmpsmcr;
    481          
    482            /* Check the parameters */
    483            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    484          
    485            if ((htim->State == HAL_TIM_STATE_BUSY))
   \        0x6   0x2039             MOVS     R0,#+57
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD02F             BEQ      ??HAL_TIM_Base_Start_DMA_0
    486            {
    487              return HAL_BUSY;
    488            }
    489            else if ((htim->State == HAL_TIM_STATE_READY))
   \        0xE   0x2039             MOVS     R0,#+57
   \       0x10   0x5C20             LDRB     R0,[R4, R0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD106             BNE      ??HAL_TIM_Base_Start_DMA_1
    490            {
    491              if ((pData == NULL) && (Length > 0U))
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD101             BNE      ??HAL_TIM_Base_Start_DMA_2
   \       0x1A   0x0018             MOVS     R0,R3
   \       0x1C   0xD112             BNE      ??HAL_TIM_Base_Start_DMA_3
    492              {
    493                return HAL_ERROR;
    494              }
    495              else
    496              {
    497                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x2239             MOVS     R2,#+57
   \       0x22   0x54A0             STRB     R0,[R4, R2]
    498              }
    499            }
    500            else
    501            {
    502              /* nothing to do */
    503            }
    504          
    505            /* Set the DMA Period elapsed callbacks */
    506            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \       0x24   0x....             LDR      R0,??DataTable9_1
   \       0x26   0x69E2             LDR      R2,[R4, #+28]
   \       0x28   0x62D0             STR      R0,[R2, #+44]
    507            htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x2A   0x....             LDR      R0,??DataTable9_2
   \       0x2C   0x69E2             LDR      R2,[R4, #+28]
   \       0x2E   0x6310             STR      R0,[R2, #+48]
    508          
    509            /* Set the DMA error callback */
    510            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x30   0x....             LDR      R0,??DataTable9_3
   \       0x32   0x69E2             LDR      R2,[R4, #+28]
   \       0x34   0x6350             STR      R0,[R2, #+52]
    511          
    512            /* Enable the DMA channel */
    513            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
   \       0x36   0x6822             LDR      R2,[R4, #+0]
   \       0x38   0x322C             ADDS     R2,R2,#+44
   \       0x3A   0x69E0             LDR      R0,[R4, #+28]
   \       0x3C   0x....'....        BL       HAL_DMA_Start_IT
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD001             BEQ      ??HAL_TIM_Base_Start_DMA_4
    514            {
    515              return HAL_ERROR;
   \                     ??HAL_TIM_Base_Start_DMA_3: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xBD10             POP      {R4,PC}
    516            }
    517          
    518            /* Enable the TIM Update DMA request */
    519            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     ??HAL_TIM_Base_Start_DMA_4: (+1)
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x68C1             LDR      R1,[R0, #+12]
   \       0x4C   0x2280             MOVS     R2,#+128
   \       0x4E   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \       0x50   0x430A             ORRS     R2,R2,R1
   \       0x52   0x60C2             STR      R2,[R0, #+12]
    520          
    521            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    522            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6880             LDR      R0,[R0, #+8]
    523            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x58   0x0740             LSLS     R0,R0,#+29
   \       0x5A   0x0F40             LSRS     R0,R0,#+29
   \       0x5C   0x2806             CMP      R0,#+6
   \       0x5E   0xD005             BEQ      ??HAL_TIM_Base_Start_DMA_5
    524            {
    525              __HAL_TIM_ENABLE(htim);
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0x2101             MOVS     R1,#+1
   \       0x66   0x4301             ORRS     R1,R1,R0
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x6001             STR      R1,[R0, #+0]
    526            }
    527          
    528            /* Return function status */
    529            return HAL_OK;
   \                     ??HAL_TIM_Base_Start_DMA_5: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \       0x6E   0xBD10             POP      {R4,PC}          ;; return
    530          }
    531          
    532          /**
    533            * @brief  Stops the TIM Base generation in DMA mode.
    534            * @param  htim TIM Base handle
    535            * @retval HAL status
    536            */

   \                                 In section .text, align 2, keep-with-next
    537          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    538          {
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    539            /* Check the parameters */
    540            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    541          
    542            /* Disable the TIM Update DMA request */
    543            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C1             LDR      R1,[R0, #+12]
   \        0x8   0x....             LDR      R2,??DataTable10  ;; 0xfffffeff
   \        0xA   0x400A             ANDS     R2,R2,R1
   \        0xC   0x60C2             STR      R2,[R0, #+12]
    544          
    545            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \        0xE   0x69E0             LDR      R0,[R4, #+28]
   \       0x10   0x....'....        BL       HAL_DMA_Abort_IT
    546          
    547            /* Disable the Peripheral */
    548            __HAL_TIM_DISABLE(htim);
   \       0x14   0x....             B.N      ?Subroutine2
    549          
    550            /* Change the htim state */
    551            htim->State = HAL_TIM_STATE_READY;
    552          
    553            /* Return function status */
    554            return HAL_OK;
    555          }
    556          
    557          /**
    558            * @}
    559            */
    560          
    561          /** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
    562           *  @brief    TIM Output Compare functions
    563           *
    564          @verbatim
    565            ==============================================================================
    566                            ##### TIM Output Compare functions #####
    567            ==============================================================================
    568            [..]
    569              This section provides functions allowing to:
    570              (+) Initialize and configure the TIM Output Compare.
    571              (+) De-initialize the TIM Output Compare.
    572              (+) Start the TIM Output Compare.
    573              (+) Stop the TIM Output Compare.
    574              (+) Start the TIM Output Compare and enable interrupt.
    575              (+) Stop the TIM Output Compare and disable interrupt.
    576              (+) Start the TIM Output Compare and enable DMA transfer.
    577              (+) Stop the TIM Output Compare and disable DMA transfer.
    578          
    579          @endverbatim
    580            * @{
    581            */
    582          /**
    583            * @brief  Initializes the TIM Output Compare according to the specified
    584            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
    585            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    586            *         requires a timer reset to avoid unexpected direction
    587            *         due to DIR bit readonly in center aligned mode.
    588            *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
    589            * @param  htim TIM Output Compare handle
    590            * @retval HAL status
    591            */

   \                                 In section .text, align 2, keep-with-next
    592          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
    593          {
   \                     HAL_TIM_OC_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    594            /* Check the TIM handle allocation */
    595            if (htim == NULL)
   \        0x4   0xD101             BNE      ??HAL_TIM_OC_Init_0
    596            {
    597              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD10             POP      {R4,PC}
    598            }
    599          
    600            /* Check the parameters */
    601            assert_param(IS_TIM_INSTANCE(htim->Instance));
    602            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    603            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    604            assert_param(IS_TIM_PERIOD(htim->Init.Period));
    605            assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
    606            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    607          
    608            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \        0xA   0x2039             MOVS     R0,#+57
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD104             BNE      ??HAL_TIM_OC_Init_1
    609            {
    610              /* Allocate lock resource and initialize it */
    611              htim->Lock = HAL_UNLOCKED;
   \       0x12   0x2138             MOVS     R1,#+56
   \       0x14   0x5460             STRB     R0,[R4, R1]
    612          
    613          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    614              /* Reset interrupt callbacks to legacy weak callbacks */
    615              TIM_ResetCallback(htim);
    616          
    617              if (htim->OC_MspInitCallback == NULL)
    618              {
    619                htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
    620              }
    621              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    622              htim->OC_MspInitCallback(htim);
    623          #else
    624              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    625              HAL_TIM_OC_MspInit(htim);
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x....'....        BL       HAL_TIM_OC_MspInit
    626          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    627            }
    628          
    629            /* Set the TIM state */
    630            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x2139             MOVS     R1,#+57
   \       0x20   0x5460             STRB     R0,[R4, R1]
    631          
    632            /* Init the base time for the Output Compare */
    633            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
   \       0x22   0x1D21             ADDS     R1,R4,#+4
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x....'....        BL       TIM_Base_SetConfig
    634          
    635            /* Initialize the TIM state*/
    636            htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x....             B.N      ??Subroutine2_0
    637          
    638            return HAL_OK;
    639          }
    640          
    641          /**
    642            * @brief  DeInitializes the TIM peripheral
    643            * @param  htim TIM Output Compare handle
    644            * @retval HAL status
    645            */

   \                                 In section .text, align 2, keep-with-next
    646          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    647          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    648            /* Check the parameters */
    649            assert_param(IS_TIM_INSTANCE(htim->Instance));
    650          
    651            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x2139             MOVS     R1,#+57
   \        0x8   0x5460             STRB     R0,[R4, R1]
    652          
    653            /* Disable the TIM Peripheral Clock */
    654            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable8  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0xD105             BNE      ??HAL_TIM_OC_DeInit_0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x4388             BICS     R0,R0,R1
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
    655          
    656          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    657            if (htim->OC_MspDeInitCallback == NULL)
    658            {
    659              htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
    660            }
    661            /* DeInit the low level hardware */
    662            htim->OC_MspDeInitCallback(htim);
    663          #else
    664            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    665            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       HAL_TIM_OC_MspDeInit
    666          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    667          
    668            /* Change TIM state */
    669            htim->State = HAL_TIM_STATE_RESET;
   \       0x26                      REQUIRE ?Subroutine4
   \       0x26                      ;; // Fall through to label ?Subroutine4
    670          
    671            /* Release Lock */
    672            __HAL_UNLOCK(htim);
    673          
    674            return HAL_OK;
    675          }
    676          
    677          /**
    678            * @brief  Initializes the TIM Output Compare MSP.
    679            * @param  htim TIM Output Compare handle
    680            * @retval None
    681            */

   \                                 In section .text, align 2
    682          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    683          {
    684            /* Prevent unused argument(s) compilation warning */
    685            UNUSED(htim);
    686          
    687            /* NOTE : This function should not be modified, when the callback is needed,
    688                      the HAL_TIM_OC_MspInit could be implemented in the user file
    689             */
    690          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    691          
    692          /**
    693            * @brief  DeInitializes TIM Output Compare MSP.
    694            * @param  htim TIM Output Compare handle
    695            * @retval None
    696            */

   \                                 In section .text, align 2
    697          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    698          {
    699            /* Prevent unused argument(s) compilation warning */
    700            UNUSED(htim);
    701          
    702            /* NOTE : This function should not be modified, when the callback is needed,
    703                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    704             */
    705          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    706          
    707          /**
    708            * @brief  Starts the TIM Output Compare signal generation.
    709            * @param  htim TIM Output Compare handle
    710            * @param  Channel TIM Channel to be enabled
    711            *          This parameter can be one of the following values:
    712            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    713            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    714            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    715            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    716            * @retval HAL status
    717            */

   \                                 In section .text, align 2, keep-with-next
    718          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    719          {
   \                     HAL_TIM_OC_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    720            uint32_t tmpsmcr;
    721          
    722            /* Check the parameters */
    723            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    724          
    725            /* Enable the Output compare channel */
    726            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x4   0x....             B.N      ??Subroutine0_0
    727          
    728            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    729            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    730            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    731            {
    732              __HAL_TIM_ENABLE(htim);
    733            }
    734          
    735            /* Return function status */
    736            return HAL_OK;
    737          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x0004             MOVS     R4,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xD006             BEQ      ??Subroutine0_1
   \        0x6   0x2904             CMP      R1,#+4
   \        0x8   0xD008             BEQ      ??Subroutine0_2
   \        0xA   0x2908             CMP      R1,#+8
   \        0xC   0xD00A             BEQ      ??Subroutine0_3
   \        0xE   0x290C             CMP      R1,#+12
   \       0x10   0xD00C             BEQ      ??Subroutine0_4
   \       0x12   0xE010             B        ??Subroutine0_0
   \                     ??Subroutine0_1: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C2             LDR      R2,[R0, #+12]
   \       0x18   0x2302             MOVS     R3,#+2
   \       0x1A   0xE00A             B        ??Subroutine0_5
   \                     ??Subroutine0_2: (+1)
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x68C2             LDR      R2,[R0, #+12]
   \       0x20   0x2304             MOVS     R3,#+4
   \       0x22   0xE006             B        ??Subroutine0_5
   \                     ??Subroutine0_3: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x68C2             LDR      R2,[R0, #+12]
   \       0x28   0x2308             MOVS     R3,#+8
   \       0x2A   0xE002             B        ??Subroutine0_5
   \                     ??Subroutine0_4: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x68C2             LDR      R2,[R0, #+12]
   \       0x30   0x2310             MOVS     R3,#+16
   \                     ??Subroutine0_5: (+1)
   \       0x32   0x4313             ORRS     R3,R3,R2
   \       0x34   0x60C3             STR      R3,[R0, #+12]
   \                     ??Subroutine0_0: (+1)
   \       0x36   0x2201             MOVS     R2,#+1
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x....'....        BL       TIM_CCxChannelCmd
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6881             LDR      R1,[R0, #+8]
   \       0x42   0x0749             LSLS     R1,R1,#+29
   \       0x44   0x0F49             LSRS     R1,R1,#+29
   \       0x46   0x2906             CMP      R1,#+6
   \       0x48   0xD003             BEQ      ??Subroutine0_6
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0x2201             MOVS     R2,#+1
   \       0x4E   0x430A             ORRS     R2,R2,R1
   \       0x50   0x6002             STR      R2,[R0, #+0]
   \                     ??Subroutine0_6: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xBD10             POP      {R4,PC}          ;; return
    738          
    739          /**
    740            * @brief  Stops the TIM Output Compare signal generation.
    741            * @param  htim TIM Output Compare handle
    742            * @param  Channel TIM Channel to be disabled
    743            *          This parameter can be one of the following values:
    744            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    745            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    746            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    747            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    748            * @retval HAL status
    749            */

   \                                 In section .text, align 2, keep-with-next
    750          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    751          {
   \                     HAL_TIM_OC_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    752            /* Check the parameters */
    753            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    754          
    755            /* Disable the Output compare channel */
    756            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x4   0x....             B.N      ??Subroutine1_0
    757          
    758            /* Disable the Peripheral */
    759            __HAL_TIM_DISABLE(htim);
    760          
    761            /* Return function status */
    762            return HAL_OK;
    763          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x0004             MOVS     R4,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xD006             BEQ      ??Subroutine1_2
   \        0x6   0x2904             CMP      R1,#+4
   \        0x8   0xD008             BEQ      ??Subroutine1_3
   \        0xA   0x2908             CMP      R1,#+8
   \        0xC   0xD00A             BEQ      ??Subroutine1_4
   \        0xE   0x290C             CMP      R1,#+12
   \       0x10   0xD00C             BEQ      ??Subroutine1_5
   \       0x12   0xE010             B        ??Subroutine1_0
   \                     ??Subroutine1_2: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C2             LDR      R2,[R0, #+12]
   \       0x18   0x2302             MOVS     R3,#+2
   \       0x1A   0xE00A             B        ??Subroutine1_6
   \                     ??Subroutine1_3: (+1)
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x68C2             LDR      R2,[R0, #+12]
   \       0x20   0x2304             MOVS     R3,#+4
   \       0x22   0xE006             B        ??Subroutine1_6
   \                     ??Subroutine1_4: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x68C2             LDR      R2,[R0, #+12]
   \       0x28   0x2308             MOVS     R3,#+8
   \       0x2A   0xE002             B        ??Subroutine1_6
   \                     ??Subroutine1_5: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x68C2             LDR      R2,[R0, #+12]
   \       0x30   0x2310             MOVS     R3,#+16
   \                     ??Subroutine1_6: (+1)
   \       0x32   0x439A             BICS     R2,R2,R3
   \       0x34   0x60C2             STR      R2,[R0, #+12]
   \                     ??Subroutine1_0: (+1)
   \       0x36   0x2200             MOVS     R2,#+0
   \                     ??Subroutine1_1: (+1)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x....'....        BL       TIM_CCxChannelCmd
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6A01             LDR      R1,[R0, #+32]
   \       0x42   0x....             LDR      R2,??DataTable14  ;; 0x1111
   \       0x44   0x400A             ANDS     R2,R2,R1
   \       0x46   0xD103             BNE      ??Subroutine1_7
   \       0x48   0x6801             LDR      R1,[R0, #+0]
   \       0x4A   0x2201             MOVS     R2,#+1
   \       0x4C   0x4391             BICS     R1,R1,R2
   \       0x4E   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine1_7: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xBD10             POP      {R4,PC}          ;; return
    764          
    765          /**
    766            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    767            * @param  htim TIM Output Compare handle
    768            * @param  Channel TIM Channel to be enabled
    769            *          This parameter can be one of the following values:
    770            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    771            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    772            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    773            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    774            * @retval HAL status
    775            */

   \                                 In section .text, align 2, keep-with-next
    776          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    777          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             B.N      ?Subroutine0
    778            uint32_t tmpsmcr;
    779          
    780            /* Check the parameters */
    781            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    782          
    783            switch (Channel)
    784            {
    785              case TIM_CHANNEL_1:
    786              {
    787                /* Enable the TIM Capture/Compare 1 interrupt */
    788                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    789                break;
    790              }
    791          
    792              case TIM_CHANNEL_2:
    793              {
    794                /* Enable the TIM Capture/Compare 2 interrupt */
    795                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
    796                break;
    797              }
    798          
    799              case TIM_CHANNEL_3:
    800              {
    801                /* Enable the TIM Capture/Compare 3 interrupt */
    802                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
    803                break;
    804              }
    805          
    806              case TIM_CHANNEL_4:
    807              {
    808                /* Enable the TIM Capture/Compare 4 interrupt */
    809                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
    810                break;
    811              }
    812          
    813              default:
    814                break;
    815            }
    816          
    817            /* Enable the Output compare channel */
    818            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    819          
    820            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    821            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    822            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    823            {
    824              __HAL_TIM_ENABLE(htim);
    825            }
    826          
    827            /* Return function status */
    828            return HAL_OK;
    829          }
    830          
    831          /**
    832            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    833            * @param  htim TIM Output Compare handle
    834            * @param  Channel TIM Channel to be disabled
    835            *          This parameter can be one of the following values:
    836            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    837            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    838            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    839            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    840            * @retval HAL status
    841            */

   \                                 In section .text, align 2, keep-with-next
    842          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    843          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             B.N      ?Subroutine1
    844            /* Check the parameters */
    845            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    846          
    847            switch (Channel)
    848            {
    849              case TIM_CHANNEL_1:
    850              {
    851                /* Disable the TIM Capture/Compare 1 interrupt */
    852                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    853                break;
    854              }
    855          
    856              case TIM_CHANNEL_2:
    857              {
    858                /* Disable the TIM Capture/Compare 2 interrupt */
    859                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
    860                break;
    861              }
    862          
    863              case TIM_CHANNEL_3:
    864              {
    865                /* Disable the TIM Capture/Compare 3 interrupt */
    866                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
    867                break;
    868              }
    869          
    870              case TIM_CHANNEL_4:
    871              {
    872                /* Disable the TIM Capture/Compare 4 interrupt */
    873                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
    874                break;
    875              }
    876          
    877              default:
    878                break;
    879            }
    880          
    881            /* Disable the Output compare channel */
    882            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    883          
    884            /* Disable the Peripheral */
    885            __HAL_TIM_DISABLE(htim);
    886          
    887            /* Return function status */
    888            return HAL_OK;
    889          }
    890          
    891          /**
    892            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    893            * @param  htim TIM Output Compare handle
    894            * @param  Channel TIM Channel to be enabled
    895            *          This parameter can be one of the following values:
    896            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    897            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    898            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    899            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    900            * @param  pData The source Buffer address.
    901            * @param  Length The length of data to be transferred from memory to TIM peripheral
    902            * @retval HAL status
    903            */

   \                                 In section .text, align 2, keep-with-next
    904          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    905          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0011             MOVS     R1,R2
    906             uint32_t tmpsmcr;
    907          
    908            /* Check the parameters */
    909            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    910          
    911            if ((htim->State == HAL_TIM_STATE_BUSY))
   \        0x8   0x2039             MOVS     R0,#+57
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD073             BEQ      ??HAL_TIM_OC_Start_DMA_0
    912            {
    913              return HAL_BUSY;
    914            }
    915            else if ((htim->State == HAL_TIM_STATE_READY))
   \       0x10   0x2039             MOVS     R0,#+57
   \       0x12   0x5C20             LDRB     R0,[R4, R0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD106             BNE      ??HAL_TIM_OC_Start_DMA_1
    916            {
    917              if ((pData == NULL) && (Length > 0U))
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD101             BNE      ??HAL_TIM_OC_Start_DMA_2
   \       0x1C   0x0018             MOVS     R0,R3
   \       0x1E   0xD151             BNE      ??HAL_TIM_OC_Start_DMA_3
    918              {
    919                return HAL_ERROR;
    920              }
    921              else
    922              {
    923                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x2239             MOVS     R2,#+57
   \       0x24   0x54A0             STRB     R0,[R4, R2]
    924              }
    925            }
    926            else
    927            {
    928              /* nothing to do */
    929            }
    930          
    931            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \       0x26   0x....             LDR      R0,??DataTable9_3
   \       0x28   0x....             LDR      R2,??DataTable10_1
   \       0x2A   0x....             LDR      R6,??DataTable10_2
   \       0x2C   0x002F             MOVS     R7,R5
   \       0x2E   0xD006             BEQ      ??HAL_TIM_OC_Start_DMA_4
   \       0x30   0x2D04             CMP      R5,#+4
   \       0x32   0xD016             BEQ      ??HAL_TIM_OC_Start_DMA_5
   \       0x34   0x2D08             CMP      R5,#+8
   \       0x36   0xD026             BEQ      ??HAL_TIM_OC_Start_DMA_6
   \       0x38   0x2D0C             CMP      R5,#+12
   \       0x3A   0xD036             BEQ      ??HAL_TIM_OC_Start_DMA_7
   \       0x3C   0xE04A             B        ??HAL_TIM_OC_Start_DMA_8
    932            {
    933              case TIM_CHANNEL_1:
    934              {
    935                /* Set the DMA compare callbacks */
    936                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \       0x3E   0x6A27             LDR      R7,[R4, #+32]
   \       0x40   0x62FE             STR      R6,[R7, #+44]
    937                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x42   0x6A26             LDR      R6,[R4, #+32]
   \       0x44   0x6332             STR      R2,[R6, #+48]
    938          
    939                /* Set the DMA error callback */
    940                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x46   0x6A22             LDR      R2,[R4, #+32]
   \       0x48   0x6350             STR      R0,[R2, #+52]
    941          
    942                /* Enable the DMA channel */
    943                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \       0x4A   0x6822             LDR      R2,[R4, #+0]
   \       0x4C   0x3234             ADDS     R2,R2,#+52
   \       0x4E   0x6A20             LDR      R0,[R4, #+32]
   \       0x50   0x....'....        BL       HAL_DMA_Start_IT
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD135             BNE      ??HAL_TIM_OC_Start_DMA_3
    944                {
    945                  return HAL_ERROR;
    946                }
    947          
    948                /* Enable the TIM Capture/Compare 1 DMA request */
    949                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x68C1             LDR      R1,[R0, #+12]
   \       0x5C   0x2280             MOVS     R2,#+128
   \       0x5E   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \       0x60   0xE036             B        ??HAL_TIM_OC_Start_DMA_9
    950                break;
    951              }
    952          
    953              case TIM_CHANNEL_2:
    954              {
    955                /* Set the DMA compare callbacks */
    956                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \       0x62   0x6A67             LDR      R7,[R4, #+36]
   \       0x64   0x62FE             STR      R6,[R7, #+44]
    957                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x66   0x6A66             LDR      R6,[R4, #+36]
   \       0x68   0x6332             STR      R2,[R6, #+48]
    958          
    959                /* Set the DMA error callback */
    960                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x6A   0x6A62             LDR      R2,[R4, #+36]
   \       0x6C   0x6350             STR      R0,[R2, #+52]
    961          
    962                /* Enable the DMA channel */
    963                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \       0x6E   0x6822             LDR      R2,[R4, #+0]
   \       0x70   0x3238             ADDS     R2,R2,#+56
   \       0x72   0x6A60             LDR      R0,[R4, #+36]
   \       0x74   0x....'....        BL       HAL_DMA_Start_IT
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD123             BNE      ??HAL_TIM_OC_Start_DMA_3
    964                {
    965                  return HAL_ERROR;
    966                }
    967          
    968                /* Enable the TIM Capture/Compare 2 DMA request */
    969                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x68C1             LDR      R1,[R0, #+12]
   \       0x80   0x2280             MOVS     R2,#+128
   \       0x82   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \       0x84   0xE024             B        ??HAL_TIM_OC_Start_DMA_9
    970                break;
    971              }
    972          
    973              case TIM_CHANNEL_3:
    974              {
    975                /* Set the DMA compare callbacks */
    976                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \       0x86   0x6AA7             LDR      R7,[R4, #+40]
   \       0x88   0x62FE             STR      R6,[R7, #+44]
    977                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x8A   0x6AA6             LDR      R6,[R4, #+40]
   \       0x8C   0x6332             STR      R2,[R6, #+48]
    978          
    979                /* Set the DMA error callback */
    980                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0x8E   0x6AA2             LDR      R2,[R4, #+40]
   \       0x90   0x6350             STR      R0,[R2, #+52]
    981          
    982                /* Enable the DMA channel */
    983                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \       0x92   0x6822             LDR      R2,[R4, #+0]
   \       0x94   0x323C             ADDS     R2,R2,#+60
   \       0x96   0x6AA0             LDR      R0,[R4, #+40]
   \       0x98   0x....'....        BL       HAL_DMA_Start_IT
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD111             BNE      ??HAL_TIM_OC_Start_DMA_3
    984                {
    985                  return HAL_ERROR;
    986                }
    987                /* Enable the TIM Capture/Compare 3 DMA request */
    988                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x68C1             LDR      R1,[R0, #+12]
   \       0xA4   0x2280             MOVS     R2,#+128
   \       0xA6   0x0112             LSLS     R2,R2,#+4        ;; #+2048
   \       0xA8   0xE012             B        ??HAL_TIM_OC_Start_DMA_9
    989                break;
    990              }
    991          
    992              case TIM_CHANNEL_4:
    993              {
    994                /* Set the DMA compare callbacks */
    995                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \       0xAA   0x6AE7             LDR      R7,[R4, #+44]
   \       0xAC   0x62FE             STR      R6,[R7, #+44]
    996                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xAE   0x6AE6             LDR      R6,[R4, #+44]
   \       0xB0   0x6332             STR      R2,[R6, #+48]
    997          
    998                /* Set the DMA error callback */
    999                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \       0xB2   0x6AE2             LDR      R2,[R4, #+44]
   \       0xB4   0x6350             STR      R0,[R2, #+52]
   1000          
   1001                /* Enable the DMA channel */
   1002                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   \       0xB6   0x6822             LDR      R2,[R4, #+0]
   \       0xB8   0x3240             ADDS     R2,R2,#+64
   \       0xBA   0x6AE0             LDR      R0,[R4, #+44]
   \       0xBC   0x....'....        BL       HAL_DMA_Start_IT
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD001             BEQ      ??HAL_TIM_OC_Start_DMA_10
   1003                {
   1004                  return HAL_ERROR;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0xBDF2             POP      {R1,R4-R7,PC}
   1005                }
   1006                /* Enable the TIM Capture/Compare 4 DMA request */
   1007                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Start_DMA_10: (+1)
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x68C1             LDR      R1,[R0, #+12]
   \       0xCC   0x2280             MOVS     R2,#+128
   \       0xCE   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \       0xD0   0x430A             ORRS     R2,R2,R1
   \       0xD2   0x60C2             STR      R2,[R0, #+12]
   1008                break;
   1009              }
   1010          
   1011              default:
   1012                break;
   1013            }
   1014          
   1015            /* Enable the Output compare channel */
   1016            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \       0xD4   0x2201             MOVS     R2,#+1
   \       0xD6   0x0029             MOVS     R1,R5
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x....'....        BL       TIM_CCxChannelCmd
   1017          
   1018            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1019            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0xDE   0x6820             LDR      R0,[R4, #+0]
   \       0xE0   0x6880             LDR      R0,[R0, #+8]
   1020            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0xE2   0x0740             LSLS     R0,R0,#+29
   \       0xE4   0x0F40             LSRS     R0,R0,#+29
   \       0xE6   0x2806             CMP      R0,#+6
   \       0xE8   0xD005             BEQ      ??HAL_TIM_OC_Start_DMA_11
   1021            {
   1022              __HAL_TIM_ENABLE(htim);
   \       0xEA   0x6820             LDR      R0,[R4, #+0]
   \       0xEC   0x6800             LDR      R0,[R0, #+0]
   \       0xEE   0x2101             MOVS     R1,#+1
   \       0xF0   0x4301             ORRS     R1,R1,R0
   \       0xF2   0x6820             LDR      R0,[R4, #+0]
   \       0xF4   0x6001             STR      R1,[R0, #+0]
   1023            }
   1024          
   1025            /* Return function status */
   1026            return HAL_OK;
   \                     ??HAL_TIM_OC_Start_DMA_11: (+1)
   \       0xF6   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \       0xF8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1027          }
   1028          
   1029          /**
   1030            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
   1031            * @param  htim TIM Output Compare handle
   1032            * @param  Channel TIM Channel to be disabled
   1033            *          This parameter can be one of the following values:
   1034            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1035            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1036            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1037            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1038            * @retval HAL status
   1039            */

   \                                 In section .text, align 2, keep-with-next
   1040          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1041          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....             B.N      ?Subroutine8

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x0004             MOVS     R4,R0
   \        0x2   0x000D             MOVS     R5,R1
   1042            /* Check the parameters */
   1043            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1044          
   1045            switch (Channel)
   \        0x4   0xD006             BEQ      ??Subroutine8_1
   \        0x6   0x2D04             CMP      R5,#+4
   \        0x8   0xD00B             BEQ      ??Subroutine8_2
   \        0xA   0x2D08             CMP      R5,#+8
   \        0xC   0xD010             BEQ      ??Subroutine8_3
   \        0xE   0x2D0C             CMP      R5,#+12
   \       0x10   0xD015             BEQ      ??Subroutine8_4
   \       0x12   0xE01C             B        ??Subroutine8_5
   1046            {
   1047              case TIM_CHANNEL_1:
   1048              {
   1049                /* Disable the TIM Capture/Compare 1 DMA request */
   1050                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??Subroutine8_1: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C1             LDR      R1,[R0, #+12]
   \       0x18   0x....             LDR      R2,??DataTable15  ;; 0xfffffdff
   \       0x1A   0x400A             ANDS     R2,R2,R1
   \       0x1C   0x60C2             STR      R2,[R0, #+12]
   1051                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x1E   0x6A20             LDR      R0,[R4, #+32]
   \       0x20   0xE013             B        ??Subroutine8_6
   1052                break;
   1053              }
   1054          
   1055              case TIM_CHANNEL_2:
   1056              {
   1057                /* Disable the TIM Capture/Compare 2 DMA request */
   1058                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??Subroutine8_2: (+1)
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x68C1             LDR      R1,[R0, #+12]
   \       0x26   0x....             LDR      R2,??DataTable15_1  ;; 0xfffffbff
   \       0x28   0x400A             ANDS     R2,R2,R1
   \       0x2A   0x60C2             STR      R2,[R0, #+12]
   1059                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x2C   0x6A60             LDR      R0,[R4, #+36]
   \       0x2E   0xE00C             B        ??Subroutine8_6
   1060                break;
   1061              }
   1062          
   1063              case TIM_CHANNEL_3:
   1064              {
   1065                /* Disable the TIM Capture/Compare 3 DMA request */
   1066                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??Subroutine8_3: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x68C1             LDR      R1,[R0, #+12]
   \       0x34   0x....             LDR      R2,??DataTable15_2  ;; 0xfffff7ff
   \       0x36   0x400A             ANDS     R2,R2,R1
   \       0x38   0x60C2             STR      R2,[R0, #+12]
   1067                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0xE005             B        ??Subroutine8_6
   1068                break;
   1069              }
   1070          
   1071              case TIM_CHANNEL_4:
   1072              {
   1073                /* Disable the TIM Capture/Compare 4 interrupt */
   1074                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??Subroutine8_4: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x68C1             LDR      R1,[R0, #+12]
   \       0x42   0x....             LDR      R2,??DataTable15_3  ;; 0xffffefff
   \       0x44   0x400A             ANDS     R2,R2,R1
   \       0x46   0x60C2             STR      R2,[R0, #+12]
   1075                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \       0x48   0x6AE0             LDR      R0,[R4, #+44]
   \                     ??Subroutine8_6: (+1)
   \       0x4A   0x....'....        BL       HAL_DMA_Abort_IT
   1076                break;
   1077              }
   1078          
   1079              default:
   1080                break;
   1081            }
   1082          
   1083            /* Disable the Output compare channel */
   1084            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??Subroutine8_5: (+1)
   \       0x4E   0x2200             MOVS     R2,#+0
   \       0x50   0x0029             MOVS     R1,R5
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x....'....        BL       TIM_CCxChannelCmd
   1085          
   1086            /* Disable the Peripheral */
   1087            __HAL_TIM_DISABLE(htim);
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6A00             LDR      R0,[R0, #+32]
   \       0x5C   0x....             LDR      R1,??DataTable14  ;; 0x1111
   \       0x5E   0x4001             ANDS     R1,R1,R0
   \       0x60   0xD105             BNE      ??Subroutine8_0
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \       0x66   0x2101             MOVS     R1,#+1
   \       0x68   0x4388             BICS     R0,R0,R1
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x6008             STR      R0,[R1, #+0]
   1088          
   1089            /* Change the htim state */
   1090            htim->State = HAL_TIM_STATE_READY;
   \                     ??Subroutine8_0: (+1)
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0x2139             MOVS     R1,#+57
   \       0x72   0x5460             STRB     R0,[R4, R1]
   1091          
   1092            /* Return function status */
   1093            return HAL_OK;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1094          }
   1095          
   1096          /**
   1097            * @}
   1098            */
   1099          
   1100          /** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
   1101           *  @brief    TIM PWM functions
   1102           *
   1103          @verbatim
   1104            ==============================================================================
   1105                                    ##### TIM PWM functions #####
   1106            ==============================================================================
   1107            [..]
   1108              This section provides functions allowing to:
   1109              (+) Initialize and configure the TIM PWM.
   1110              (+) De-initialize the TIM PWM.
   1111              (+) Start the TIM PWM.
   1112              (+) Stop the TIM PWM.
   1113              (+) Start the TIM PWM and enable interrupt.
   1114              (+) Stop the TIM PWM and disable interrupt.
   1115              (+) Start the TIM PWM and enable DMA transfer.
   1116              (+) Stop the TIM PWM and disable DMA transfer.
   1117          
   1118          @endverbatim
   1119            * @{
   1120            */
   1121          /**
   1122            * @brief  Initializes the TIM PWM Time Base according to the specified
   1123            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1124            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1125            *         requires a timer reset to avoid unexpected direction
   1126            *         due to DIR bit readonly in center aligned mode.
   1127            *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
   1128            * @param  htim TIM PWM handle
   1129            * @retval HAL status
   1130            */

   \                                 In section .text, align 2, keep-with-next
   1131          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1132          {
   \                     HAL_TIM_PWM_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1133            /* Check the TIM handle allocation */
   1134            if (htim == NULL)
   \        0x4   0xD101             BNE      ??HAL_TIM_PWM_Init_0
   1135            {
   1136              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD10             POP      {R4,PC}
   1137            }
   1138          
   1139            /* Check the parameters */
   1140            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1141            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1142            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1143            assert_param(IS_TIM_PERIOD(htim->Init.Period));
   1144            assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
   1145            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1146          
   1147            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \        0xA   0x2039             MOVS     R0,#+57
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD104             BNE      ??HAL_TIM_PWM_Init_1
   1148            {
   1149              /* Allocate lock resource and initialize it */
   1150              htim->Lock = HAL_UNLOCKED;
   \       0x12   0x2138             MOVS     R1,#+56
   \       0x14   0x5460             STRB     R0,[R4, R1]
   1151          
   1152          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1153              /* Reset interrupt callbacks to legacy weak callbacks */
   1154              TIM_ResetCallback(htim);
   1155          
   1156              if (htim->PWM_MspInitCallback == NULL)
   1157              {
   1158                htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
   1159              }
   1160              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1161              htim->PWM_MspInitCallback(htim);
   1162          #else
   1163              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1164              HAL_TIM_PWM_MspInit(htim);
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x....'....        BL       HAL_TIM_PWM_MspInit
   1165          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1166            }
   1167          
   1168            /* Set the TIM state */
   1169            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x2139             MOVS     R1,#+57
   \       0x20   0x5460             STRB     R0,[R4, R1]
   1170          
   1171            /* Init the base time for the PWM */
   1172            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x22   0x1D21             ADDS     R1,R4,#+4
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x....'....        BL       TIM_Base_SetConfig
   1173          
   1174            /* Initialize the TIM state*/
   1175            htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x....             B.N      ??Subroutine2_0
   1176          
   1177            return HAL_OK;
   1178          }
   1179          
   1180          /**
   1181            * @brief  DeInitializes the TIM peripheral
   1182            * @param  htim TIM PWM handle
   1183            * @retval HAL status
   1184            */

   \                                 In section .text, align 2, keep-with-next
   1185          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1186          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1187            /* Check the parameters */
   1188            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1189          
   1190            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x2139             MOVS     R1,#+57
   \        0x8   0x5460             STRB     R0,[R4, R1]
   1191          
   1192            /* Disable the TIM Peripheral Clock */
   1193            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable9  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0xD105             BNE      ??HAL_TIM_PWM_DeInit_0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x4388             BICS     R0,R0,R1
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   1194          
   1195          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1196            if (htim->PWM_MspDeInitCallback == NULL)
   1197            {
   1198              htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
   1199            }
   1200            /* DeInit the low level hardware */
   1201            htim->PWM_MspDeInitCallback(htim);
   1202          #else
   1203            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1204            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       HAL_TIM_PWM_MspDeInit
   1205          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1206          
   1207            /* Change TIM state */
   1208            htim->State = HAL_TIM_STATE_RESET;
   \       0x26   0x....             B.N      ?Subroutine4
   1209          
   1210            /* Release Lock */
   1211            __HAL_UNLOCK(htim);
   1212          
   1213            return HAL_OK;
   1214          }
   1215          
   1216          /**
   1217            * @brief  Initializes the TIM PWM MSP.
   1218            * @param  htim TIM PWM handle
   1219            * @retval None
   1220            */

   \                                 In section .text, align 2
   1221          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1222          {
   1223            /* Prevent unused argument(s) compilation warning */
   1224            UNUSED(htim);
   1225          
   1226            /* NOTE : This function should not be modified, when the callback is needed,
   1227                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1228             */
   1229          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1230          
   1231          /**
   1232            * @brief  DeInitializes TIM PWM MSP.
   1233            * @param  htim TIM PWM handle
   1234            * @retval None
   1235            */

   \                                 In section .text, align 2
   1236          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1237          {
   1238            /* Prevent unused argument(s) compilation warning */
   1239            UNUSED(htim);
   1240          
   1241            /* NOTE : This function should not be modified, when the callback is needed,
   1242                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1243             */
   1244          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1245          
   1246          /**
   1247            * @brief  Starts the PWM signal generation.
   1248            * @param  htim TIM handle
   1249            * @param  Channel TIM Channels to be enabled
   1250            *          This parameter can be one of the following values:
   1251            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1252            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1253            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1254            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1255            * @retval HAL status
   1256            */

   \                                 In section .text, align 2, keep-with-next
   1257          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1258          {
   \                     HAL_TIM_PWM_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1259            uint32_t tmpsmcr;
   1260          
   1261            /* Check the parameters */
   1262            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1263          
   1264            /* Enable the Capture compare channel */
   1265            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x4   0x....             B.N      ??Subroutine0_0
   1266          
   1267            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1268            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1269            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1270            {
   1271              __HAL_TIM_ENABLE(htim);
   1272            }
   1273          
   1274            /* Return function status */
   1275            return HAL_OK;
   1276          }
   1277          
   1278          /**
   1279            * @brief  Stops the PWM signal generation.
   1280            * @param  htim TIM PWM handle
   1281            * @param  Channel TIM Channels to be disabled
   1282            *          This parameter can be one of the following values:
   1283            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1284            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1285            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1286            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1287            * @retval HAL status
   1288            */

   \                                 In section .text, align 2, keep-with-next
   1289          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1290          {
   \                     HAL_TIM_PWM_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1291            /* Check the parameters */
   1292            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1293          
   1294            /* Disable the Capture compare channel */
   1295            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....'....        BL       TIM_CCxChannelCmd
   1296          
   1297            /* Disable the Peripheral */
   1298            __HAL_TIM_DISABLE(htim);
   \        0xC                      REQUIRE ?Subroutine2
   \        0xC                      ;; // Fall through to label ?Subroutine2
   1299          
   1300            /* Change the htim state */
   1301            htim->State = HAL_TIM_STATE_READY;
   1302          
   1303            /* Return function status */
   1304            return HAL_OK;
   1305          }
   1306          
   1307          /**
   1308            * @brief  Starts the PWM signal generation in interrupt mode.
   1309            * @param  htim TIM PWM handle
   1310            * @param  Channel TIM Channel to be enabled
   1311            *          This parameter can be one of the following values:
   1312            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1313            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1314            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1315            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1316            * @retval HAL status
   1317            */

   \                                 In section .text, align 2, keep-with-next
   1318          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1319          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2                      REQUIRE ?Subroutine0
   \        0x2                      ;; // Fall through to label ?Subroutine0
   1320            uint32_t tmpsmcr;
   1321            /* Check the parameters */
   1322            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1323          
   1324            switch (Channel)
   1325            {
   1326              case TIM_CHANNEL_1:
   1327              {
   1328                /* Enable the TIM Capture/Compare 1 interrupt */
   1329                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1330                break;
   1331              }
   1332          
   1333              case TIM_CHANNEL_2:
   1334              {
   1335                /* Enable the TIM Capture/Compare 2 interrupt */
   1336                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1337                break;
   1338              }
   1339          
   1340              case TIM_CHANNEL_3:
   1341              {
   1342                /* Enable the TIM Capture/Compare 3 interrupt */
   1343                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1344                break;
   1345              }
   1346          
   1347              case TIM_CHANNEL_4:
   1348              {
   1349                /* Enable the TIM Capture/Compare 4 interrupt */
   1350                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1351                break;
   1352              }
   1353          
   1354              default:
   1355                break;
   1356            }
   1357          
   1358            /* Enable the Capture compare channel */
   1359            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1360          
   1361            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1362            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1363            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1364            {
   1365              __HAL_TIM_ENABLE(htim);
   1366            }
   1367          
   1368            /* Return function status */
   1369            return HAL_OK;
   1370          }
   1371          
   1372          /**
   1373            * @brief  Stops the PWM signal generation in interrupt mode.
   1374            * @param  htim TIM PWM handle
   1375            * @param  Channel TIM Channels to be disabled
   1376            *          This parameter can be one of the following values:
   1377            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1378            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1379            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1380            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1381            * @retval HAL status
   1382            */

   \                                 In section .text, align 2, keep-with-next
   1383          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1384          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2                      REQUIRE ?Subroutine1
   \        0x2                      ;; // Fall through to label ?Subroutine1
   1385            /* Check the parameters */
   1386            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1387          
   1388            switch (Channel)
   1389            {
   1390              case TIM_CHANNEL_1:
   1391              {
   1392                /* Disable the TIM Capture/Compare 1 interrupt */
   1393                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1394                break;
   1395              }
   1396          
   1397              case TIM_CHANNEL_2:
   1398              {
   1399                /* Disable the TIM Capture/Compare 2 interrupt */
   1400                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1401                break;
   1402              }
   1403          
   1404              case TIM_CHANNEL_3:
   1405              {
   1406                /* Disable the TIM Capture/Compare 3 interrupt */
   1407                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1408                break;
   1409              }
   1410          
   1411              case TIM_CHANNEL_4:
   1412              {
   1413                /* Disable the TIM Capture/Compare 4 interrupt */
   1414                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1415                break;
   1416              }
   1417          
   1418              default:
   1419                break;
   1420            }
   1421          
   1422            /* Disable the Capture compare channel */
   1423            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1424          
   1425            /* Disable the Peripheral */
   1426            __HAL_TIM_DISABLE(htim);
   1427          
   1428            /* Return function status */
   1429            return HAL_OK;
   1430          }
   1431          
   1432          /**
   1433            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1434            * @param  htim TIM PWM handle
   1435            * @param  Channel TIM Channels to be enabled
   1436            *          This parameter can be one of the following values:
   1437            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1438            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1439            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1440            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1441            * @param  pData The source Buffer address.
   1442            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1443            * @retval HAL status
   1444            */

   \                                 In section .text, align 2, keep-with-next
   1445          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1446          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0011             MOVS     R1,R2
   1447            uint32_t tmpsmcr;
   1448          
   1449            /* Check the parameters */
   1450            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1451          
   1452            if ((htim->State == HAL_TIM_STATE_BUSY))
   \        0x8   0x2039             MOVS     R0,#+57
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD073             BEQ      ??HAL_TIM_PWM_Start_DMA_0
   1453            {
   1454              return HAL_BUSY;
   1455            }
   1456            else if ((htim->State == HAL_TIM_STATE_READY))
   \       0x10   0x2039             MOVS     R0,#+57
   \       0x12   0x5C20             LDRB     R0,[R4, R0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD106             BNE      ??HAL_TIM_PWM_Start_DMA_1
   1457            {
   1458              if ((pData == NULL) && (Length > 0U))
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD101             BNE      ??HAL_TIM_PWM_Start_DMA_2
   \       0x1C   0x0018             MOVS     R0,R3
   \       0x1E   0xD151             BNE      ??HAL_TIM_PWM_Start_DMA_3
   1459              {
   1460                return HAL_ERROR;
   1461              }
   1462              else
   1463              {
   1464                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x2239             MOVS     R2,#+57
   \       0x24   0x54A0             STRB     R0,[R4, R2]
   1465              }
   1466            }
   1467            else
   1468            {
   1469              /* nothing to do */
   1470            }
   1471          
   1472            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \       0x26   0x....             LDR      R0,??DataTable14_1
   \       0x28   0x....             LDR      R2,??DataTable14_2
   \       0x2A   0x....             LDR      R6,??DataTable14_3
   \       0x2C   0x002F             MOVS     R7,R5
   \       0x2E   0xD006             BEQ      ??HAL_TIM_PWM_Start_DMA_4
   \       0x30   0x2D04             CMP      R5,#+4
   \       0x32   0xD016             BEQ      ??HAL_TIM_PWM_Start_DMA_5
   \       0x34   0x2D08             CMP      R5,#+8
   \       0x36   0xD026             BEQ      ??HAL_TIM_PWM_Start_DMA_6
   \       0x38   0x2D0C             CMP      R5,#+12
   \       0x3A   0xD036             BEQ      ??HAL_TIM_PWM_Start_DMA_7
   \       0x3C   0xE04A             B        ??HAL_TIM_PWM_Start_DMA_8
   1473            {
   1474              case TIM_CHANNEL_1:
   1475              {
   1476                /* Set the DMA compare callbacks */
   1477                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \       0x3E   0x6A27             LDR      R7,[R4, #+32]
   \       0x40   0x62FE             STR      R6,[R7, #+44]
   1478                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x42   0x6A26             LDR      R6,[R4, #+32]
   \       0x44   0x6332             STR      R2,[R6, #+48]
   1479          
   1480                /* Set the DMA error callback */
   1481                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x46   0x6A22             LDR      R2,[R4, #+32]
   \       0x48   0x6350             STR      R0,[R2, #+52]
   1482          
   1483                /* Enable the DMA channel */
   1484                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \       0x4A   0x6822             LDR      R2,[R4, #+0]
   \       0x4C   0x3234             ADDS     R2,R2,#+52
   \       0x4E   0x6A20             LDR      R0,[R4, #+32]
   \       0x50   0x....'....        BL       HAL_DMA_Start_IT
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD135             BNE      ??HAL_TIM_PWM_Start_DMA_3
   1485                {
   1486                  return HAL_ERROR;
   1487                }
   1488          
   1489                /* Enable the TIM Capture/Compare 1 DMA request */
   1490                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x68C1             LDR      R1,[R0, #+12]
   \       0x5C   0x2280             MOVS     R2,#+128
   \       0x5E   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \       0x60   0xE036             B        ??HAL_TIM_PWM_Start_DMA_9
   1491                break;
   1492              }
   1493          
   1494              case TIM_CHANNEL_2:
   1495              {
   1496                /* Set the DMA compare callbacks */
   1497                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \       0x62   0x6A67             LDR      R7,[R4, #+36]
   \       0x64   0x62FE             STR      R6,[R7, #+44]
   1498                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x66   0x6A66             LDR      R6,[R4, #+36]
   \       0x68   0x6332             STR      R2,[R6, #+48]
   1499          
   1500                /* Set the DMA error callback */
   1501                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x6A   0x6A62             LDR      R2,[R4, #+36]
   \       0x6C   0x6350             STR      R0,[R2, #+52]
   1502          
   1503                /* Enable the DMA channel */
   1504                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \       0x6E   0x6822             LDR      R2,[R4, #+0]
   \       0x70   0x3238             ADDS     R2,R2,#+56
   \       0x72   0x6A60             LDR      R0,[R4, #+36]
   \       0x74   0x....'....        BL       HAL_DMA_Start_IT
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD123             BNE      ??HAL_TIM_PWM_Start_DMA_3
   1505                {
   1506                  return HAL_ERROR;
   1507                }
   1508                /* Enable the TIM Capture/Compare 2 DMA request */
   1509                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x68C1             LDR      R1,[R0, #+12]
   \       0x80   0x2280             MOVS     R2,#+128
   \       0x82   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \       0x84   0xE024             B        ??HAL_TIM_PWM_Start_DMA_9
   1510                break;
   1511              }
   1512          
   1513              case TIM_CHANNEL_3:
   1514              {
   1515                /* Set the DMA compare callbacks */
   1516                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \       0x86   0x6AA7             LDR      R7,[R4, #+40]
   \       0x88   0x62FE             STR      R6,[R7, #+44]
   1517                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x8A   0x6AA6             LDR      R6,[R4, #+40]
   \       0x8C   0x6332             STR      R2,[R6, #+48]
   1518          
   1519                /* Set the DMA error callback */
   1520                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0x8E   0x6AA2             LDR      R2,[R4, #+40]
   \       0x90   0x6350             STR      R0,[R2, #+52]
   1521          
   1522                /* Enable the DMA channel */
   1523                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \       0x92   0x6822             LDR      R2,[R4, #+0]
   \       0x94   0x323C             ADDS     R2,R2,#+60
   \       0x96   0x6AA0             LDR      R0,[R4, #+40]
   \       0x98   0x....'....        BL       HAL_DMA_Start_IT
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD111             BNE      ??HAL_TIM_PWM_Start_DMA_3
   1524                {
   1525                  return HAL_ERROR;
   1526                }
   1527                /* Enable the TIM Output Capture/Compare 3 request */
   1528                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x68C1             LDR      R1,[R0, #+12]
   \       0xA4   0x2280             MOVS     R2,#+128
   \       0xA6   0x0112             LSLS     R2,R2,#+4        ;; #+2048
   \       0xA8   0xE012             B        ??HAL_TIM_PWM_Start_DMA_9
   1529                break;
   1530              }
   1531          
   1532              case TIM_CHANNEL_4:
   1533              {
   1534                /* Set the DMA compare callbacks */
   1535                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \       0xAA   0x6AE7             LDR      R7,[R4, #+44]
   \       0xAC   0x62FE             STR      R6,[R7, #+44]
   1536                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xAE   0x6AE6             LDR      R6,[R4, #+44]
   \       0xB0   0x6332             STR      R2,[R6, #+48]
   1537          
   1538                /* Set the DMA error callback */
   1539                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \       0xB2   0x6AE2             LDR      R2,[R4, #+44]
   \       0xB4   0x6350             STR      R0,[R2, #+52]
   1540          
   1541                /* Enable the DMA channel */
   1542                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   \       0xB6   0x6822             LDR      R2,[R4, #+0]
   \       0xB8   0x3240             ADDS     R2,R2,#+64
   \       0xBA   0x6AE0             LDR      R0,[R4, #+44]
   \       0xBC   0x....'....        BL       HAL_DMA_Start_IT
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD001             BEQ      ??HAL_TIM_PWM_Start_DMA_10
   1543                {
   1544                  return HAL_ERROR;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0xBDF2             POP      {R1,R4-R7,PC}
   1545                }
   1546                /* Enable the TIM Capture/Compare 4 DMA request */
   1547                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Start_DMA_10: (+1)
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x68C1             LDR      R1,[R0, #+12]
   \       0xCC   0x2280             MOVS     R2,#+128
   \       0xCE   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \       0xD0   0x430A             ORRS     R2,R2,R1
   \       0xD2   0x60C2             STR      R2,[R0, #+12]
   1548                break;
   1549              }
   1550          
   1551              default:
   1552                break;
   1553            }
   1554          
   1555            /* Enable the Capture compare channel */
   1556            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \       0xD4   0x2201             MOVS     R2,#+1
   \       0xD6   0x0029             MOVS     R1,R5
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x....'....        BL       TIM_CCxChannelCmd
   1557          
   1558            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1559            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0xDE   0x6820             LDR      R0,[R4, #+0]
   \       0xE0   0x6880             LDR      R0,[R0, #+8]
   1560            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0xE2   0x0740             LSLS     R0,R0,#+29
   \       0xE4   0x0F40             LSRS     R0,R0,#+29
   \       0xE6   0x2806             CMP      R0,#+6
   \       0xE8   0xD005             BEQ      ??HAL_TIM_PWM_Start_DMA_11
   1561            {
   1562              __HAL_TIM_ENABLE(htim);
   \       0xEA   0x6820             LDR      R0,[R4, #+0]
   \       0xEC   0x6800             LDR      R0,[R0, #+0]
   \       0xEE   0x2101             MOVS     R1,#+1
   \       0xF0   0x4301             ORRS     R1,R1,R0
   \       0xF2   0x6820             LDR      R0,[R4, #+0]
   \       0xF4   0x6001             STR      R1,[R0, #+0]
   1563            }
   1564          
   1565            /* Return function status */
   1566            return HAL_OK;
   \                     ??HAL_TIM_PWM_Start_DMA_11: (+1)
   \       0xF6   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \       0xF8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1567          }
   1568          
   1569          /**
   1570            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1571            * @param  htim TIM PWM handle
   1572            * @param  Channel TIM Channels to be disabled
   1573            *          This parameter can be one of the following values:
   1574            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1575            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1576            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1577            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1578            * @retval HAL status
   1579            */

   \                                 In section .text, align 2, keep-with-next
   1580          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1581          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2                      REQUIRE ?Subroutine8
   \        0x2                      ;; // Fall through to label ?Subroutine8
   1582            /* Check the parameters */
   1583            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1584          
   1585            switch (Channel)
   1586            {
   1587              case TIM_CHANNEL_1:
   1588              {
   1589                /* Disable the TIM Capture/Compare 1 DMA request */
   1590                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1591                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1592                break;
   1593              }
   1594          
   1595              case TIM_CHANNEL_2:
   1596              {
   1597                /* Disable the TIM Capture/Compare 2 DMA request */
   1598                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1599                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1600                break;
   1601              }
   1602          
   1603              case TIM_CHANNEL_3:
   1604              {
   1605                /* Disable the TIM Capture/Compare 3 DMA request */
   1606                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1607                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1608                break;
   1609              }
   1610          
   1611              case TIM_CHANNEL_4:
   1612              {
   1613                /* Disable the TIM Capture/Compare 4 interrupt */
   1614                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1615                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   1616                break;
   1617              }
   1618          
   1619              default:
   1620                break;
   1621            }
   1622          
   1623            /* Disable the Capture compare channel */
   1624            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1625          
   1626            /* Disable the Peripheral */
   1627            __HAL_TIM_DISABLE(htim);
   1628          
   1629            /* Change the htim state */
   1630            htim->State = HAL_TIM_STATE_READY;
   1631          
   1632            /* Return function status */
   1633            return HAL_OK;
   1634          }
   1635          
   1636          /**
   1637            * @}
   1638            */
   1639          
   1640          /** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
   1641           *  @brief    TIM Input Capture functions
   1642           *
   1643          @verbatim
   1644            ==============================================================================
   1645                        ##### TIM Input Capture functions #####
   1646            ==============================================================================
   1647           [..]
   1648             This section provides functions allowing to:
   1649             (+) Initialize and configure the TIM Input Capture.
   1650             (+) De-initialize the TIM Input Capture.
   1651             (+) Start the TIM Input Capture.
   1652             (+) Stop the TIM Input Capture.
   1653             (+) Start the TIM Input Capture and enable interrupt.
   1654             (+) Stop the TIM Input Capture and disable interrupt.
   1655             (+) Start the TIM Input Capture and enable DMA transfer.
   1656             (+) Stop the TIM Input Capture and disable DMA transfer.
   1657          
   1658          @endverbatim
   1659            * @{
   1660            */
   1661          /**
   1662            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1663            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1664            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1665            *         requires a timer reset to avoid unexpected direction
   1666            *         due to DIR bit readonly in center aligned mode.
   1667            *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
   1668            * @param  htim TIM Input Capture handle
   1669            * @retval HAL status
   1670            */

   \                                 In section .text, align 2, keep-with-next
   1671          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1672          {
   \                     HAL_TIM_IC_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1673            /* Check the TIM handle allocation */
   1674            if (htim == NULL)
   \        0x4   0xD101             BNE      ??HAL_TIM_IC_Init_0
   1675            {
   1676              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD10             POP      {R4,PC}
   1677            }
   1678          
   1679            /* Check the parameters */
   1680            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1681            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1682            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1683            assert_param(IS_TIM_PERIOD(htim->Init.Period));
   1684            assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
   1685            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1686          
   1687            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \        0xA   0x2039             MOVS     R0,#+57
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD104             BNE      ??HAL_TIM_IC_Init_1
   1688            {
   1689              /* Allocate lock resource and initialize it */
   1690              htim->Lock = HAL_UNLOCKED;
   \       0x12   0x2138             MOVS     R1,#+56
   \       0x14   0x5460             STRB     R0,[R4, R1]
   1691          
   1692          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1693              /* Reset interrupt callbacks to legacy weak callbacks */
   1694              TIM_ResetCallback(htim);
   1695          
   1696              if (htim->IC_MspInitCallback == NULL)
   1697              {
   1698                htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
   1699              }
   1700              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1701              htim->IC_MspInitCallback(htim);
   1702          #else
   1703              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1704              HAL_TIM_IC_MspInit(htim);
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x....'....        BL       HAL_TIM_IC_MspInit
   1705          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1706            }
   1707          
   1708            /* Set the TIM state */
   1709            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x2139             MOVS     R1,#+57
   \       0x20   0x5460             STRB     R0,[R4, R1]
   1710          
   1711            /* Init the base time for the input capture */
   1712            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x22   0x1D21             ADDS     R1,R4,#+4
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x....'....        BL       TIM_Base_SetConfig
   1713          
   1714            /* Initialize the TIM state*/
   1715            htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x....             B.N      ??Subroutine2_0
   1716          
   1717            return HAL_OK;
   1718          }
   1719          
   1720          /**
   1721            * @brief  DeInitializes the TIM peripheral
   1722            * @param  htim TIM Input Capture handle
   1723            * @retval HAL status
   1724            */

   \                                 In section .text, align 2, keep-with-next
   1725          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1726          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1727            /* Check the parameters */
   1728            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1729          
   1730            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x2139             MOVS     R1,#+57
   \        0x8   0x5460             STRB     R0,[R4, R1]
   1731          
   1732            /* Disable the TIM Peripheral Clock */
   1733            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable14  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0xD105             BNE      ??HAL_TIM_IC_DeInit_0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x4388             BICS     R0,R0,R1
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   1734          
   1735          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1736            if (htim->IC_MspDeInitCallback == NULL)
   1737            {
   1738              htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
   1739            }
   1740            /* DeInit the low level hardware */
   1741            htim->IC_MspDeInitCallback(htim);
   1742          #else
   1743            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1744            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       HAL_TIM_IC_MspDeInit
   1745          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1746          
   1747            /* Change TIM state */
   1748            htim->State = HAL_TIM_STATE_RESET;
   \       0x26   0x....             B.N      ?Subroutine4
   1749          
   1750            /* Release Lock */
   1751            __HAL_UNLOCK(htim);
   1752          
   1753            return HAL_OK;
   1754          }
   1755          
   1756          /**
   1757            * @brief  Initializes the TIM Input Capture MSP.
   1758            * @param  htim TIM Input Capture handle
   1759            * @retval None
   1760            */

   \                                 In section .text, align 2
   1761          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1762          {
   1763            /* Prevent unused argument(s) compilation warning */
   1764            UNUSED(htim);
   1765          
   1766            /* NOTE : This function should not be modified, when the callback is needed,
   1767                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1768             */
   1769          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1770          
   1771          /**
   1772            * @brief  DeInitializes TIM Input Capture MSP.
   1773            * @param  htim TIM handle
   1774            * @retval None
   1775            */

   \                                 In section .text, align 2
   1776          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1777          {
   1778            /* Prevent unused argument(s) compilation warning */
   1779            UNUSED(htim);
   1780          
   1781            /* NOTE : This function should not be modified, when the callback is needed,
   1782                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1783             */
   1784          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1785          
   1786          /**
   1787            * @brief  Starts the TIM Input Capture measurement.
   1788            * @param  htim TIM Input Capture handle
   1789            * @param  Channel TIM Channels to be enabled
   1790            *          This parameter can be one of the following values:
   1791            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1792            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1793            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1794            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1795            * @retval HAL status
   1796            */

   \                                 In section .text, align 2, keep-with-next
   1797          HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1798          {
   \                     HAL_TIM_IC_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1799            uint32_t tmpsmcr;
   1800          
   1801            /* Check the parameters */
   1802            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1803          
   1804            /* Enable the Input Capture channel */
   1805            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x4   0x....             B.N      ??Subroutine0_0
   1806          
   1807            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1808            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1809            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1810            {
   1811              __HAL_TIM_ENABLE(htim);
   1812            }
   1813          
   1814            /* Return function status */
   1815            return HAL_OK;
   1816          }
   1817          
   1818          /**
   1819            * @brief  Stops the TIM Input Capture measurement.
   1820            * @param  htim TIM Input Capture handle
   1821            * @param  Channel TIM Channels to be disabled
   1822            *          This parameter can be one of the following values:
   1823            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1824            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1825            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1826            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1827            * @retval HAL status
   1828            */

   \                                 In section .text, align 2, keep-with-next
   1829          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1830          {
   \                     HAL_TIM_IC_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1831            /* Check the parameters */
   1832            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1833          
   1834            /* Disable the Input Capture channel */
   1835            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x4   0x....             B.N      ??Subroutine1_0
   1836          
   1837            /* Disable the Peripheral */
   1838            __HAL_TIM_DISABLE(htim);
   1839          
   1840            /* Return function status */
   1841            return HAL_OK;
   1842          }
   1843          
   1844          /**
   1845            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1846            * @param  htim TIM Input Capture handle
   1847            * @param  Channel TIM Channels to be enabled
   1848            *          This parameter can be one of the following values:
   1849            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1850            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1851            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1852            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1853            * @retval HAL status
   1854            */

   \                                 In section .text, align 2, keep-with-next
   1855          HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1856          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             B.N      ?Subroutine0
   1857            uint32_t tmpsmcr;
   1858          
   1859            /* Check the parameters */
   1860            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1861          
   1862            switch (Channel)
   1863            {
   1864              case TIM_CHANNEL_1:
   1865              {
   1866                /* Enable the TIM Capture/Compare 1 interrupt */
   1867                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1868                break;
   1869              }
   1870          
   1871              case TIM_CHANNEL_2:
   1872              {
   1873                /* Enable the TIM Capture/Compare 2 interrupt */
   1874                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1875                break;
   1876              }
   1877          
   1878              case TIM_CHANNEL_3:
   1879              {
   1880                /* Enable the TIM Capture/Compare 3 interrupt */
   1881                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1882                break;
   1883              }
   1884          
   1885              case TIM_CHANNEL_4:
   1886              {
   1887                /* Enable the TIM Capture/Compare 4 interrupt */
   1888                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1889                break;
   1890              }
   1891          
   1892              default:
   1893                break;
   1894            }
   1895            /* Enable the Input Capture channel */
   1896            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1897          
   1898            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1899            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1900            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1901            {
   1902              __HAL_TIM_ENABLE(htim);
   1903            }
   1904          
   1905            /* Return function status */
   1906            return HAL_OK;
   1907          }
   1908          
   1909          /**
   1910            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1911            * @param  htim TIM Input Capture handle
   1912            * @param  Channel TIM Channels to be disabled
   1913            *          This parameter can be one of the following values:
   1914            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1915            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1916            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1917            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1918            * @retval HAL status
   1919            */

   \                                 In section .text, align 2, keep-with-next
   1920          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1921          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             B.N      ?Subroutine1
   1922            /* Check the parameters */
   1923            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1924          
   1925            switch (Channel)
   1926            {
   1927              case TIM_CHANNEL_1:
   1928              {
   1929                /* Disable the TIM Capture/Compare 1 interrupt */
   1930                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1931                break;
   1932              }
   1933          
   1934              case TIM_CHANNEL_2:
   1935              {
   1936                /* Disable the TIM Capture/Compare 2 interrupt */
   1937                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1938                break;
   1939              }
   1940          
   1941              case TIM_CHANNEL_3:
   1942              {
   1943                /* Disable the TIM Capture/Compare 3 interrupt */
   1944                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1945                break;
   1946              }
   1947          
   1948              case TIM_CHANNEL_4:
   1949              {
   1950                /* Disable the TIM Capture/Compare 4 interrupt */
   1951                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1952                break;
   1953              }
   1954          
   1955              default:
   1956                break;
   1957            }
   1958          
   1959            /* Disable the Input Capture channel */
   1960            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1961          
   1962            /* Disable the Peripheral */
   1963            __HAL_TIM_DISABLE(htim);
   1964          
   1965            /* Return function status */
   1966            return HAL_OK;
   1967          }
   1968          
   1969          /**
   1970            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   1971            * @param  htim TIM Input Capture handle
   1972            * @param  Channel TIM Channels to be enabled
   1973            *          This parameter can be one of the following values:
   1974            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1975            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1976            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1977            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1978            * @param  pData The destination Buffer address.
   1979            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   1980            * @retval HAL status
   1981            */

   \                                 In section .text, align 2, keep-with-next
   1982          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1983          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1984            uint32_t tmpsmcr;
   1985          
   1986            /* Check the parameters */
   1987            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1988            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1989          
   1990            if ((htim->State == HAL_TIM_STATE_BUSY))
   \        0x4   0x2039             MOVS     R0,#+57
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0xD073             BEQ      ??HAL_TIM_IC_Start_DMA_0
   1991            {
   1992              return HAL_BUSY;
   1993            }
   1994            else if ((htim->State == HAL_TIM_STATE_READY))
   \        0xC   0x2039             MOVS     R0,#+57
   \        0xE   0x5C20             LDRB     R0,[R4, R0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD106             BNE      ??HAL_TIM_IC_Start_DMA_1
   1995            {
   1996              if ((pData == NULL) && (Length > 0U))
   \       0x14   0x2A00             CMP      R2,#+0
   \       0x16   0xD101             BNE      ??HAL_TIM_IC_Start_DMA_2
   \       0x18   0x0018             MOVS     R0,R3
   \       0x1A   0xD151             BNE      ??HAL_TIM_IC_Start_DMA_3
   1997              {
   1998                return HAL_ERROR;
   1999              }
   2000              else
   2001              {
   2002                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x2539             MOVS     R5,#+57
   \       0x20   0x5560             STRB     R0,[R4, R5]
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \       0x22   0x000D             MOVS     R5,R1
   2003              }
   2004            }
   2005            else
   2006            {
   2007              /* nothing to do */
   2008            }
   2009          
   2010            switch (Channel)
   \       0x24   0x....             LDR      R0,??DataTable14_1
   \       0x26   0x....             LDR      R1,??DataTable17
   \       0x28   0x....             LDR      R6,??DataTable17_1
   \       0x2A   0xD006             BEQ      ??HAL_TIM_IC_Start_DMA_4
   \       0x2C   0x2D04             CMP      R5,#+4
   \       0x2E   0xD016             BEQ      ??HAL_TIM_IC_Start_DMA_5
   \       0x30   0x2D08             CMP      R5,#+8
   \       0x32   0xD026             BEQ      ??HAL_TIM_IC_Start_DMA_6
   \       0x34   0x2D0C             CMP      R5,#+12
   \       0x36   0xD036             BEQ      ??HAL_TIM_IC_Start_DMA_7
   \       0x38   0xE04A             B        ??HAL_TIM_IC_Start_DMA_8
   2011            {
   2012              case TIM_CHANNEL_1:
   2013              {
   2014                /* Set the DMA capture callbacks */
   2015                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \       0x3A   0x6A27             LDR      R7,[R4, #+32]
   \       0x3C   0x62FE             STR      R6,[R7, #+44]
   2016                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x3E   0x6A26             LDR      R6,[R4, #+32]
   \       0x40   0x6331             STR      R1,[R6, #+48]
   2017          
   2018                /* Set the DMA error callback */
   2019                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x42   0x6A21             LDR      R1,[R4, #+32]
   \       0x44   0x6348             STR      R0,[R1, #+52]
   2020          
   2021                /* Enable the DMA channel */
   2022                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x3134             ADDS     R1,R1,#+52
   \       0x4A   0x6A20             LDR      R0,[R4, #+32]
   \       0x4C   0x....'....        BL       HAL_DMA_Start_IT
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD135             BNE      ??HAL_TIM_IC_Start_DMA_3
   2023                {
   2024                  return HAL_ERROR;
   2025                }
   2026                /* Enable the TIM Capture/Compare 1 DMA request */
   2027                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x68C1             LDR      R1,[R0, #+12]
   \       0x58   0x2280             MOVS     R2,#+128
   \       0x5A   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \       0x5C   0xE036             B        ??HAL_TIM_IC_Start_DMA_9
   2028                break;
   2029              }
   2030          
   2031              case TIM_CHANNEL_2:
   2032              {
   2033                /* Set the DMA capture callbacks */
   2034                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \       0x5E   0x6A67             LDR      R7,[R4, #+36]
   \       0x60   0x62FE             STR      R6,[R7, #+44]
   2035                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x62   0x6A66             LDR      R6,[R4, #+36]
   \       0x64   0x6331             STR      R1,[R6, #+48]
   2036          
   2037                /* Set the DMA error callback */
   2038                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x66   0x6A61             LDR      R1,[R4, #+36]
   \       0x68   0x6348             STR      R0,[R1, #+52]
   2039          
   2040                /* Enable the DMA channel */
   2041                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x3138             ADDS     R1,R1,#+56
   \       0x6E   0x6A60             LDR      R0,[R4, #+36]
   \       0x70   0x....'....        BL       HAL_DMA_Start_IT
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD123             BNE      ??HAL_TIM_IC_Start_DMA_3
   2042                {
   2043                  return HAL_ERROR;
   2044                }
   2045                /* Enable the TIM Capture/Compare 2  DMA request */
   2046                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x68C1             LDR      R1,[R0, #+12]
   \       0x7C   0x2280             MOVS     R2,#+128
   \       0x7E   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \       0x80   0xE024             B        ??HAL_TIM_IC_Start_DMA_9
   2047                break;
   2048              }
   2049          
   2050              case TIM_CHANNEL_3:
   2051              {
   2052                /* Set the DMA capture callbacks */
   2053                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \       0x82   0x6AA7             LDR      R7,[R4, #+40]
   \       0x84   0x62FE             STR      R6,[R7, #+44]
   2054                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x86   0x6AA6             LDR      R6,[R4, #+40]
   \       0x88   0x6331             STR      R1,[R6, #+48]
   2055          
   2056                /* Set the DMA error callback */
   2057                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0x8A   0x6AA1             LDR      R1,[R4, #+40]
   \       0x8C   0x6348             STR      R0,[R1, #+52]
   2058          
   2059                /* Enable the DMA channel */
   2060                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
   \       0x8E   0x6821             LDR      R1,[R4, #+0]
   \       0x90   0x313C             ADDS     R1,R1,#+60
   \       0x92   0x6AA0             LDR      R0,[R4, #+40]
   \       0x94   0x....'....        BL       HAL_DMA_Start_IT
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD111             BNE      ??HAL_TIM_IC_Start_DMA_3
   2061                {
   2062                  return HAL_ERROR;
   2063                }
   2064                /* Enable the TIM Capture/Compare 3  DMA request */
   2065                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x68C1             LDR      R1,[R0, #+12]
   \       0xA0   0x2280             MOVS     R2,#+128
   \       0xA2   0x0112             LSLS     R2,R2,#+4        ;; #+2048
   \       0xA4   0xE012             B        ??HAL_TIM_IC_Start_DMA_9
   2066                break;
   2067              }
   2068          
   2069              case TIM_CHANNEL_4:
   2070              {
   2071                /* Set the DMA capture callbacks */
   2072                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \       0xA6   0x6AE7             LDR      R7,[R4, #+44]
   \       0xA8   0x62FE             STR      R6,[R7, #+44]
   2073                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xAA   0x6AE6             LDR      R6,[R4, #+44]
   \       0xAC   0x6331             STR      R1,[R6, #+48]
   2074          
   2075                /* Set the DMA error callback */
   2076                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \       0xAE   0x6AE1             LDR      R1,[R4, #+44]
   \       0xB0   0x6348             STR      R0,[R1, #+52]
   2077          
   2078                /* Enable the DMA channel */
   2079                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
   \       0xB2   0x6821             LDR      R1,[R4, #+0]
   \       0xB4   0x3140             ADDS     R1,R1,#+64
   \       0xB6   0x6AE0             LDR      R0,[R4, #+44]
   \       0xB8   0x....'....        BL       HAL_DMA_Start_IT
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD001             BEQ      ??HAL_TIM_IC_Start_DMA_10
   2080                {
   2081                  return HAL_ERROR;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \       0xC0   0x2001             MOVS     R0,#+1
   \       0xC2   0xBDF2             POP      {R1,R4-R7,PC}
   2082                }
   2083                /* Enable the TIM Capture/Compare 4  DMA request */
   2084                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Start_DMA_10: (+1)
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x68C1             LDR      R1,[R0, #+12]
   \       0xC8   0x2280             MOVS     R2,#+128
   \       0xCA   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \                     ??HAL_TIM_IC_Start_DMA_9: (+1)
   \       0xCC   0x430A             ORRS     R2,R2,R1
   \       0xCE   0x60C2             STR      R2,[R0, #+12]
   2085                break;
   2086              }
   2087          
   2088              default:
   2089                break;
   2090            }
   2091          
   2092            /* Enable the Input Capture channel */
   2093            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_8: (+1)
   \       0xD0   0x2201             MOVS     R2,#+1
   \       0xD2   0x0029             MOVS     R1,R5
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x....'....        BL       TIM_CCxChannelCmd
   2094          
   2095            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2096            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0xDA   0x6820             LDR      R0,[R4, #+0]
   \       0xDC   0x6880             LDR      R0,[R0, #+8]
   2097            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0xDE   0x0740             LSLS     R0,R0,#+29
   \       0xE0   0x0F40             LSRS     R0,R0,#+29
   \       0xE2   0x2806             CMP      R0,#+6
   \       0xE4   0xD005             BEQ      ??HAL_TIM_IC_Start_DMA_11
   2098            {
   2099              __HAL_TIM_ENABLE(htim);
   \       0xE6   0x6820             LDR      R0,[R4, #+0]
   \       0xE8   0x6800             LDR      R0,[R0, #+0]
   \       0xEA   0x2101             MOVS     R1,#+1
   \       0xEC   0x4301             ORRS     R1,R1,R0
   \       0xEE   0x6820             LDR      R0,[R4, #+0]
   \       0xF0   0x6001             STR      R1,[R0, #+0]
   2100            }
   2101          
   2102            /* Return function status */
   2103            return HAL_OK;
   \                     ??HAL_TIM_IC_Start_DMA_11: (+1)
   \       0xF2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \       0xF4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2104          }
   2105          
   2106          /**
   2107            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   2108            * @param  htim TIM Input Capture handle
   2109            * @param  Channel TIM Channels to be disabled
   2110            *          This parameter can be one of the following values:
   2111            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2112            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2113            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2114            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2115            * @retval HAL status
   2116            */

   \                                 In section .text, align 2, keep-with-next
   2117          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2118          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....             B.N      ?Subroutine8
   2119            /* Check the parameters */
   2120            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2121            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2122          
   2123            switch (Channel)
   2124            {
   2125              case TIM_CHANNEL_1:
   2126              {
   2127                /* Disable the TIM Capture/Compare 1 DMA request */
   2128                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2129                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   2130                break;
   2131              }
   2132          
   2133              case TIM_CHANNEL_2:
   2134              {
   2135                /* Disable the TIM Capture/Compare 2 DMA request */
   2136                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2137                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   2138                break;
   2139              }
   2140          
   2141              case TIM_CHANNEL_3:
   2142              {
   2143                /* Disable the TIM Capture/Compare 3  DMA request */
   2144                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   2145                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   2146                break;
   2147              }
   2148          
   2149              case TIM_CHANNEL_4:
   2150              {
   2151                /* Disable the TIM Capture/Compare 4  DMA request */
   2152                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   2153                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   2154                break;
   2155              }
   2156          
   2157              default:
   2158                break;
   2159            }
   2160          
   2161            /* Disable the Input Capture channel */
   2162            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2163          
   2164            /* Disable the Peripheral */
   2165            __HAL_TIM_DISABLE(htim);
   2166          
   2167            /* Change the htim state */
   2168            htim->State = HAL_TIM_STATE_READY;
   2169          
   2170            /* Return function status */
   2171            return HAL_OK;
   2172          }
   2173          /**
   2174            * @}
   2175            */
   2176          
   2177          /** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
   2178           *  @brief    TIM One Pulse functions
   2179           *
   2180          @verbatim
   2181            ==============================================================================
   2182                                  ##### TIM One Pulse functions #####
   2183            ==============================================================================
   2184            [..]
   2185              This section provides functions allowing to:
   2186              (+) Initialize and configure the TIM One Pulse.
   2187              (+) De-initialize the TIM One Pulse.
   2188              (+) Start the TIM One Pulse.
   2189              (+) Stop the TIM One Pulse.
   2190              (+) Start the TIM One Pulse and enable interrupt.
   2191              (+) Stop the TIM One Pulse and disable interrupt.
   2192              (+) Start the TIM One Pulse and enable DMA transfer.
   2193              (+) Stop the TIM One Pulse and disable DMA transfer.
   2194          
   2195          @endverbatim
   2196            * @{
   2197            */
   2198          /**
   2199            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   2200            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   2201            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2202            *         requires a timer reset to avoid unexpected direction
   2203            *         due to DIR bit readonly in center aligned mode.
   2204            *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
   2205            * @param  htim TIM One Pulse handle
   2206            * @param  OnePulseMode Select the One pulse mode.
   2207            *         This parameter can be one of the following values:
   2208            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   2209            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   2210            * @retval HAL status
   2211            */

   \                                 In section .text, align 2, keep-with-next
   2212          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2213          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2214            /* Check the TIM handle allocation */
   2215            if (htim == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE      ??HAL_TIM_OnePulse_Init_0
   2216            {
   2217              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xBD32             POP      {R1,R4,R5,PC}
   2218            }
   2219          
   2220            /* Check the parameters */
   2221            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2222            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2223            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2224            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2225            assert_param(IS_TIM_PERIOD(htim->Init.Period));
   2226            assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
   2227            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2228          
   2229            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \        0xE   0x2039             MOVS     R0,#+57
   \       0x10   0x5C20             LDRB     R0,[R4, R0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD104             BNE      ??HAL_TIM_OnePulse_Init_1
   2230            {
   2231              /* Allocate lock resource and initialize it */
   2232              htim->Lock = HAL_UNLOCKED;
   \       0x16   0x2138             MOVS     R1,#+56
   \       0x18   0x5460             STRB     R0,[R4, R1]
   2233          
   2234          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2235              /* Reset interrupt callbacks to legacy weak callbacks */
   2236              TIM_ResetCallback(htim);
   2237          
   2238              if (htim->OnePulse_MspInitCallback == NULL)
   2239              {
   2240                htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
   2241              }
   2242              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2243              htim->OnePulse_MspInitCallback(htim);
   2244          #else
   2245              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2246              HAL_TIM_OnePulse_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x....'....        BL       HAL_TIM_OnePulse_MspInit
   2247          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2248            }
   2249          
   2250            /* Set the TIM state */
   2251            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x2139             MOVS     R1,#+57
   \       0x24   0x5460             STRB     R0,[R4, R1]
   2252          
   2253            /* Configure the Time base in the One Pulse Mode */
   2254            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x....'....        BL       TIM_Base_SetConfig
   2255          
   2256            /* Reset the OPM Bit */
   2257            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x2208             MOVS     R2,#+8
   \       0x34   0x4391             BICS     R1,R1,R2
   \       0x36   0x6001             STR      R1,[R0, #+0]
   2258          
   2259            /* Configure the OPM Mode */
   2260            htim->Instance->CR1 |= OnePulseMode;
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6801             LDR      R1,[R0, #+0]
   \       0x3C   0x430D             ORRS     R5,R5,R1
   \       0x3E   0x6005             STR      R5,[R0, #+0]
   2261          
   2262            /* Initialize the TIM state*/
   2263            htim->State = HAL_TIM_STATE_READY;
   \       0x40   0x....             B.N      ??Subroutine8_0
   2264          
   2265            return HAL_OK;
   2266          }
   2267          
   2268          /**
   2269            * @brief  DeInitializes the TIM One Pulse
   2270            * @param  htim TIM One Pulse handle
   2271            * @retval HAL status
   2272            */

   \                                 In section .text, align 2, keep-with-next
   2273          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2274          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2275            /* Check the parameters */
   2276            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2277          
   2278            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x2139             MOVS     R1,#+57
   \        0x8   0x5460             STRB     R0,[R4, R1]
   2279          
   2280            /* Disable the TIM Peripheral Clock */
   2281            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable17_2  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0xD105             BNE      ??HAL_TIM_OnePulse_DeInit_0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x4388             BICS     R0,R0,R1
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   2282          
   2283          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2284            if (htim->OnePulse_MspDeInitCallback == NULL)
   2285            {
   2286              htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
   2287            }
   2288            /* DeInit the low level hardware */
   2289            htim->OnePulse_MspDeInitCallback(htim);
   2290          #else
   2291            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2292            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       HAL_TIM_OnePulse_MspDeInit
   2293          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2294          
   2295            /* Change TIM state */
   2296            htim->State = HAL_TIM_STATE_RESET;
   \       0x26   0x....             B.N      ?Subroutine4
   2297          
   2298            /* Release Lock */
   2299            __HAL_UNLOCK(htim);
   2300          
   2301            return HAL_OK;
   2302          }
   2303          
   2304          /**
   2305            * @brief  Initializes the TIM One Pulse MSP.
   2306            * @param  htim TIM One Pulse handle
   2307            * @retval None
   2308            */

   \                                 In section .text, align 2
   2309          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2310          {
   2311            /* Prevent unused argument(s) compilation warning */
   2312            UNUSED(htim);
   2313          
   2314            /* NOTE : This function should not be modified, when the callback is needed,
   2315                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2316             */
   2317          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2318          
   2319          /**
   2320            * @brief  DeInitializes TIM One Pulse MSP.
   2321            * @param  htim TIM One Pulse handle
   2322            * @retval None
   2323            */

   \                                 In section .text, align 2
   2324          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2325          {
   2326            /* Prevent unused argument(s) compilation warning */
   2327            UNUSED(htim);
   2328          
   2329            /* NOTE : This function should not be modified, when the callback is needed,
   2330                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2331             */
   2332          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2333          
   2334          /**
   2335            * @brief  Starts the TIM One Pulse signal generation.
   2336            * @param  htim TIM One Pulse handle
   2337            * @param  OutputChannel TIM Channels to be enabled
   2338            *          This parameter can be one of the following values:
   2339            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2340            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2341            * @retval HAL status
   2342            */

   \                                 In section .text, align 2, keep-with-next
   2343          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2344          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2345            /* Prevent unused argument(s) compilation warning */
   2346            UNUSED(OutputChannel);
   2347          
   2348            /* Enable the Capture compare and the Input Capture channels
   2349              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2350              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2351              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2352              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2353          
   2354              No need to enable the counter, it's enabled automatically by hardware
   2355              (the counter starts in response to a stimulus and generate a pulse */
   2356          
   2357            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x....             B.N      ?Subroutine3
   2358            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2359          
   2360            /* Return function status */
   2361            return HAL_OK;
   2362          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x....'....        BL       TIM_CCxChannelCmd
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x2104             MOVS     R1,#+4
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x....'....        BL       TIM_CCxChannelCmd
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD10             POP      {R4,PC}          ;; return
   2363          
   2364          /**
   2365            * @brief  Stops the TIM One Pulse signal generation.
   2366            * @param  htim TIM One Pulse handle
   2367            * @param  OutputChannel TIM Channels to be disable
   2368            *          This parameter can be one of the following values:
   2369            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2370            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2371            * @retval HAL status
   2372            */

   \                                 In section .text, align 2, keep-with-next
   2373          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2374          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2375            /* Prevent unused argument(s) compilation warning */
   2376            UNUSED(OutputChannel);
   2377          
   2378            /* Disable the Capture compare and the Input Capture channels
   2379            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2380            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2381            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2382            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2383          
   2384            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x....'....        BL       TIM_CCxChannelCmd
   2385            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x2104             MOVS     R1,#+4
   \       0x12   0x....             B.N      ??Subroutine1_1
   2386          
   2387            /* Disable the Peripheral */
   2388            __HAL_TIM_DISABLE(htim);
   2389          
   2390            /* Return function status */
   2391            return HAL_OK;
   2392          }
   2393          
   2394          /**
   2395            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2396            * @param  htim TIM One Pulse handle
   2397            * @param  OutputChannel TIM Channels to be enabled
   2398            *          This parameter can be one of the following values:
   2399            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2400            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2401            * @retval HAL status
   2402            */

   \                                 In section .text, align 2, keep-with-next
   2403          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2404          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2405            /* Prevent unused argument(s) compilation warning */
   2406            UNUSED(OutputChannel);
   2407          
   2408            /* Enable the Capture compare and the Input Capture channels
   2409              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2410              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2411              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2412              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2413          
   2414              No need to enable the counter, it's enabled automatically by hardware
   2415              (the counter starts in response to a stimulus and generate a pulse */
   2416          
   2417            /* Enable the TIM Capture/Compare 1 interrupt */
   2418            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C1             LDR      R1,[R0, #+12]
   \        0x8   0x2202             MOVS     R2,#+2
   \        0xA   0x430A             ORRS     R2,R2,R1
   \        0xC   0x60C2             STR      R2,[R0, #+12]
   2419          
   2420            /* Enable the TIM Capture/Compare 2 interrupt */
   2421            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x2204             MOVS     R2,#+4
   \       0x12   0x430A             ORRS     R2,R2,R1
   \       0x14   0x60C2             STR      R2,[R0, #+12]
   2422          
   2423            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A                      REQUIRE ?Subroutine3
   \       0x1A                      ;; // Fall through to label ?Subroutine3
   2424            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2425          
   2426            /* Return function status */
   2427            return HAL_OK;
   2428          }
   2429          
   2430          /**
   2431            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2432            * @param  htim TIM One Pulse handle
   2433            * @param  OutputChannel TIM Channels to be enabled
   2434            *          This parameter can be one of the following values:
   2435            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2436            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2437            * @retval HAL status
   2438            */

   \                                 In section .text, align 2, keep-with-next
   2439          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2440          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2441            /* Prevent unused argument(s) compilation warning */
   2442            UNUSED(OutputChannel);
   2443          
   2444            /* Disable the TIM Capture/Compare 1 interrupt */
   2445            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C1             LDR      R1,[R0, #+12]
   \        0x8   0x2202             MOVS     R2,#+2
   \        0xA   0x4391             BICS     R1,R1,R2
   \        0xC   0x60C1             STR      R1,[R0, #+12]
   2446          
   2447            /* Disable the TIM Capture/Compare 2 interrupt */
   2448            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x2204             MOVS     R2,#+4
   \       0x12   0x4391             BICS     R1,R1,R2
   \       0x14   0x60C1             STR      R1,[R0, #+12]
   2449          
   2450            /* Disable the Capture compare and the Input Capture channels
   2451            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2452            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2453            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2454            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2455            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x....'....        BL       TIM_CCxChannelCmd
   2456            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x2104             MOVS     R1,#+4
   \       0x22   0x....             B.N      ??Subroutine1_1
   2457          
   2458            /* Disable the Peripheral */
   2459            __HAL_TIM_DISABLE(htim);
   2460          
   2461            /* Return function status */
   2462            return HAL_OK;
   2463          }
   2464          
   2465          /**
   2466            * @}
   2467            */
   2468          
   2469          /** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
   2470           *  @brief    TIM Encoder functions
   2471           *
   2472          @verbatim
   2473            ==============================================================================
   2474                                    ##### TIM Encoder functions #####
   2475            ==============================================================================
   2476            [..]
   2477              This section provides functions allowing to:
   2478              (+) Initialize and configure the TIM Encoder.
   2479              (+) De-initialize the TIM Encoder.
   2480              (+) Start the TIM Encoder.
   2481              (+) Stop the TIM Encoder.
   2482              (+) Start the TIM Encoder and enable interrupt.
   2483              (+) Stop the TIM Encoder and disable interrupt.
   2484              (+) Start the TIM Encoder and enable DMA transfer.
   2485              (+) Stop the TIM Encoder and disable DMA transfer.
   2486          
   2487          @endverbatim
   2488            * @{
   2489            */
   2490          /**
   2491            * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
   2492            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2493            *         requires a timer reset to avoid unexpected direction
   2494            *         due to DIR bit readonly in center aligned mode.
   2495            *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
   2496            * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
   2497            *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
   2498            *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
   2499            * @param  htim TIM Encoder Interface handle
   2500            * @param  sConfig TIM Encoder Interface configuration structure
   2501            * @retval HAL status
   2502            */

   \                                 In section .text, align 2, keep-with-next
   2503          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
   2504          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   2505            uint32_t tmpsmcr;
   2506            uint32_t tmpccmr1;
   2507            uint32_t tmpccer;
   2508          
   2509            /* Check the TIM handle allocation */
   2510            if (htim == NULL)
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD101             BNE      ??HAL_TIM_Encoder_Init_0
   2511            {
   2512              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xBDF2             POP      {R1,R4-R7,PC}
   2513            }
   2514          
   2515            /* Check the parameters */
   2516            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2517            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2518            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2519            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2520            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2521            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2522            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2523            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2524            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2525            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2526            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2527            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2528            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2529            assert_param(IS_TIM_PERIOD(htim->Init.Period));
   2530            assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
   2531          
   2532            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \        0xE   0x2039             MOVS     R0,#+57
   \       0x10   0x5C28             LDRB     R0,[R5, R0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD104             BNE      ??HAL_TIM_Encoder_Init_1
   2533            {
   2534              /* Allocate lock resource and initialize it */
   2535              htim->Lock = HAL_UNLOCKED;
   \       0x16   0x2138             MOVS     R1,#+56
   \       0x18   0x5468             STRB     R0,[R5, R1]
   2536          
   2537          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2538              /* Reset interrupt callbacks to legacy weak callbacks */
   2539              TIM_ResetCallback(htim);
   2540          
   2541              if (htim->Encoder_MspInitCallback == NULL)
   2542              {
   2543                htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
   2544              }
   2545              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2546              htim->Encoder_MspInitCallback(htim);
   2547          #else
   2548              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2549              HAL_TIM_Encoder_MspInit(htim);
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0x....'....        BL       HAL_TIM_Encoder_MspInit
   2550          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2551            }
   2552          
   2553            /* Set the TIM state */
   2554            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x2139             MOVS     R1,#+57
   \       0x24   0x5468             STRB     R0,[R5, R1]
   2555          
   2556            /* Reset the SMS and ECE bits */
   2557            htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6881             LDR      R1,[R0, #+8]
   \       0x2A   0x....             LDR      R2,??DataTable18  ;; 0xffffbff8
   \       0x2C   0x400A             ANDS     R2,R2,R1
   \       0x2E   0x6082             STR      R2,[R0, #+8]
   2558          
   2559            /* Configure the Time base in the Encoder Mode */
   2560            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x30   0x1D29             ADDS     R1,R5,#+4
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x....'....        BL       TIM_Base_SetConfig
   2561          
   2562            /* Get the TIMx SMCR register value */
   2563            tmpsmcr = htim->Instance->SMCR;
   \       0x38   0x6828             LDR      R0,[R5, #+0]
   \       0x3A   0x6881             LDR      R1,[R0, #+8]
   2564          
   2565            /* Get the TIMx CCMR1 register value */
   2566            tmpccmr1 = htim->Instance->CCMR1;
   \       0x3C   0x6983             LDR      R3,[R0, #+24]
   2567          
   2568            /* Get the TIMx CCER register value */
   2569            tmpccer = htim->Instance->CCER;
   \       0x3E   0x6A02             LDR      R2,[R0, #+32]
   2570          
   2571            /* Set the encoder Mode */
   2572            tmpsmcr |= sConfig->EncoderMode;
   2573          
   2574            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2575            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2576            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   2577          
   2578            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2579            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2580            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2581            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   2582            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   \       0x40   0x....             LDR      R6,??DataTable18_1  ;; 0xfffffcfc
   \       0x42   0x401E             ANDS     R6,R6,R3
   \       0x44   0x68A3             LDR      R3,[R4, #+8]
   \       0x46   0x4333             ORRS     R3,R3,R6
   \       0x48   0x69A6             LDR      R6,[R4, #+24]
   \       0x4A   0x0236             LSLS     R6,R6,#+8
   \       0x4C   0x431E             ORRS     R6,R6,R3
   \       0x4E   0x....             LDR      R7,??DataTable18_2  ;; 0xffff0303
   \       0x50   0x4037             ANDS     R7,R7,R6
   \       0x52   0x68E3             LDR      R3,[R4, #+12]
   \       0x54   0x433B             ORRS     R3,R3,R7
   \       0x56   0x69E6             LDR      R6,[R4, #+28]
   \       0x58   0x0236             LSLS     R6,R6,#+8
   \       0x5A   0x431E             ORRS     R6,R6,R3
   \       0x5C   0x6923             LDR      R3,[R4, #+16]
   \       0x5E   0x011F             LSLS     R7,R3,#+4
   \       0x60   0x4337             ORRS     R7,R7,R6
   \       0x62   0x6A23             LDR      R3,[R4, #+32]
   \       0x64   0x031B             LSLS     R3,R3,#+12
   \       0x66   0x433B             ORRS     R3,R3,R7
   2583          
   2584            /* Set the TI1 and the TI2 Polarities */
   2585            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2586            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2587            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   \       0x68   0x26AA             MOVS     R6,#+170
   \       0x6A   0x43B2             BICS     R2,R2,R6
   \       0x6C   0x6866             LDR      R6,[R4, #+4]
   \       0x6E   0x4316             ORRS     R6,R6,R2
   \       0x70   0x6962             LDR      R2,[R4, #+20]
   \       0x72   0x0112             LSLS     R2,R2,#+4
   \       0x74   0x4332             ORRS     R2,R2,R6
   2588          
   2589            /* Write to TIMx SMCR */
   2590            htim->Instance->SMCR = tmpsmcr;
   \       0x76   0x6824             LDR      R4,[R4, #+0]
   \       0x78   0x430C             ORRS     R4,R4,R1
   \       0x7A   0x6084             STR      R4,[R0, #+8]
   2591          
   2592            /* Write to TIMx CCMR1 */
   2593            htim->Instance->CCMR1 = tmpccmr1;
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x6183             STR      R3,[R0, #+24]
   2594          
   2595            /* Write to TIMx CCER */
   2596            htim->Instance->CCER = tmpccer;
   \       0x80   0x6828             LDR      R0,[R5, #+0]
   \       0x82   0x6202             STR      R2,[R0, #+32]
   2597          
   2598            /* Initialize the TIM state*/
   2599            htim->State = HAL_TIM_STATE_READY;
   \       0x84   0x2001             MOVS     R0,#+1
   \       0x86   0x2139             MOVS     R1,#+57
   \       0x88   0x5468             STRB     R0,[R5, R1]
   2600          
   2601            return HAL_OK;
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2602          }
   2603          
   2604          
   2605          /**
   2606            * @brief  DeInitializes the TIM Encoder interface
   2607            * @param  htim TIM Encoder Interface handle
   2608            * @retval HAL status
   2609            */

   \                                 In section .text, align 2, keep-with-next
   2610          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2611          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2612            /* Check the parameters */
   2613            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2614          
   2615            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x2139             MOVS     R1,#+57
   \        0x8   0x5460             STRB     R0,[R4, R1]
   2616          
   2617            /* Disable the TIM Peripheral Clock */
   2618            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable17_2  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0xD105             BNE      ??HAL_TIM_Encoder_DeInit_0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x4388             BICS     R0,R0,R1
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   2619          
   2620          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2621            if (htim->Encoder_MspDeInitCallback == NULL)
   2622            {
   2623              htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
   2624            }
   2625            /* DeInit the low level hardware */
   2626            htim->Encoder_MspDeInitCallback(htim);
   2627          #else
   2628            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2629            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       HAL_TIM_Encoder_MspDeInit
   2630          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2631          
   2632            /* Change TIM state */
   2633            htim->State = HAL_TIM_STATE_RESET;
   \       0x26   0x....             B.N      ?Subroutine4
   2634          
   2635            /* Release Lock */
   2636            __HAL_UNLOCK(htim);
   2637          
   2638            return HAL_OK;
   2639          }
   2640          
   2641          /**
   2642            * @brief  Initializes the TIM Encoder Interface MSP.
   2643            * @param  htim TIM Encoder Interface handle
   2644            * @retval None
   2645            */

   \                                 In section .text, align 2
   2646          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2647          {
   2648            /* Prevent unused argument(s) compilation warning */
   2649            UNUSED(htim);
   2650          
   2651            /* NOTE : This function should not be modified, when the callback is needed,
   2652                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2653             */
   2654          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2655          
   2656          /**
   2657            * @brief  DeInitializes TIM Encoder Interface MSP.
   2658            * @param  htim TIM Encoder Interface handle
   2659            * @retval None
   2660            */

   \                                 In section .text, align 2
   2661          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2662          {
   2663            /* Prevent unused argument(s) compilation warning */
   2664            UNUSED(htim);
   2665          
   2666            /* NOTE : This function should not be modified, when the callback is needed,
   2667                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2668             */
   2669          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2670          
   2671          /**
   2672            * @brief  Starts the TIM Encoder Interface.
   2673            * @param  htim TIM Encoder Interface handle
   2674            * @param  Channel TIM Channels to be enabled
   2675            *          This parameter can be one of the following values:
   2676            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2677            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2678            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2679            * @retval HAL status
   2680            */

   \                                 In section .text, align 2, keep-with-next
   2681          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2682          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2683            /* Check the parameters */
   2684            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2685          
   2686            /* Enable the encoder interface channels */
   2687            switch (Channel)
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD001             BEQ      ??HAL_TIM_Encoder_Start_0
   \        0x8   0x2904             CMP      R1,#+4
   \        0xA   0xD101             BNE      ??HAL_TIM_Encoder_Start_1
   2688            {
   2689              case TIM_CHANNEL_1:
   2690              {
   2691                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2692                break;
   2693              }
   2694          
   2695              case TIM_CHANNEL_2:
   2696              {
   2697                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0xE006             B        ??HAL_TIM_Encoder_Start_2
   2698                break;
   2699              }
   2700          
   2701              default :
   2702              {
   2703                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x....'....        BL       TIM_CCxChannelCmd
   2704                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x1A   0x2201             MOVS     R2,#+1
   \       0x1C   0x2104             MOVS     R1,#+4
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x....'....        BL       TIM_CCxChannelCmd
   2705                break;
   2706              }
   2707            }
   2708            /* Enable the Peripheral */
   2709            __HAL_TIM_ENABLE(htim);
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x2201             MOVS     R2,#+1
   \       0x2A   0x430A             ORRS     R2,R2,R1
   \       0x2C   0x6002             STR      R2,[R0, #+0]
   2710          
   2711            /* Return function status */
   2712            return HAL_OK;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
   2713          }
   2714          
   2715          /**
   2716            * @brief  Stops the TIM Encoder Interface.
   2717            * @param  htim TIM Encoder Interface handle
   2718            * @param  Channel TIM Channels to be disabled
   2719            *          This parameter can be one of the following values:
   2720            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2721            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2722            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2723            * @retval HAL status
   2724            */

   \                                 In section .text, align 2, keep-with-next
   2725          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2726          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2727            /* Check the parameters */
   2728            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2729          
   2730            /* Disable the Input Capture channels 1 and 2
   2731              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2732            switch (Channel)
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD001             BEQ      ??HAL_TIM_Encoder_Stop_0
   \        0x8   0x2904             CMP      R1,#+4
   \        0xA   0xD101             BNE      ??HAL_TIM_Encoder_Stop_1
   2733            {
   2734              case TIM_CHANNEL_1:
   2735              {
   2736                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2737                break;
   2738              }
   2739          
   2740              case TIM_CHANNEL_2:
   2741              {
   2742                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0xE006             B        ??HAL_TIM_Encoder_Stop_2
   2743                break;
   2744              }
   2745          
   2746              default :
   2747              {
   2748                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x....'....        BL       TIM_CCxChannelCmd
   2749                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x2104             MOVS     R1,#+4
   2750                break;
   2751              }
   2752            }
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \       0x1E   0x....             B.N      ??Subroutine1_1
   2753          
   2754            /* Disable the Peripheral */
   2755            __HAL_TIM_DISABLE(htim);
   2756          
   2757            /* Return function status */
   2758            return HAL_OK;
   2759          }
   2760          
   2761          /**
   2762            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2763            * @param  htim TIM Encoder Interface handle
   2764            * @param  Channel TIM Channels to be enabled
   2765            *          This parameter can be one of the following values:
   2766            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2767            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2768            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2769            * @retval HAL status
   2770            */

   \                                 In section .text, align 2, keep-with-next
   2771          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2772          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   2773            /* Check the parameters */
   2774            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2775          
   2776            /* Enable the encoder interface channels */
   2777            /* Enable the capture compare Interrupts 1 and/or 2 */
   2778            switch (Channel)
   \        0x4   0x2502             MOVS     R5,#+2
   \        0x6   0x2404             MOVS     R4,#+4
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD002             BEQ      ??HAL_TIM_Encoder_Start_IT_0
   \        0xC   0x2904             CMP      R1,#+4
   \        0xE   0xD009             BEQ      ??HAL_TIM_Encoder_Start_IT_1
   \       0x10   0xE00E             B        ??HAL_TIM_Encoder_Start_IT_2
   2779            {
   2780              case TIM_CHANNEL_1:
   2781              {
   2782                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x6830             LDR      R0,[R6, #+0]
   \       0x16   0x....'....        BL       TIM_CCxChannelCmd
   2783                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x1A   0x6830             LDR      R0,[R6, #+0]
   \       0x1C   0x68C1             LDR      R1,[R0, #+12]
   \       0x1E   0x430D             ORRS     R5,R5,R1
   \       0x20   0x60C5             STR      R5,[R0, #+12]
   2784                break;
   \       0x22   0xE016             B        ??HAL_TIM_Encoder_Start_IT_3
   2785              }
   2786          
   2787              case TIM_CHANNEL_2:
   2788              {
   2789                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \       0x24   0x2201             MOVS     R2,#+1
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0x....'....        BL       TIM_CCxChannelCmd
   2790                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x2C   0x6830             LDR      R0,[R6, #+0]
   \       0x2E   0xE00D             B        ??HAL_TIM_Encoder_Start_IT_4
   2791                break;
   2792              }
   2793          
   2794              default :
   2795              {
   2796                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x6830             LDR      R0,[R6, #+0]
   \       0x36   0x....'....        BL       TIM_CCxChannelCmd
   2797                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x3A   0x2201             MOVS     R2,#+1
   \       0x3C   0x2104             MOVS     R1,#+4
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x....'....        BL       TIM_CCxChannelCmd
   2798                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x44   0x6830             LDR      R0,[R6, #+0]
   \       0x46   0x68C1             LDR      R1,[R0, #+12]
   \       0x48   0x430D             ORRS     R5,R5,R1
   \       0x4A   0x60C5             STR      R5,[R0, #+12]
   2799                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_Encoder_Start_IT_4: (+1)
   \       0x4C   0x68C1             LDR      R1,[R0, #+12]
   \       0x4E   0x430C             ORRS     R4,R4,R1
   \       0x50   0x60C4             STR      R4,[R0, #+12]
   2800                break;
   2801              }
   2802            }
   2803          
   2804            /* Enable the Peripheral */
   2805            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \       0x52   0x6830             LDR      R0,[R6, #+0]
   \       0x54   0x6801             LDR      R1,[R0, #+0]
   \       0x56   0x2201             MOVS     R2,#+1
   \       0x58   0x430A             ORRS     R2,R2,R1
   \       0x5A   0x6002             STR      R2,[R0, #+0]
   2806          
   2807            /* Return function status */
   2808            return HAL_OK;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xBD70             POP      {R4-R6,PC}       ;; return
   2809          }
   2810          
   2811          /**
   2812            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2813            * @param  htim TIM Encoder Interface handle
   2814            * @param  Channel TIM Channels to be disabled
   2815            *          This parameter can be one of the following values:
   2816            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2817            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2818            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2819            * @retval HAL status
   2820            */

   \                                 In section .text, align 2, keep-with-next
   2821          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2822          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2823            /* Check the parameters */
   2824            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2825          
   2826            /* Disable the Input Capture channels 1 and 2
   2827              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2828            if (Channel == TIM_CHANNEL_1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2602             MOVS     R6,#+2
   \        0x8   0x43F6             MVNS     R6,R6            ;; #-3
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD107             BNE      ??HAL_TIM_Encoder_Stop_IT_0
   2829            {
   2830              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x....'....        BL       TIM_CCxChannelCmd
   2831          
   2832              /* Disable the capture compare Interrupts 1 */
   2833              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C1             LDR      R1,[R0, #+12]
   \       0x18   0x400E             ANDS     R6,R6,R1
   \       0x1A   0x60C6             STR      R6,[R0, #+12]
   \       0x1C   0xE018             B        ??HAL_TIM_Encoder_Stop_IT_1
   2834            }
   2835            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \       0x1E   0x2504             MOVS     R5,#+4
   \       0x20   0x43ED             MVNS     R5,R5            ;; #-5
   \       0x22   0x2904             CMP      R1,#+4
   \       0x24   0xD103             BNE      ??HAL_TIM_Encoder_Stop_IT_2
   2836            {
   2837              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x....'....        BL       TIM_CCxChannelCmd
   2838          
   2839              /* Disable the capture compare Interrupts 2 */
   2840              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x2C   0xE00C             B        ??HAL_TIM_Encoder_Stop_IT_3
   2841            }
   2842            else
   2843            {
   2844              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x....'....        BL       TIM_CCxChannelCmd
   2845              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x2104             MOVS     R1,#+4
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x....'....        BL       TIM_CCxChannelCmd
   2846          
   2847              /* Disable the capture compare Interrupts 1 and 2 */
   2848              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x68C1             LDR      R1,[R0, #+12]
   \       0x44   0x400E             ANDS     R6,R6,R1
   \       0x46   0x60C6             STR      R6,[R0, #+12]
   2849              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x68C1             LDR      R1,[R0, #+12]
   \       0x4C   0x400D             ANDS     R5,R5,R1
   \       0x4E   0x60C5             STR      R5,[R0, #+12]
   2850            }
   2851          
   2852            /* Disable the Peripheral */
   2853            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \       0x50   0x....             B.N      ?Subroutine10
   2854          
   2855            /* Change the htim state */
   2856            htim->State = HAL_TIM_STATE_READY;
   2857          
   2858            /* Return function status */
   2859            return HAL_OK;
   2860          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6A00             LDR      R0,[R0, #+32]
   \        0x4   0x....             LDR      R1,??DataTable20_1  ;; 0x1111
   \        0x6   0x4001             ANDS     R1,R1,R0
   \        0x8   0xD105             BNE      ??Subroutine10_0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x4388             BICS     R0,R0,R1
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \                     ??Subroutine10_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x2139             MOVS     R1,#+57
   \       0x1A   0x5460             STRB     R0,[R4, R1]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD70             POP      {R4-R6,PC}       ;; return
   2861          
   2862          /**
   2863            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2864            * @param  htim TIM Encoder Interface handle
   2865            * @param  Channel TIM Channels to be enabled
   2866            *          This parameter can be one of the following values:
   2867            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2868            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2869            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2870            * @param  pData1 The destination Buffer address for IC1.
   2871            * @param  pData2 The destination Buffer address for IC2.
   2872            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2873            * @retval HAL status
   2874            */

   \                                 In section .text, align 2, keep-with-next
   2875          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2876          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2877            /* Check the parameters */
   2878            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2879          
   2880            if ((htim->State == HAL_TIM_STATE_BUSY))
   \        0x4   0x2039             MOVS     R0,#+57
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0xD07B             BEQ      ??HAL_TIM_Encoder_Start_DMA_0
   \        0xC   0x9300             STR      R3,[SP, #+0]
   2881            {
   2882              return HAL_BUSY;
   2883            }
   2884            else if ((htim->State == HAL_TIM_STATE_READY))
   \        0xE   0x2039             MOVS     R0,#+57
   \       0x10   0x5C20             LDRB     R0,[R4, R0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD10A             BNE      ??HAL_TIM_Encoder_Start_DMA_1
   2885            {
   2886              if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
   \       0x16   0x2A00             CMP      R2,#+0
   \       0x18   0xD001             BEQ      ??HAL_TIM_Encoder_Start_DMA_2
   \       0x1A   0x2B00             CMP      R3,#+0
   \       0x1C   0xD103             BNE      ??HAL_TIM_Encoder_Start_DMA_3
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x8B00             LDRH     R0,[R0, #+24]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD16D             BNE      ??HAL_TIM_Encoder_Start_DMA_4
   2887              {
   2888                return HAL_ERROR;
   2889              }
   2890              else
   2891              {
   2892                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0x2339             MOVS     R3,#+57
   \       0x2A   0x54E0             STRB     R0,[R4, R3]
   2893              }
   2894            }
   2895            else
   2896            {
   2897              /* nothing to do */
   2898            }
   2899          
   2900            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \       0x2C   0x2780             MOVS     R7,#+128
   \       0x2E   0x00BF             LSLS     R7,R7,#+2        ;; #+512
   \       0x30   0x2601             MOVS     R6,#+1
   \       0x32   0x....             LDR      R5,??DataTable19
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD004             BEQ      ??HAL_TIM_Encoder_Start_DMA_5
   \       0x38   0x2904             CMP      R1,#+4
   \       0x3A   0xD01E             BEQ      ??HAL_TIM_Encoder_Start_DMA_6
   \       0x3C   0x293C             CMP      R1,#+60
   \       0x3E   0xD03D             BEQ      ??HAL_TIM_Encoder_Start_DMA_7
   \       0x40   0xE079             B        ??HAL_TIM_Encoder_Start_DMA_8
   2901            {
   2902              case TIM_CHANNEL_1:
   2903              {
   2904                /* Set the DMA capture callbacks */
   2905                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \       0x42   0x....             LDR      R0,??DataTable19_1
   \       0x44   0x6A21             LDR      R1,[R4, #+32]
   \       0x46   0x62C8             STR      R0,[R1, #+44]
   2906                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x48   0x....             LDR      R0,??DataTable19_2
   \       0x4A   0x6A21             LDR      R1,[R4, #+32]
   \       0x4C   0x6308             STR      R0,[R1, #+48]
   2907          
   2908                /* Set the DMA error callback */
   2909                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x4E   0x6A20             LDR      R0,[R4, #+32]
   \       0x50   0x6345             STR      R5,[R0, #+52]
   2910          
   2911                /* Enable the DMA channel */
   2912                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   \       0x52   0x4668             MOV      R0,SP
   \       0x54   0x8B03             LDRH     R3,[R0, #+24]
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0x3134             ADDS     R1,R1,#+52
   \       0x5A   0x6A20             LDR      R0,[R4, #+32]
   \       0x5C   0x....'....        BL       HAL_DMA_Start_IT
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD14E             BNE      ??HAL_TIM_Encoder_Start_DMA_4
   2913                {
   2914                  return HAL_ERROR;
   2915                }
   2916                /* Enable the TIM Input Capture DMA request */
   2917                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x68C1             LDR      R1,[R0, #+12]
   \       0x68   0x430F             ORRS     R7,R7,R1
   \       0x6A   0x60C7             STR      R7,[R0, #+12]
   2918          
   2919                /* Enable the Peripheral */
   2920                __HAL_TIM_ENABLE(htim);
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0x430E             ORRS     R6,R6,R1
   \       0x72   0x6006             STR      R6,[R0, #+0]
   2921          
   2922                /* Enable the Capture compare channel */
   2923                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x74   0x2201             MOVS     R2,#+1
   \       0x76   0x2100             MOVS     R1,#+0
   \       0x78   0xE01C             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2924                break;
   2925              }
   2926          
   2927              case TIM_CHANNEL_2:
   2928              {
   2929                /* Set the DMA capture callbacks */
   2930                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \       0x7A   0x....             LDR      R0,??DataTable19_1
   \       0x7C   0x6A61             LDR      R1,[R4, #+36]
   \       0x7E   0x62C8             STR      R0,[R1, #+44]
   2931                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x80   0x....             LDR      R0,??DataTable19_2
   \       0x82   0x6A61             LDR      R1,[R4, #+36]
   \       0x84   0x6308             STR      R0,[R1, #+48]
   2932          
   2933                /* Set the DMA error callback */
   2934                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   \       0x86   0x6A60             LDR      R0,[R4, #+36]
   \       0x88   0x6345             STR      R5,[R0, #+52]
   2935                /* Enable the DMA channel */
   2936                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   \       0x8A   0x4668             MOV      R0,SP
   \       0x8C   0x8B03             LDRH     R3,[R0, #+24]
   \       0x8E   0x9A00             LDR      R2,[SP, #+0]
   \       0x90   0x6821             LDR      R1,[R4, #+0]
   \       0x92   0x3138             ADDS     R1,R1,#+56
   \       0x94   0x6A60             LDR      R0,[R4, #+36]
   \       0x96   0x....'....        BL       HAL_DMA_Start_IT
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD131             BNE      ??HAL_TIM_Encoder_Start_DMA_4
   2937                {
   2938                  return HAL_ERROR;
   2939                }
   2940                /* Enable the TIM Input Capture  DMA request */
   2941                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0x9E   0x6820             LDR      R0,[R4, #+0]
   \       0xA0   0x68C1             LDR      R1,[R0, #+12]
   \       0xA2   0x02B2             LSLS     R2,R6,#+10
   \       0xA4   0x430A             ORRS     R2,R2,R1
   \       0xA6   0x60C2             STR      R2,[R0, #+12]
   2942          
   2943                /* Enable the Peripheral */
   2944                __HAL_TIM_ENABLE(htim);
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x6801             LDR      R1,[R0, #+0]
   \       0xAC   0x430E             ORRS     R6,R6,R1
   \       0xAE   0x6006             STR      R6,[R0, #+0]
   2945          
   2946                /* Enable the Capture compare channel */
   2947                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0xB0   0x2201             MOVS     R2,#+1
   \       0xB2   0x2104             MOVS     R1,#+4
   \                     ??HAL_TIM_Encoder_Start_DMA_9: (+1)
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x....'....        BL       TIM_CCxChannelCmd
   2948                break;
   \       0xBA   0xE03C             B        ??HAL_TIM_Encoder_Start_DMA_8
   2949              }
   2950          
   2951              case TIM_CHANNEL_ALL:
   2952              {
   2953                /* Set the DMA capture callbacks */
   2954                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \       0xBC   0x....             LDR      R0,??DataTable19_1
   \       0xBE   0x6A21             LDR      R1,[R4, #+32]
   \       0xC0   0x62C8             STR      R0,[R1, #+44]
   2955                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xC2   0x....             LDR      R0,??DataTable19_2
   \       0xC4   0x6A21             LDR      R1,[R4, #+32]
   \       0xC6   0x6308             STR      R0,[R1, #+48]
   2956          
   2957                /* Set the DMA error callback */
   2958                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0xC8   0x6A20             LDR      R0,[R4, #+32]
   \       0xCA   0x6345             STR      R5,[R0, #+52]
   2959          
   2960                /* Enable the DMA channel */
   2961                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   \       0xCC   0x4668             MOV      R0,SP
   \       0xCE   0x8B03             LDRH     R3,[R0, #+24]
   \       0xD0   0x6821             LDR      R1,[R4, #+0]
   \       0xD2   0x3134             ADDS     R1,R1,#+52
   \       0xD4   0x6A20             LDR      R0,[R4, #+32]
   \       0xD6   0x....'....        BL       HAL_DMA_Start_IT
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD111             BNE      ??HAL_TIM_Encoder_Start_DMA_4
   2962                {
   2963                  return HAL_ERROR;
   2964                }
   2965          
   2966                /* Set the DMA capture callbacks */
   2967                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \       0xDE   0x....             LDR      R0,??DataTable19_1
   \       0xE0   0x6A61             LDR      R1,[R4, #+36]
   \       0xE2   0x62C8             STR      R0,[R1, #+44]
   2968                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xE4   0x....             LDR      R0,??DataTable19_2
   \       0xE6   0x6A61             LDR      R1,[R4, #+36]
   \       0xE8   0x6308             STR      R0,[R1, #+48]
   2969          
   2970                /* Set the DMA error callback */
   2971                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0xEA   0x6A60             LDR      R0,[R4, #+36]
   \       0xEC   0x6345             STR      R5,[R0, #+52]
   2972          
   2973                /* Enable the DMA channel */
   2974                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   \       0xEE   0x4668             MOV      R0,SP
   \       0xF0   0x8B03             LDRH     R3,[R0, #+24]
   \       0xF2   0x9A00             LDR      R2,[SP, #+0]
   \       0xF4   0x6821             LDR      R1,[R4, #+0]
   \       0xF6   0x3138             ADDS     R1,R1,#+56
   \       0xF8   0x6A60             LDR      R0,[R4, #+36]
   \       0xFA   0x....'....        BL       HAL_DMA_Start_IT
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD001             BEQ      ??HAL_TIM_Encoder_Start_DMA_10
   2975                {
   2976                  return HAL_ERROR;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \      0x102   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \      0x104   0xBDF2             POP      {R1,R4-R7,PC}
   2977                }
   2978                /* Enable the Peripheral */
   2979                __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_DMA_10: (+1)
   \      0x106   0x6820             LDR      R0,[R4, #+0]
   \      0x108   0x6801             LDR      R1,[R0, #+0]
   \      0x10A   0x430E             ORRS     R6,R6,R1
   \      0x10C   0x6006             STR      R6,[R0, #+0]
   2980          
   2981                /* Enable the Capture compare channel */
   2982                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \      0x10E   0x2201             MOVS     R2,#+1
   \      0x110   0x2100             MOVS     R1,#+0
   \      0x112   0x6820             LDR      R0,[R4, #+0]
   \      0x114   0x....'....        BL       TIM_CCxChannelCmd
   2983                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \      0x118   0x2201             MOVS     R2,#+1
   \      0x11A   0x2104             MOVS     R1,#+4
   \      0x11C   0x6820             LDR      R0,[R4, #+0]
   \      0x11E   0x....'....        BL       TIM_CCxChannelCmd
   2984          
   2985                /* Enable the TIM Input Capture  DMA request */
   2986                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \      0x122   0x6820             LDR      R0,[R4, #+0]
   \      0x124   0x68C1             LDR      R1,[R0, #+12]
   \      0x126   0x430F             ORRS     R7,R7,R1
   \      0x128   0x60C7             STR      R7,[R0, #+12]
   2987                /* Enable the TIM Input Capture  DMA request */
   2988                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \      0x12A   0x6820             LDR      R0,[R4, #+0]
   \      0x12C   0x68C1             LDR      R1,[R0, #+12]
   \      0x12E   0x2280             MOVS     R2,#+128
   \      0x130   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \      0x132   0x430A             ORRS     R2,R2,R1
   \      0x134   0x60C2             STR      R2,[R0, #+12]
   2989                break;
   2990              }
   2991          
   2992              default:
   2993                break;
   2994            }
   2995            /* Return function status */
   2996            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_8: (+1)
   \      0x136   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_11: (+1)
   \      0x138   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2997          }
   2998          
   2999          /**
   3000            * @brief  Stops the TIM Encoder Interface in DMA mode.
   3001            * @param  htim TIM Encoder Interface handle
   3002            * @param  Channel TIM Channels to be enabled
   3003            *          This parameter can be one of the following values:
   3004            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3005            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3006            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3007            * @retval HAL status
   3008            */

   \                                 In section .text, align 2, keep-with-next
   3009          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   3010          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3011            /* Check the parameters */
   3012            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   3013          
   3014            /* Disable the Input Capture channels 1 and 2
   3015              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3016            if (Channel == TIM_CHANNEL_1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x....             LDR      R6,??DataTable19_3  ;; 0xfffffdff
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD108             BNE      ??HAL_TIM_Encoder_Stop_DMA_0
   3017            {
   3018              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x....'....        BL       TIM_CCxChannelCmd
   3019          
   3020              /* Disable the capture compare DMA Request 1 */
   3021              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C1             LDR      R1,[R0, #+12]
   \       0x16   0x400E             ANDS     R6,R6,R1
   \       0x18   0x60C6             STR      R6,[R0, #+12]
   3022              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x1A   0x6A20             LDR      R0,[R4, #+32]
   \       0x1C   0xE01F             B        ??HAL_TIM_Encoder_Stop_DMA_1
   3023            }
   3024            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \       0x1E   0x....             LDR      R5,??DataTable20  ;; 0xfffffbff
   \       0x20   0x2904             CMP      R1,#+4
   \       0x22   0xD107             BNE      ??HAL_TIM_Encoder_Stop_DMA_2
   3025            {
   3026              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x....'....        BL       TIM_CCxChannelCmd
   3027          
   3028              /* Disable the capture compare DMA Request 2 */
   3029              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x68C1             LDR      R1,[R0, #+12]
   \       0x2E   0x400D             ANDS     R5,R5,R1
   \       0x30   0x60C5             STR      R5,[R0, #+12]
   3030              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x32   0xE013             B        ??HAL_TIM_Encoder_Stop_DMA_3
   3031            }
   3032            else
   3033            {
   3034              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x....'....        BL       TIM_CCxChannelCmd
   3035              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x2104             MOVS     R1,#+4
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x....'....        BL       TIM_CCxChannelCmd
   3036          
   3037              /* Disable the capture compare DMA Request 1 and 2 */
   3038              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x68C1             LDR      R1,[R0, #+12]
   \       0x4A   0x400E             ANDS     R6,R6,R1
   \       0x4C   0x60C6             STR      R6,[R0, #+12]
   3039              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x68C1             LDR      R1,[R0, #+12]
   \       0x52   0x400D             ANDS     R5,R5,R1
   \       0x54   0x60C5             STR      R5,[R0, #+12]
   3040              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x56   0x6A20             LDR      R0,[R4, #+32]
   \       0x58   0x....'....        BL       HAL_DMA_Abort_IT
   3041              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \       0x5C   0x6A60             LDR      R0,[R4, #+36]
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \       0x5E   0x....'....        BL       HAL_DMA_Abort_IT
   3042            }
   3043          
   3044            /* Disable the Peripheral */
   3045            __HAL_TIM_DISABLE(htim);
   \       0x62                      REQUIRE ?Subroutine10
   \       0x62                      ;; // Fall through to label ?Subroutine10
   3046          
   3047            /* Change the htim state */
   3048            htim->State = HAL_TIM_STATE_READY;
   3049          
   3050            /* Return function status */
   3051            return HAL_OK;
   3052          }
   3053          
   3054          /**
   3055            * @}
   3056            */
   3057          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
   3058           *  @brief    TIM IRQ handler management
   3059           *
   3060          @verbatim
   3061            ==============================================================================
   3062                                  ##### IRQ handler management #####
   3063            ==============================================================================
   3064            [..]
   3065              This section provides Timer IRQ handler function.
   3066          
   3067          @endverbatim
   3068            * @{
   3069            */
   3070          /**
   3071            * @brief  This function handles TIM interrupts requests.
   3072            * @param  htim TIM  handle
   3073            * @retval None
   3074            */

   \                                 In section .text, align 2, keep-with-next
   3075          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   3076          {
   \                     HAL_TIM_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3077            /* Capture compare 1 event */
   3078            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x2602             MOVS     R6,#+2
   \        0xA   0x6901             LDR      R1,[R0, #+16]
   \        0xC   0x4031             ANDS     R1,R1,R6
   \        0xE   0xD015             BEQ      ??HAL_TIM_IRQHandler_0
   3079            {
   3080              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
   \       0x10   0x68C1             LDR      R1,[R0, #+12]
   \       0x12   0x4031             ANDS     R1,R1,R6
   \       0x14   0xD012             BEQ      ??HAL_TIM_IRQHandler_0
   3081              {
   3082                {
   3083                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \       0x16   0x2102             MOVS     R1,#+2
   \       0x18   0x43C9             MVNS     R1,R1            ;; #-3
   \       0x1A   0x6101             STR      R1,[R0, #+16]
   3084                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x7621             STRB     R1,[R4, #+24]
   3085          
   3086                  /* Input capture event */
   3087                  if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   \       0x20   0x6980             LDR      R0,[R0, #+24]
   \       0x22   0x0780             LSLS     R0,R0,#+30
   \       0x24   0xD003             BEQ      ??HAL_TIM_IRQHandler_1
   3088                  {
   3089          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3090                    htim->IC_CaptureCallback(htim);
   3091          #else
   3092                    HAL_TIM_IC_CaptureCallback(htim);
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0x2C   0xE005             B        ??HAL_TIM_IRQHandler_2
   3093          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3094                  }
   3095                  /* Output compare event */
   3096                  else
   3097                  {
   3098          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3099                    htim->OC_DelayElapsedCallback(htim);
   3100                    htim->PWM_PulseFinishedCallback(htim);
   3101          #else
   3102                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3103                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   3104          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3105                  }
   3106                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \       0x3A   0x7625             STRB     R5,[R4, #+24]
   3107                }
   3108              }
   3109            }
   3110            /* Capture compare 2 event */
   3111            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x2704             MOVS     R7,#+4
   \       0x40   0x6901             LDR      R1,[R0, #+16]
   \       0x42   0x4039             ANDS     R1,R1,R7
   \       0x44   0xD016             BEQ      ??HAL_TIM_IRQHandler_3
   3112            {
   3113              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
   \       0x46   0x68C1             LDR      R1,[R0, #+12]
   \       0x48   0x4039             ANDS     R1,R1,R7
   \       0x4A   0xD013             BEQ      ??HAL_TIM_IRQHandler_3
   3114              {
   3115                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \       0x4C   0x2104             MOVS     R1,#+4
   \       0x4E   0x43C9             MVNS     R1,R1            ;; #-5
   \       0x50   0x6101             STR      R1,[R0, #+16]
   3116                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x52   0x7626             STRB     R6,[R4, #+24]
   3117                /* Input capture event */
   3118                if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   \       0x54   0x6980             LDR      R0,[R0, #+24]
   \       0x56   0x21C0             MOVS     R1,#+192
   \       0x58   0x0089             LSLS     R1,R1,#+2        ;; #+768
   \       0x5A   0x4001             ANDS     R1,R1,R0
   \       0x5C   0xD003             BEQ      ??HAL_TIM_IRQHandler_4
   3119                {
   3120          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3121                  htim->IC_CaptureCallback(htim);
   3122          #else
   3123                  HAL_TIM_IC_CaptureCallback(htim);
   \       0x5E   0x0020             MOVS     R0,R4
   \       0x60   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0x64   0xE005             B        ??HAL_TIM_IRQHandler_5
   3124          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3125                }
   3126                /* Output compare event */
   3127                else
   3128                {
   3129          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3130                  htim->OC_DelayElapsedCallback(htim);
   3131                  htim->PWM_PulseFinishedCallback(htim);
   3132          #else
   3133                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3134                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   3135          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3136                }
   3137                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \       0x72   0x7625             STRB     R5,[R4, #+24]
   3138              }
   3139            }
   3140            /* Capture compare 3 event */
   3141            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x2608             MOVS     R6,#+8
   \       0x78   0x6901             LDR      R1,[R0, #+16]
   \       0x7A   0x4031             ANDS     R1,R1,R6
   \       0x7C   0xD014             BEQ      ??HAL_TIM_IRQHandler_6
   3142            {
   3143              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
   \       0x7E   0x68C1             LDR      R1,[R0, #+12]
   \       0x80   0x4031             ANDS     R1,R1,R6
   \       0x82   0xD011             BEQ      ??HAL_TIM_IRQHandler_6
   3144              {
   3145                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \       0x84   0x2108             MOVS     R1,#+8
   \       0x86   0x43C9             MVNS     R1,R1            ;; #-9
   \       0x88   0x6101             STR      R1,[R0, #+16]
   3146                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x8A   0x7627             STRB     R7,[R4, #+24]
   3147                /* Input capture event */
   3148                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   \       0x8C   0x69C0             LDR      R0,[R0, #+28]
   \       0x8E   0x0780             LSLS     R0,R0,#+30
   \       0x90   0xD003             BEQ      ??HAL_TIM_IRQHandler_7
   3149                {
   3150          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3151                  htim->IC_CaptureCallback(htim);
   3152          #else
   3153                  HAL_TIM_IC_CaptureCallback(htim);
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0x98   0xE005             B        ??HAL_TIM_IRQHandler_8
   3154          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3155                }
   3156                /* Output compare event */
   3157                else
   3158                {
   3159          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3160                  htim->OC_DelayElapsedCallback(htim);
   3161                  htim->PWM_PulseFinishedCallback(htim);
   3162          #else
   3163                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3164                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0xA0   0x0020             MOVS     R0,R4
   \       0xA2   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   3165          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3166                }
   3167                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \       0xA6   0x7625             STRB     R5,[R4, #+24]
   3168              }
   3169            }
   3170            /* Capture compare 4 event */
   3171            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x2110             MOVS     R1,#+16
   \       0xAC   0x6902             LDR      R2,[R0, #+16]
   \       0xAE   0x400A             ANDS     R2,R2,R1
   \       0xB0   0xD016             BEQ      ??HAL_TIM_IRQHandler_9
   3172            {
   3173              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
   \       0xB2   0x68C2             LDR      R2,[R0, #+12]
   \       0xB4   0x4011             ANDS     R1,R1,R2
   \       0xB6   0xD013             BEQ      ??HAL_TIM_IRQHandler_9
   3174              {
   3175                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \       0xB8   0x2110             MOVS     R1,#+16
   \       0xBA   0x43C9             MVNS     R1,R1            ;; #-17
   \       0xBC   0x6101             STR      R1,[R0, #+16]
   3176                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0xBE   0x7626             STRB     R6,[R4, #+24]
   3177                /* Input capture event */
   3178                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   \       0xC0   0x69C0             LDR      R0,[R0, #+28]
   \       0xC2   0x21C0             MOVS     R1,#+192
   \       0xC4   0x0089             LSLS     R1,R1,#+2        ;; #+768
   \       0xC6   0x4001             ANDS     R1,R1,R0
   \       0xC8   0xD003             BEQ      ??HAL_TIM_IRQHandler_10
   3179                {
   3180          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3181                  htim->IC_CaptureCallback(htim);
   3182          #else
   3183                  HAL_TIM_IC_CaptureCallback(htim);
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0xD0   0xE005             B        ??HAL_TIM_IRQHandler_11
   3184          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3185                }
   3186                /* Output compare event */
   3187                else
   3188                {
   3189          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3190                  htim->OC_DelayElapsedCallback(htim);
   3191                  htim->PWM_PulseFinishedCallback(htim);
   3192          #else
   3193                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \       0xD2   0x0020             MOVS     R0,R4
   \       0xD4   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3194                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0xD8   0x0020             MOVS     R0,R4
   \       0xDA   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   3195          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3196                }
   3197                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \       0xDE   0x7625             STRB     R5,[R4, #+24]
   3198              }
   3199            }
   3200            /* TIM Update event */
   3201            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \       0xE0   0x6820             LDR      R0,[R4, #+0]
   \       0xE2   0x2101             MOVS     R1,#+1
   \       0xE4   0x6902             LDR      R2,[R0, #+16]
   \       0xE6   0x400A             ANDS     R2,R2,R1
   \       0xE8   0xD008             BEQ      ??HAL_TIM_IRQHandler_12
   3202            {
   3203              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
   \       0xEA   0x68C2             LDR      R2,[R0, #+12]
   \       0xEC   0x4011             ANDS     R1,R1,R2
   \       0xEE   0xD005             BEQ      ??HAL_TIM_IRQHandler_12
   3204              {
   3205                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \       0xF0   0x2101             MOVS     R1,#+1
   \       0xF2   0x43C9             MVNS     R1,R1            ;; #-2
   \       0xF4   0x6101             STR      R1,[R0, #+16]
   3206          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3207                htim->PeriodElapsedCallback(htim);
   3208          #else
   3209                HAL_TIM_PeriodElapsedCallback(htim);
   \       0xF6   0x0020             MOVS     R0,R4
   \       0xF8   0x....'....        BL       HAL_TIM_PeriodElapsedCallback
   3210          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3211              }
   3212            }
   3213            /* TIM Trigger detection event */
   3214            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \       0xFC   0x6820             LDR      R0,[R4, #+0]
   \       0xFE   0x2140             MOVS     R1,#+64
   \      0x100   0x6902             LDR      R2,[R0, #+16]
   \      0x102   0x400A             ANDS     R2,R2,R1
   \      0x104   0xD008             BEQ      ??HAL_TIM_IRQHandler_13
   3215            {
   3216              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
   \      0x106   0x68C2             LDR      R2,[R0, #+12]
   \      0x108   0x4011             ANDS     R1,R1,R2
   \      0x10A   0xD005             BEQ      ??HAL_TIM_IRQHandler_13
   3217              {
   3218                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \      0x10C   0x2140             MOVS     R1,#+64
   \      0x10E   0x43C9             MVNS     R1,R1            ;; #-65
   \      0x110   0x6101             STR      R1,[R0, #+16]
   3219          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3220                htim->TriggerCallback(htim);
   3221          #else
   3222                HAL_TIM_TriggerCallback(htim);
   \      0x112   0x0020             MOVS     R0,R4
   \      0x114   0x....'....        BL       HAL_TIM_TriggerCallback
   3223          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3224              }
   3225            }
   3226          }
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \      0x118   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   3227          
   3228          /**
   3229            * @}
   3230            */
   3231          
   3232          /** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
   3233           *  @brief    TIM Peripheral Control functions
   3234           *
   3235          @verbatim
   3236            ==============================================================================
   3237                             ##### Peripheral Control functions #####
   3238            ==============================================================================
   3239           [..]
   3240             This section provides functions allowing to:
   3241                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   3242                (+) Configure External Clock source.
   3243                (+) Configure Master and the Slave synchronization.
   3244                (+) Configure the DMA Burst Mode.
   3245          
   3246          @endverbatim
   3247            * @{
   3248            */
   3249          
   3250          /**
   3251            * @brief  Initializes the TIM Output Compare Channels according to the specified
   3252            *         parameters in the TIM_OC_InitTypeDef.
   3253            * @param  htim TIM Output Compare handle
   3254            * @param  sConfig TIM Output Compare configuration structure
   3255            * @param  Channel TIM Channels to configure
   3256            *          This parameter can be one of the following values:
   3257            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3258            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3259            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3260            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3261            * @retval HAL status
   3262            */

   \                                 In section .text, align 2, keep-with-next
   3263          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
   3264                                                     TIM_OC_InitTypeDef *sConfig,
   3265                                                     uint32_t Channel)
   3266          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3267            /* Check the parameters */
   3268            assert_param(IS_TIM_CHANNELS(Channel));
   3269            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   3270            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3271          
   3272            /* Process Locked */
   3273            __HAL_LOCK(htim);
   \        0x4   0x2038             MOVS     R0,#+56
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIM_OC_ConfigChannel_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \       0x10   0x0026             MOVS     R6,R4
   \       0x12   0x3638             ADDS     R6,R6,#+56
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x7035             STRB     R5,[R6, #+0]
   3274          
   3275            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x2339             MOVS     R3,#+57
   \       0x1C   0x54E0             STRB     R0,[R4, R3]
   3276          
   3277            switch (Channel)
   \       0x1E   0x2A00             CMP      R2,#+0
   \       0x20   0xD006             BEQ      ??HAL_TIM_OC_ConfigChannel_1
   \       0x22   0x2A04             CMP      R2,#+4
   \       0x24   0xD008             BEQ      ??HAL_TIM_OC_ConfigChannel_2
   \       0x26   0x2A08             CMP      R2,#+8
   \       0x28   0xD00A             BEQ      ??HAL_TIM_OC_ConfigChannel_3
   \       0x2A   0x2A0C             CMP      R2,#+12
   \       0x2C   0xD00C             BEQ      ??HAL_TIM_OC_ConfigChannel_4
   \       0x2E   0xE00E             B        ??HAL_TIM_OC_ConfigChannel_5
   3278            {
   3279              case TIM_CHANNEL_1:
   3280              {
   3281                /* Check the parameters */
   3282                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3283          
   3284                /* Configure the TIM Channel 1 in Output Compare */
   3285                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x....'....        BL       TIM_OC1_SetConfig
   3286                break;
   \       0x36   0xE00A             B        ??HAL_TIM_OC_ConfigChannel_5
   3287              }
   3288          
   3289              case TIM_CHANNEL_2:
   3290              {
   3291                /* Check the parameters */
   3292                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3293          
   3294                /* Configure the TIM Channel 2 in Output Compare */
   3295                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x....'....        BL       TIM_OC2_SetConfig
   3296                break;
   \       0x3E   0xE006             B        ??HAL_TIM_OC_ConfigChannel_5
   3297              }
   3298          
   3299              case TIM_CHANNEL_3:
   3300              {
   3301                /* Check the parameters */
   3302                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3303          
   3304                /* Configure the TIM Channel 3 in Output Compare */
   3305                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x....'....        BL       TIM_OC3_SetConfig
   3306                break;
   \       0x46   0xE002             B        ??HAL_TIM_OC_ConfigChannel_5
   3307              }
   3308          
   3309              case TIM_CHANNEL_4:
   3310              {
   3311                /* Check the parameters */
   3312                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3313          
   3314                /* Configure the TIM Channel 4 in Output Compare */
   3315                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x....'....        BL       TIM_OC4_SetConfig
   3316                break;
   3317              }
   3318          
   3319              default:
   3320                break;
   3321            }
   3322          
   3323            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \       0x4E   0x....             B.N      ?Subroutine11
   3324          
   3325            __HAL_UNLOCK(htim);
   3326          
   3327            return HAL_OK;
   3328          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x2039             MOVS     R0,#+57
   \        0x2   0x5425             STRB     R5,[R4, R0]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x7030             STRB     R0,[R6, #+0]
   \        0x8   0xBD70             POP      {R4-R6,PC}       ;; return
   3329          
   3330          /**
   3331            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3332            *         parameters in the TIM_IC_InitTypeDef.
   3333            * @param  htim TIM IC handle
   3334            * @param  sConfig TIM Input Capture configuration structure
   3335            * @param  Channel TIM Channel to configure
   3336            *          This parameter can be one of the following values:
   3337            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3338            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3339            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3340            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3341            * @retval HAL status
   3342            */

   \                                 In section .text, align 2, keep-with-next
   3343          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
   3344          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   3345            /* Check the parameters */
   3346            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3347            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3348            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3349            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3350            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3351          
   3352            /* Process Locked */
   3353            __HAL_LOCK(htim);
   \        0x4   0x2038             MOVS     R0,#+56
   \        0x6   0x5C28             LDRB     R0,[R5, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIM_IC_ConfigChannel_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x2338             MOVS     R3,#+56
   \       0x14   0x54E8             STRB     R0,[R5, R3]
   3354          
   3355            htim->State = HAL_TIM_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2339             MOVS     R3,#+57
   \       0x1A   0x54E8             STRB     R0,[R5, R3]
   3356          
   3357            if (Channel == TIM_CHANNEL_1)
   \       0x1C   0x270C             MOVS     R7,#+12
   \       0x1E   0x43FF             MVNS     R7,R7            ;; #-13
   \       0x20   0x000C             MOVS     R4,R1
   \       0x22   0x2A00             CMP      R2,#+0
   \       0x24   0xD10D             BNE      ??HAL_TIM_IC_ConfigChannel_1
   3358            {
   3359              /* TI1 Configuration */
   3360              TIM_TI1_SetConfig(htim->Instance,
   3361                                sConfig->ICPolarity,
   3362                                sConfig->ICSelection,
   3363                                sConfig->ICFilter);
   \       0x26   0x68E3             LDR      R3,[R4, #+12]
   \       0x28   0x6862             LDR      R2,[R4, #+4]
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x....'....        BL       TIM_TI1_SetConfig
   3364          
   3365              /* Reset the IC1PSC Bits */
   3366              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x6981             LDR      R1,[R0, #+24]
   \       0x36   0x400F             ANDS     R7,R7,R1
   \       0x38   0x6187             STR      R7,[R0, #+24]
   3367          
   3368              /* Set the IC1PSC value */
   3369              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x6981             LDR      R1,[R0, #+24]
   \       0x3E   0x68A2             LDR      R2,[R4, #+8]
   \       0x40   0xE010             B.N      ??HAL_TIM_IC_ConfigChannel_2
   3370            }
   3371            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \       0x42   0x....             LDR      R6,??DataTable22  ;; 0xfffff3ff
   \       0x44   0x2A04             CMP      R2,#+4
   \       0x46   0xD110             BNE      ??HAL_TIM_IC_ConfigChannel_3
   3372            {
   3373              /* TI2 Configuration */
   3374              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3375          
   3376              TIM_TI2_SetConfig(htim->Instance,
   3377                                sConfig->ICPolarity,
   3378                                sConfig->ICSelection,
   3379                                sConfig->ICFilter);
   \       0x48   0x68E3             LDR      R3,[R4, #+12]
   \       0x4A   0x6862             LDR      R2,[R4, #+4]
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x....'....        BL       TIM_TI2_SetConfig
   3380          
   3381              /* Reset the IC2PSC Bits */
   3382              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \       0x54   0x6828             LDR      R0,[R5, #+0]
   \       0x56   0x6981             LDR      R1,[R0, #+24]
   \       0x58   0x400E             ANDS     R6,R6,R1
   \       0x5A   0x6186             STR      R6,[R0, #+24]
   3383          
   3384              /* Set the IC2PSC value */
   3385              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x6981             LDR      R1,[R0, #+24]
   \       0x60   0x68A2             LDR      R2,[R4, #+8]
   \       0x62   0x0212             LSLS     R2,R2,#+8
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \       0x64   0x430A             ORRS     R2,R2,R1
   \       0x66   0x6182             STR      R2,[R0, #+24]
   \       0x68   0xE052             B        ??HAL_TIM_IC_ConfigChannel_4
   3386            }
   3387            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \       0x6A   0x2A08             CMP      R2,#+8
   \       0x6C   0x68E0             LDR      R0,[R4, #+12]
   \       0x6E   0xD125             BNE      ??HAL_TIM_IC_ConfigChannel_5
   3388            {
   3389              /* TI3 Configuration */
   3390              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3391          
   3392              TIM_TI3_SetConfig(htim->Instance,
   3393                                sConfig->ICPolarity,
   3394                                sConfig->ICSelection,
   3395                                sConfig->ICFilter);
   \       0x70   0x6861             LDR      R1,[R4, #+4]
   \       0x72   0x9101             STR      R1,[SP, #+4]
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x682A             LDR      R2,[R5, #+0]
   \       0x78   0x6A13             LDR      R3,[R2, #+32]
   \       0x7A   0x....             LDR      R6,??DataTable22_1  ;; 0xfffffeff
   \       0x7C   0x401E             ANDS     R6,R6,R3
   \       0x7E   0x6216             STR      R6,[R2, #+32]
   \       0x80   0x69D3             LDR      R3,[R2, #+28]
   \       0x82   0x6A16             LDR      R6,[R2, #+32]
   \       0x84   0x9600             STR      R6,[SP, #+0]
   \       0x86   0x2603             MOVS     R6,#+3
   \       0x88   0x43B3             BICS     R3,R3,R6
   \       0x8A   0x9E01             LDR      R6,[SP, #+4]
   \       0x8C   0x431E             ORRS     R6,R6,R3
   \       0x8E   0x23F0             MOVS     R3,#+240
   \       0x90   0x439E             BICS     R6,R6,R3
   \       0x92   0x0100             LSLS     R0,R0,#+4
   \       0x94   0x4003             ANDS     R3,R3,R0
   \       0x96   0x4333             ORRS     R3,R3,R6
   \       0x98   0x61D3             STR      R3,[R2, #+28]
   \       0x9A   0x9B00             LDR      R3,[SP, #+0]
   \       0x9C   0x....             LDR      R0,??DataTable22_2  ;; 0xfffff5ff
   \       0x9E   0x4018             ANDS     R0,R0,R3
   \       0xA0   0x0209             LSLS     R1,R1,#+8
   \       0xA2   0x23A0             MOVS     R3,#+160
   \       0xA4   0x011B             LSLS     R3,R3,#+4        ;; #+2560
   \       0xA6   0x400B             ANDS     R3,R3,R1
   \       0xA8   0x4303             ORRS     R3,R3,R0
   \       0xAA   0x6213             STR      R3,[R2, #+32]
   3396          
   3397              /* Reset the IC3PSC Bits */
   3398              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \       0xAC   0x6828             LDR      R0,[R5, #+0]
   \       0xAE   0x69C1             LDR      R1,[R0, #+28]
   \       0xB0   0x400F             ANDS     R7,R7,R1
   \       0xB2   0x61C7             STR      R7,[R0, #+28]
   3399          
   3400              /* Set the IC3PSC value */
   3401              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \       0xB4   0x6828             LDR      R0,[R5, #+0]
   \       0xB6   0x69C1             LDR      R1,[R0, #+28]
   \       0xB8   0x68A2             LDR      R2,[R4, #+8]
   \       0xBA   0xE027             B        ??HAL_TIM_IC_ConfigChannel_6
   3402            }
   3403            else
   3404            {
   3405              /* TI4 Configuration */
   3406              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3407          
   3408              TIM_TI4_SetConfig(htim->Instance,
   3409                                sConfig->ICPolarity,
   3410                                sConfig->ICSelection,
   3411                                sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_5: (+1)
   \       0xBC   0x9001             STR      R0,[SP, #+4]
   \       0xBE   0x6860             LDR      R0,[R4, #+4]
   \       0xC0   0x6821             LDR      R1,[R4, #+0]
   \       0xC2   0x682A             LDR      R2,[R5, #+0]
   \       0xC4   0x6A13             LDR      R3,[R2, #+32]
   \       0xC6   0x....             LDR      R7,??DataTable22_3  ;; 0xffffefff
   \       0xC8   0x401F             ANDS     R7,R7,R3
   \       0xCA   0x6217             STR      R7,[R2, #+32]
   \       0xCC   0x69D3             LDR      R3,[R2, #+28]
   \       0xCE   0x9700             STR      R7,[SP, #+0]
   \       0xD0   0x....             LDR      R7,??DataTable22_4  ;; 0xfffffcff
   \       0xD2   0x401F             ANDS     R7,R7,R3
   \       0xD4   0x0203             LSLS     R3,R0,#+8
   \       0xD6   0x433B             ORRS     R3,R3,R7
   \       0xD8   0x....             LDR      R0,??DataTable22_5  ;; 0xffff0fff
   \       0xDA   0x4018             ANDS     R0,R0,R3
   \       0xDC   0x9B01             LDR      R3,[SP, #+4]
   \       0xDE   0x031B             LSLS     R3,R3,#+12
   \       0xE0   0x27F0             MOVS     R7,#+240
   \       0xE2   0x023F             LSLS     R7,R7,#+8        ;; #+61440
   \       0xE4   0x401F             ANDS     R7,R7,R3
   \       0xE6   0x4307             ORRS     R7,R7,R0
   \       0xE8   0x61D7             STR      R7,[R2, #+28]
   \       0xEA   0x9B00             LDR      R3,[SP, #+0]
   \       0xEC   0x....             LDR      R0,??DataTable23  ;; 0xffff5fff
   \       0xEE   0x4018             ANDS     R0,R0,R3
   \       0xF0   0x0309             LSLS     R1,R1,#+12
   \       0xF2   0x23A0             MOVS     R3,#+160
   \       0xF4   0x021B             LSLS     R3,R3,#+8        ;; #+40960
   \       0xF6   0x400B             ANDS     R3,R3,R1
   \       0xF8   0x4303             ORRS     R3,R3,R0
   \       0xFA   0x6213             STR      R3,[R2, #+32]
   3412          
   3413              /* Reset the IC4PSC Bits */
   3414              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \       0xFC   0x6828             LDR      R0,[R5, #+0]
   \       0xFE   0x69C1             LDR      R1,[R0, #+28]
   \      0x100   0x400E             ANDS     R6,R6,R1
   \      0x102   0x61C6             STR      R6,[R0, #+28]
   3415          
   3416              /* Set the IC4PSC value */
   3417              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   \      0x104   0x6828             LDR      R0,[R5, #+0]
   \      0x106   0x69C1             LDR      R1,[R0, #+28]
   \      0x108   0x68A2             LDR      R2,[R4, #+8]
   \      0x10A   0x0212             LSLS     R2,R2,#+8
   \                     ??HAL_TIM_IC_ConfigChannel_6: (+1)
   \      0x10C   0x430A             ORRS     R2,R2,R1
   \      0x10E   0x61C2             STR      R2,[R0, #+28]
   3418            }
   3419          
   3420            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \      0x110   0x2001             MOVS     R0,#+1
   \      0x112   0x2139             MOVS     R1,#+57
   \      0x114   0x5468             STRB     R0,[R5, R1]
   3421          
   3422            __HAL_UNLOCK(htim);
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x2138             MOVS     R1,#+56
   \      0x11A   0x5468             STRB     R0,[R5, R1]
   3423          
   3424            return HAL_OK;
   \      0x11C   0xBDFE             POP      {R1-R7,PC}       ;; return
   3425          }
   3426          
   3427          /**
   3428            * @brief  Initializes the TIM PWM  channels according to the specified
   3429            *         parameters in the TIM_OC_InitTypeDef.
   3430            * @param  htim TIM PWM handle
   3431            * @param  sConfig TIM PWM configuration structure
   3432            * @param  Channel TIM Channels to be configured
   3433            *          This parameter can be one of the following values:
   3434            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3435            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3436            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3437            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3438            * @retval HAL status
   3439            */

   \                                 In section .text, align 2, keep-with-next
   3440          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
   3441                                                      TIM_OC_InitTypeDef *sConfig,
   3442                                                      uint32_t Channel)
   3443          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3444            /* Check the parameters */
   3445            assert_param(IS_TIM_CHANNELS(Channel));
   3446            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3447            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3448            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3449          
   3450            /* Process Locked */
   3451            __HAL_LOCK(htim);
   \        0x4   0x2038             MOVS     R0,#+56
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIM_PWM_ConfigChannel_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x2338             MOVS     R3,#+56
   \       0x14   0x54E0             STRB     R0,[R4, R3]
   3452          
   3453            htim->State = HAL_TIM_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2339             MOVS     R3,#+57
   \       0x1A   0x54E0             STRB     R0,[R4, R3]
   3454          
   3455            switch (Channel)
   \       0x1C   0x....             LDR      R7,??DataTable23_1  ;; 0xfffffbff
   \       0x1E   0x0286             LSLS     R6,R0,#+10
   \       0x20   0x000D             MOVS     R5,R1
   \       0x22   0x2A00             CMP      R2,#+0
   \       0x24   0xD006             BEQ      ??HAL_TIM_PWM_ConfigChannel_1
   \       0x26   0x2A04             CMP      R2,#+4
   \       0x28   0xD015             BEQ      ??HAL_TIM_PWM_ConfigChannel_2
   \       0x2A   0x2A08             CMP      R2,#+8
   \       0x2C   0xD025             BEQ      ??HAL_TIM_PWM_ConfigChannel_3
   \       0x2E   0x2A0C             CMP      R2,#+12
   \       0x30   0xD034             BEQ      ??HAL_TIM_PWM_ConfigChannel_4
   \       0x32   0xE044             B        ??HAL_TIM_PWM_ConfigChannel_5
   3456            {
   3457              case TIM_CHANNEL_1:
   3458              {
   3459                /* Check the parameters */
   3460                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3461          
   3462                /* Configure the Channel 1 in PWM mode */
   3463                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x....'....        BL       TIM_OC1_SetConfig
   3464          
   3465                /* Set the Preload enable bit for channel1 */
   3466                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6981             LDR      R1,[R0, #+24]
   \       0x3E   0x2208             MOVS     R2,#+8
   \       0x40   0x430A             ORRS     R2,R2,R1
   \       0x42   0x6182             STR      R2,[R0, #+24]
   3467          
   3468                /* Configure the Output Fast mode */
   3469                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6981             LDR      R1,[R0, #+24]
   \       0x48   0x2204             MOVS     R2,#+4
   \       0x4A   0x4391             BICS     R1,R1,R2
   \       0x4C   0x6181             STR      R1,[R0, #+24]
   3470                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6981             LDR      R1,[R0, #+24]
   \       0x52   0x68EA             LDR      R2,[R5, #+12]
   \       0x54   0xE00E             B.N      ??HAL_TIM_PWM_ConfigChannel_6
   3471                break;
   3472              }
   3473          
   3474              case TIM_CHANNEL_2:
   3475              {
   3476                /* Check the parameters */
   3477                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3478          
   3479                /* Configure the Channel 2 in PWM mode */
   3480                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_OC2_SetConfig
   3481          
   3482                /* Set the Preload enable bit for channel2 */
   3483                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6981             LDR      R1,[R0, #+24]
   \       0x60   0x430E             ORRS     R6,R6,R1
   \       0x62   0x6186             STR      R6,[R0, #+24]
   3484          
   3485                /* Configure the Output Fast mode */
   3486                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6981             LDR      R1,[R0, #+24]
   \       0x68   0x400F             ANDS     R7,R7,R1
   \       0x6A   0x6187             STR      R7,[R0, #+24]
   3487                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6981             LDR      R1,[R0, #+24]
   \       0x70   0x68EA             LDR      R2,[R5, #+12]
   \       0x72   0x0212             LSLS     R2,R2,#+8
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \       0x74   0x430A             ORRS     R2,R2,R1
   \       0x76   0x6182             STR      R2,[R0, #+24]
   3488                break;
   \       0x78   0xE021             B        ??HAL_TIM_PWM_ConfigChannel_5
   3489              }
   3490          
   3491              case TIM_CHANNEL_3:
   3492              {
   3493                /* Check the parameters */
   3494                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3495          
   3496                /* Configure the Channel 3 in PWM mode */
   3497                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x....'....        BL       TIM_OC3_SetConfig
   3498          
   3499                /* Set the Preload enable bit for channel3 */
   3500                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x69C1             LDR      R1,[R0, #+28]
   \       0x84   0x2208             MOVS     R2,#+8
   \       0x86   0x430A             ORRS     R2,R2,R1
   \       0x88   0x61C2             STR      R2,[R0, #+28]
   3501          
   3502                /* Configure the Output Fast mode */
   3503                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x69C1             LDR      R1,[R0, #+28]
   \       0x8E   0x2204             MOVS     R2,#+4
   \       0x90   0x4391             BICS     R1,R1,R2
   \       0x92   0x61C1             STR      R1,[R0, #+28]
   3504                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x69C1             LDR      R1,[R0, #+28]
   \       0x98   0x68EA             LDR      R2,[R5, #+12]
   \       0x9A   0xE00E             B        ??HAL_TIM_PWM_ConfigChannel_7
   3505                break;
   3506              }
   3507          
   3508              case TIM_CHANNEL_4:
   3509              {
   3510                /* Check the parameters */
   3511                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3512          
   3513                /* Configure the Channel 4 in PWM mode */
   3514                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x....'....        BL       TIM_OC4_SetConfig
   3515          
   3516                /* Set the Preload enable bit for channel4 */
   3517                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x69C1             LDR      R1,[R0, #+28]
   \       0xA6   0x430E             ORRS     R6,R6,R1
   \       0xA8   0x61C6             STR      R6,[R0, #+28]
   3518          
   3519                /* Configure the Output Fast mode */
   3520                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x69C1             LDR      R1,[R0, #+28]
   \       0xAE   0x400F             ANDS     R7,R7,R1
   \       0xB0   0x61C7             STR      R7,[R0, #+28]
   3521                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0x69C1             LDR      R1,[R0, #+28]
   \       0xB6   0x68EA             LDR      R2,[R5, #+12]
   \       0xB8   0x0212             LSLS     R2,R2,#+8
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \       0xBA   0x430A             ORRS     R2,R2,R1
   \       0xBC   0x61C2             STR      R2,[R0, #+28]
   3522                break;
   3523              }
   3524          
   3525              default:
   3526                break;
   3527            }
   3528          
   3529            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \       0xBE   0x2001             MOVS     R0,#+1
   \       0xC0   0x2139             MOVS     R1,#+57
   \       0xC2   0x5460             STRB     R0,[R4, R1]
   3530          
   3531            __HAL_UNLOCK(htim);
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0x2138             MOVS     R1,#+56
   \       0xC8   0x5460             STRB     R0,[R4, R1]
   3532          
   3533            return HAL_OK;
   \       0xCA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3534          }
   3535          
   3536          /**
   3537            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3538            *         parameters in the TIM_OnePulse_InitTypeDef.
   3539            * @param  htim TIM One Pulse handle
   3540            * @param  sConfig TIM One Pulse configuration structure
   3541            * @param  OutputChannel TIM output channel to configure
   3542            *          This parameter can be one of the following values:
   3543            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3544            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3545            * @param  InputChannel TIM input Channel to configure
   3546            *          This parameter can be one of the following values:
   3547            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3548            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3549            * @retval HAL status
   3550            */

   \                                 In section .text, align 2, keep-with-next
   3551          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3552          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   3553            TIM_OC_InitTypeDef temp1;
   3554          
   3555            /* Check the parameters */
   3556            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3557            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3558          
   3559            if (OutputChannel != InputChannel)
   \        0x4   0x429A             CMP      R2,R3
   \        0x6   0xD062             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_0
   \        0x8   0x0004             MOVS     R4,R0
   3560            {
   3561              /* Process Locked */
   3562              __HAL_LOCK(htim);
   \        0xA   0x2038             MOVS     R0,#+56
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD101             BNE      ??HAL_TIM_OnePulse_ConfigChannel_1
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE05C             B        ??HAL_TIM_OnePulse_ConfigChannel_2
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \       0x16   0x000F             MOVS     R7,R1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x2138             MOVS     R1,#+56
   \       0x1C   0x5460             STRB     R0,[R4, R1]
   3563          
   3564              htim->State = HAL_TIM_STATE_BUSY;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x2139             MOVS     R1,#+57
   \       0x22   0x5460             STRB     R0,[R4, R1]
   3565          
   3566              /* Extract the Output compare configuration from sConfig structure */
   3567              temp1.OCMode = sConfig->OCMode;
   \       0x24   0x6838             LDR      R0,[R7, #+0]
   \       0x26   0x9000             STR      R0,[SP, #+0]
   3568              temp1.Pulse = sConfig->Pulse;
   \       0x28   0x6878             LDR      R0,[R7, #+4]
   \       0x2A   0x9001             STR      R0,[SP, #+4]
   3569              temp1.OCPolarity = sConfig->OCPolarity;
   \       0x2C   0x68B8             LDR      R0,[R7, #+8]
   \       0x2E   0x9002             STR      R0,[SP, #+8]
   3570          
   3571              switch (OutputChannel)
   \       0x30   0x2A00             CMP      R2,#+0
   \       0x32   0xD002             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_3
   \       0x34   0x2A04             CMP      R2,#+4
   \       0x36   0xD005             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_4
   \       0x38   0xE008             B        ??HAL_TIM_OnePulse_ConfigChannel_5
   3572              {
   3573                case TIM_CHANNEL_1:
   3574                {
   3575                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3576          
   3577                  TIM_OC1_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x....'....        BL       TIM_OC1_SetConfig
   3578                  break;
   \       0x42   0xE003             B        ??HAL_TIM_OnePulse_ConfigChannel_5
   3579                }
   3580                case TIM_CHANNEL_2:
   3581                {
   3582                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3583          
   3584                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x....'....        BL       TIM_OC2_SetConfig
   3585                  break;
   3586                }
   3587                default:
   3588                  break;
   3589              }
   3590          
   3591              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \       0x4C   0x2607             MOVS     R6,#+7
   \       0x4E   0x43F6             MVNS     R6,R6            ;; #-8
   \       0x50   0x2570             MOVS     R5,#+112
   \       0x52   0x43ED             MVNS     R5,R5            ;; #-113
   \       0x54   0x9804             LDR      R0,[SP, #+16]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD002             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_6
   \       0x5A   0x2804             CMP      R0,#+4
   \       0x5C   0xD013             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_7
   \       0x5E   0xE02F             B        ??HAL_TIM_OnePulse_ConfigChannel_8
   3592              {
   3593                case TIM_CHANNEL_1:
   3594                {
   3595                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3596          
   3597                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3598                                    sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \       0x60   0x697B             LDR      R3,[R7, #+20]
   \       0x62   0x693A             LDR      R2,[R7, #+16]
   \       0x64   0x68F9             LDR      R1,[R7, #+12]
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x....'....        BL       TIM_TI1_SetConfig
   3599          
   3600                  /* Reset the IC1PSC Bits */
   3601                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6981             LDR      R1,[R0, #+24]
   \       0x70   0x220C             MOVS     R2,#+12
   \       0x72   0x4391             BICS     R1,R1,R2
   \       0x74   0x6181             STR      R1,[R0, #+24]
   3602          
   3603                  /* Select the Trigger source */
   3604                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6881             LDR      R1,[R0, #+8]
   \       0x7A   0x400D             ANDS     R5,R5,R1
   \       0x7C   0x6085             STR      R5,[R0, #+8]
   3605                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x6881             LDR      R1,[R0, #+8]
   \       0x82   0x2250             MOVS     R2,#+80
   \       0x84   0xE011             B        ??HAL_TIM_OnePulse_ConfigChannel_9
   3606          
   3607                  /* Select the Slave Mode */
   3608                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3609                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3610                  break;
   3611                }
   3612                case TIM_CHANNEL_2:
   3613                {
   3614                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3615          
   3616                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3617                                    sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \       0x86   0x697B             LDR      R3,[R7, #+20]
   \       0x88   0x693A             LDR      R2,[R7, #+16]
   \       0x8A   0x68F9             LDR      R1,[R7, #+12]
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x....'....        BL       TIM_TI2_SetConfig
   3618          
   3619                  /* Reset the IC2PSC Bits */
   3620                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6981             LDR      R1,[R0, #+24]
   \       0x96   0x....             LDR      R2,??DataTable22  ;; 0xfffff3ff
   \       0x98   0x400A             ANDS     R2,R2,R1
   \       0x9A   0x6182             STR      R2,[R0, #+24]
   3621          
   3622                  /* Select the Trigger source */
   3623                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x6881             LDR      R1,[R0, #+8]
   \       0xA0   0x400D             ANDS     R5,R5,R1
   \       0xA2   0x6085             STR      R5,[R0, #+8]
   3624                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6881             LDR      R1,[R0, #+8]
   \       0xA8   0x2260             MOVS     R2,#+96
   \                     ??HAL_TIM_OnePulse_ConfigChannel_9: (+1)
   \       0xAA   0x430A             ORRS     R2,R2,R1
   \       0xAC   0x6082             STR      R2,[R0, #+8]
   3625          
   3626                  /* Select the Slave Mode */
   3627                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0x6881             LDR      R1,[R0, #+8]
   \       0xB2   0x400E             ANDS     R6,R6,R1
   \       0xB4   0x6086             STR      R6,[R0, #+8]
   3628                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x6881             LDR      R1,[R0, #+8]
   \       0xBA   0x2206             MOVS     R2,#+6
   \       0xBC   0x430A             ORRS     R2,R2,R1
   \       0xBE   0x6082             STR      R2,[R0, #+8]
   3629                  break;
   3630                }
   3631          
   3632                default:
   3633                  break;
   3634              }
   3635          
   3636              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_8: (+1)
   \       0xC0   0x2001             MOVS     R0,#+1
   \       0xC2   0x2139             MOVS     R1,#+57
   \       0xC4   0x5460             STRB     R0,[R4, R1]
   3637          
   3638              __HAL_UNLOCK(htim);
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x2138             MOVS     R1,#+56
   \       0xCA   0x5460             STRB     R0,[R4, R1]
   3639          
   3640              return HAL_OK;
   \       0xCC   0xE000             B        ??HAL_TIM_OnePulse_ConfigChannel_2
   3641            }
   3642            else
   3643            {
   3644              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \       0xCE   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \       0xD0   0xB005             ADD      SP,SP,#+20
   \       0xD2   0xBDF0             POP      {R4-R7,PC}       ;; return
   3645            }
   3646          }
   3647          
   3648          /**
   3649            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
   3650            * @param  htim TIM handle
   3651            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
   3652            *         This parameter can be one of the following values:
   3653            *            @arg TIM_DMABASE_CR1
   3654            *            @arg TIM_DMABASE_CR2
   3655            *            @arg TIM_DMABASE_SMCR
   3656            *            @arg TIM_DMABASE_DIER
   3657            *            @arg TIM_DMABASE_SR
   3658            *            @arg TIM_DMABASE_EGR
   3659            *            @arg TIM_DMABASE_CCMR1
   3660            *            @arg TIM_DMABASE_CCMR2
   3661            *            @arg TIM_DMABASE_CCER
   3662            *            @arg TIM_DMABASE_CNT
   3663            *            @arg TIM_DMABASE_PSC
   3664            *            @arg TIM_DMABASE_ARR
   3665            *            @arg TIM_DMABASE_CCR1
   3666            *            @arg TIM_DMABASE_CCR2
   3667            *            @arg TIM_DMABASE_CCR3
   3668            *            @arg TIM_DMABASE_CCR4
   3669            *            @arg TIM_DMABASE_DCR
   3670            * @param  BurstRequestSrc TIM DMA Request sources
   3671            *         This parameter can be one of the following values:
   3672            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3673            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3674            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3675            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3676            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3677            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3678            * @param  BurstBuffer The Buffer address.
   3679            * @param  BurstLength DMA Burst length. This parameter can be one value
   3680            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3681            * @retval HAL status
   3682            */

   \                                 In section .text, align 2, keep-with-next
   3683          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3684                                                        uint32_t *BurstBuffer, uint32_t  BurstLength)
   3685          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x0004             MOVS     R4,R0
   3686            /* Check the parameters */
   3687            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3688            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3689            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3690            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3691          
   3692            if ((htim->State == HAL_TIM_STATE_BUSY))
   \        0x6   0x2039             MOVS     R0,#+57
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD044             BEQ      ??HAL_TIM_DMABurst_WriteStart_0
   \        0xE   0x9300             STR      R3,[SP, #+0]
   \       0x10   0x9D08             LDR      R5,[SP, #+32]
   3693            {
   3694              return HAL_BUSY;
   3695            }
   3696            else if ((htim->State == HAL_TIM_STATE_READY))
   \       0x12   0x2039             MOVS     R0,#+57
   \       0x14   0x5C20             LDRB     R0,[R4, R0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD106             BNE      ??HAL_TIM_DMABurst_WriteStart_1
   3697            {
   3698              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   \       0x1A   0x2B00             CMP      R3,#+0
   \       0x1C   0xD101             BNE      ??HAL_TIM_DMABurst_WriteStart_2
   \       0x1E   0x2D00             CMP      R5,#+0
   \       0x20   0xD17B             BNE      ??HAL_TIM_DMABurst_WriteStart_3
   3699              {
   3700                return HAL_ERROR;
   3701              }
   3702              else
   3703              {
   3704                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0x2139             MOVS     R1,#+57
   \       0x26   0x5460             STRB     R0,[R4, R1]
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \       0x28   0x9201             STR      R2,[SP, #+4]
   3705              }
   3706            }
   3707            else
   3708            {
   3709              /* nothing to do */
   3710            }
   3711            switch (BurstRequestSrc)
   \       0x2A   0x0A2B             LSRS     R3,R5,#+8
   \       0x2C   0x1C5B             ADDS     R3,R3,#+1
   \       0x2E   0x....             LDR      R1,??DataTable24
   \       0x30   0x....             LDR      R2,??DataTable24_1
   \       0x32   0x....             LDR      R0,??DataTable24_2
   \       0x34   0x9E01             LDR      R6,[SP, #+4]
   \       0x36   0x2780             MOVS     R7,#+128
   \       0x38   0x007F             LSLS     R7,R7,#+1        ;; #+256
   \       0x3A   0x42BE             CMP      R6,R7
   \       0x3C   0xD00F             BEQ      ??HAL_TIM_DMABurst_WriteStart_4
   \       0x3E   0x007F             LSLS     R7,R7,#+1
   \       0x40   0x42BE             CMP      R6,R7
   \       0x42   0xD02A             BEQ      ??HAL_TIM_DMABurst_WriteStart_5
   \       0x44   0x007F             LSLS     R7,R7,#+1
   \       0x46   0x42BE             CMP      R6,R7
   \       0x48   0xD036             BEQ      ??HAL_TIM_DMABurst_WriteStart_6
   \       0x4A   0x007F             LSLS     R7,R7,#+1
   \       0x4C   0x42BE             CMP      R6,R7
   \       0x4E   0xD03E             BEQ      ??HAL_TIM_DMABurst_WriteStart_7
   \       0x50   0x007F             LSLS     R7,R7,#+1
   \       0x52   0x42BE             CMP      R6,R7
   \       0x54   0xD046             BEQ      ??HAL_TIM_DMABurst_WriteStart_8
   \       0x56   0x00BF             LSLS     R7,R7,#+2
   \       0x58   0x42BE             CMP      R6,R7
   \       0x5A   0xD04E             BEQ      ??HAL_TIM_DMABurst_WriteStart_9
   \       0x5C   0xE00F             B        ??HAL_TIM_DMABurst_WriteStart_10
   3712            {
   3713              case TIM_DMA_UPDATE:
   3714              {
   3715                /* Set the DMA Period elapsed callbacks */
   3716                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \       0x5E   0x....             LDR      R1,??DataTable24_3
   \       0x60   0x69E2             LDR      R2,[R4, #+28]
   \       0x62   0x62D1             STR      R1,[R2, #+44]
   3717                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x64   0x....             LDR      R1,??DataTable24_4
   \       0x66   0x69E2             LDR      R2,[R4, #+28]
   \       0x68   0x6311             STR      R1,[R2, #+48]
   3718          
   3719                /* Set the DMA error callback */
   3720                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x6A   0x69E1             LDR      R1,[R4, #+28]
   \       0x6C   0x6348             STR      R0,[R1, #+52]
   3721          
   3722                /* Enable the DMA channel */
   3723                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0x6E   0x6822             LDR      R2,[R4, #+0]
   \       0x70   0x324C             ADDS     R2,R2,#+76
   \       0x72   0x9900             LDR      R1,[SP, #+0]
   \       0x74   0x69E0             LDR      R0,[R4, #+28]
   \       0x76   0x....'....        BL       HAL_DMA_Start_IT
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD14D             BNE      ??HAL_TIM_DMABurst_WriteStart_3
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \       0x7E   0x9802             LDR      R0,[SP, #+8]
   3724                {
   3725                  return HAL_ERROR;
   3726                }
   3727                break;
   3728              }
   3729              case TIM_DMA_CC1:
   3730              {
   3731                /* Set the DMA compare callbacks */
   3732                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3733                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3734          
   3735                /* Set the DMA error callback */
   3736                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3737          
   3738                /* Enable the DMA channel */
   3739                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3740                {
   3741                  return HAL_ERROR;
   3742                }
   3743                break;
   3744              }
   3745              case TIM_DMA_CC2:
   3746              {
   3747                /* Set the DMA compare callbacks */
   3748                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3749                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3750          
   3751                /* Set the DMA error callback */
   3752                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3753          
   3754                /* Enable the DMA channel */
   3755                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3756                {
   3757                  return HAL_ERROR;
   3758                }
   3759                break;
   3760              }
   3761              case TIM_DMA_CC3:
   3762              {
   3763                /* Set the DMA compare callbacks */
   3764                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3765                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3766          
   3767                /* Set the DMA error callback */
   3768                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   3769          
   3770                /* Enable the DMA channel */
   3771                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3772                {
   3773                  return HAL_ERROR;
   3774                }
   3775                break;
   3776              }
   3777              case TIM_DMA_CC4:
   3778              {
   3779                /* Set the DMA compare callbacks */
   3780                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3781                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3782          
   3783                /* Set the DMA error callback */
   3784                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   3785          
   3786                /* Enable the DMA channel */
   3787                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3788                {
   3789                  return HAL_ERROR;
   3790                }
   3791                break;
   3792              }
   3793              case TIM_DMA_TRIGGER:
   3794              {
   3795                /* Set the DMA trigger callbacks */
   3796                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3797                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   3798          
   3799                /* Set the DMA error callback */
   3800                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   3801          
   3802                /* Enable the DMA channel */
   3803                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3804                {
   3805                  return HAL_ERROR;
   3806                }
   3807                break;
   3808              }
   3809              default:
   3810                break;
   3811            }
   3812            /* configure the DMA Burst Mode */
   3813            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   \       0x80   0x4305             ORRS     R5,R5,R0
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6485             STR      R5,[R0, #+72]
   3814          
   3815            /* Enable the TIM DMA Request */
   3816            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x68C1             LDR      R1,[R0, #+12]
   \       0x8A   0x9A01             LDR      R2,[SP, #+4]
   \       0x8C   0x430A             ORRS     R2,R2,R1
   \       0x8E   0x60C2             STR      R2,[R0, #+12]
   3817          
   3818            htim->State = HAL_TIM_STATE_READY;
   \       0x90   0x2001             MOVS     R0,#+1
   \       0x92   0x2139             MOVS     R1,#+57
   \       0x94   0x5460             STRB     R0,[R4, R1]
   3819          
   3820            /* Return function status */
   3821            return HAL_OK;
   \       0x96   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \       0x98   0xBDFE             POP      {R1-R7,PC}       ;; return
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \       0x9A   0x6A26             LDR      R6,[R4, #+32]
   \       0x9C   0x62F2             STR      R2,[R6, #+44]
   \       0x9E   0x6A22             LDR      R2,[R4, #+32]
   \       0xA0   0x6311             STR      R1,[R2, #+48]
   \       0xA2   0x6A21             LDR      R1,[R4, #+32]
   \       0xA4   0x6348             STR      R0,[R1, #+52]
   \       0xA6   0x6822             LDR      R2,[R4, #+0]
   \       0xA8   0x324C             ADDS     R2,R2,#+76
   \       0xAA   0x9900             LDR      R1,[SP, #+0]
   \       0xAC   0x6A20             LDR      R0,[R4, #+32]
   \                     ??HAL_TIM_DMABurst_WriteStart_11: (+1)
   \       0xAE   0x....'....        BL       HAL_DMA_Start_IT
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD131             BNE      ??HAL_TIM_DMABurst_WriteStart_3
   \       0xB6   0xE7E2             B        ??HAL_TIM_DMABurst_WriteStart_10
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \       0xB8   0x6A66             LDR      R6,[R4, #+36]
   \       0xBA   0x62F2             STR      R2,[R6, #+44]
   \       0xBC   0x6A62             LDR      R2,[R4, #+36]
   \       0xBE   0x6311             STR      R1,[R2, #+48]
   \       0xC0   0x6A61             LDR      R1,[R4, #+36]
   \       0xC2   0x6348             STR      R0,[R1, #+52]
   \       0xC4   0x6822             LDR      R2,[R4, #+0]
   \       0xC6   0x324C             ADDS     R2,R2,#+76
   \       0xC8   0x9900             LDR      R1,[SP, #+0]
   \       0xCA   0x6A60             LDR      R0,[R4, #+36]
   \       0xCC   0xE7EF             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \       0xCE   0x6AA6             LDR      R6,[R4, #+40]
   \       0xD0   0x62F2             STR      R2,[R6, #+44]
   \       0xD2   0x6AA2             LDR      R2,[R4, #+40]
   \       0xD4   0x6311             STR      R1,[R2, #+48]
   \       0xD6   0x6AA1             LDR      R1,[R4, #+40]
   \       0xD8   0x6348             STR      R0,[R1, #+52]
   \       0xDA   0x6822             LDR      R2,[R4, #+0]
   \       0xDC   0x324C             ADDS     R2,R2,#+76
   \       0xDE   0x9900             LDR      R1,[SP, #+0]
   \       0xE0   0x6AA0             LDR      R0,[R4, #+40]
   \       0xE2   0xE7E4             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \       0xE4   0x6AE6             LDR      R6,[R4, #+44]
   \       0xE6   0x62F2             STR      R2,[R6, #+44]
   \       0xE8   0x6AE2             LDR      R2,[R4, #+44]
   \       0xEA   0x6311             STR      R1,[R2, #+48]
   \       0xEC   0x6AE1             LDR      R1,[R4, #+44]
   \       0xEE   0x6348             STR      R0,[R1, #+52]
   \       0xF0   0x6822             LDR      R2,[R4, #+0]
   \       0xF2   0x324C             ADDS     R2,R2,#+76
   \       0xF4   0x9900             LDR      R1,[SP, #+0]
   \       0xF6   0x6AE0             LDR      R0,[R4, #+44]
   \       0xF8   0xE7D9             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \       0xFA   0x....             LDR      R1,??DataTable25
   \       0xFC   0x6B62             LDR      R2,[R4, #+52]
   \       0xFE   0x62D1             STR      R1,[R2, #+44]
   \      0x100   0x....             LDR      R1,??DataTable25_1
   \      0x102   0x6B62             LDR      R2,[R4, #+52]
   \      0x104   0x6311             STR      R1,[R2, #+48]
   \      0x106   0x6B61             LDR      R1,[R4, #+52]
   \      0x108   0x6348             STR      R0,[R1, #+52]
   \      0x10A   0x6822             LDR      R2,[R4, #+0]
   \      0x10C   0x324C             ADDS     R2,R2,#+76
   \      0x10E   0x9900             LDR      R1,[SP, #+0]
   \      0x110   0x6B60             LDR      R0,[R4, #+52]
   \      0x112   0x....'....        BL       HAL_DMA_Start_IT
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD0B1             BEQ      ??HAL_TIM_DMABurst_WriteStart_10
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \      0x11A   0x2001             MOVS     R0,#+1
   \      0x11C   0xBDFE             POP      {R1-R7,PC}
   3822          }
   3823          
   3824          /**
   3825            * @brief  Stops the TIM DMA Burst mode
   3826            * @param  htim TIM handle
   3827            * @param  BurstRequestSrc TIM DMA Request sources to disable
   3828            * @retval HAL status
   3829            */

   \                                 In section .text, align 2, keep-with-next
   3830          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3831          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....             B.N      ?Subroutine9

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x0004             MOVS     R4,R0
   \        0x2   0x000D             MOVS     R5,R1
   3832            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
   3833            /* Check the parameters */
   3834            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3835          
   3836            /* Abort the DMA transfer (at least disable the DMA channel) */
   3837            switch (BurstRequestSrc)
   \        0x6   0x2280             MOVS     R2,#+128
   \        0x8   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \        0xA   0x4291             CMP      R1,R2
   \        0xC   0xD00F             BEQ      ??Subroutine9_0
   \        0xE   0x0052             LSLS     R2,R2,#+1
   \       0x10   0x4291             CMP      R1,R2
   \       0x12   0xD00E             BEQ      ??Subroutine9_1
   \       0x14   0x0052             LSLS     R2,R2,#+1
   \       0x16   0x4291             CMP      R1,R2
   \       0x18   0xD00D             BEQ      ??Subroutine9_2
   \       0x1A   0x0052             LSLS     R2,R2,#+1
   \       0x1C   0x4291             CMP      R1,R2
   \       0x1E   0xD00C             BEQ      ??Subroutine9_3
   \       0x20   0x0052             LSLS     R2,R2,#+1
   \       0x22   0x4291             CMP      R1,R2
   \       0x24   0xD00B             BEQ      ??Subroutine9_4
   \       0x26   0x0092             LSLS     R2,R2,#+2
   \       0x28   0x4291             CMP      R1,R2
   \       0x2A   0xD00A             BEQ      ??Subroutine9_5
   \       0x2C   0xE00C             B        ??Subroutine9_6
   3838            {
   3839              case TIM_DMA_UPDATE:
   3840              {
   3841                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??Subroutine9_0: (+1)
   \       0x2E   0x69E0             LDR      R0,[R4, #+28]
   \       0x30   0xE008             B        ??Subroutine9_7
   3842                break;
   3843              }
   3844              case TIM_DMA_CC1:
   3845              {
   3846                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??Subroutine9_1: (+1)
   \       0x32   0x6A20             LDR      R0,[R4, #+32]
   \       0x34   0xE006             B        ??Subroutine9_7
   3847                break;
   3848              }
   3849              case TIM_DMA_CC2:
   3850              {
   3851                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??Subroutine9_2: (+1)
   \       0x36   0x6A60             LDR      R0,[R4, #+36]
   \       0x38   0xE004             B        ??Subroutine9_7
   3852                break;
   3853              }
   3854              case TIM_DMA_CC3:
   3855              {
   3856                status =  HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??Subroutine9_3: (+1)
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0xE002             B        ??Subroutine9_7
   3857                break;
   3858              }
   3859              case TIM_DMA_CC4:
   3860              {
   3861                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??Subroutine9_4: (+1)
   \       0x3E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x40   0xE000             B        ??Subroutine9_7
   3862                break;
   3863              }
   3864              case TIM_DMA_TRIGGER:
   3865              {
   3866                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??Subroutine9_5: (+1)
   \       0x42   0x6B60             LDR      R0,[R4, #+52]
   \                     ??Subroutine9_7: (+1)
   \       0x44   0x....'....        BL       HAL_DMA_Abort_IT
   3867                break;
   3868              }
   3869              default:
   3870                break;
   3871            }
   3872          
   3873            if (HAL_OK == status)
   \                     ??Subroutine9_6: (+1)
   \       0x48   0x0001             MOVS     R1,R0
   \       0x4A   0xD103             BNE      ??Subroutine9_8
   3874            {
   3875              /* Disable the TIM Update DMA request */
   3876              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x68CA             LDR      R2,[R1, #+12]
   \       0x50   0x43AA             BICS     R2,R2,R5
   \       0x52   0x60CA             STR      R2,[R1, #+12]
   3877            }
   3878          
   3879            /* Return function status */
   3880            return status;
   \                     ??Subroutine9_8: (+1)
   \       0x54   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3881          }
   3882          
   3883          /**
   3884            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   3885            * @param  htim TIM handle
   3886            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   3887            *         This parameter can be one of the following values:
   3888            *            @arg TIM_DMABASE_CR1
   3889            *            @arg TIM_DMABASE_CR2
   3890            *            @arg TIM_DMABASE_SMCR
   3891            *            @arg TIM_DMABASE_DIER
   3892            *            @arg TIM_DMABASE_SR
   3893            *            @arg TIM_DMABASE_EGR
   3894            *            @arg TIM_DMABASE_CCMR1
   3895            *            @arg TIM_DMABASE_CCMR2
   3896            *            @arg TIM_DMABASE_CCER
   3897            *            @arg TIM_DMABASE_CNT
   3898            *            @arg TIM_DMABASE_PSC
   3899            *            @arg TIM_DMABASE_ARR
   3900            *            @arg TIM_DMABASE_CCR1
   3901            *            @arg TIM_DMABASE_CCR2
   3902            *            @arg TIM_DMABASE_CCR3
   3903            *            @arg TIM_DMABASE_CCR4
   3904            *            @arg TIM_DMABASE_DCR
   3905            * @param  BurstRequestSrc TIM DMA Request sources
   3906            *         This parameter can be one of the following values:
   3907            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3908            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3909            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3910            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3911            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3912            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3913            * @param  BurstBuffer The Buffer address.
   3914            * @param  BurstLength DMA Burst length. This parameter can be one value
   3915            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3916            * @retval HAL status
   3917            */

   \                                 In section .text, align 2, keep-with-next
   3918          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3919                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3920          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x0004             MOVS     R4,R0
   3921            /* Check the parameters */
   3922            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3923            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3924            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3925            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3926          
   3927            if ((htim->State == HAL_TIM_STATE_BUSY))
   \        0x6   0x2039             MOVS     R0,#+57
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD044             BEQ      ??HAL_TIM_DMABurst_ReadStart_0
   \        0xE   0x9300             STR      R3,[SP, #+0]
   \       0x10   0x9D08             LDR      R5,[SP, #+32]
   3928            {
   3929              return HAL_BUSY;
   3930            }
   3931            else if ((htim->State == HAL_TIM_STATE_READY))
   \       0x12   0x2039             MOVS     R0,#+57
   \       0x14   0x5C20             LDRB     R0,[R4, R0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD106             BNE      ??HAL_TIM_DMABurst_ReadStart_1
   3932            {
   3933              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   \       0x1A   0x2B00             CMP      R3,#+0
   \       0x1C   0xD101             BNE      ??HAL_TIM_DMABurst_ReadStart_2
   \       0x1E   0x2D00             CMP      R5,#+0
   \       0x20   0xD17B             BNE      ??HAL_TIM_DMABurst_ReadStart_3
   3934              {
   3935                return HAL_ERROR;
   3936              }
   3937              else
   3938              {
   3939                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0x2139             MOVS     R1,#+57
   \       0x26   0x5460             STRB     R0,[R4, R1]
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \       0x28   0x9201             STR      R2,[SP, #+4]
   3940              }
   3941            }
   3942            else
   3943            {
   3944              /* nothing to do */
   3945            }
   3946            switch (BurstRequestSrc)
   \       0x2A   0x0A2B             LSRS     R3,R5,#+8
   \       0x2C   0x1C5B             ADDS     R3,R3,#+1
   \       0x2E   0x....             LDR      R1,??DataTable25_2
   \       0x30   0x....             LDR      R2,??DataTable25_3
   \       0x32   0x....             LDR      R0,??DataTable24_2
   \       0x34   0x9E01             LDR      R6,[SP, #+4]
   \       0x36   0x2780             MOVS     R7,#+128
   \       0x38   0x007F             LSLS     R7,R7,#+1        ;; #+256
   \       0x3A   0x42BE             CMP      R6,R7
   \       0x3C   0xD00F             BEQ      ??HAL_TIM_DMABurst_ReadStart_4
   \       0x3E   0x007F             LSLS     R7,R7,#+1
   \       0x40   0x42BE             CMP      R6,R7
   \       0x42   0xD02A             BEQ      ??HAL_TIM_DMABurst_ReadStart_5
   \       0x44   0x007F             LSLS     R7,R7,#+1
   \       0x46   0x42BE             CMP      R6,R7
   \       0x48   0xD036             BEQ      ??HAL_TIM_DMABurst_ReadStart_6
   \       0x4A   0x007F             LSLS     R7,R7,#+1
   \       0x4C   0x42BE             CMP      R6,R7
   \       0x4E   0xD03E             BEQ      ??HAL_TIM_DMABurst_ReadStart_7
   \       0x50   0x007F             LSLS     R7,R7,#+1
   \       0x52   0x42BE             CMP      R6,R7
   \       0x54   0xD046             BEQ      ??HAL_TIM_DMABurst_ReadStart_8
   \       0x56   0x00BF             LSLS     R7,R7,#+2
   \       0x58   0x42BE             CMP      R6,R7
   \       0x5A   0xD04E             BEQ      ??HAL_TIM_DMABurst_ReadStart_9
   \       0x5C   0xE00F             B        ??HAL_TIM_DMABurst_ReadStart_10
   3947            {
   3948              case TIM_DMA_UPDATE:
   3949              {
   3950                /* Set the DMA Period elapsed callbacks */
   3951                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \       0x5E   0x....             LDR      R1,??DataTable24_3
   \       0x60   0x69E2             LDR      R2,[R4, #+28]
   \       0x62   0x62D1             STR      R1,[R2, #+44]
   3952                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x64   0x....             LDR      R1,??DataTable24_4
   \       0x66   0x69E2             LDR      R2,[R4, #+28]
   \       0x68   0x6311             STR      R1,[R2, #+48]
   3953          
   3954                /* Set the DMA error callback */
   3955                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x6A   0x69E1             LDR      R1,[R4, #+28]
   \       0x6C   0x6348             STR      R0,[R1, #+52]
   3956          
   3957                /* Enable the DMA channel */
   3958                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0x6E   0x9A00             LDR      R2,[SP, #+0]
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0x314C             ADDS     R1,R1,#+76
   \       0x74   0x69E0             LDR      R0,[R4, #+28]
   \       0x76   0x....'....        BL       HAL_DMA_Start_IT
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD14D             BNE      ??HAL_TIM_DMABurst_ReadStart_3
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \       0x7E   0x9802             LDR      R0,[SP, #+8]
   3959                {
   3960                  return HAL_ERROR;
   3961                }
   3962                break;
   3963              }
   3964              case TIM_DMA_CC1:
   3965              {
   3966                /* Set the DMA capture callbacks */
   3967                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   3968                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3969          
   3970                /* Set the DMA error callback */
   3971                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3972          
   3973                /* Enable the DMA channel */
   3974                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3975                {
   3976                  return HAL_ERROR;
   3977                }
   3978                break;
   3979              }
   3980              case TIM_DMA_CC2:
   3981              {
   3982                /* Set the DMA capture/compare callbacks */
   3983                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   3984                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3985          
   3986                /* Set the DMA error callback */
   3987                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3988          
   3989                /* Enable the DMA channel */
   3990                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3991                {
   3992                  return HAL_ERROR;
   3993                }
   3994                break;
   3995              }
   3996              case TIM_DMA_CC3:
   3997              {
   3998                /* Set the DMA capture callbacks */
   3999                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   4000                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4001          
   4002                /* Set the DMA error callback */
   4003                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   4004          
   4005                /* Enable the DMA channel */
   4006                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4007                {
   4008                  return HAL_ERROR;
   4009                }
   4010                break;
   4011              }
   4012              case TIM_DMA_CC4:
   4013              {
   4014                /* Set the DMA capture callbacks */
   4015                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   4016                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4017          
   4018                /* Set the DMA error callback */
   4019                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   4020          
   4021                /* Enable the DMA channel */
   4022                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4023                {
   4024                  return HAL_ERROR;
   4025                }
   4026                break;
   4027              }
   4028              case TIM_DMA_TRIGGER:
   4029              {
   4030                /* Set the DMA trigger callbacks */
   4031                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   4032                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   4033          
   4034                /* Set the DMA error callback */
   4035                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   4036          
   4037                /* Enable the DMA channel */
   4038                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4039                {
   4040                  return HAL_ERROR;
   4041                }
   4042                break;
   4043              }
   4044              default:
   4045                break;
   4046            }
   4047          
   4048            /* configure the DMA Burst Mode */
   4049            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   \       0x80   0x4305             ORRS     R5,R5,R0
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6485             STR      R5,[R0, #+72]
   4050          
   4051            /* Enable the TIM DMA Request */
   4052            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x68C1             LDR      R1,[R0, #+12]
   \       0x8A   0x9A01             LDR      R2,[SP, #+4]
   \       0x8C   0x430A             ORRS     R2,R2,R1
   \       0x8E   0x60C2             STR      R2,[R0, #+12]
   4053          
   4054            htim->State = HAL_TIM_STATE_READY;
   \       0x90   0x2001             MOVS     R0,#+1
   \       0x92   0x2139             MOVS     R1,#+57
   \       0x94   0x5460             STRB     R0,[R4, R1]
   4055          
   4056            /* Return function status */
   4057            return HAL_OK;
   \       0x96   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \       0x98   0xBDFE             POP      {R1-R7,PC}       ;; return
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \       0x9A   0x6A26             LDR      R6,[R4, #+32]
   \       0x9C   0x62F2             STR      R2,[R6, #+44]
   \       0x9E   0x6A22             LDR      R2,[R4, #+32]
   \       0xA0   0x6311             STR      R1,[R2, #+48]
   \       0xA2   0x6A21             LDR      R1,[R4, #+32]
   \       0xA4   0x6348             STR      R0,[R1, #+52]
   \       0xA6   0x9A00             LDR      R2,[SP, #+0]
   \       0xA8   0x6821             LDR      R1,[R4, #+0]
   \       0xAA   0x314C             ADDS     R1,R1,#+76
   \       0xAC   0x6A20             LDR      R0,[R4, #+32]
   \                     ??HAL_TIM_DMABurst_ReadStart_11: (+1)
   \       0xAE   0x....'....        BL       HAL_DMA_Start_IT
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD131             BNE      ??HAL_TIM_DMABurst_ReadStart_3
   \       0xB6   0xE7E2             B        ??HAL_TIM_DMABurst_ReadStart_10
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \       0xB8   0x6A66             LDR      R6,[R4, #+36]
   \       0xBA   0x62F2             STR      R2,[R6, #+44]
   \       0xBC   0x6A62             LDR      R2,[R4, #+36]
   \       0xBE   0x6311             STR      R1,[R2, #+48]
   \       0xC0   0x6A61             LDR      R1,[R4, #+36]
   \       0xC2   0x6348             STR      R0,[R1, #+52]
   \       0xC4   0x9A00             LDR      R2,[SP, #+0]
   \       0xC6   0x6821             LDR      R1,[R4, #+0]
   \       0xC8   0x314C             ADDS     R1,R1,#+76
   \       0xCA   0x6A60             LDR      R0,[R4, #+36]
   \       0xCC   0xE7EF             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \       0xCE   0x6AA6             LDR      R6,[R4, #+40]
   \       0xD0   0x62F2             STR      R2,[R6, #+44]
   \       0xD2   0x6AA2             LDR      R2,[R4, #+40]
   \       0xD4   0x6311             STR      R1,[R2, #+48]
   \       0xD6   0x6AA1             LDR      R1,[R4, #+40]
   \       0xD8   0x6348             STR      R0,[R1, #+52]
   \       0xDA   0x9A00             LDR      R2,[SP, #+0]
   \       0xDC   0x6821             LDR      R1,[R4, #+0]
   \       0xDE   0x314C             ADDS     R1,R1,#+76
   \       0xE0   0x6AA0             LDR      R0,[R4, #+40]
   \       0xE2   0xE7E4             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \       0xE4   0x6AE6             LDR      R6,[R4, #+44]
   \       0xE6   0x62F2             STR      R2,[R6, #+44]
   \       0xE8   0x6AE2             LDR      R2,[R4, #+44]
   \       0xEA   0x6311             STR      R1,[R2, #+48]
   \       0xEC   0x6AE1             LDR      R1,[R4, #+44]
   \       0xEE   0x6348             STR      R0,[R1, #+52]
   \       0xF0   0x9A00             LDR      R2,[SP, #+0]
   \       0xF2   0x6821             LDR      R1,[R4, #+0]
   \       0xF4   0x314C             ADDS     R1,R1,#+76
   \       0xF6   0x6AE0             LDR      R0,[R4, #+44]
   \       0xF8   0xE7D9             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \       0xFA   0x....             LDR      R1,??DataTable25
   \       0xFC   0x6B62             LDR      R2,[R4, #+52]
   \       0xFE   0x62D1             STR      R1,[R2, #+44]
   \      0x100   0x....             LDR      R1,??DataTable25_1
   \      0x102   0x6B62             LDR      R2,[R4, #+52]
   \      0x104   0x6311             STR      R1,[R2, #+48]
   \      0x106   0x6B61             LDR      R1,[R4, #+52]
   \      0x108   0x6348             STR      R0,[R1, #+52]
   \      0x10A   0x9A00             LDR      R2,[SP, #+0]
   \      0x10C   0x6821             LDR      R1,[R4, #+0]
   \      0x10E   0x314C             ADDS     R1,R1,#+76
   \      0x110   0x6B60             LDR      R0,[R4, #+52]
   \      0x112   0x....'....        BL       HAL_DMA_Start_IT
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD0B1             BEQ      ??HAL_TIM_DMABurst_ReadStart_10
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \      0x11A   0x2001             MOVS     R0,#+1
   \      0x11C   0xBDFE             POP      {R1-R7,PC}
   4058          }
   4059          
   4060          /**
   4061            * @brief  Stop the DMA burst reading
   4062            * @param  htim TIM handle
   4063            * @param  BurstRequestSrc TIM DMA Request sources to disable.
   4064            * @retval HAL status
   4065            */

   \                                 In section .text, align 2, keep-with-next
   4066          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4067          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2                      REQUIRE ?Subroutine9
   \        0x2                      ;; // Fall through to label ?Subroutine9
   4068            HAL_StatusTypeDef status = HAL_OK;
   4069            /* Check the parameters */
   4070            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4071          
   4072            /* Abort the DMA transfer (at least disable the DMA channel) */
   4073            switch (BurstRequestSrc)
   4074            {
   4075              case TIM_DMA_UPDATE:
   4076              {
   4077                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   4078                break;
   4079              }
   4080              case TIM_DMA_CC1:
   4081              {
   4082                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   4083                break;
   4084              }
   4085              case TIM_DMA_CC2:
   4086              {
   4087                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   4088                break;
   4089              }
   4090              case TIM_DMA_CC3:
   4091              {
   4092                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   4093                break;
   4094              }
   4095              case TIM_DMA_CC4:
   4096              {
   4097                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   4098                break;
   4099              }
   4100              case TIM_DMA_TRIGGER:
   4101              {
   4102                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   4103                break;
   4104              }
   4105              default:
   4106                break;
   4107            }
   4108          
   4109            if (HAL_OK == status)
   4110            {
   4111              /* Disable the TIM Update DMA request */
   4112              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   4113            }
   4114          
   4115            /* Return function status */
   4116            return status;
   4117          }
   4118          
   4119          /**
   4120            * @brief  Generate a software event
   4121            * @param  htim TIM handle
   4122            * @param  EventSource specifies the event source.
   4123            *          This parameter can be one of the following values:
   4124            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   4125            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   4126            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   4127            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   4128            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   4129            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   4130            * @note   Basic timers can only generate an update event.
   4131            * @retval HAL status
   4132            */
   4133          

   \                                 In section .text, align 2, keep-with-next
   4134          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   4135          {
   \                     HAL_TIM_GenerateEvent: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   4136            /* Check the parameters */
   4137            assert_param(IS_TIM_INSTANCE(htim->Instance));
   4138            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   4139          
   4140            /* Process Locked */
   4141            __HAL_LOCK(htim);
   \        0x2   0x2238             MOVS     R2,#+56
   \        0x4   0x5C82             LDRB     R2,[R0, R2]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD101             BNE      ??HAL_TIM_GenerateEvent_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD30             POP      {R4,R5,PC}
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \        0xE   0x0002             MOVS     R2,R0
   \       0x10   0x3238             ADDS     R2,R2,#+56
   \       0x12   0x2301             MOVS     R3,#+1
   \       0x14   0x7013             STRB     R3,[R2, #+0]
   4142          
   4143            /* Change the TIM state */
   4144            htim->State = HAL_TIM_STATE_BUSY;
   \       0x16   0x2402             MOVS     R4,#+2
   \       0x18   0x2539             MOVS     R5,#+57
   \       0x1A   0x5544             STRB     R4,[R0, R5]
   4145          
   4146            /* Set the event sources */
   4147            htim->Instance->EGR = EventSource;
   \       0x1C   0x6804             LDR      R4,[R0, #+0]
   \       0x1E   0x6161             STR      R1,[R4, #+20]
   4148          
   4149            /* Change the TIM state */
   4150            htim->State = HAL_TIM_STATE_READY;
   \       0x20   0x5543             STRB     R3,[R0, R5]
   4151          
   4152            __HAL_UNLOCK(htim);
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x7010             STRB     R0,[R2, #+0]
   4153          
   4154            /* Return function status */
   4155            return HAL_OK;
   \       0x26   0xBD30             POP      {R4,R5,PC}       ;; return
   4156          }
   4157          
   4158          /**
   4159            * @brief  Configures the OCRef clear feature
   4160            * @param  htim TIM handle
   4161            * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
   4162            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   4163            * @param  Channel specifies the TIM Channel
   4164            *          This parameter can be one of the following values:
   4165            *            @arg TIM_CHANNEL_1: TIM Channel 1
   4166            *            @arg TIM_CHANNEL_2: TIM Channel 2
   4167            *            @arg TIM_CHANNEL_3: TIM Channel 3
   4168            *            @arg TIM_CHANNEL_4: TIM Channel 4
   4169            * @retval HAL status
   4170            */

   \                                 In section .text, align 2, keep-with-next
   4171          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
   4172                                                     TIM_ClearInputConfigTypeDef *sClearInputConfig,
   4173                                                     uint32_t Channel)
   4174          {
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0017             MOVS     R7,R2
   4175            /* Check the parameters */
   4176            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   4177            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   4178          
   4179            /* Process Locked */
   4180            __HAL_LOCK(htim);
   \        0x6   0x2038             MOVS     R0,#+56
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE      ??HAL_TIM_ConfigOCrefClear_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \       0x12   0x9100             STR      R1,[SP, #+0]
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x2038             MOVS     R0,#+56
   \       0x18   0x5425             STRB     R5,[R4, R0]
   4181          
   4182            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x2139             MOVS     R1,#+57
   \       0x1E   0x5460             STRB     R0,[R4, R1]
   4183          
   4184            switch (sClearInputConfig->ClearInputSource)
   \       0x20   0x2600             MOVS     R6,#+0
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0x6840             LDR      R0,[R0, #+4]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ      ??HAL_TIM_ConfigOCrefClear_1
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD006             BEQ      ??HAL_TIM_ConfigOCrefClear_2
   \       0x2E   0xE015             B        ??HAL_TIM_ConfigOCrefClear_3
   4185            {
   4186              case TIM_CLEARINPUTSOURCE_NONE:
   4187              {
   4188                /* Clear the OCREF clear selection bit and the the ETR Bits */
   4189                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6881             LDR      R1,[R0, #+8]
   \       0x34   0x....             LDR      R2,??DataTable27  ;; 0xffff00ff
   \       0x36   0x400A             ANDS     R2,R2,R1
   \       0x38   0x6082             STR      R2,[R0, #+8]
   4190                break;
   \       0x3A   0xE00F             B        ??HAL_TIM_ConfigOCrefClear_3
   4191              }
   4192          
   4193              case TIM_CLEARINPUTSOURCE_ETR:
   4194              {
   4195                /* Check the parameters */
   4196                assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   4197                assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   4198                assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   4199          
   4200                /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
   4201                if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \       0x3C   0x9800             LDR      R0,[SP, #+0]
   \       0x3E   0x68C0             LDR      R0,[R0, #+12]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD004             BEQ      ??HAL_TIM_ConfigOCrefClear_4
   4202                {
   4203                    htim->State = HAL_TIM_STATE_READY;
   \       0x44   0x5465             STRB     R5,[R4, R1]
   4204                  __HAL_UNLOCK(htim);
   \       0x46   0x2038             MOVS     R0,#+56
   \       0x48   0x5426             STRB     R6,[R4, R0]
   4205                  return HAL_ERROR;
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xBDF2             POP      {R1,R4-R7,PC}
   4206                }
   4207          
   4208                TIM_ETR_SetConfig(htim->Instance,
   4209                                  sClearInputConfig->ClearInputPrescaler,
   4210                                  sClearInputConfig->ClearInputPolarity,
   4211                                  sClearInputConfig->ClearInputFilter);
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0x6903             LDR      R3,[R0, #+16]
   \       0x52   0x6882             LDR      R2,[R0, #+8]
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_ETR_SetConfig
   4212                break;
   4213              }
   4214          
   4215              default:
   4216                break;
   4217            }
   4218          
   4219            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \       0x5C   0x2080             MOVS     R0,#+128
   \       0x5E   0x43C0             MVNS     R0,R0            ;; #-129
   \       0x60   0x2180             MOVS     R1,#+128
   \       0x62   0x....             LDR      R2,??DataTable27_1  ;; 0xffff7fff
   \       0x64   0x020B             LSLS     R3,R1,#+8
   \       0x66   0x2F00             CMP      R7,#+0
   \       0x68   0xD006             BEQ      ??HAL_TIM_ConfigOCrefClear_5
   \       0x6A   0x2F04             CMP      R7,#+4
   \       0x6C   0xD011             BEQ      ??HAL_TIM_ConfigOCrefClear_6
   \       0x6E   0x2F08             CMP      R7,#+8
   \       0x70   0xD01B             BEQ      ??HAL_TIM_ConfigOCrefClear_7
   \       0x72   0x2F0C             CMP      R7,#+12
   \       0x74   0xD026             BEQ      ??HAL_TIM_ConfigOCrefClear_8
   \       0x76   0xE030             B        ??HAL_TIM_ConfigOCrefClear_9
   4220            {
   4221              case TIM_CHANNEL_1:
   4222              {
   4223                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \       0x78   0x6822             LDR      R2,[R4, #+0]
   \       0x7A   0x9B00             LDR      R3,[SP, #+0]
   \       0x7C   0x681B             LDR      R3,[R3, #+0]
   \       0x7E   0x2B00             CMP      R3,#+0
   \       0x80   0xD003             BEQ      ??HAL_TIM_ConfigOCrefClear_10
   4224                {
   4225                  /* Enable the OCREF clear feature for Channel 1 */
   4226                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   \       0x82   0x6990             LDR      R0,[R2, #+24]
   \       0x84   0x4301             ORRS     R1,R1,R0
   \       0x86   0x6191             STR      R1,[R2, #+24]
   \       0x88   0xE027             B        ??HAL_TIM_ConfigOCrefClear_9
   4227                }
   4228                else
   4229                {
   4230                  /* Disable the OCREF clear feature for Channel 1 */
   4231                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \       0x8A   0x6991             LDR      R1,[R2, #+24]
   \       0x8C   0x4008             ANDS     R0,R0,R1
   \       0x8E   0x6190             STR      R0,[R2, #+24]
   \       0x90   0xE023             B        ??HAL_TIM_ConfigOCrefClear_9
   4232                }
   4233                break;
   4234              }
   4235              case TIM_CHANNEL_2:
   4236              {
   4237                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x9900             LDR      R1,[SP, #+0]
   \       0x96   0x6809             LDR      R1,[R1, #+0]
   \       0x98   0x2900             CMP      R1,#+0
   \       0x9A   0x6981             LDR      R1,[R0, #+24]
   \       0x9C   0xD002             BEQ      ??HAL_TIM_ConfigOCrefClear_11
   4238                {
   4239                  /* Enable the OCREF clear feature for Channel 2 */
   4240                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   \       0x9E   0x430B             ORRS     R3,R3,R1
   \       0xA0   0x6183             STR      R3,[R0, #+24]
   \       0xA2   0xE01A             B        ??HAL_TIM_ConfigOCrefClear_9
   4241                }
   4242                else
   4243                {
   4244                  /* Disable the OCREF clear feature for Channel 2 */
   4245                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   \                     ??HAL_TIM_ConfigOCrefClear_11: (+1)
   \       0xA4   0x400A             ANDS     R2,R2,R1
   \       0xA6   0x6182             STR      R2,[R0, #+24]
   \       0xA8   0xE017             B        ??HAL_TIM_ConfigOCrefClear_9
   4246                }
   4247                break;
   4248              }
   4249              case TIM_CHANNEL_3:
   4250              {
   4251                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \       0xAA   0x6822             LDR      R2,[R4, #+0]
   \       0xAC   0x9B00             LDR      R3,[SP, #+0]
   \       0xAE   0x681B             LDR      R3,[R3, #+0]
   \       0xB0   0x2B00             CMP      R3,#+0
   \       0xB2   0xD003             BEQ      ??HAL_TIM_ConfigOCrefClear_12
   4252                {
   4253                  /* Enable the OCREF clear feature for Channel 3 */
   4254                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   \       0xB4   0x69D0             LDR      R0,[R2, #+28]
   \       0xB6   0x4301             ORRS     R1,R1,R0
   \       0xB8   0x61D1             STR      R1,[R2, #+28]
   \       0xBA   0xE00E             B        ??HAL_TIM_ConfigOCrefClear_9
   4255                }
   4256                else
   4257                {
   4258                  /* Disable the OCREF clear feature for Channel 3 */
   4259                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   \                     ??HAL_TIM_ConfigOCrefClear_12: (+1)
   \       0xBC   0x69D1             LDR      R1,[R2, #+28]
   \       0xBE   0x4008             ANDS     R0,R0,R1
   \       0xC0   0x61D0             STR      R0,[R2, #+28]
   \       0xC2   0xE00A             B        ??HAL_TIM_ConfigOCrefClear_9
   4260                }
   4261                break;
   4262              }
   4263              case TIM_CHANNEL_4:
   4264              {
   4265                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x9900             LDR      R1,[SP, #+0]
   \       0xC8   0x6809             LDR      R1,[R1, #+0]
   \       0xCA   0x2900             CMP      R1,#+0
   \       0xCC   0x69C1             LDR      R1,[R0, #+28]
   \       0xCE   0xD002             BEQ      ??HAL_TIM_ConfigOCrefClear_13
   4266                {
   4267                  /* Enable the OCREF clear feature for Channel 4 */
   4268                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   \       0xD0   0x430B             ORRS     R3,R3,R1
   \       0xD2   0x61C3             STR      R3,[R0, #+28]
   \       0xD4   0xE001             B        ??HAL_TIM_ConfigOCrefClear_9
   4269                }
   4270                else
   4271                {
   4272                  /* Disable the OCREF clear feature for Channel 4 */
   4273                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   \                     ??HAL_TIM_ConfigOCrefClear_13: (+1)
   \       0xD6   0x400A             ANDS     R2,R2,R1
   \       0xD8   0x61C2             STR      R2,[R0, #+28]
   4274                }
   4275                break;
   4276              }
   4277              default:
   4278                break;
   4279            }
   4280          
   4281            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \       0xDA   0x2039             MOVS     R0,#+57
   \       0xDC   0x5425             STRB     R5,[R4, R0]
   4282          
   4283            __HAL_UNLOCK(htim);
   \       0xDE   0x2038             MOVS     R0,#+56
   \       0xE0   0x5426             STRB     R6,[R4, R0]
   4284          
   4285            return HAL_OK;
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4286          }
   4287          
   4288          /**
   4289            * @brief   Configures the clock source to be used
   4290            * @param  htim TIM handle
   4291            * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
   4292            *         contains the clock source information for the TIM peripheral.
   4293            * @retval HAL status
   4294            */

   \                                 In section .text, align 2, keep-with-next
   4295          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
   4296          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4297            uint32_t tmpsmcr;
   4298          
   4299            /* Process Locked */
   4300            __HAL_LOCK(htim);
   \        0x4   0x2038             MOVS     R0,#+56
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIM_ConfigClockSource_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \       0x10   0x0026             MOVS     R6,R4
   \       0x12   0x3638             ADDS     R6,R6,#+56
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x7035             STRB     R5,[R6, #+0]
   4301          
   4302            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x2239             MOVS     R2,#+57
   \       0x1C   0x54A0             STRB     R0,[R4, R2]
   4303          
   4304            /* Check the parameters */
   4305            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   4306          
   4307            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   4308            tmpsmcr = htim->Instance->SMCR;
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6882             LDR      R2,[R0, #+8]
   4309            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   4310            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   4311            htim->Instance->SMCR = tmpsmcr;
   \       0x22   0x....             LDR      R3,??DataTable27_2  ;; 0xffff0088
   \       0x24   0x4013             ANDS     R3,R3,R2
   \       0x26   0x6083             STR      R3,[R0, #+8]
   4312          
   4313            switch (sClockSourceConfig->ClockSource)
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x0002             MOVS     R2,R0
   \       0x2C   0xD03C             BEQ      ??HAL_TIM_ConfigClockSource_1
   \       0x2E   0x2810             CMP      R0,#+16
   \       0x30   0xD03A             BEQ      ??HAL_TIM_ConfigClockSource_1
   \       0x32   0x2820             CMP      R0,#+32
   \       0x34   0xD038             BEQ      ??HAL_TIM_ConfigClockSource_1
   \       0x36   0x2830             CMP      R0,#+48
   \       0x38   0xD036             BEQ      ??HAL_TIM_ConfigClockSource_1
   \       0x3A   0x2840             CMP      R0,#+64
   \       0x3C   0xD02D             BEQ      ??HAL_TIM_ConfigClockSource_2
   \       0x3E   0x2850             CMP      R0,#+80
   \       0x40   0xD01D             BEQ      ??HAL_TIM_ConfigClockSource_3
   \       0x42   0x2860             CMP      R0,#+96
   \       0x44   0xD022             BEQ      ??HAL_TIM_ConfigClockSource_4
   \       0x46   0x2870             CMP      R0,#+112
   \       0x48   0xD003             BEQ      ??HAL_TIM_ConfigClockSource_5
   \       0x4A   0x036B             LSLS     R3,R5,#+13
   \       0x4C   0x4298             CMP      R0,R3
   \       0x4E   0xD00A             BEQ      ??HAL_TIM_ConfigClockSource_6
   \       0x50   0xE02E             B        ??HAL_TIM_ConfigClockSource_7
   4314            {
   4315              case TIM_CLOCKSOURCE_INTERNAL:
   4316              {
   4317                assert_param(IS_TIM_INSTANCE(htim->Instance));
   4318                break;
   4319              }
   4320          
   4321              case TIM_CLOCKSOURCE_ETRMODE1:
   4322              {
   4323                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   4324                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4325          
   4326                /* Check ETR input conditioning related parameters */
   4327                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4328                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4329                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4330          
   4331                /* Configure the ETR Clock source */
   4332                TIM_ETR_SetConfig(htim->Instance,
   4333                                  sClockSourceConfig->ClockPrescaler,
   4334                                  sClockSourceConfig->ClockPolarity,
   4335                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \       0x52   0x68CB             LDR      R3,[R1, #+12]
   \       0x54   0x684A             LDR      R2,[R1, #+4]
   \       0x56   0x6889             LDR      R1,[R1, #+8]
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x....'....        BL       TIM_ETR_SetConfig
   4336          
   4337                /* Select the External clock mode1 and the ETRF trigger */
   4338                tmpsmcr = htim->Instance->SMCR;
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6881             LDR      R1,[R0, #+8]
   4339                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   4340                /* Write to TIMx SMCR */
   4341                htim->Instance->SMCR = tmpsmcr;
   \       0x62   0x2277             MOVS     R2,#+119
   \       0x64   0xE008             B.N      ??HAL_TIM_ConfigClockSource_8
   4342                break;
   4343              }
   4344          
   4345              case TIM_CLOCKSOURCE_ETRMODE2:
   4346              {
   4347                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   4348                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   4349          
   4350                /* Check ETR input conditioning related parameters */
   4351                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4352                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4353                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4354          
   4355                /* Configure the ETR Clock source */
   4356                TIM_ETR_SetConfig(htim->Instance,
   4357                                  sClockSourceConfig->ClockPrescaler,
   4358                                  sClockSourceConfig->ClockPolarity,
   4359                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \       0x66   0x68CB             LDR      R3,[R1, #+12]
   \       0x68   0x684A             LDR      R2,[R1, #+4]
   \       0x6A   0x6889             LDR      R1,[R1, #+8]
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x....'....        BL       TIM_ETR_SetConfig
   4360                /* Enable the External clock mode2 */
   4361                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6881             LDR      R1,[R0, #+8]
   \       0x76   0x03AA             LSLS     R2,R5,#+14
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \       0x78   0x430A             ORRS     R2,R2,R1
   \       0x7A   0x6082             STR      R2,[R0, #+8]
   4362                break;
   \       0x7C   0xE018             B        ??HAL_TIM_ConfigClockSource_7
   4363              }
   4364          
   4365              case TIM_CLOCKSOURCE_TI1:
   4366              {
   4367                /* Check whether or not the timer instance supports external clock mode 1 */
   4368                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4369          
   4370                /* Check TI1 input conditioning related parameters */
   4371                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4372                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4373          
   4374                TIM_TI1_ConfigInputStage(htim->Instance,
   4375                                         sClockSourceConfig->ClockPolarity,
   4376                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \       0x7E   0x68CA             LDR      R2,[R1, #+12]
   \       0x80   0x6849             LDR      R1,[R1, #+4]
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x....'....        BL       TIM_TI1_ConfigInputStage
   4377                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \       0x88   0x2150             MOVS     R1,#+80
   \       0x8A   0xE00E             B        ??HAL_TIM_ConfigClockSource_9
   4378                break;
   4379              }
   4380          
   4381              case TIM_CLOCKSOURCE_TI2:
   4382              {
   4383                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   4384                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4385          
   4386                /* Check TI2 input conditioning related parameters */
   4387                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4388                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4389          
   4390                TIM_TI2_ConfigInputStage(htim->Instance,
   4391                                         sClockSourceConfig->ClockPolarity,
   4392                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \       0x8C   0x68CA             LDR      R2,[R1, #+12]
   \       0x8E   0x6849             LDR      R1,[R1, #+4]
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x....'....        BL       TIM_TI2_ConfigInputStage
   4393                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \       0x96   0x2160             MOVS     R1,#+96
   \       0x98   0xE007             B        ??HAL_TIM_ConfigClockSource_9
   4394                break;
   4395              }
   4396          
   4397              case TIM_CLOCKSOURCE_TI1ED:
   4398              {
   4399                /* Check whether or not the timer instance supports external clock mode 1 */
   4400                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4401          
   4402                /* Check TI1 input conditioning related parameters */
   4403                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4404                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4405          
   4406                TIM_TI1_ConfigInputStage(htim->Instance,
   4407                                         sClockSourceConfig->ClockPolarity,
   4408                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \       0x9A   0x68CA             LDR      R2,[R1, #+12]
   \       0x9C   0x6849             LDR      R1,[R1, #+4]
   \       0x9E   0x6820             LDR      R0,[R4, #+0]
   \       0xA0   0x....'....        BL       TIM_TI1_ConfigInputStage
   4409                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \       0xA4   0x2140             MOVS     R1,#+64
   \       0xA6   0xE000             B        ??HAL_TIM_ConfigClockSource_9
   4410                break;
   4411              }
   4412          
   4413              case TIM_CLOCKSOURCE_ITR0:
   4414              case TIM_CLOCKSOURCE_ITR1:
   4415              case TIM_CLOCKSOURCE_ITR2:
   4416              case TIM_CLOCKSOURCE_ITR3:
   4417              {
   4418                /* Check whether or not the timer instance supports internal trigger input */
   4419                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4420          
   4421                TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \       0xA8   0x0001             MOVS     R1,R0
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x....'....        BL       TIM_ITRx_SetConfig
   4422                break;
   4423              }
   4424          
   4425              default:
   4426                break;
   4427            }
   4428            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \       0xB0                      REQUIRE ?Subroutine11
   \       0xB0                      ;; // Fall through to label ?Subroutine11
   4429          
   4430            __HAL_UNLOCK(htim);
   4431          
   4432            return HAL_OK;
   4433          }
   4434          
   4435          /**
   4436            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4437            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4438            * @param  htim TIM handle.
   4439            * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
   4440            *         output of a XOR gate.
   4441            *          This parameter can be one of the following values:
   4442            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4443            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4444            *            pins are connected to the TI1 input (XOR combination)
   4445            * @retval HAL status
   4446            */

   \                                 In section .text, align 2, keep-with-next
   4447          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4448          {
   4449            uint32_t tmpcr2;
   4450          
   4451            /* Check the parameters */
   4452            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4453            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4454          
   4455            /* Get the TIMx CR2 register value */
   4456            tmpcr2 = htim->Instance->CR2;
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x6842             LDR      R2,[R0, #+4]
   4457          
   4458            /* Reset the TI1 selection */
   4459            tmpcr2 &= ~TIM_CR2_TI1S;
   4460          
   4461            /* Set the TI1 selection */
   4462            tmpcr2 |= TI1_Selection;
   4463          
   4464            /* Write to TIMxCR2 */
   4465            htim->Instance->CR2 = tmpcr2;
   \        0x4   0x2380             MOVS     R3,#+128
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x4311             ORRS     R1,R1,R2
   \        0xA   0x6041             STR      R1,[R0, #+4]
   4466          
   4467            return HAL_OK;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
   4468          }
   4469          
   4470          /**
   4471            * @brief  Configures the TIM in Slave mode
   4472            * @param  htim TIM handle.
   4473            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4474            *         contains the selected trigger (internal trigger input, filtered
   4475            *         timer input or external trigger input) and the Slave mode
   4476            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4477            * @retval HAL status
   4478            */

   \                                 In section .text, align 2, keep-with-next
   4479          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
   4480          {
   \                     HAL_TIM_SlaveConfigSynchro: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4481            /* Check the parameters */
   4482            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4483            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4484            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4485          
   4486            __HAL_LOCK(htim);
   \        0x4   0x2038             MOVS     R0,#+56
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIM_SlaveConfigSynchro_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_TIM_SlaveConfigSynchro_0: (+1)
   \       0x10   0x0027             MOVS     R7,R4
   \       0x12   0x3738             ADDS     R7,R7,#+56
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x703D             STRB     R5,[R7, #+0]
   4487          
   4488            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x2239             MOVS     R2,#+57
   \       0x1C   0x54A0             STRB     R0,[R4, R2]
   4489          
   4490            if(TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   \       0x1E   0x2600             MOVS     R6,#+0
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       TIM_SlaveTimer_SetConfig
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD000             BEQ      ??HAL_TIM_SlaveConfigSynchro_1
   4491            {
   4492                htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x....             B.N      ?Subroutine7
   4493              __HAL_UNLOCK(htim);
   4494              return HAL_ERROR;
   4495            }
   4496          
   4497            /* Disable Trigger Interrupt */
   4498            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchro_1: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x68C1             LDR      R1,[R0, #+12]
   \       0x30   0x2240             MOVS     R2,#+64
   \       0x32   0x4391             BICS     R1,R1,R2
   \       0x34   0x60C1             STR      R1,[R0, #+12]
   4499          
   4500            /* Disable Trigger DMA request */
   4501            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \       0x36   0x....             B.N      ?Subroutine6
   4502          
   4503            htim->State = HAL_TIM_STATE_READY;
   4504          
   4505            __HAL_UNLOCK(htim);
   4506          
   4507            return HAL_OK;
   4508          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2039             MOVS     R0,#+57
   \        0x2   0x5425             STRB     R5,[R4, R0]
   \        0x4   0x703E             STRB     R6,[R7, #+0]
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0x....             LDR      R2,??DataTable31  ;; 0xffffbfff
   \        0x6   0x400A             ANDS     R2,R2,R1
   \        0x8   0x60C2             STR      R2,[R0, #+12]
   \        0xA   0x2039             MOVS     R0,#+57
   \        0xC   0x5425             STRB     R5,[R4, R0]
   \        0xE   0x703E             STRB     R6,[R7, #+0]
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4509          
   4510          /**
   4511            * @brief  Configures the TIM in Slave mode in interrupt mode
   4512            * @param  htim TIM handle.
   4513            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4514            *         contains the selected trigger (internal trigger input, filtered
   4515            *         timer input or external trigger input) and the Slave mode
   4516            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4517            * @retval HAL status
   4518            */

   \                                 In section .text, align 2, keep-with-next
   4519          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
   4520                                                                  TIM_SlaveConfigTypeDef *sSlaveConfig)
   4521          {
   \                     HAL_TIM_SlaveConfigSynchro_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4522            /* Check the parameters */
   4523            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4524            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4525            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4526          
   4527            __HAL_LOCK(htim);
   \        0x4   0x2038             MOVS     R0,#+56
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIM_SlaveConfigSynchro_IT_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_0: (+1)
   \       0x10   0x0027             MOVS     R7,R4
   \       0x12   0x3738             ADDS     R7,R7,#+56
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x703D             STRB     R5,[R7, #+0]
   4528          
   4529            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x2239             MOVS     R2,#+57
   \       0x1C   0x54A0             STRB     R0,[R4, R2]
   4530          
   4531            if(TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   \       0x1E   0x2600             MOVS     R6,#+0
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       TIM_SlaveTimer_SetConfig
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD000             BEQ      ??HAL_TIM_SlaveConfigSynchro_IT_1
   4532            {
   4533                htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x....             B.N      ?Subroutine7
   4534              __HAL_UNLOCK(htim);
   4535              return HAL_ERROR;
   4536            }
   4537          
   4538            /* Enable Trigger Interrupt */
   4539            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_1: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x68C1             LDR      R1,[R0, #+12]
   \       0x30   0x2240             MOVS     R2,#+64
   \       0x32   0x430A             ORRS     R2,R2,R1
   \       0x34   0x60C2             STR      R2,[R0, #+12]
   4540          
   4541            /* Disable Trigger DMA request */
   4542            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \       0x36   0x....             B.N      ?Subroutine6
   4543          
   4544            htim->State = HAL_TIM_STATE_READY;
   4545          
   4546            __HAL_UNLOCK(htim);
   4547          
   4548            return HAL_OK;
   4549          }
   4550          
   4551          /**
   4552            * @brief  Read the captured value from Capture Compare unit
   4553            * @param  htim TIM handle.
   4554            * @param  Channel TIM Channels to be enabled
   4555            *          This parameter can be one of the following values:
   4556            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4557            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4558            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4559            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4560            * @retval Captured value
   4561            */

   \                                 In section .text, align 2, keep-with-next
   4562          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4563          {
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4564            uint32_t tmpreg = 0U;
   \        0x2   0x2000             MOVS     R0,#+0
   4565          
   4566            switch (Channel)
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD006             BEQ      ??HAL_TIM_ReadCapturedValue_0
   \        0x8   0x2904             CMP      R1,#+4
   \        0xA   0xD007             BEQ      ??HAL_TIM_ReadCapturedValue_1
   \        0xC   0x2908             CMP      R1,#+8
   \        0xE   0xD008             BEQ      ??HAL_TIM_ReadCapturedValue_2
   \       0x10   0x290C             CMP      R1,#+12
   \       0x12   0xD009             BEQ      ??HAL_TIM_ReadCapturedValue_3
   \       0x14   0x4770             BX       LR
   4567            {
   4568              case TIM_CHANNEL_1:
   4569              {
   4570                /* Check the parameters */
   4571                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4572          
   4573                /* Return the capture 1 value */
   4574                tmpreg =  htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \       0x16   0x6810             LDR      R0,[R2, #+0]
   \       0x18   0x6B40             LDR      R0,[R0, #+52]
   4575          
   4576                break;
   \       0x1A   0x4770             BX       LR
   4577              }
   4578              case TIM_CHANNEL_2:
   4579              {
   4580                /* Check the parameters */
   4581                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4582          
   4583                /* Return the capture 2 value */
   4584                tmpreg =   htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \       0x1C   0x6810             LDR      R0,[R2, #+0]
   \       0x1E   0x6B80             LDR      R0,[R0, #+56]
   4585          
   4586                break;
   \       0x20   0x4770             BX       LR
   4587              }
   4588          
   4589              case TIM_CHANNEL_3:
   4590              {
   4591                /* Check the parameters */
   4592                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4593          
   4594                /* Return the capture 3 value */
   4595                tmpreg =   htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \       0x22   0x6810             LDR      R0,[R2, #+0]
   \       0x24   0x6BC0             LDR      R0,[R0, #+60]
   4596          
   4597                break;
   \       0x26   0x4770             BX       LR
   4598              }
   4599          
   4600              case TIM_CHANNEL_4:
   4601              {
   4602                /* Check the parameters */
   4603                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4604          
   4605                /* Return the capture 4 value */
   4606                tmpreg =   htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \       0x28   0x6810             LDR      R0,[R2, #+0]
   \       0x2A   0x6C00             LDR      R0,[R0, #+64]
   4607          
   4608                break;
   4609              }
   4610          
   4611              default:
   4612                break;
   4613            }
   4614          
   4615            return tmpreg;
   \       0x2C   0x4770             BX       LR               ;; return
   4616          }
   4617          
   4618          /**
   4619            * @}
   4620            */
   4621          
   4622          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4623           *  @brief    TIM Callbacks functions
   4624           *
   4625          @verbatim
   4626            ==============================================================================
   4627                                  ##### TIM Callbacks functions #####
   4628            ==============================================================================
   4629           [..]
   4630             This section provides TIM callback functions:
   4631             (+) TIM Period elapsed callback
   4632             (+) TIM Output Compare callback
   4633             (+) TIM Input capture callback
   4634             (+) TIM Trigger callback
   4635             (+) TIM Error callback
   4636          
   4637          @endverbatim
   4638            * @{
   4639            */
   4640          
   4641          /**
   4642            * @brief  Period elapsed callback in non-blocking mode
   4643            * @param  htim TIM handle
   4644            * @retval None
   4645            */

   \                                 In section .text, align 2
   4646          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4647          {
   4648            /* Prevent unused argument(s) compilation warning */
   4649            UNUSED(htim);
   4650          
   4651            /* NOTE : This function should not be modified, when the callback is needed,
   4652                      the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4653             */
   4654          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4655          
   4656          /**
   4657            * @brief  Period elapsed half complete callback in non-blocking mode
   4658            * @param  htim TIM handle
   4659            * @retval None
   4660            */

   \                                 In section .text, align 2
   4661          __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
   4662          {
   4663            /* Prevent unused argument(s) compilation warning */
   4664            UNUSED(htim);
   4665          
   4666            /* NOTE : This function should not be modified, when the callback is needed,
   4667                      the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   4668             */
   4669          }
   \                     HAL_TIM_PeriodElapsedHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4670          
   4671          /**
   4672            * @brief  Output Compare callback in non-blocking mode
   4673            * @param  htim TIM OC handle
   4674            * @retval None
   4675            */

   \                                 In section .text, align 2
   4676          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4677          {
   4678            /* Prevent unused argument(s) compilation warning */
   4679            UNUSED(htim);
   4680          
   4681            /* NOTE : This function should not be modified, when the callback is needed,
   4682                      the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4683             */
   4684          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4685          
   4686          /**
   4687            * @brief  Input Capture callback in non-blocking mode
   4688            * @param  htim TIM IC handle
   4689            * @retval None
   4690            */

   \                                 In section .text, align 2
   4691          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4692          {
   4693            /* Prevent unused argument(s) compilation warning */
   4694            UNUSED(htim);
   4695          
   4696            /* NOTE : This function should not be modified, when the callback is needed,
   4697                      the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4698             */
   4699          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4700          
   4701          /**
   4702            * @brief  Input Capture half complete callback in non-blocking mode
   4703            * @param  htim TIM IC handle
   4704            * @retval None
   4705            */

   \                                 In section .text, align 2
   4706          __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
   4707          {
   4708            /* Prevent unused argument(s) compilation warning */
   4709            UNUSED(htim);
   4710          
   4711            /* NOTE : This function should not be modified, when the callback is needed,
   4712                      the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   4713             */
   4714          }
   \                     HAL_TIM_IC_CaptureHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4715          
   4716          /**
   4717            * @brief  PWM Pulse finished callback in non-blocking mode
   4718            * @param  htim TIM handle
   4719            * @retval None
   4720            */

   \                                 In section .text, align 2
   4721          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4722          {
   4723            /* Prevent unused argument(s) compilation warning */
   4724            UNUSED(htim);
   4725          
   4726            /* NOTE : This function should not be modified, when the callback is needed,
   4727                      the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4728             */
   4729          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4730          
   4731          /**
   4732            * @brief  PWM Pulse finished half complete callback in non-blocking mode
   4733            * @param  htim TIM handle
   4734            * @retval None
   4735            */

   \                                 In section .text, align 2
   4736          __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
   4737          {
   4738            /* Prevent unused argument(s) compilation warning */
   4739            UNUSED(htim);
   4740          
   4741            /* NOTE : This function should not be modified, when the callback is needed,
   4742                      the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   4743             */
   4744          }
   \                     HAL_TIM_PWM_PulseFinishedHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4745          
   4746          /**
   4747            * @brief  Hall Trigger detection callback in non-blocking mode
   4748            * @param  htim TIM handle
   4749            * @retval None
   4750            */

   \                                 In section .text, align 2
   4751          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4752          {
   4753            /* Prevent unused argument(s) compilation warning */
   4754            UNUSED(htim);
   4755          
   4756            /* NOTE : This function should not be modified, when the callback is needed,
   4757                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4758             */
   4759          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4760          
   4761          /**
   4762            * @brief  Hall Trigger detection half complete callback in non-blocking mode
   4763            * @param  htim TIM handle
   4764            * @retval None
   4765            */

   \                                 In section .text, align 2
   4766          __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
   4767          {
   4768            /* Prevent unused argument(s) compilation warning */
   4769            UNUSED(htim);
   4770          
   4771            /* NOTE : This function should not be modified, when the callback is needed,
   4772                      the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   4773             */
   4774          }
   \                     HAL_TIM_TriggerHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4775          
   4776          /**
   4777            * @brief  Timer error callback in non-blocking mode
   4778            * @param  htim TIM handle
   4779            * @retval None
   4780            */

   \                                 In section .text, align 2
   4781          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4782          {
   4783            /* Prevent unused argument(s) compilation warning */
   4784            UNUSED(htim);
   4785          
   4786            /* NOTE : This function should not be modified, when the callback is needed,
   4787                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4788             */
   4789          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4790          
   4791          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   4792          /**
   4793            * @brief  Register a User TIM callback to be used instead of the weak predefined callback
   4794            * @param htim tim handle
   4795            * @param CallbackID ID of the callback to be registered
   4796            *        This parameter can be one of the following values:
   4797            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   4798            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   4799            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   4800            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   4801            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   4802            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   4803            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   4804            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   4805            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   4806            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   4807            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   4808            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   4809            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   4810            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   4811            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   4812            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   4813            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   4814            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   4815            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   4816            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   4817            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   4818            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   4819            *          @param pCallback pointer to the callback function
   4820            *          @retval status
   4821            */
   4822          HAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID, pTIM_CallbackTypeDef pCallback)
   4823          {
   4824            HAL_StatusTypeDef status = HAL_OK;
   4825          
   4826            if (pCallback == NULL)
   4827            {
   4828              return HAL_ERROR;
   4829            }
   4830            /* Process locked */
   4831            __HAL_LOCK(htim);
   4832          
   4833            if (htim->State == HAL_TIM_STATE_READY)
   4834            {
   4835              switch (CallbackID)
   4836              {
   4837                case HAL_TIM_BASE_MSPINIT_CB_ID :
   4838                  htim->Base_MspInitCallback                 = pCallback;
   4839                  break;
   4840          
   4841                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   4842                  htim->Base_MspDeInitCallback               = pCallback;
   4843                  break;
   4844          
   4845                case HAL_TIM_IC_MSPINIT_CB_ID :
   4846                  htim->IC_MspInitCallback                   = pCallback;
   4847                  break;
   4848          
   4849                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   4850                  htim->IC_MspDeInitCallback                 = pCallback;
   4851                  break;
   4852          
   4853                case HAL_TIM_OC_MSPINIT_CB_ID :
   4854                  htim->OC_MspInitCallback                   = pCallback;
   4855                  break;
   4856          
   4857                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   4858                  htim->OC_MspDeInitCallback                 = pCallback;
   4859                  break;
   4860          
   4861                case HAL_TIM_PWM_MSPINIT_CB_ID :
   4862                  htim->PWM_MspInitCallback                  = pCallback;
   4863                  break;
   4864          
   4865                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   4866                  htim->PWM_MspDeInitCallback                = pCallback;
   4867                  break;
   4868          
   4869                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   4870                  htim->OnePulse_MspInitCallback             = pCallback;
   4871                  break;
   4872          
   4873                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   4874                  htim->OnePulse_MspDeInitCallback           = pCallback;
   4875                  break;
   4876          
   4877                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   4878                  htim->Encoder_MspInitCallback              = pCallback;
   4879                  break;
   4880          
   4881                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   4882                  htim->Encoder_MspDeInitCallback            = pCallback;
   4883                  break;
   4884          
   4885                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   4886                  htim->PeriodElapsedCallback                = pCallback;
   4887                  break;
   4888          
   4889                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   4890                  htim->PeriodElapsedHalfCpltCallback        = pCallback;
   4891                  break;
   4892          
   4893                case HAL_TIM_TRIGGER_CB_ID :
   4894                  htim->TriggerCallback                      = pCallback;
   4895                  break;
   4896          
   4897                case HAL_TIM_TRIGGER_HALF_CB_ID :
   4898                  htim->TriggerHalfCpltCallback              = pCallback;
   4899                  break;
   4900          
   4901                case HAL_TIM_IC_CAPTURE_CB_ID :
   4902                  htim->IC_CaptureCallback                   = pCallback;
   4903                  break;
   4904          
   4905                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   4906                  htim->IC_CaptureHalfCpltCallback           = pCallback;
   4907                  break;
   4908          
   4909                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   4910                  htim->OC_DelayElapsedCallback              = pCallback;
   4911                  break;
   4912          
   4913                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   4914                  htim->PWM_PulseFinishedCallback            = pCallback;
   4915                  break;
   4916          
   4917                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   4918                  htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;
   4919                  break;
   4920          
   4921                case HAL_TIM_ERROR_CB_ID :
   4922                  htim->ErrorCallback                        = pCallback;
   4923                  break;
   4924          
   4925                default :
   4926                  /* Return error status */
   4927                  status =  HAL_ERROR;
   4928                  break;
   4929              }
   4930            }
   4931            else if (htim->State == HAL_TIM_STATE_RESET)
   4932            {
   4933              switch (CallbackID)
   4934              {
   4935                case HAL_TIM_BASE_MSPINIT_CB_ID :
   4936                  htim->Base_MspInitCallback         = pCallback;
   4937                  break;
   4938          
   4939                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   4940                  htim->Base_MspDeInitCallback       = pCallback;
   4941                  break;
   4942          
   4943                case HAL_TIM_IC_MSPINIT_CB_ID :
   4944                  htim->IC_MspInitCallback           = pCallback;
   4945                  break;
   4946          
   4947                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   4948                  htim->IC_MspDeInitCallback         = pCallback;
   4949                  break;
   4950          
   4951                case HAL_TIM_OC_MSPINIT_CB_ID :
   4952                  htim->OC_MspInitCallback           = pCallback;
   4953                  break;
   4954          
   4955                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   4956                  htim->OC_MspDeInitCallback         = pCallback;
   4957                  break;
   4958          
   4959                case HAL_TIM_PWM_MSPINIT_CB_ID :
   4960                  htim->PWM_MspInitCallback          = pCallback;
   4961                  break;
   4962          
   4963                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   4964                  htim->PWM_MspDeInitCallback        = pCallback;
   4965                  break;
   4966          
   4967                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   4968                  htim->OnePulse_MspInitCallback     = pCallback;
   4969                  break;
   4970          
   4971                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   4972                  htim->OnePulse_MspDeInitCallback   = pCallback;
   4973                  break;
   4974          
   4975                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   4976                  htim->Encoder_MspInitCallback      = pCallback;
   4977                  break;
   4978          
   4979                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   4980                  htim->Encoder_MspDeInitCallback    = pCallback;
   4981                  break;
   4982          
   4983                default :
   4984                  /* Return error status */
   4985                  status =  HAL_ERROR;
   4986                  break;
   4987              }
   4988            }
   4989            else
   4990            {
   4991              /* Return error status */
   4992              status =  HAL_ERROR;
   4993            }
   4994          
   4995            /* Release Lock */
   4996            __HAL_UNLOCK(htim);
   4997          
   4998            return status;
   4999          }
   5000          
   5001          /**
   5002            * @brief  Unregister a TIM callback
   5003            *         TIM callback is redirected to the weak predefined callback
   5004            * @param htim tim handle
   5005            * @param CallbackID ID of the callback to be unregistered
   5006            *        This parameter can be one of the following values:
   5007            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5008            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5009            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5010            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5011            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5012            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5013            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5014            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5015            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5016            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5017            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5018            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5019            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5020            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   5021            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5022            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5023            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5024            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5025            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5026            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5027            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5028            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5029            *          @retval status
   5030            */
   5031          HAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)
   5032          {
   5033            HAL_StatusTypeDef status = HAL_OK;
   5034          
   5035            /* Process locked */
   5036            __HAL_LOCK(htim);
   5037          
   5038            if (htim->State == HAL_TIM_STATE_READY)
   5039            {
   5040              switch (CallbackID)
   5041              {
   5042                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5043                  htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;                      /* Legacy weak Base MspInit Callback */
   5044                  break;
   5045          
   5046                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5047                  htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;                    /* Legacy weak Base Msp DeInit Callback */
   5048                  break;
   5049          
   5050                case HAL_TIM_IC_MSPINIT_CB_ID :
   5051                  htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;                        /* Legacy weak IC Msp Init Callback */
   5052                  break;
   5053          
   5054                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5055                  htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;                      /* Legacy weak IC Msp DeInit Callback */
   5056                  break;
   5057          
   5058                case HAL_TIM_OC_MSPINIT_CB_ID :
   5059                  htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;                        /* Legacy weak OC Msp Init Callback */
   5060                  break;
   5061          
   5062                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5063                  htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;                      /* Legacy weak OC Msp DeInit Callback */
   5064                  break;
   5065          
   5066                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5067                  htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;                       /* Legacy weak PWM Msp Init Callback */
   5068                  break;
   5069          
   5070                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5071                  htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;                     /* Legacy weak PWM Msp DeInit Callback */
   5072                  break;
   5073          
   5074                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5075                  htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;                  /* Legacy weak One Pulse Msp Init Callback */
   5076                  break;
   5077          
   5078                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5079                  htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;                /* Legacy weak One Pulse Msp DeInit Callback */
   5080                  break;
   5081          
   5082                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5083                  htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;                   /* Legacy weak Encoder Msp Init Callback */
   5084                  break;
   5085          
   5086                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5087                  htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;                 /* Legacy weak Encoder Msp DeInit Callback */
   5088                  break;
   5089          
   5090                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5091                  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak Period Elapsed Callback */
   5092                  break;
   5093          
   5094                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5095                  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak Period Elapsed half complete Callback */
   5096                  break;
   5097          
   5098                case HAL_TIM_TRIGGER_CB_ID :
   5099                  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak Trigger Callback */
   5100                  break;
   5101          
   5102                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5103                  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak Trigger half complete Callback */
   5104                  break;
   5105          
   5106                case HAL_TIM_IC_CAPTURE_CB_ID :
   5107                  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC Capture Callback */
   5108                  break;
   5109          
   5110                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5111                  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC Capture half complete Callback */
   5112                  break;
   5113          
   5114                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5115                  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC Delay Elapsed Callback */
   5116                  break;
   5117          
   5118                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5119                  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM Pulse Finished Callback */
   5120                  break;
   5121          
   5122                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5123                  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM Pulse Finished half complete Callback */
   5124                  break;
   5125          
   5126                case HAL_TIM_ERROR_CB_ID :
   5127                  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak Error Callback */
   5128                  break;
   5129          
   5130                default :
   5131                  /* Return error status */
   5132                  status =  HAL_ERROR;
   5133                  break;
   5134              }
   5135            }
   5136            else if (htim->State == HAL_TIM_STATE_RESET)
   5137            {
   5138              switch (CallbackID)
   5139              {
   5140                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5141                  htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;              /* Legacy weak Base MspInit Callback */
   5142                  break;
   5143          
   5144                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5145                  htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;            /* Legacy weak Base Msp DeInit Callback */
   5146                  break;
   5147          
   5148                case HAL_TIM_IC_MSPINIT_CB_ID :
   5149                  htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;                /* Legacy weak IC Msp Init Callback */
   5150                  break;
   5151          
   5152                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5153                  htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;              /* Legacy weak IC Msp DeInit Callback */
   5154                  break;
   5155          
   5156                case HAL_TIM_OC_MSPINIT_CB_ID :
   5157                  htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;                /* Legacy weak OC Msp Init Callback */
   5158                  break;
   5159          
   5160                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5161                  htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;              /* Legacy weak OC Msp DeInit Callback */
   5162                  break;
   5163          
   5164                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5165                  htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;               /* Legacy weak PWM Msp Init Callback */
   5166                  break;
   5167          
   5168                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5169                  htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;             /* Legacy weak PWM Msp DeInit Callback */
   5170                  break;
   5171          
   5172                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5173                  htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;          /* Legacy weak One Pulse Msp Init Callback */
   5174                  break;
   5175          
   5176                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5177                  htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;        /* Legacy weak One Pulse Msp DeInit Callback */
   5178                  break;
   5179          
   5180                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5181                  htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;           /* Legacy weak Encoder Msp Init Callback */
   5182                  break;
   5183          
   5184                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5185                  htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;         /* Legacy weak Encoder Msp DeInit Callback */
   5186                  break;
   5187          
   5188                default :
   5189                  /* Return error status */
   5190                  status =  HAL_ERROR;
   5191                  break;
   5192              }
   5193            }
   5194            else
   5195            {
   5196              /* Return error status */
   5197              status =  HAL_ERROR;
   5198            }
   5199          
   5200            /* Release Lock */
   5201            __HAL_UNLOCK(htim);
   5202          
   5203            return status;
   5204          }
   5205          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5206          
   5207          /**
   5208            * @}
   5209            */
   5210          
   5211          /** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
   5212           *  @brief   TIM Peripheral State functions
   5213           *
   5214          @verbatim
   5215            ==============================================================================
   5216                                  ##### Peripheral State functions #####
   5217            ==============================================================================
   5218              [..]
   5219              This subsection permits to get in run-time the status of the peripheral
   5220              and the data flow.
   5221          
   5222          @endverbatim
   5223            * @{
   5224            */
   5225          
   5226          /**
   5227            * @brief  Return the TIM Base handle state.
   5228            * @param  htim TIM Base handle
   5229            * @retval HAL state
   5230            */

   \                                 In section .text, align 2, keep-with-next
   5231          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   5232          {
   5233            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \        0x0   0x2139             MOVS     R1,#+57
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5234          }
   5235          
   5236          /**
   5237            * @brief  Return the TIM OC handle state.
   5238            * @param  htim TIM Output Compare handle
   5239            * @retval HAL state
   5240            */

   \                                 In section .text, align 2, keep-with-next
   5241          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   5242          {
   5243            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \        0x0   0x2139             MOVS     R1,#+57
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5244          }
   5245          
   5246          /**
   5247            * @brief  Return the TIM PWM handle state.
   5248            * @param  htim TIM handle
   5249            * @retval HAL state
   5250            */

   \                                 In section .text, align 2, keep-with-next
   5251          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   5252          {
   5253            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \        0x0   0x2139             MOVS     R1,#+57
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5254          }
   5255          
   5256          /**
   5257            * @brief  Return the TIM Input Capture handle state.
   5258            * @param  htim TIM IC handle
   5259            * @retval HAL state
   5260            */

   \                                 In section .text, align 2, keep-with-next
   5261          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   5262          {
   5263            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \        0x0   0x2139             MOVS     R1,#+57
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5264          }
   5265          
   5266          /**
   5267            * @brief  Return the TIM One Pulse Mode handle state.
   5268            * @param  htim TIM OPM handle
   5269            * @retval HAL state
   5270            */

   \                                 In section .text, align 2, keep-with-next
   5271          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   5272          {
   5273            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \        0x0   0x2139             MOVS     R1,#+57
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5274          }
   5275          
   5276          /**
   5277            * @brief  Return the TIM Encoder Mode handle state.
   5278            * @param  htim TIM Encoder Interface handle
   5279            * @retval HAL state
   5280            */

   \                                 In section .text, align 2, keep-with-next
   5281          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   5282          {
   5283            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \        0x0   0x2139             MOVS     R1,#+57
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5284          }
   5285          
   5286          /**
   5287            * @}
   5288            */
   5289          
   5290          /**
   5291            * @}
   5292            */
   5293          
   5294          /** @defgroup TIM_Private_Functions TIM Private Functions
   5295            * @{
   5296            */
   5297          
   5298          /**
   5299            * @brief  TIM DMA error callback
   5300            * @param  hdma pointer to DMA handle.
   5301            * @retval None
   5302            */

   \                                 In section .text, align 2, keep-with-next
   5303          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   5304          {
   \                     TIM_DMAError: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   5305            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   5306          
   5307            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x5481             STRB     R1,[R0, R2]
   5308          
   5309          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5310            htim->ErrorCallback(htim);
   5311          #else
   5312            HAL_TIM_ErrorCallback(htim);
   \        0xA   0x....'....        BL       HAL_TIM_ErrorCallback
   5313          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5314          }
   \        0xE   0xBD01             POP      {R0,PC}          ;; return
   5315          
   5316          /**
   5317            * @brief  TIM DMA Delay Pulse complete callback.
   5318            * @param  hdma pointer to DMA handle.
   5319            * @retval None
   5320            */

   \                                 In section .text, align 2, keep-with-next
   5321          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   5322          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5323            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A84             LDR      R4,[R0, #+40]
   5324          
   5325            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x54A1             STRB     R1,[R4, R2]
   5326          
   5327            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xA   0x6A22             LDR      R2,[R4, #+32]
   \        0xC   0x4290             CMP      R0,R2
   \        0xE   0xD101             BNE      ??TIM_DMADelayPulseCplt_0
   5328            {
   5329              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x10   0x7621             STRB     R1,[R4, #+24]
   \       0x12   0xE00E             B        ??TIM_DMADelayPulseCplt_1
   5330            }
   5331            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \       0x14   0x6A61             LDR      R1,[R4, #+36]
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD101             BNE      ??TIM_DMADelayPulseCplt_2
   5332            {
   5333              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE008             B        ??TIM_DMADelayPulseCplt_3
   5334            }
   5335            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseCplt_2: (+1)
   \       0x1E   0x6AA1             LDR      R1,[R4, #+40]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE      ??TIM_DMADelayPulseCplt_4
   5336            {
   5337              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x24   0x2004             MOVS     R0,#+4
   \       0x26   0xE003             B        ??TIM_DMADelayPulseCplt_3
   5338            }
   5339            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseCplt_4: (+1)
   \       0x28   0x6AE1             LDR      R1,[R4, #+44]
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD101             BNE      ??TIM_DMADelayPulseCplt_1
   5340            {
   5341              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x2E   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMADelayPulseCplt_3: (+1)
   \       0x30   0x7620             STRB     R0,[R4, #+24]
   5342            }
   5343            else
   5344            {
   5345              /* nothing to do */
   5346            }
   5347          
   5348          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5349            htim->PWM_PulseFinishedCallback(htim);
   5350          #else
   5351            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   5352          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5353          
   5354            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x7620             STRB     R0,[R4, #+24]
   5355          }
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
   5356          
   5357          /**
   5358            * @brief  TIM DMA Delay Pulse half complete callback.
   5359            * @param  hdma pointer to DMA handle.
   5360            * @retval None
   5361            */

   \                                 In section .text, align 2, keep-with-next
   5362          void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
   5363          {
   \                     TIM_DMADelayPulseHalfCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5364            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A84             LDR      R4,[R0, #+40]
   5365          
   5366            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x54A1             STRB     R1,[R4, R2]
   5367          
   5368            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xA   0x6A22             LDR      R2,[R4, #+32]
   \        0xC   0x4290             CMP      R0,R2
   \        0xE   0xD101             BNE      ??TIM_DMADelayPulseHalfCplt_0
   5369            {
   5370              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x10   0x7621             STRB     R1,[R4, #+24]
   \       0x12   0xE00E             B        ??TIM_DMADelayPulseHalfCplt_1
   5371            }
   5372            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseHalfCplt_0: (+1)
   \       0x14   0x6A61             LDR      R1,[R4, #+36]
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD101             BNE      ??TIM_DMADelayPulseHalfCplt_2
   5373            {
   5374              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE008             B        ??TIM_DMADelayPulseHalfCplt_3
   5375            }
   5376            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseHalfCplt_2: (+1)
   \       0x1E   0x6AA1             LDR      R1,[R4, #+40]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE      ??TIM_DMADelayPulseHalfCplt_4
   5377            {
   5378              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x24   0x2004             MOVS     R0,#+4
   \       0x26   0xE003             B        ??TIM_DMADelayPulseHalfCplt_3
   5379            }
   5380            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseHalfCplt_4: (+1)
   \       0x28   0x6AE1             LDR      R1,[R4, #+44]
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD101             BNE      ??TIM_DMADelayPulseHalfCplt_1
   5381            {
   5382              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x2E   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMADelayPulseHalfCplt_3: (+1)
   \       0x30   0x7620             STRB     R0,[R4, #+24]
   5383            }
   5384            else
   5385            {
   5386              /* nothing to do */
   5387            }
   5388          
   5389          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5390            htim->PWM_PulseFinishedHalfCpltCallback(htim);
   5391          #else
   5392            HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
   \                     ??TIM_DMADelayPulseHalfCplt_1: (+1)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x....'....        BL       HAL_TIM_PWM_PulseFinishedHalfCpltCallback
   5393          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5394          
   5395            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x7620             STRB     R0,[R4, #+24]
   5396          }
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
   5397          
   5398          /**
   5399            * @brief  TIM DMA Capture complete callback.
   5400            * @param  hdma pointer to DMA handle.
   5401            * @retval None
   5402            */

   \                                 In section .text, align 2, keep-with-next
   5403          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   5404          {
   \                     TIM_DMACaptureCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5405            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A84             LDR      R4,[R0, #+40]
   5406          
   5407            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x54A1             STRB     R1,[R4, R2]
   5408          
   5409            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xA   0x6A22             LDR      R2,[R4, #+32]
   \        0xC   0x4290             CMP      R0,R2
   \        0xE   0xD101             BNE      ??TIM_DMACaptureCplt_0
   5410            {
   5411              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x10   0x7621             STRB     R1,[R4, #+24]
   \       0x12   0xE00E             B        ??TIM_DMACaptureCplt_1
   5412            }
   5413            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \       0x14   0x6A61             LDR      R1,[R4, #+36]
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD101             BNE      ??TIM_DMACaptureCplt_2
   5414            {
   5415              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE008             B        ??TIM_DMACaptureCplt_3
   5416            }
   5417            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureCplt_2: (+1)
   \       0x1E   0x6AA1             LDR      R1,[R4, #+40]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE      ??TIM_DMACaptureCplt_4
   5418            {
   5419              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x24   0x2004             MOVS     R0,#+4
   \       0x26   0xE003             B        ??TIM_DMACaptureCplt_3
   5420            }
   5421            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureCplt_4: (+1)
   \       0x28   0x6AE1             LDR      R1,[R4, #+44]
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD101             BNE      ??TIM_DMACaptureCplt_1
   5422            {
   5423              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x2E   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMACaptureCplt_3: (+1)
   \       0x30   0x7620             STRB     R0,[R4, #+24]
   5424            }
   5425            else
   5426            {
   5427              /* nothing to do */
   5428            }
   5429          
   5430          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5431            htim->IC_CaptureCallback(htim);
   5432          #else
   5433            HAL_TIM_IC_CaptureCallback(htim);
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   5434          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5435          
   5436            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x7620             STRB     R0,[R4, #+24]
   5437          }
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
   5438          
   5439          /**
   5440            * @brief  TIM DMA Capture half complete callback.
   5441            * @param  hdma pointer to DMA handle.
   5442            * @retval None
   5443            */

   \                                 In section .text, align 2, keep-with-next
   5444          void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
   5445          {
   \                     TIM_DMACaptureHalfCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5446            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A84             LDR      R4,[R0, #+40]
   5447          
   5448            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x54A1             STRB     R1,[R4, R2]
   5449          
   5450            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xA   0x6A22             LDR      R2,[R4, #+32]
   \        0xC   0x4290             CMP      R0,R2
   \        0xE   0xD101             BNE      ??TIM_DMACaptureHalfCplt_0
   5451            {
   5452              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x10   0x7621             STRB     R1,[R4, #+24]
   \       0x12   0xE00E             B        ??TIM_DMACaptureHalfCplt_1
   5453            }
   5454            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureHalfCplt_0: (+1)
   \       0x14   0x6A61             LDR      R1,[R4, #+36]
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD101             BNE      ??TIM_DMACaptureHalfCplt_2
   5455            {
   5456              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE008             B        ??TIM_DMACaptureHalfCplt_3
   5457            }
   5458            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureHalfCplt_2: (+1)
   \       0x1E   0x6AA1             LDR      R1,[R4, #+40]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE      ??TIM_DMACaptureHalfCplt_4
   5459            {
   5460              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x24   0x2004             MOVS     R0,#+4
   \       0x26   0xE003             B        ??TIM_DMACaptureHalfCplt_3
   5461            }
   5462            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureHalfCplt_4: (+1)
   \       0x28   0x6AE1             LDR      R1,[R4, #+44]
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD101             BNE      ??TIM_DMACaptureHalfCplt_1
   5463            {
   5464              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x2E   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMACaptureHalfCplt_3: (+1)
   \       0x30   0x7620             STRB     R0,[R4, #+24]
   5465            }
   5466            else
   5467            {
   5468              /* nothing to do */
   5469            }
   5470          
   5471          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5472            htim->IC_CaptureHalfCpltCallback(htim);
   5473          #else
   5474            HAL_TIM_IC_CaptureHalfCpltCallback(htim);
   \                     ??TIM_DMACaptureHalfCplt_1: (+1)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x....'....        BL       HAL_TIM_IC_CaptureHalfCpltCallback
   5475          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5476          
   5477            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x7620             STRB     R0,[R4, #+24]
   5478          }
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
   5479          
   5480          /**
   5481            * @brief  TIM DMA Period Elapse complete callback.
   5482            * @param  hdma pointer to DMA handle.
   5483            * @retval None
   5484            */

   \                                 In section .text, align 2, keep-with-next
   5485          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   5486          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   5487            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   5488          
   5489            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x5481             STRB     R1,[R0, R2]
   5490          
   5491          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5492            htim->PeriodElapsedCallback(htim);
   5493          #else
   5494            HAL_TIM_PeriodElapsedCallback(htim);
   \        0xA   0x....'....        BL       HAL_TIM_PeriodElapsedCallback
   5495          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5496          }
   \        0xE   0xBD01             POP      {R0,PC}          ;; return
   5497          
   5498          /**
   5499            * @brief  TIM DMA Period Elapse half complete callback.
   5500            * @param  hdma pointer to DMA handle.
   5501            * @retval None
   5502            */

   \                                 In section .text, align 2, keep-with-next
   5503          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
   5504          {
   \                     TIM_DMAPeriodElapsedHalfCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   5505            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   5506          
   5507            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x5481             STRB     R1,[R0, R2]
   5508          
   5509          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5510            htim->PeriodElapsedHalfCpltCallback(htim);
   5511          #else
   5512            HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
   \        0xA   0x....'....        BL       HAL_TIM_PeriodElapsedHalfCpltCallback
   5513          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5514          }
   \        0xE   0xBD01             POP      {R0,PC}          ;; return
   5515          
   5516          /**
   5517            * @brief  TIM DMA Trigger callback.
   5518            * @param  hdma pointer to DMA handle.
   5519            * @retval None
   5520            */

   \                                 In section .text, align 2, keep-with-next
   5521          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   5522          {
   \                     TIM_DMATriggerCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   5523            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   5524          
   5525            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x5481             STRB     R1,[R0, R2]
   5526          
   5527          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5528            htim->TriggerCallback(htim);
   5529          #else
   5530            HAL_TIM_TriggerCallback(htim);
   \        0xA   0x....'....        BL       HAL_TIM_TriggerCallback
   5531          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5532          }
   \        0xE   0xBD01             POP      {R0,PC}          ;; return
   5533          
   5534          /**
   5535            * @brief  TIM DMA Trigger half complete callback.
   5536            * @param  hdma pointer to DMA handle.
   5537            * @retval None
   5538            */

   \                                 In section .text, align 2, keep-with-next
   5539          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
   5540          {
   \                     TIM_DMATriggerHalfCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   5541            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   5542          
   5543            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2239             MOVS     R2,#+57
   \        0x8   0x5481             STRB     R1,[R0, R2]
   5544          
   5545          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5546            htim->TriggerHalfCpltCallback(htim);
   5547          #else
   5548            HAL_TIM_TriggerHalfCpltCallback(htim);
   \        0xA   0x....'....        BL       HAL_TIM_TriggerHalfCpltCallback
   5549          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5550          }
   \        0xE   0xBD01             POP      {R0,PC}          ;; return
   5551          
   5552          /**
   5553            * @brief  Time Base configuration
   5554            * @param  TIMx TIM peripheral
   5555            * @param  Structure TIM Base configuration structure
   5556            * @retval None
   5557            */

   \                                 In section .text, align 2, keep-with-next
   5558          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   5559          {
   \                     TIM_Base_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   5560            uint32_t tmpcr1;
   5561            tmpcr1 = TIMx->CR1;
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   5562          
   5563            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   5564            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \        0x4   0x....             LDR      R3,??DataTable35  ;; 0x40011400
   \        0x6   0x....             LDR      R4,??DataTable35_1  ;; 0x40010800
   \        0x8   0x2580             MOVS     R5,#+128
   \        0xA   0x05ED             LSLS     R5,R5,#+23       ;; #+1073741824
   \        0xC   0x42A8             CMP      R0,R5
   \        0xE   0xD003             BEQ      ??TIM_Base_SetConfig_0
   \       0x10   0x42A0             CMP      R0,R4
   \       0x12   0xD001             BEQ      ??TIM_Base_SetConfig_0
   \       0x14   0x4298             CMP      R0,R3
   \       0x16   0xD108             BNE      ??TIM_Base_SetConfig_1
   5565            {
   5566              /* Select the Counter Mode */
   5567              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   5568              tmpcr1 |= Structure->CounterMode;
   \                     ??TIM_Base_SetConfig_0: (+1)
   \       0x18   0x2670             MOVS     R6,#+112
   \       0x1A   0x43B2             BICS     R2,R2,R6
   \       0x1C   0x0016             MOVS     R6,R2
   \       0x1E   0x684A             LDR      R2,[R1, #+4]
   \       0x20   0x4332             ORRS     R2,R2,R6
   5569            }
   5570          
   5571            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \       0x22   0x42A8             CMP      R0,R5
   \       0x24   0xD003             BEQ      ??TIM_Base_SetConfig_2
   \       0x26   0x42A0             CMP      R0,R4
   \       0x28   0xD001             BEQ      ??TIM_Base_SetConfig_2
   \                     ??TIM_Base_SetConfig_1: (+1)
   \       0x2A   0x4298             CMP      R0,R3
   \       0x2C   0xD103             BNE      ??TIM_Base_SetConfig_3
   5572            {
   5573              /* Set the clock division */
   5574              tmpcr1 &= ~TIM_CR1_CKD;
   5575              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \       0x2E   0x....             LDR      R3,??DataTable35_2  ;; 0xfffffcff
   \       0x30   0x4013             ANDS     R3,R3,R2
   \       0x32   0x68CA             LDR      R2,[R1, #+12]
   \       0x34   0x431A             ORRS     R2,R2,R3
   5576            }
   5577          
   5578            /* Set the auto-reload preload */
   5579            MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   5580          
   5581            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_3: (+1)
   \       0x36   0x2380             MOVS     R3,#+128
   \       0x38   0x439A             BICS     R2,R2,R3
   \       0x3A   0x690B             LDR      R3,[R1, #+16]
   \       0x3C   0x4313             ORRS     R3,R3,R2
   \       0x3E   0x6003             STR      R3,[R0, #+0]
   5582          
   5583            /* Set the Autoreload value */
   5584            TIMx->ARR = (uint32_t)Structure->Period ;
   \       0x40   0x688A             LDR      R2,[R1, #+8]
   \       0x42   0x62C2             STR      R2,[R0, #+44]
   5585          
   5586            /* Set the Prescaler value */
   5587            TIMx->PSC = Structure->Prescaler;
   \       0x44   0x6809             LDR      R1,[R1, #+0]
   \       0x46   0x6281             STR      R1,[R0, #+40]
   5588          
   5589            /* Generate an update event to reload the Prescaler
   5590               and the repetition counter (only for advanced timer) value immediately */
   5591            TIMx->EGR = TIM_EGR_UG;
   \       0x48   0x2101             MOVS     R1,#+1
   \       0x4A   0x6141             STR      R1,[R0, #+20]
   5592          }
   \       0x4C   0xBD70             POP      {R4-R6,PC}       ;; return
   5593          
   5594          /**
   5595            * @brief  Timer Output Compare 1 configuration
   5596            * @param  TIMx to select the TIM peripheral
   5597            * @param  OC_Config The ouput configuration structure
   5598            * @retval None
   5599            */

   \                                 In section .text, align 2, keep-with-next
   5600          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5601          {
   \                     TIM_OC1_SetConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   5602            uint32_t tmpccmrx;
   5603            uint32_t tmpccer;
   5604            uint32_t tmpcr2;
   5605          
   5606            /* Disable the Channel 1: Reset the CC1E Bit */
   5607            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x2301             MOVS     R3,#+1
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x6202             STR      R2,[R0, #+32]
   5608          
   5609            /* Get the TIMx CCER register value */
   5610            tmpccer = TIMx->CCER;
   \        0xA   0x6A03             LDR      R3,[R0, #+32]
   5611            /* Get the TIMx CR2 register value */
   5612            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   5613          
   5614            /* Get the TIMx CCMR1 register value */
   5615            tmpccmrx = TIMx->CCMR1;
   5616          
   5617            /* Reset the Output Compare Mode Bits */
   5618            tmpccmrx &= ~TIM_CCMR1_OC1M;
   5619            tmpccmrx &= ~TIM_CCMR1_CC1S;
   5620            /* Select the Output Compare Mode */
   5621            tmpccmrx |= OC_Config->OCMode;
   \        0xE   0x6985             LDR      R5,[R0, #+24]
   \       0x10   0x2473             MOVS     R4,#+115
   \       0x12   0x43A5             BICS     R5,R5,R4
   \       0x14   0x680C             LDR      R4,[R1, #+0]
   \       0x16   0x432C             ORRS     R4,R4,R5
   5622          
   5623            /* Reset the Output Polarity level */
   5624            tmpccer &= ~TIM_CCER_CC1P;
   5625            /* Set the Output Compare Polarity */
   5626            tmpccer |= OC_Config->OCPolarity;
   \       0x18   0x2502             MOVS     R5,#+2
   \       0x1A   0x43AB             BICS     R3,R3,R5
   \       0x1C   0x688D             LDR      R5,[R1, #+8]
   \       0x1E   0x431D             ORRS     R5,R5,R3
   5627          
   5628            /* Write to TIMx CR2 */
   5629            TIMx->CR2 = tmpcr2;
   \       0x20   0x6042             STR      R2,[R0, #+4]
   5630          
   5631            /* Write to TIMx CCMR1 */
   5632            TIMx->CCMR1 = tmpccmrx;
   \       0x22   0x6184             STR      R4,[R0, #+24]
   5633          
   5634            /* Set the Capture Compare Register value */
   5635            TIMx->CCR1 = OC_Config->Pulse;
   \       0x24   0x6849             LDR      R1,[R1, #+4]
   \       0x26   0x6341             STR      R1,[R0, #+52]
   5636          
   5637            /* Write to TIMx CCER */
   5638            TIMx->CCER = tmpccer;
   \       0x28   0x6205             STR      R5,[R0, #+32]
   5639          }
   \       0x2A   0xBD30             POP      {R4,R5,PC}       ;; return
   5640          
   5641          /**
   5642            * @brief  Timer Output Compare 2 configuration
   5643            * @param  TIMx to select the TIM peripheral
   5644            * @param  OC_Config The ouput configuration structure
   5645            * @retval None
   5646            */

   \                                 In section .text, align 2, keep-with-next
   5647          static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5648          {
   \                     TIM_OC2_SetConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   5649            uint32_t tmpccmrx;
   5650            uint32_t tmpccer;
   5651            uint32_t tmpcr2;
   5652          
   5653            /* Disable the Channel 2: Reset the CC2E Bit */
   5654            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x2310             MOVS     R3,#+16
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x6202             STR      R2,[R0, #+32]
   5655          
   5656            /* Get the TIMx CCER register value */
   5657            tmpccer = TIMx->CCER;
   \        0xA   0x6A02             LDR      R2,[R0, #+32]
   5658            /* Get the TIMx CR2 register value */
   5659            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6843             LDR      R3,[R0, #+4]
   5660          
   5661            /* Get the TIMx CCMR1 register value */
   5662            tmpccmrx = TIMx->CCMR1;
   5663          
   5664            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   5665            tmpccmrx &= ~TIM_CCMR1_OC2M;
   5666            tmpccmrx &= ~TIM_CCMR1_CC2S;
   5667          
   5668            /* Select the Output Compare Mode */
   5669            tmpccmrx |= (OC_Config->OCMode << 8U);
   \        0xE   0x6984             LDR      R4,[R0, #+24]
   \       0x10   0x....             LDR      R5,??DataTable35_3  ;; 0xffff8cff
   \       0x12   0x4025             ANDS     R5,R5,R4
   \       0x14   0x680C             LDR      R4,[R1, #+0]
   \       0x16   0x0224             LSLS     R4,R4,#+8
   \       0x18   0x432C             ORRS     R4,R4,R5
   5670          
   5671            /* Reset the Output Polarity level */
   5672            tmpccer &= ~TIM_CCER_CC2P;
   5673            /* Set the Output Compare Polarity */
   5674            tmpccer |= (OC_Config->OCPolarity << 4U);
   \       0x1A   0x2520             MOVS     R5,#+32
   \       0x1C   0x43AA             BICS     R2,R2,R5
   \       0x1E   0x688D             LDR      R5,[R1, #+8]
   \       0x20   0x012D             LSLS     R5,R5,#+4
   \       0x22   0x4315             ORRS     R5,R5,R2
   5675          
   5676            /* Write to TIMx CR2 */
   5677            TIMx->CR2 = tmpcr2;
   \       0x24   0x6043             STR      R3,[R0, #+4]
   5678          
   5679            /* Write to TIMx CCMR1 */
   5680            TIMx->CCMR1 = tmpccmrx;
   \       0x26   0x6184             STR      R4,[R0, #+24]
   5681          
   5682            /* Set the Capture Compare Register value */
   5683            TIMx->CCR2 = OC_Config->Pulse;
   \       0x28   0x6849             LDR      R1,[R1, #+4]
   \       0x2A   0x6381             STR      R1,[R0, #+56]
   5684          
   5685            /* Write to TIMx CCER */
   5686            TIMx->CCER = tmpccer;
   \       0x2C   0x6205             STR      R5,[R0, #+32]
   5687          }
   \       0x2E   0xBD30             POP      {R4,R5,PC}       ;; return
   5688          
   5689          /**
   5690            * @brief  Timer Output Compare 3 configuration
   5691            * @param  TIMx to select the TIM peripheral
   5692            * @param  OC_Config The ouput configuration structure
   5693            * @retval None
   5694            */

   \                                 In section .text, align 2, keep-with-next
   5695          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5696          {
   \                     TIM_OC3_SetConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   5697            uint32_t tmpccmrx;
   5698            uint32_t tmpccer;
   5699            uint32_t tmpcr2;
   5700          
   5701            /* Disable the Channel 3: Reset the CC2E Bit */
   5702            TIMx->CCER &= ~TIM_CCER_CC3E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x....             LDR      R3,??DataTable35_4  ;; 0xfffffeff
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0x6203             STR      R3,[R0, #+32]
   5703          
   5704            /* Get the TIMx CCER register value */
   5705            tmpccer = TIMx->CCER;
   \        0xA   0x6A04             LDR      R4,[R0, #+32]
   5706            /* Get the TIMx CR2 register value */
   5707            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   5708          
   5709            /* Get the TIMx CCMR2 register value */
   5710            tmpccmrx = TIMx->CCMR2;
   5711          
   5712            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   5713            tmpccmrx &= ~TIM_CCMR2_OC3M;
   5714            tmpccmrx &= ~TIM_CCMR2_CC3S;
   5715            /* Select the Output Compare Mode */
   5716            tmpccmrx |= OC_Config->OCMode;
   \        0xE   0x69C5             LDR      R5,[R0, #+28]
   \       0x10   0x2373             MOVS     R3,#+115
   \       0x12   0x439D             BICS     R5,R5,R3
   \       0x14   0x680B             LDR      R3,[R1, #+0]
   \       0x16   0x432B             ORRS     R3,R3,R5
   5717          
   5718            /* Reset the Output Polarity level */
   5719            tmpccer &= ~TIM_CCER_CC3P;
   5720            /* Set the Output Compare Polarity */
   5721            tmpccer |= (OC_Config->OCPolarity << 8U);
   \       0x18   0x....             LDR      R5,??DataTable35_5  ;; 0xfffffdff
   \       0x1A   0x4025             ANDS     R5,R5,R4
   \       0x1C   0x688C             LDR      R4,[R1, #+8]
   \       0x1E   0x0224             LSLS     R4,R4,#+8
   \       0x20   0x432C             ORRS     R4,R4,R5
   5722          
   5723            /* Write to TIMx CR2 */
   5724            TIMx->CR2 = tmpcr2;
   \       0x22   0x6042             STR      R2,[R0, #+4]
   5725          
   5726            /* Write to TIMx CCMR2 */
   5727            TIMx->CCMR2 = tmpccmrx;
   \       0x24   0x61C3             STR      R3,[R0, #+28]
   5728          
   5729            /* Set the Capture Compare Register value */
   5730            TIMx->CCR3 = OC_Config->Pulse;
   \       0x26   0x6849             LDR      R1,[R1, #+4]
   \       0x28   0x63C1             STR      R1,[R0, #+60]
   5731          
   5732            /* Write to TIMx CCER */
   5733            TIMx->CCER = tmpccer;
   \       0x2A   0x6204             STR      R4,[R0, #+32]
   5734          }
   \       0x2C   0xBD30             POP      {R4,R5,PC}       ;; return
   5735          
   5736          /**
   5737            * @brief  Timer Output Compare 4 configuration
   5738            * @param  TIMx to select the TIM peripheral
   5739            * @param  OC_Config The ouput configuration structure
   5740            * @retval None
   5741            */

   \                                 In section .text, align 2, keep-with-next
   5742          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5743          {
   \                     TIM_OC4_SetConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   5744            uint32_t tmpccmrx;
   5745            uint32_t tmpccer;
   5746            uint32_t tmpcr2;
   5747          
   5748            /* Disable the Channel 4: Reset the CC4E Bit */
   5749            TIMx->CCER &= ~TIM_CCER_CC4E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x....             LDR      R3,??DataTable35_6  ;; 0xffffefff
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0x6203             STR      R3,[R0, #+32]
   5750          
   5751            /* Get the TIMx CCER register value */
   5752            tmpccer = TIMx->CCER;
   \        0xA   0x6A03             LDR      R3,[R0, #+32]
   5753            /* Get the TIMx CR2 register value */
   5754            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   5755          
   5756            /* Get the TIMx CCMR2 register value */
   5757            tmpccmrx = TIMx->CCMR2;
   5758          
   5759            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   5760            tmpccmrx &= ~TIM_CCMR2_OC4M;
   5761            tmpccmrx &= ~TIM_CCMR2_CC4S;
   5762          
   5763            /* Select the Output Compare Mode */
   5764            tmpccmrx |= (OC_Config->OCMode << 8U);
   \        0xE   0x69C4             LDR      R4,[R0, #+28]
   \       0x10   0x....             LDR      R5,??DataTable35_3  ;; 0xffff8cff
   \       0x12   0x4025             ANDS     R5,R5,R4
   \       0x14   0x680C             LDR      R4,[R1, #+0]
   \       0x16   0x0224             LSLS     R4,R4,#+8
   \       0x18   0x432C             ORRS     R4,R4,R5
   5765          
   5766            /* Reset the Output Polarity level */
   5767            tmpccer &= ~TIM_CCER_CC4P;
   5768            /* Set the Output Compare Polarity */
   5769            tmpccer |= (OC_Config->OCPolarity << 12U);
   \       0x1A   0x....             LDR      R5,??DataTable35_7  ;; 0xffffdfff
   \       0x1C   0x401D             ANDS     R5,R5,R3
   \       0x1E   0x688B             LDR      R3,[R1, #+8]
   \       0x20   0x031B             LSLS     R3,R3,#+12
   \       0x22   0x432B             ORRS     R3,R3,R5
   5770          
   5771            /* Write to TIMx CR2 */
   5772            TIMx->CR2 = tmpcr2;
   \       0x24   0x6042             STR      R2,[R0, #+4]
   5773          
   5774            /* Write to TIMx CCMR2 */
   5775            TIMx->CCMR2 = tmpccmrx;
   \       0x26   0x61C4             STR      R4,[R0, #+28]
   5776          
   5777            /* Set the Capture Compare Register value */
   5778            TIMx->CCR4 = OC_Config->Pulse;
   \       0x28   0x6849             LDR      R1,[R1, #+4]
   \       0x2A   0x6401             STR      R1,[R0, #+64]
   5779          
   5780            /* Write to TIMx CCER */
   5781            TIMx->CCER = tmpccer;
   \       0x2C   0x6203             STR      R3,[R0, #+32]
   5782          }
   \       0x2E   0xBD30             POP      {R4,R5,PC}       ;; return
   5783          
   5784          /**
   5785            * @brief  Slave Timer configuration function
   5786            * @param  htim TIM handle
   5787            * @param  sSlaveConfig Slave timer configuration
   5788            * @retval None
   5789            */

   \                                 In section .text, align 2, keep-with-next
   5790          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   5791                                               TIM_SlaveConfigTypeDef *sSlaveConfig)
   5792          {
   \                     TIM_SlaveTimer_SetConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5793            uint32_t tmpsmcr;
   5794            uint32_t tmpccmr1;
   5795            uint32_t tmpccer;
   5796          
   5797            /* Get the TIMx SMCR register value */
   5798            tmpsmcr = htim->Instance->SMCR;
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x6882             LDR      R2,[R0, #+8]
   5799          
   5800            /* Reset the Trigger Selection Bits */
   5801            tmpsmcr &= ~TIM_SMCR_TS;
   5802            /* Set the Input Trigger source */
   5803            tmpsmcr |= sSlaveConfig->InputTrigger;
   5804          
   5805            /* Reset the slave mode Bits */
   5806            tmpsmcr &= ~TIM_SMCR_SMS;
   5807            /* Set the slave mode */
   5808            tmpsmcr |= sSlaveConfig->SlaveMode;
   5809          
   5810            /* Write to TIMx SMCR */
   5811            htim->Instance->SMCR = tmpsmcr;
   \        0x6   0x2370             MOVS     R3,#+112
   \        0x8   0x439A             BICS     R2,R2,R3
   \        0xA   0x684B             LDR      R3,[R1, #+4]
   \        0xC   0x4313             ORRS     R3,R3,R2
   \        0xE   0x2207             MOVS     R2,#+7
   \       0x10   0x4393             BICS     R3,R3,R2
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0x431A             ORRS     R2,R2,R3
   \       0x16   0x6082             STR      R2,[R0, #+8]
   5812          
   5813            /* Configure the trigger prescaler, filter, and polarity */
   5814            switch (sSlaveConfig->InputTrigger)
   \       0x18   0x684A             LDR      R2,[R1, #+4]
   \       0x1A   0x2A40             CMP      R2,#+64
   \       0x1C   0xD00B             BEQ      ??TIM_SlaveTimer_SetConfig_0
   \       0x1E   0x2A50             CMP      R2,#+80
   \       0x20   0xD01C             BEQ      ??TIM_SlaveTimer_SetConfig_1
   \       0x22   0x2A60             CMP      R2,#+96
   \       0x24   0xD01F             BEQ      ??TIM_SlaveTimer_SetConfig_2
   \       0x26   0x2A70             CMP      R2,#+112
   \       0x28   0xD121             BNE      ??TIM_SlaveTimer_SetConfig_3
   5815            {
   5816              case TIM_TS_ETRF:
   5817              {
   5818                /* Check the parameters */
   5819                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   5820                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   5821                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5822                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5823                /* Configure the ETR Trigger source */
   5824                TIM_ETR_SetConfig(htim->Instance,
   5825                                  sSlaveConfig->TriggerPrescaler,
   5826                                  sSlaveConfig->TriggerPolarity,
   5827                                  sSlaveConfig->TriggerFilter);
   \       0x2A   0x690B             LDR      R3,[R1, #+16]
   \       0x2C   0x688A             LDR      R2,[R1, #+8]
   \       0x2E   0x68C9             LDR      R1,[R1, #+12]
   \       0x30   0x....'....        BL       TIM_ETR_SetConfig
   5828                break;
   \       0x34   0xE01B             B        ??TIM_SlaveTimer_SetConfig_3
   5829              }
   5830          
   5831              case TIM_TS_TI1F_ED:
   5832              {
   5833                /* Check the parameters */
   5834                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5835                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5836          
   5837                if(sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
   \                     ??TIM_SlaveTimer_SetConfig_0: (+1)
   \       0x36   0x680A             LDR      R2,[R1, #+0]
   \       0x38   0x2A05             CMP      R2,#+5
   \       0x3A   0xD101             BNE      ??TIM_SlaveTimer_SetConfig_4
   5838                {
   5839                  return HAL_ERROR;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xBD10             POP      {R4,PC}
   5840                }
   5841          
   5842                /* Disable the Channel 1: Reset the CC1E Bit */
   5843                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_4: (+1)
   \       0x40   0x6A02             LDR      R2,[R0, #+32]
   5844                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \       0x42   0x6A03             LDR      R3,[R0, #+32]
   \       0x44   0x2401             MOVS     R4,#+1
   \       0x46   0x43A3             BICS     R3,R3,R4
   \       0x48   0x6203             STR      R3,[R0, #+32]
   5845                tmpccmr1 = htim->Instance->CCMR1;
   \       0x4A   0x6983             LDR      R3,[R0, #+24]
   5846          
   5847                /* Set the filter */
   5848                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5849                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   5850          
   5851                /* Write to TIMx CCMR1 and CCER registers */
   5852                htim->Instance->CCMR1 = tmpccmr1;
   \       0x4C   0x24F0             MOVS     R4,#+240
   \       0x4E   0x43A3             BICS     R3,R3,R4
   \       0x50   0x6909             LDR      R1,[R1, #+16]
   \       0x52   0x0109             LSLS     R1,R1,#+4
   \       0x54   0x4319             ORRS     R1,R1,R3
   \       0x56   0x6181             STR      R1,[R0, #+24]
   5853                htim->Instance->CCER = tmpccer;
   \       0x58   0x6202             STR      R2,[R0, #+32]
   5854                break;
   \       0x5A   0xE008             B        ??TIM_SlaveTimer_SetConfig_3
   5855              }
   5856          
   5857              case TIM_TS_TI1FP1:
   5858              {
   5859                /* Check the parameters */
   5860                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5861                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5862                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5863          
   5864                /* Configure TI1 Filter and Polarity */
   5865                TIM_TI1_ConfigInputStage(htim->Instance,
   5866                                         sSlaveConfig->TriggerPolarity,
   5867                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_1: (+1)
   \       0x5C   0x690A             LDR      R2,[R1, #+16]
   \       0x5E   0x6889             LDR      R1,[R1, #+8]
   \       0x60   0x....'....        BL       TIM_TI1_ConfigInputStage
   5868                break;
   \       0x64   0xE003             B        ??TIM_SlaveTimer_SetConfig_3
   5869              }
   5870          
   5871              case TIM_TS_TI2FP2:
   5872              {
   5873                /* Check the parameters */
   5874                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5875                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5876                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5877          
   5878                /* Configure TI2 Filter and Polarity */
   5879                TIM_TI2_ConfigInputStage(htim->Instance,
   5880                                         sSlaveConfig->TriggerPolarity,
   5881                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_2: (+1)
   \       0x66   0x690A             LDR      R2,[R1, #+16]
   \       0x68   0x6889             LDR      R1,[R1, #+8]
   \       0x6A   0x....'....        BL       TIM_TI2_ConfigInputStage
   5882                break;
   5883              }
   5884          
   5885              case TIM_TS_ITR0:
   5886              case TIM_TS_ITR1:
   5887              case TIM_TS_ITR2:
   5888              case TIM_TS_ITR3:
   5889              {
   5890                /* Check the parameter */
   5891                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5892                break;
   5893              }
   5894          
   5895              default:
   5896                break;
   5897            }
   5898            return HAL_OK;
   \                     ??TIM_SlaveTimer_SetConfig_3: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xBD10             POP      {R4,PC}          ;; return
   5899          }
   5900          
   5901          /**
   5902            * @brief  Configure the TI1 as Input.
   5903            * @param  TIMx to select the TIM peripheral.
   5904            * @param  TIM_ICPolarity The Input Polarity.
   5905            *          This parameter can be one of the following values:
   5906            *            @arg TIM_ICPOLARITY_RISING
   5907            *            @arg TIM_ICPOLARITY_FALLING
   5908            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5909            * @param  TIM_ICSelection specifies the input to be used.
   5910            *          This parameter can be one of the following values:
   5911            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
   5912            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
   5913            *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
   5914            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   5915            *          This parameter must be a value between 0x00 and 0x0F.
   5916            * @retval None
   5917            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
   5918            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
   5919            *        protected against un-initialized filter and polarity values.
   5920            */

   \                                 In section .text, align 2, keep-with-next
   5921          static void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5922                                        uint32_t TIM_ICFilter)
   5923          {
   \                     TIM_TI1_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   5924            uint32_t tmpccmr1;
   5925            uint32_t tmpccer;
   5926          
   5927            /* Disable the Channel 1: Reset the CC1E Bit */
   5928            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0x2501             MOVS     R5,#+1
   \        0x6   0x43AC             BICS     R4,R4,R5
   \        0x8   0x6204             STR      R4,[R0, #+32]
   5929            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6985             LDR      R5,[R0, #+24]
   5930            tmpccer = TIMx->CCER;
   \        0xC   0x6A04             LDR      R4,[R0, #+32]
   5931          
   5932            /* Select the Input */
   5933            if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \        0xE   0x2680             MOVS     R6,#+128
   \       0x10   0x05F6             LSLS     R6,R6,#+23       ;; #+1073741824
   \       0x12   0x42B0             CMP      R0,R6
   \       0x14   0xD005             BEQ      ??TIM_TI1_SetConfig_0
   \       0x16   0x....             LDR      R6,??DataTable35_1  ;; 0x40010800
   \       0x18   0x42B0             CMP      R0,R6
   \       0x1A   0xD002             BEQ      ??TIM_TI1_SetConfig_0
   \       0x1C   0x....             LDR      R6,??DataTable35  ;; 0x40011400
   \       0x1E   0x42B0             CMP      R0,R6
   \       0x20   0xD102             BNE      ??TIM_TI1_SetConfig_1
   5934            {
   5935              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   5936              tmpccmr1 |= TIM_ICSelection;
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \       0x22   0x2603             MOVS     R6,#+3
   \       0x24   0x43B5             BICS     R5,R5,R6
   \       0x26   0xE000             B        ??TIM_TI1_SetConfig_2
   5937            }
   5938            else
   5939            {
   5940              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \       0x28   0x2201             MOVS     R2,#+1
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \       0x2A   0x432A             ORRS     R2,R2,R5
   5941            }
   5942          
   5943            /* Set the filter */
   5944            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5945            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   5946          
   5947            /* Select the Polarity and set the CC1E Bit */
   5948            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5949            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   5950          
   5951            /* Write to TIMx CCMR1 and CCER registers */
   5952            TIMx->CCMR1 = tmpccmr1;
   \       0x2C   0x25F0             MOVS     R5,#+240
   \       0x2E   0x43AA             BICS     R2,R2,R5
   \       0x30   0x011B             LSLS     R3,R3,#+4
   \       0x32   0x401D             ANDS     R5,R5,R3
   \       0x34   0x4315             ORRS     R5,R5,R2
   \       0x36   0x6185             STR      R5,[R0, #+24]
   5953            TIMx->CCER = tmpccer;
   \       0x38   0x220A             MOVS     R2,#+10
   \       0x3A   0x4394             BICS     R4,R4,R2
   \       0x3C   0x....             B.N      ?Subroutine12
   5954          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x400A             ANDS     R2,R2,R1
   \        0x2   0x4322             ORRS     R2,R2,R4
   \        0x4   0x6202             STR      R2,[R0, #+32]
   \        0x6   0xBD70             POP      {R4-R6,PC}       ;; return
   5955          
   5956          /**
   5957            * @brief  Configure the Polarity and Filter for TI1.
   5958            * @param  TIMx to select the TIM peripheral.
   5959            * @param  TIM_ICPolarity The Input Polarity.
   5960            *          This parameter can be one of the following values:
   5961            *            @arg TIM_ICPOLARITY_RISING
   5962            *            @arg TIM_ICPOLARITY_FALLING
   5963            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5964            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   5965            *          This parameter must be a value between 0x00 and 0x0F.
   5966            * @retval None
   5967            */

   \                                 In section .text, align 2, keep-with-next
   5968          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5969          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   5970            uint32_t tmpccmr1;
   5971            uint32_t tmpccer;
   5972          
   5973            /* Disable the Channel 1: Reset the CC1E Bit */
   5974            tmpccer = TIMx->CCER;
   \        0x2   0x6A03             LDR      R3,[R0, #+32]
   5975            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x4   0x6A04             LDR      R4,[R0, #+32]
   \        0x6   0x2501             MOVS     R5,#+1
   \        0x8   0x43AC             BICS     R4,R4,R5
   \        0xA   0x6204             STR      R4,[R0, #+32]
   5976            tmpccmr1 = TIMx->CCMR1;
   5977          
   5978            /* Set the filter */
   5979            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5980            tmpccmr1 |= (TIM_ICFilter << 4U);
   5981          
   5982            /* Select the Polarity and set the CC1E Bit */
   5983            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5984            tmpccer |= TIM_ICPolarity;
   5985          
   5986            /* Write to TIMx CCMR1 and CCER registers */
   5987            TIMx->CCMR1 = tmpccmr1;
   \        0xC   0x6984             LDR      R4,[R0, #+24]
   \        0xE   0x25F0             MOVS     R5,#+240
   \       0x10   0x43AC             BICS     R4,R4,R5
   \       0x12   0x0112             LSLS     R2,R2,#+4
   \       0x14   0x4322             ORRS     R2,R2,R4
   \       0x16   0x6182             STR      R2,[R0, #+24]
   5988            TIMx->CCER = tmpccer;
   \       0x18   0x220A             MOVS     R2,#+10
   \       0x1A   0x4393             BICS     R3,R3,R2
   \       0x1C   0x4319             ORRS     R1,R1,R3
   \       0x1E   0x6201             STR      R1,[R0, #+32]
   5989          }
   \       0x20   0xBD30             POP      {R4,R5,PC}       ;; return
   5990          
   5991          /**
   5992            * @brief  Configure the TI2 as Input.
   5993            * @param  TIMx to select the TIM peripheral
   5994            * @param  TIM_ICPolarity The Input Polarity.
   5995            *          This parameter can be one of the following values:
   5996            *            @arg TIM_ICPOLARITY_RISING
   5997            *            @arg TIM_ICPOLARITY_FALLING
   5998            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5999            * @param  TIM_ICSelection specifies the input to be used.
   6000            *          This parameter can be one of the following values:
   6001            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
   6002            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   6003            *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
   6004            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6005            *          This parameter must be a value between 0x00 and 0x0F.
   6006            * @retval None
   6007            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
   6008            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
   6009            *        protected against un-initialized filter and polarity values.
   6010            */

   \                                 In section .text, align 2, keep-with-next
   6011          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6012                                        uint32_t TIM_ICFilter)
   6013          {
   \                     TIM_TI2_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6014            uint32_t tmpccmr1;
   6015            uint32_t tmpccer;
   6016          
   6017            /* Disable the Channel 2: Reset the CC2E Bit */
   6018            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0x2510             MOVS     R5,#+16
   \        0x6   0x43AC             BICS     R4,R4,R5
   \        0x8   0x6204             STR      R4,[R0, #+32]
   6019            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6985             LDR      R5,[R0, #+24]
   6020            tmpccer = TIMx->CCER;
   \        0xC   0x6A04             LDR      R4,[R0, #+32]
   6021          
   6022            /* Select the Input */
   6023            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   6024            tmpccmr1 |= (TIM_ICSelection << 8U);
   6025          
   6026            /* Set the filter */
   6027            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   6028            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   6029          
   6030            /* Select the Polarity and set the CC2E Bit */
   6031            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   6032            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   6033          
   6034            /* Write to TIMx CCMR1 and CCER registers */
   6035            TIMx->CCMR1 = tmpccmr1 ;
   \        0xE   0x....             LDR      R6,??DataTable35_2  ;; 0xfffffcff
   \       0x10   0x402E             ANDS     R6,R6,R5
   \       0x12   0x0212             LSLS     R2,R2,#+8
   \       0x14   0x4332             ORRS     R2,R2,R6
   \       0x16   0x....             LDR      R5,??DataTable35_8  ;; 0xffff0fff
   \       0x18   0x4015             ANDS     R5,R5,R2
   \       0x1A   0x031A             LSLS     R2,R3,#+12
   \       0x1C   0x23F0             MOVS     R3,#+240
   \       0x1E   0x021B             LSLS     R3,R3,#+8        ;; #+61440
   \       0x20   0x4013             ANDS     R3,R3,R2
   \       0x22   0x432B             ORRS     R3,R3,R5
   \       0x24   0x6183             STR      R3,[R0, #+24]
   6036            TIMx->CCER = tmpccer;
   \       0x26   0x22A0             MOVS     R2,#+160
   \       0x28   0x4394             BICS     R4,R4,R2
   \       0x2A   0x0109             LSLS     R1,R1,#+4
   \       0x2C                      REQUIRE ?Subroutine12
   \       0x2C                      ;; // Fall through to label ?Subroutine12
   6037          }
   6038          
   6039          /**
   6040            * @brief  Configure the Polarity and Filter for TI2.
   6041            * @param  TIMx to select the TIM peripheral.
   6042            * @param  TIM_ICPolarity The Input Polarity.
   6043            *          This parameter can be one of the following values:
   6044            *            @arg TIM_ICPOLARITY_RISING
   6045            *            @arg TIM_ICPOLARITY_FALLING
   6046            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6047            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6048            *          This parameter must be a value between 0x00 and 0x0F.
   6049            * @retval None
   6050            */

   \                                 In section .text, align 2, keep-with-next
   6051          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6052          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   6053            uint32_t tmpccmr1;
   6054            uint32_t tmpccer;
   6055          
   6056            /* Disable the Channel 2: Reset the CC2E Bit */
   6057            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A03             LDR      R3,[R0, #+32]
   \        0x4   0x2410             MOVS     R4,#+16
   \        0x6   0x43A3             BICS     R3,R3,R4
   \        0x8   0x6203             STR      R3,[R0, #+32]
   6058            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6984             LDR      R4,[R0, #+24]
   6059            tmpccer = TIMx->CCER;
   \        0xC   0x6A03             LDR      R3,[R0, #+32]
   6060          
   6061            /* Set the filter */
   6062            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   6063            tmpccmr1 |= (TIM_ICFilter << 12U);
   6064          
   6065            /* Select the Polarity and set the CC2E Bit */
   6066            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   6067            tmpccer |= (TIM_ICPolarity << 4U);
   6068          
   6069            /* Write to TIMx CCMR1 and CCER registers */
   6070            TIMx->CCMR1 = tmpccmr1 ;
   \        0xE   0x....             LDR      R5,??DataTable35_8  ;; 0xffff0fff
   \       0x10   0x4025             ANDS     R5,R5,R4
   \       0x12   0x0312             LSLS     R2,R2,#+12
   \       0x14   0x432A             ORRS     R2,R2,R5
   \       0x16   0x6182             STR      R2,[R0, #+24]
   6071            TIMx->CCER = tmpccer;
   \       0x18   0x22A0             MOVS     R2,#+160
   \       0x1A   0x4393             BICS     R3,R3,R2
   \       0x1C   0x0109             LSLS     R1,R1,#+4
   \       0x1E   0x4319             ORRS     R1,R1,R3
   \       0x20   0x6201             STR      R1,[R0, #+32]
   6072          }
   \       0x22   0xBD30             POP      {R4,R5,PC}       ;; return
   6073          
   6074          /**
   6075            * @brief  Configure the TI3 as Input.
   6076            * @param  TIMx to select the TIM peripheral
   6077            * @param  TIM_ICPolarity The Input Polarity.
   6078            *          This parameter can be one of the following values:
   6079            *            @arg TIM_ICPOLARITY_RISING
   6080            *            @arg TIM_ICPOLARITY_FALLING
   6081            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6082            * @param  TIM_ICSelection specifies the input to be used.
   6083            *          This parameter can be one of the following values:
   6084            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
   6085            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   6086            *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
   6087            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6088            *          This parameter must be a value between 0x00 and 0x0F.
   6089            * @retval None
   6090            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
   6091            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6092            *        protected against un-initialized filter and polarity values.
   6093            */
   6094          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6095                                        uint32_t TIM_ICFilter)
   6096          {
   6097            uint32_t tmpccmr2;
   6098            uint32_t tmpccer;
   6099          
   6100            /* Disable the Channel 3: Reset the CC3E Bit */
   6101            TIMx->CCER &= ~TIM_CCER_CC3E;
   6102            tmpccmr2 = TIMx->CCMR2;
   6103            tmpccer = TIMx->CCER;
   6104          
   6105            /* Select the Input */
   6106            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   6107            tmpccmr2 |= TIM_ICSelection;
   6108          
   6109            /* Set the filter */
   6110            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   6111            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   6112          
   6113            /* Select the Polarity and set the CC3E Bit */
   6114            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   6115            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   6116          
   6117            /* Write to TIMx CCMR2 and CCER registers */
   6118            TIMx->CCMR2 = tmpccmr2;
   6119            TIMx->CCER = tmpccer;
   6120          }
   6121          
   6122          /**
   6123            * @brief  Configure the TI4 as Input.
   6124            * @param  TIMx to select the TIM peripheral
   6125            * @param  TIM_ICPolarity The Input Polarity.
   6126            *          This parameter can be one of the following values:
   6127            *            @arg TIM_ICPOLARITY_RISING
   6128            *            @arg TIM_ICPOLARITY_FALLING
   6129            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6130            * @param  TIM_ICSelection specifies the input to be used.
   6131            *          This parameter can be one of the following values:
   6132            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
   6133            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   6134            *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
   6135            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6136            *          This parameter must be a value between 0x00 and 0x0F.
   6137            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
   6138            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6139            *        protected against un-initialized filter and polarity values.
   6140            * @retval None
   6141            */
   6142          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6143                                        uint32_t TIM_ICFilter)
   6144          {
   6145            uint32_t tmpccmr2;
   6146            uint32_t tmpccer;
   6147          
   6148            /* Disable the Channel 4: Reset the CC4E Bit */
   6149            TIMx->CCER &= ~TIM_CCER_CC4E;
   6150            tmpccmr2 = TIMx->CCMR2;
   6151            tmpccer = TIMx->CCER;
   6152          
   6153            /* Select the Input */
   6154            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   6155            tmpccmr2 |= (TIM_ICSelection << 8U);
   6156          
   6157            /* Set the filter */
   6158            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   6159            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   6160          
   6161            /* Select the Polarity and set the CC4E Bit */
   6162            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   6163            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   6164          
   6165            /* Write to TIMx CCMR2 and CCER registers */
   6166            TIMx->CCMR2 = tmpccmr2;
   6167            TIMx->CCER = tmpccer ;
   6168          }
   6169          
   6170          /**
   6171            * @brief  Selects the Input Trigger source
   6172            * @param  TIMx to select the TIM peripheral
   6173            * @param  InputTriggerSource The Input Trigger source.
   6174            *          This parameter can be one of the following values:
   6175            *            @arg TIM_TS_ITR0: Internal Trigger 0
   6176            *            @arg TIM_TS_ITR1: Internal Trigger 1
   6177            *            @arg TIM_TS_ITR2: Internal Trigger 2
   6178            *            @arg TIM_TS_ITR3: Internal Trigger 3
   6179            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   6180            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   6181            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   6182            *            @arg TIM_TS_ETRF: External Trigger input
   6183            * @retval None
   6184            */

   \                                 In section .text, align 2, keep-with-next
   6185          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
   6186          {
   6187            uint32_t tmpsmcr;
   6188          
   6189            /* Get the TIMx SMCR register value */
   6190            tmpsmcr = TIMx->SMCR;
   6191            /* Reset the TS Bits */
   6192            tmpsmcr &= ~TIM_SMCR_TS;
   6193            /* Set the Input Trigger source and the slave mode*/
   6194            tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   6195            /* Write to TIMx SMCR */
   6196            TIMx->SMCR = tmpsmcr;
   \                     TIM_ITRx_SetConfig: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x2370             MOVS     R3,#+112
   \        0x4   0x439A             BICS     R2,R2,R3
   \        0x6   0x4311             ORRS     R1,R1,R2
   \        0x8   0x2207             MOVS     R2,#+7
   \        0xA   0x430A             ORRS     R2,R2,R1
   \        0xC   0x6082             STR      R2,[R0, #+8]
   6197          }
   \        0xE   0x4770             BX       LR               ;; return
   6198          /**
   6199            * @brief  Configures the TIMx External Trigger (ETR).
   6200            * @param  TIMx to select the TIM peripheral
   6201            * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
   6202            *          This parameter can be one of the following values:
   6203            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   6204            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   6205            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   6206            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   6207            * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
   6208            *          This parameter can be one of the following values:
   6209            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   6210            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   6211            * @param  ExtTRGFilter External Trigger Filter.
   6212            *          This parameter must be a value between 0x00 and 0x0F
   6213            * @retval None
   6214            */

   \                                 In section .text, align 2, keep-with-next
   6215          static void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
   6216                                        uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   6217          {
   \                     TIM_ETR_SetConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   6218            uint32_t tmpsmcr;
   6219          
   6220            tmpsmcr = TIMx->SMCR;
   6221          
   6222            /* Reset the ETR Bits */
   6223            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   6224          
   6225            /* Set the Prescaler, the Filter value and the Polarity */
   6226            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   6227          
   6228            /* Write to TIMx SMCR */
   6229            TIMx->SMCR = tmpsmcr;
   \        0x2   0x6884             LDR      R4,[R0, #+8]
   \        0x4   0x....             LDR      R5,??DataTable35_9  ;; 0xffff00ff
   \        0x6   0x4025             ANDS     R5,R5,R4
   \        0x8   0x4329             ORRS     R1,R1,R5
   \        0xA   0x430A             ORRS     R2,R2,R1
   \        0xC   0x0219             LSLS     R1,R3,#+8
   \        0xE   0x4311             ORRS     R1,R1,R2
   \       0x10   0x6081             STR      R1,[R0, #+8]
   6230          }
   \       0x12   0xBD30             POP      {R4,R5,PC}       ;; return
   6231          
   6232          /**
   6233            * @brief  Enables or disables the TIM Capture Compare Channel x.
   6234            * @param  TIMx to select the TIM peripheral
   6235            * @param  Channel specifies the TIM Channel
   6236            *          This parameter can be one of the following values:
   6237            *            @arg TIM_CHANNEL_1: TIM Channel 1
   6238            *            @arg TIM_CHANNEL_2: TIM Channel 2
   6239            *            @arg TIM_CHANNEL_3: TIM Channel 3
   6240            *            @arg TIM_CHANNEL_4: TIM Channel 4
   6241            * @param  ChannelState specifies the TIM Channel CCxE bit new state.
   6242            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
   6243            * @retval None
   6244            */

   \                                 In section .text, align 2, keep-with-next
   6245          static void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
   6246          {
   \                     TIM_CCxChannelCmd: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6247            uint32_t tmp;
   6248          
   6249            /* Check the parameters */
   6250            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   6251            assert_param(IS_TIM_CHANNELS(Channel));
   6252          
   6253            tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   6254          
   6255            /* Reset the CCxE Bit */
   6256            TIMx->CCER &= ~tmp;
   \        0x2   0x06C9             LSLS     R1,R1,#+27
   \        0x4   0x0EC9             LSRS     R1,R1,#+27
   \        0x6   0x6A03             LDR      R3,[R0, #+32]
   \        0x8   0x2401             MOVS     R4,#+1
   \        0xA   0x408C             LSLS     R4,R4,R1
   \        0xC   0x43A3             BICS     R3,R3,R4
   \        0xE   0x6203             STR      R3,[R0, #+32]
   6257          
   6258            /* Set or reset the CCxE Bit */
   6259            TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   \       0x10   0x6A03             LDR      R3,[R0, #+32]
   \       0x12   0x408A             LSLS     R2,R2,R1
   \       0x14   0x431A             ORRS     R2,R2,R3
   \       0x16   0x6202             STR      R2,[R0, #+32]
   6260          }
   \       0x18   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0xFFFF'BFF8        DC32     0xffffbff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0xFFFF'FCFC        DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0xFFFF'0303        DC32     0xffff0303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0xFFFF'F3FF        DC32     0xfffff3ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0xFFFF'F5FF        DC32     0xfffff5ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \        0x0   0xFFFF'FCFF        DC32     0xfffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \        0x0   0xFFFF'0FFF        DC32     0xffff0fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0xFFFF'5FFF        DC32     0xffff5fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x....'....        DC32     TIM_DMATriggerCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x....'....        DC32     TIM_DMATriggerHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0xFFFF'00FF        DC32     0xffff00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \        0x0   0xFFFF'0088        DC32     0xffff0088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0xFFFF'BFFF        DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \        0x0   0x4001'1400        DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \        0x0   0x4001'0800        DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \        0x0   0xFFFF'FCFF        DC32     0xfffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \        0x0   0xFFFF'8CFF        DC32     0xffff8cff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_5:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_6:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_7:
   \        0x0   0xFFFF'DFFF        DC32     0xffffdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_8:
   \        0x0   0xFFFF'0FFF        DC32     0xffff0fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_9:
   \        0x0   0xFFFF'00FF        DC32     0xffff00ff
   6261          
   6262          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6263          /**
   6264            * @brief  Reset interrupt callbacks to the legacy weak callbacks.
   6265            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   6266            *                the configuration information for TIM module.
   6267            * @retval None
   6268            */
   6269          void TIM_ResetCallback(TIM_HandleTypeDef *htim)
   6270          {
   6271            /* Reset the TIM callback to the legacy weak callbacks */
   6272            htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak PeriodElapsedCallback             */
   6273            htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak PeriodElapsedHalfCpltCallback     */
   6274            htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak TriggerCallback                   */
   6275            htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak TriggerHalfCpltCallback           */
   6276            htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC_CaptureCallback                */
   6277            htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC_CaptureHalfCpltCallback        */
   6278            htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC_DelayElapsedCallback           */
   6279            htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM_PulseFinishedCallback         */
   6280            htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM_PulseFinishedHalfCpltCallback */
   6281            htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak ErrorCallback                     */
   6282          }
   6283          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6284          
   6285          /**
   6286            * @}
   6287            */
   6288          
   6289          #endif /* HAL_TIM_MODULE_ENABLED */
   6290          /**
   6291            * @}
   6292            */
   6293          
   6294          /**
   6295            * @}
   6296            */
   6297          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
       8   HAL_TIM_Base_Start_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       8   HAL_TIM_Base_Stop_DMA
         8   -> HAL_DMA_Abort_IT
       0   HAL_TIM_Base_Stop_IT
      16   HAL_TIM_ConfigClockSource
        16   -> TIM_ETR_SetConfig
        16   -> TIM_ITRx_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      24   HAL_TIM_ConfigOCrefClear
        24   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      32   HAL_TIM_DMABurst_ReadStart
        32   -> HAL_DMA_Start_IT
       0   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort_IT
      32   HAL_TIM_DMABurst_WriteStart
        32   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort_IT
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      24   HAL_TIM_Encoder_Init
        24   -> HAL_TIM_Encoder_MspInit
        24   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
       8   HAL_TIM_Encoder_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
      12   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
       0   HAL_TIM_IC_CaptureHalfCpltCallback
      32   HAL_TIM_IC_ConfigChannel
        32   -> TIM_TI1_SetConfig
        32   -> TIM_TI2_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
       8   HAL_TIM_IC_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_IC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_IT
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_IRQHandler
        24   -> HAL_TIM_IC_CaptureCallback
        24   -> HAL_TIM_OC_DelayElapsedCallback
        24   -> HAL_TIM_PWM_PulseFinishedCallback
        24   -> HAL_TIM_PeriodElapsedCallback
        24   -> HAL_TIM_TriggerCallback
      16   HAL_TIM_OC_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
       8   HAL_TIM_OC_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop_IT
         8   -> TIM_CCxChannelCmd
      40   HAL_TIM_OnePulse_ConfigChannel
        40   -> TIM_OC1_SetConfig
        40   -> TIM_OC2_SetConfig
        40   -> TIM_TI1_SetConfig
        40   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
       8   HAL_TIM_OnePulse_Start
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop_IT
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_ConfigChannel
        24   -> TIM_OC1_SetConfig
        24   -> TIM_OC2_SetConfig
        24   -> TIM_OC3_SetConfig
        24   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       0   HAL_TIM_PWM_PulseFinishedHalfCpltCallback
       8   HAL_TIM_PWM_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       0   HAL_TIM_PWM_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PWM_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_PWM_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_PeriodElapsedHalfCpltCallback
       0   HAL_TIM_ReadCapturedValue
      24   HAL_TIM_SlaveConfigSynchro
        24   -> TIM_SlaveTimer_SetConfig
      24   HAL_TIM_SlaveConfigSynchro_IT
        24   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       0   HAL_TIM_TriggerHalfCpltCallback
      16   TIM_Base_SetConfig
       8   TIM_CCxChannelCmd
       8   TIM_DMACaptureCplt
         8   -> HAL_TIM_IC_CaptureCallback
       8   TIM_DMACaptureHalfCplt
         8   -> HAL_TIM_IC_CaptureHalfCpltCallback
       8   TIM_DMADelayPulseCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       8   TIM_DMADelayPulseHalfCplt
         8   -> HAL_TIM_PWM_PulseFinishedHalfCpltCallback
       8   TIM_DMAError
         8   -> HAL_TIM_ErrorCallback
       8   TIM_DMAPeriodElapsedCplt
         8   -> HAL_TIM_PeriodElapsedCallback
       8   TIM_DMAPeriodElapsedHalfCplt
         8   -> HAL_TIM_PeriodElapsedHalfCpltCallback
       8   TIM_DMATriggerCplt
         8   -> HAL_TIM_TriggerCallback
       8   TIM_DMATriggerHalfCplt
         8   -> HAL_TIM_TriggerHalfCpltCallback
      12   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
      12   TIM_OC1_SetConfig
      12   TIM_OC2_SetConfig
      12   TIM_OC3_SetConfig
      12   TIM_OC4_SetConfig
       8   TIM_SlaveTimer_SetConfig
         8   -> TIM_ETR_SetConfig
         8   -> TIM_TI1_ConfigInputStage
         8   -> TIM_TI2_ConfigInputStage
      12   TIM_TI1_ConfigInputStage
      16   TIM_TI1_SetConfig
      12   TIM_TI2_ConfigInputStage
      16   TIM_TI2_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable31
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable35_3
       4  ??DataTable35_4
       4  ??DataTable35_5
       4  ??DataTable35_6
       4  ??DataTable35_7
       4  ??DataTable35_8
       4  ??DataTable35_9
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
      86  ?Subroutine0
      84  ?Subroutine1
      32  ?Subroutine10
      10  ?Subroutine11
       8  ?Subroutine12
      32  ?Subroutine2
      18  ?Subroutine3
      12  ?Subroutine4
       8  ?Subroutine5
      20  ?Subroutine6
      10  ?Subroutine7
     120  ?Subroutine8
      86  ?Subroutine9
      40  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      44  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      32  HAL_TIM_Base_Start
     112  HAL_TIM_Base_Start_DMA
      30  HAL_TIM_Base_Start_IT
      30  HAL_TIM_Base_Stop
      22  HAL_TIM_Base_Stop_DMA
      30  HAL_TIM_Base_Stop_IT
     176  HAL_TIM_ConfigClockSource
     230  HAL_TIM_ConfigOCrefClear
      16  HAL_TIM_ConfigTI1Input
     286  HAL_TIM_DMABurst_ReadStart
       2  HAL_TIM_DMABurst_ReadStop
     286  HAL_TIM_DMABurst_WriteStart
       4  HAL_TIM_DMABurst_WriteStop
      40  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     142  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      50  HAL_TIM_Encoder_Start
     314  HAL_TIM_Encoder_Start_DMA
      96  HAL_TIM_Encoder_Start_IT
      32  HAL_TIM_Encoder_Stop
      98  HAL_TIM_Encoder_Stop_DMA
      82  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      40  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
       2  HAL_TIM_IC_CaptureHalfCpltCallback
     286  HAL_TIM_IC_ConfigChannel
      40  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      44  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
       6  HAL_TIM_IC_Start
     246  HAL_TIM_IC_Start_DMA
       4  HAL_TIM_IC_Start_IT
       6  HAL_TIM_IC_Stop
       4  HAL_TIM_IC_Stop_DMA
       4  HAL_TIM_IC_Stop_IT
     282  HAL_TIM_IRQHandler
      80  HAL_TIM_OC_ConfigChannel
      38  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      44  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
       6  HAL_TIM_OC_Start
     250  HAL_TIM_OC_Start_DMA
       4  HAL_TIM_OC_Start_IT
       6  HAL_TIM_OC_Stop
       4  HAL_TIM_OC_Stop_DMA
       4  HAL_TIM_OC_Stop_IT
     212  HAL_TIM_OnePulse_ConfigChannel
      40  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      66  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      12  HAL_TIM_OnePulse_Start
      26  HAL_TIM_OnePulse_Start_IT
      20  HAL_TIM_OnePulse_Stop
      36  HAL_TIM_OnePulse_Stop_IT
     204  HAL_TIM_PWM_ConfigChannel
      40  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      44  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
       2  HAL_TIM_PWM_PulseFinishedHalfCpltCallback
       6  HAL_TIM_PWM_Start
     250  HAL_TIM_PWM_Start_DMA
       2  HAL_TIM_PWM_Start_IT
      12  HAL_TIM_PWM_Stop
       2  HAL_TIM_PWM_Stop_DMA
       2  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
       2  HAL_TIM_PeriodElapsedHalfCpltCallback
      46  HAL_TIM_ReadCapturedValue
      56  HAL_TIM_SlaveConfigSynchro
      56  HAL_TIM_SlaveConfigSynchro_IT
       2  HAL_TIM_TriggerCallback
       2  HAL_TIM_TriggerHalfCpltCallback
      78  TIM_Base_SetConfig
      26  TIM_CCxChannelCmd
      62  TIM_DMACaptureCplt
      62  TIM_DMACaptureHalfCplt
      62  TIM_DMADelayPulseCplt
      62  TIM_DMADelayPulseHalfCplt
      16  TIM_DMAError
      16  TIM_DMAPeriodElapsedCplt
      16  TIM_DMAPeriodElapsedHalfCplt
      16  TIM_DMATriggerCplt
      16  TIM_DMATriggerHalfCplt
      20  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
      44  TIM_OC1_SetConfig
      48  TIM_OC2_SetConfig
      46  TIM_OC3_SetConfig
      48  TIM_OC4_SetConfig
     114  TIM_SlaveTimer_SetConfig
      34  TIM_TI1_ConfigInputStage
      62  TIM_TI1_SetConfig
      36  TIM_TI2_ConfigInputStage
      44  TIM_TI2_SetConfig

 
 6'510 bytes in section .text
 
 6'466 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: none
