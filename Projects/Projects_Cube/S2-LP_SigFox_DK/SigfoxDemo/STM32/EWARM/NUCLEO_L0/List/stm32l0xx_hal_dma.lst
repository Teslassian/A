###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  12:25:24
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_dma.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW6C9A.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_dma.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal_dma.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal_dma.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_dma.c
      4            * @author  MCD Application Team
      5            * @brief   DMA HAL module driver.
      6            *         This file provides firmware functions to manage the following
      7            *         functionalities of the Direct Memory Access (DMA) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral State and errors functions
     11            @verbatim
     12            ==============================================================================
     13                                  ##### How to use this driver #####
     14            ==============================================================================
     15            [..]
     16             (#) Enable and configure the peripheral to be connected to the DMA Channel
     17                 (except for internal SRAM / FLASH memories: no initialization is
     18                 necessary).
     19          
     20             (#) For a given Channel, program the required configuration through the following parameters:
     21                 Channel request, Transfer Direction, Source and Destination data formats,
     22                 Circular or Normal mode, Channel Priority level, Source and Destination Increment mode
     23                 using HAL_DMA_Init() function.
     24          
     25             (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error
     26                 detection.
     27          
     28             (#) Use HAL_DMA_Abort() function to abort the current transfer
     29          
     30               -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.
     31          
     32               *** Polling mode IO operation ***
     33               =================================
     34              [..]
     35                    (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source
     36                        address and destination address and the Length of data to be transferred
     37                    (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this
     38                        case a fixed Timeout can be configured by User depending from his application.
     39          
     40               *** Interrupt mode IO operation ***
     41               ===================================
     42              [..]
     43                    (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
     44                    (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()
     45                    (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of
     46                        Source address and destination address and the Length of data to be transferred.
     47                        In this case the DMA interrupt is configured
     48                    (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
     49                    (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can
     50                        add his own function to register callbacks with HAL_DMA_RegisterCallback().
     51          
     52               *** DMA HAL driver macros list ***
     53               =============================================
     54                [..]
     55                 Below the list of macros in DMA HAL driver.
     56          
     57                 (+) __HAL_DMA_ENABLE: Enable the specified DMA Channel.
     58                 (+) __HAL_DMA_DISABLE: Disable the specified DMA Channel.
     59                 (+) __HAL_DMA_GET_FLAG: Get the DMA Channel pending flags.
     60                 (+) __HAL_DMA_CLEAR_FLAG: Clear the DMA Channel pending flags.
     61                 (+) __HAL_DMA_ENABLE_IT: Enable the specified DMA Channel interrupts.
     62                 (+) __HAL_DMA_DISABLE_IT: Disable the specified DMA Channel interrupts.
     63                 (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Channel interrupt has occurred or not.
     64          
     65               [..]
     66                (@) You can refer to the DMA HAL driver header file for more useful macros
     67          
     68            @endverbatim
     69            ******************************************************************************
     70            * @attention
     71            *
     72            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics.
     73            * All rights reserved.</center></h2>
     74            *
     75            * This software component is licensed by ST under BSD 3-Clause license,
     76            * the "License"; You may not use this file except in compliance with the
     77            * License. You may obtain a copy of the License at:
     78            *                        opensource.org/licenses/BSD-3-Clause
     79            *
     80            ******************************************************************************
     81            */
     82          
     83          /* Includes ------------------------------------------------------------------*/
     84          #include "stm32l0xx_hal.h"
     85          
     86          /** @addtogroup STM32L0xx_HAL_Driver
     87            * @{
     88            */
     89          
     90          /** @defgroup DMA DMA
     91            * @brief DMA HAL module driver
     92            * @{
     93            */
     94          
     95          #ifdef HAL_DMA_MODULE_ENABLED
     96          
     97          /* Private typedef -----------------------------------------------------------*/
     98          /** @defgroup DMA_Private_Functions DMA Private Functions
     99            * @{
    100            */
    101          
    102          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
    103          /**
    104            * @}
    105            */
    106          
    107          /* Exported functions ---------------------------------------------------------*/
    108          
    109          /** @defgroup DMA_Exported_Functions DMA Exported Functions
    110            * @{
    111            */
    112          
    113          /** @defgroup DMA_Exported_Functions_Group1 Initialization and de-initialization functions
    114           *  @brief   Initialization and de-initialization functions
    115           *
    116          @verbatim
    117           ===============================================================================
    118                       ##### Initialization and de-initialization functions  #####
    119           ===============================================================================
    120              [..]
    121              This section provides functions allowing to initialize the DMA Channel source
    122              and destination addresses, incrementation and data sizes, transfer direction,
    123              circular/normal mode selection, memory-to-memory mode selection and Channel priority value.
    124              [..]
    125              The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    126              reference manual.
    127          
    128          @endverbatim
    129            * @{
    130            */
    131          
    132          /**
    133            * @brief  Initialize the DMA according to the specified
    134            *         parameters in the DMA_InitTypeDef and initialize the associated handle.
    135            * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
    136            *               the configuration information for the specified DMA Channel.
    137            * @retval HAL status
    138            */

   \                                 In section .text, align 2, keep-with-next
    139          HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
    140          {
   \                     HAL_DMA_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    141            uint32_t tmp;
    142          
    143            /* Check the DMA handle allocation */
    144            if(hdma == NULL)
   \        0x4   0xD101             BNE      ??HAL_DMA_Init_0
    145            {
    146              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD70             POP      {R4-R6,PC}
    147            }
    148          
    149            /* Check the parameters */
    150            assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    151            assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));
    152            assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    153            assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    154            assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    155            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    156            assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    157            assert_param(IS_DMA_MODE(hdma->Init.Mode));
    158            assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    159          
    160            /* Compute the channel index */
    161            /* Only one DMA: DMA1 */
    162            hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
   \                     ??HAL_DMA_Init_0: (+1)
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....             LDR      R1,??DataTable1  ;; 0xbffdfff8
   \        0xE   0x1840             ADDS     R0,R0,R1
   \       0x10   0x2114             MOVS     R1,#+20
   \       0x12   0x....'....        BL       __aeabi_uidiv
   \       0x16   0x0080             LSLS     R0,R0,#+2
   \       0x18   0x6460             STR      R0,[R4, #+68]
    163            hdma->DmaBaseAddress = DMA1;
   \       0x1A   0x....             LDR      R0,??DataTable1_1  ;; 0x40020000
   \       0x1C   0x6420             STR      R0,[R4, #+64]
    164          
    165            /* Change DMA peripheral state */
    166            hdma->State = HAL_DMA_STATE_BUSY;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x2125             MOVS     R1,#+37
   \       0x22   0x5460             STRB     R0,[R4, R1]
    167          
    168            /* Get the CR register value */
    169            tmp = hdma->Instance->CCR;
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6800             LDR      R0,[R0, #+0]
    170          
    171            /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
    172            tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
    173                                DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
    174                                DMA_CCR_DIR   | DMA_CCR_MEM2MEM));
    175          
    176            /* Prepare the DMA Channel configuration */
    177            tmp |=  hdma->Init.Direction        |
    178                    hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    179                    hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    180                    hdma->Init.Mode                | hdma->Init.Priority;
    181          
    182            /* Write to DMA Channel CR register */
    183            hdma->Instance->CCR = tmp;
   \       0x28   0x....             LDR      R1,??DataTable1_2  ;; 0xffff800f
   \       0x2A   0x4001             ANDS     R1,R1,R0
   \       0x2C   0x68A0             LDR      R0,[R4, #+8]
   \       0x2E   0x4308             ORRS     R0,R0,R1
   \       0x30   0x68E1             LDR      R1,[R4, #+12]
   \       0x32   0x4301             ORRS     R1,R1,R0
   \       0x34   0x6920             LDR      R0,[R4, #+16]
   \       0x36   0x4308             ORRS     R0,R0,R1
   \       0x38   0x6961             LDR      R1,[R4, #+20]
   \       0x3A   0x4301             ORRS     R1,R1,R0
   \       0x3C   0x69A0             LDR      R0,[R4, #+24]
   \       0x3E   0x4308             ORRS     R0,R0,R1
   \       0x40   0x69E1             LDR      R1,[R4, #+28]
   \       0x42   0x4301             ORRS     R1,R1,R0
   \       0x44   0x6A20             LDR      R0,[R4, #+32]
   \       0x46   0x4308             ORRS     R0,R0,R1
   \       0x48   0x6821             LDR      R1,[R4, #+0]
   \       0x4A   0x6008             STR      R0,[R1, #+0]
    184          
    185            /* Set request selection */
    186            if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
   \       0x4C   0x68A0             LDR      R0,[R4, #+8]
   \       0x4E   0x2180             MOVS     R1,#+128
   \       0x50   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \       0x52   0x4288             CMP      R0,R1
   \       0x54   0xD010             BEQ      ??HAL_DMA_Init_1
    187            {
    188              /* Write to DMA channel selection register */
    189              /* Reset request selection for DMA1 Channelx */
    190              DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
   \       0x56   0x....             LDR      R0,??DataTable1_3  ;; 0x400200a8
   \       0x58   0x211C             MOVS     R1,#+28
   \       0x5A   0x6802             LDR      R2,[R0, #+0]
   \       0x5C   0x230F             MOVS     R3,#+15
   \       0x5E   0x6C65             LDR      R5,[R4, #+68]
   \       0x60   0x261C             MOVS     R6,#+28
   \       0x62   0x402E             ANDS     R6,R6,R5
   \       0x64   0x40B3             LSLS     R3,R3,R6
   \       0x66   0x439A             BICS     R2,R2,R3
   \       0x68   0x6002             STR      R2,[R0, #+0]
    191          
    192              /* Configure request selection for DMA1 Channelx */
    193              DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
   \       0x6A   0x6802             LDR      R2,[R0, #+0]
   \       0x6C   0x6863             LDR      R3,[R4, #+4]
   \       0x6E   0x6C65             LDR      R5,[R4, #+68]
   \       0x70   0x4029             ANDS     R1,R1,R5
   \       0x72   0x408B             LSLS     R3,R3,R1
   \       0x74   0x4313             ORRS     R3,R3,R2
   \       0x76   0x6003             STR      R3,[R0, #+0]
    194            }
    195          
    196            /* Initialise the error code */
    197            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \                     ??HAL_DMA_Init_1: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x63E0             STR      R0,[R4, #+60]
    198          
    199            /* Initialize the DMA state*/
    200            hdma->State  = HAL_DMA_STATE_READY;
   \       0x7C   0x2101             MOVS     R1,#+1
   \       0x7E   0x2225             MOVS     R2,#+37
   \       0x80   0x54A1             STRB     R1,[R4, R2]
    201          
    202            /* Allocate lock resource and initialize it */
    203            hdma->Lock = HAL_UNLOCKED;
   \       0x82   0x2124             MOVS     R1,#+36
   \       0x84   0x5460             STRB     R0,[R4, R1]
    204          
    205            return HAL_OK;
   \       0x86   0xBD70             POP      {R4-R6,PC}       ;; return
    206          }
    207          
    208          /**
    209            * @brief  DeInitialize the DMA peripheral.
    210            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    211            *               the configuration information for the specified DMA Channel.
    212            * @retval HAL status
    213            */

   \                                 In section .text, align 2, keep-with-next
    214          HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
    215          {
   \                     HAL_DMA_DeInit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    216          
    217            /* Check the DMA handle allocation */
    218            if (NULL == hdma )
   \        0x4   0xD101             BNE      ??HAL_DMA_DeInit_0
    219            {
    220              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD70             POP      {R4-R6,PC}
    221            }
    222          
    223            /* Check the parameters */
    224            assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    225          
    226            /* Disable the selected DMA Channelx */
    227            __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_DeInit_0: (+1)
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x4391             BICS     R1,R1,R2
   \       0x12   0x6001             STR      R1,[R0, #+0]
    228          
    229            /* Compute the channel index */
    230            /* DMA1 */
    231            hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x....             LDR      R1,??DataTable1  ;; 0xbffdfff8
   \       0x18   0x1840             ADDS     R0,R0,R1
   \       0x1A   0x2114             MOVS     R1,#+20
   \       0x1C   0x....'....        BL       __aeabi_uidiv
   \       0x20   0x0080             LSLS     R0,R0,#+2
   \       0x22   0x6460             STR      R0,[R4, #+68]
    232            hdma->DmaBaseAddress = DMA1;
   \       0x24   0x....             LDR      R0,??DataTable1_1  ;; 0x40020000
   \       0x26   0x6420             STR      R0,[R4, #+64]
    233          
    234            /* Reset DMA Channel control register */
    235            hdma->Instance->CCR  = 0U;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    236          
    237            /* Clear all flags */
    238            hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
   \       0x2E   0x211C             MOVS     R1,#+28
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x6C63             LDR      R3,[R4, #+68]
   \       0x34   0x400B             ANDS     R3,R3,R1
   \       0x36   0x409A             LSLS     R2,R2,R3
   \       0x38   0x6C23             LDR      R3,[R4, #+64]
   \       0x3A   0x605A             STR      R2,[R3, #+4]
    239          
    240            /* Reset DMA channel selection register */
    241            /* DMA1 */
    242            DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
   \       0x3C   0x....             LDR      R2,??DataTable1_3  ;; 0x400200a8
   \       0x3E   0x6813             LDR      R3,[R2, #+0]
   \       0x40   0x250F             MOVS     R5,#+15
   \       0x42   0x6C66             LDR      R6,[R4, #+68]
   \       0x44   0x4031             ANDS     R1,R1,R6
   \       0x46   0x408D             LSLS     R5,R5,R1
   \       0x48   0x43AB             BICS     R3,R3,R5
   \       0x4A   0x6013             STR      R3,[R2, #+0]
    243          
    244            /* Clean callbacks */
    245            hdma->XferCpltCallback = NULL;
   \       0x4C   0x62E0             STR      R0,[R4, #+44]
    246            hdma->XferHalfCpltCallback = NULL;
   \       0x4E   0x6320             STR      R0,[R4, #+48]
    247            hdma->XferErrorCallback = NULL;
   \       0x50   0x6360             STR      R0,[R4, #+52]
    248            hdma->XferAbortCallback = NULL;
   \       0x52   0x63A0             STR      R0,[R4, #+56]
    249          
    250            /* Initialise the error code */
    251            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \       0x54   0x63E0             STR      R0,[R4, #+60]
    252          
    253            /* Initialize the DMA state */
    254            hdma->State = HAL_DMA_STATE_RESET;
   \       0x56   0x2225             MOVS     R2,#+37
   \       0x58   0x54A0             STRB     R0,[R4, R2]
    255          
    256            /* Release Lock */
    257            __HAL_UNLOCK(hdma);
   \       0x5A   0x2124             MOVS     R1,#+36
   \       0x5C   0x5460             STRB     R0,[R4, R1]
    258          
    259            return HAL_OK;
   \       0x5E   0xBD70             POP      {R4-R6,PC}       ;; return
    260          }
    261          
    262          /**
    263            * @}
    264            */
    265          
    266          /** @defgroup DMA_Exported_Functions_Group2 Input and Output operation functions
    267           *  @brief   Input and Output operation functions
    268           *
    269          @verbatim
    270           ===============================================================================
    271                                #####  IO operation functions  #####
    272           ===============================================================================
    273              [..]  This section provides functions allowing to:
    274                (+) Configure the source, destination address and data length and Start DMA transfer
    275                (+) Configure the source, destination address and data length and
    276                    Start DMA transfer with interrupt
    277                (+) Abort DMA transfer
    278                (+) Poll for transfer complete
    279                (+) Handle DMA interrupt request
    280          
    281          @endverbatim
    282            * @{
    283            */
    284          
    285          /**
    286            * @brief  Start the DMA Transfer.
    287            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    288            *               the configuration information for the specified DMA Channel.
    289            * @param  SrcAddress The source memory Buffer address
    290            * @param  DstAddress The destination memory Buffer address
    291            * @param  DataLength The length of data to be transferred from source to destination
    292            * @retval HAL status
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    295          {
   \                     HAL_DMA_Start: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    296            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x2500             MOVS     R5,#+0
    297          
    298            /* Check the parameters */
    299            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    300          
    301            /* Process locked */
    302            __HAL_LOCK(hdma);
   \        0x8   0x2624             MOVS     R6,#+36
   \        0xA   0x5DA6             LDRB     R6,[R4, R6]
   \        0xC   0x2E01             CMP      R6,#+1
   \        0xE   0xD101             BNE      ??HAL_DMA_Start_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_DMA_Start_0: (+1)
   \       0x14   0x2601             MOVS     R6,#+1
   \       0x16   0x2724             MOVS     R7,#+36
   \       0x18   0x55E6             STRB     R6,[R4, R7]
    303          
    304            if(HAL_DMA_STATE_READY == hdma->State)
   \       0x1A   0x2602             MOVS     R6,#+2
   \       0x1C   0x2725             MOVS     R7,#+37
   \       0x1E   0x5DE7             LDRB     R7,[R4, R7]
   \       0x20   0x2F01             CMP      R7,#+1
   \       0x22   0xD110             BNE      ??HAL_DMA_Start_1
    305            {
    306              /* Change DMA peripheral state */
    307              hdma->State = HAL_DMA_STATE_BUSY;
   \       0x24   0x2725             MOVS     R7,#+37
   \       0x26   0x55E6             STRB     R6,[R4, R7]
    308              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \       0x28   0x63E0             STR      R0,[R4, #+60]
    309          
    310              /* Disable the peripheral */
    311              __HAL_DMA_DISABLE(hdma);
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x6806             LDR      R6,[R0, #+0]
   \       0x2E   0x2701             MOVS     R7,#+1
   \       0x30   0x43BE             BICS     R6,R6,R7
   \       0x32   0x6006             STR      R6,[R0, #+0]
    312          
    313              /* Configure the source, destination address and the data length & clear flags*/
    314              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       DMA_SetConfig
    315          
    316              /* Enable the Peripheral */
    317              __HAL_DMA_ENABLE(hdma);
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x2201             MOVS     R2,#+1
   \       0x40   0x430A             ORRS     R2,R2,R1
   \       0x42   0x6002             STR      R2,[R0, #+0]
   \       0x44   0xE002             B        ??HAL_DMA_Start_2
    318            }
    319            else
    320            {
    321              /* Process Unlocked */
    322              __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Start_1: (+1)
   \       0x46   0x2124             MOVS     R1,#+36
   \       0x48   0x5460             STRB     R0,[R4, R1]
    323              status = HAL_BUSY;
   \       0x4A   0x2502             MOVS     R5,#+2
    324            }
    325            return status;
   \                     ??HAL_DMA_Start_2: (+1)
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    326          }
    327          
    328          /**
    329            * @brief  Start the DMA Transfer with interrupt enabled.
    330            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    331            *               the configuration information for the specified DMA Channel.
    332            * @param  SrcAddress The source memory Buffer address
    333            * @param  DstAddress The destination memory Buffer address
    334            * @param  DataLength The length of data to be transferred from source to destination
    335            * @retval HAL status
    336            */

   \                                 In section .text, align 2, keep-with-next
    337          HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    338          {
   \                     HAL_DMA_Start_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    339            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x2500             MOVS     R5,#+0
    340          
    341            /* Check the parameters */
    342            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    343          
    344            /* Process locked */
    345            __HAL_LOCK(hdma);
   \        0x8   0x2624             MOVS     R6,#+36
   \        0xA   0x5DA6             LDRB     R6,[R4, R6]
   \        0xC   0x2E01             CMP      R6,#+1
   \        0xE   0xD101             BNE      ??HAL_DMA_Start_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_DMA_Start_IT_0: (+1)
   \       0x14   0x2601             MOVS     R6,#+1
   \       0x16   0x2724             MOVS     R7,#+36
   \       0x18   0x55E6             STRB     R6,[R4, R7]
    346          
    347            if(HAL_DMA_STATE_READY == hdma->State)
   \       0x1A   0x2602             MOVS     R6,#+2
   \       0x1C   0x2725             MOVS     R7,#+37
   \       0x1E   0x5DE7             LDRB     R7,[R4, R7]
   \       0x20   0x2F01             CMP      R7,#+1
   \       0x22   0xD11F             BNE      ??HAL_DMA_Start_IT_1
    348            {
    349              /* Change DMA peripheral state */
    350              hdma->State = HAL_DMA_STATE_BUSY;
   \       0x24   0x2725             MOVS     R7,#+37
   \       0x26   0x55E6             STRB     R6,[R4, R7]
    351              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \       0x28   0x63E0             STR      R0,[R4, #+60]
    352          
    353              /* Disable the peripheral */
    354              __HAL_DMA_DISABLE(hdma);
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x6806             LDR      R6,[R0, #+0]
   \       0x2E   0x2701             MOVS     R7,#+1
   \       0x30   0x43BE             BICS     R6,R6,R7
   \       0x32   0x6006             STR      R6,[R0, #+0]
    355          
    356              /* Configure the source, destination address and the data length & clear flags*/
    357              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       DMA_SetConfig
    358          
    359              /* Enable the transfer complete interrupt */
    360              /* Enable the transfer Error interrupt */
    361              if(NULL != hdma->XferHalfCpltCallback )
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6B21             LDR      R1,[R4, #+48]
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0xD001             BEQ      ??HAL_DMA_Start_IT_2
    362              {
    363                /* Enable the Half transfer complete interrupt as well */
    364                __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
   \       0x44   0x220E             MOVS     R2,#+14
   \       0x46   0xE005             B        ??HAL_DMA_Start_IT_3
    365              }
    366              else
    367              {
    368                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
   \                     ??HAL_DMA_Start_IT_2: (+1)
   \       0x48   0x2204             MOVS     R2,#+4
   \       0x4A   0x4391             BICS     R1,R1,R2
   \       0x4C   0x6001             STR      R1,[R0, #+0]
    369                __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0x220A             MOVS     R2,#+10
   \                     ??HAL_DMA_Start_IT_3: (+1)
   \       0x54   0x430A             ORRS     R2,R2,R1
   \       0x56   0x6002             STR      R2,[R0, #+0]
    370              }
    371          
    372              /* Enable the Peripheral */
    373              __HAL_DMA_ENABLE(hdma);
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6801             LDR      R1,[R0, #+0]
   \       0x5C   0x2201             MOVS     R2,#+1
   \       0x5E   0x430A             ORRS     R2,R2,R1
   \       0x60   0x6002             STR      R2,[R0, #+0]
   \       0x62   0xE002             B        ??HAL_DMA_Start_IT_4
    374            }
    375            else
    376            {
    377              /* Process Unlocked */
    378              __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Start_IT_1: (+1)
   \       0x64   0x2124             MOVS     R1,#+36
   \       0x66   0x5460             STRB     R0,[R4, R1]
    379          
    380              /* Remain BUSY */
    381              status = HAL_BUSY;
   \       0x68   0x2502             MOVS     R5,#+2
    382            }
    383            return status;
   \                     ??HAL_DMA_Start_IT_4: (+1)
   \       0x6A   0x0028             MOVS     R0,R5
   \       0x6C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    384          }
    385          
    386          /**
    387            * @brief  Abort the DMA Transfer.
    388            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    389            *               the configuration information for the specified DMA Channel.
    390              * @retval HAL status
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
    393          {
   \                     HAL_DMA_Abort: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    394            HAL_StatusTypeDef status = HAL_OK;
    395          
    396            /* Check the DMA peripheral state */
    397            if(hdma->State != HAL_DMA_STATE_BUSY)
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0x3124             ADDS     R1,R1,#+36
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2325             MOVS     R3,#+37
   \        0xA   0x5CC3             LDRB     R3,[R0, R3]
   \        0xC   0x2B02             CMP      R3,#+2
   \        0xE   0xD004             BEQ      ??HAL_DMA_Abort_0
    398            {
    399              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \       0x10   0x2304             MOVS     R3,#+4
   \       0x12   0x63C3             STR      R3,[R0, #+60]
    400          
    401              /* Process Unlocked */
    402              __HAL_UNLOCK(hdma);
   \       0x14   0x700A             STRB     R2,[R1, #+0]
    403          
    404              return HAL_ERROR;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD30             POP      {R4,R5,PC}
    405            }
    406            else
    407            {
    408              /* Disable DMA IT */
    409              __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
   \                     ??HAL_DMA_Abort_0: (+1)
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0x681C             LDR      R4,[R3, #+0]
   \       0x1E   0x250E             MOVS     R5,#+14
   \       0x20   0x43AC             BICS     R4,R4,R5
   \       0x22   0x601C             STR      R4,[R3, #+0]
    410          
    411              /* Disable the channel */
    412              __HAL_DMA_DISABLE(hdma);
   \       0x24   0x6803             LDR      R3,[R0, #+0]
   \       0x26   0x681C             LDR      R4,[R3, #+0]
   \       0x28   0x2501             MOVS     R5,#+1
   \       0x2A   0x43AC             BICS     R4,R4,R5
   \       0x2C   0x601C             STR      R4,[R3, #+0]
    413          
    414              /* Clear all flags */
    415              hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
   \       0x2E   0x2301             MOVS     R3,#+1
   \       0x30   0x2444             MOVS     R4,#+68
   \       0x32   0x5D04             LDRB     R4,[R0, R4]
   \       0x34   0x251C             MOVS     R5,#+28
   \       0x36   0x4025             ANDS     R5,R5,R4
   \       0x38   0x2401             MOVS     R4,#+1
   \       0x3A   0x40AC             LSLS     R4,R4,R5
   \       0x3C   0x6C05             LDR      R5,[R0, #+64]
   \       0x3E   0x606C             STR      R4,[R5, #+4]
    416          
    417              /* Change the DMA state */
    418              hdma->State = HAL_DMA_STATE_READY;
   \       0x40   0x2425             MOVS     R4,#+37
   \       0x42   0x5503             STRB     R3,[R0, R4]
    419          
    420              /* Process Unlocked */
    421              __HAL_UNLOCK(hdma);
   \       0x44   0x700A             STRB     R2,[R1, #+0]
    422          
    423              return status;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xBD30             POP      {R4,R5,PC}       ;; return
    424            }
    425          }
    426          
    427          /**
    428            * @brief  Aborts the DMA Transfer in Interrupt mode.
    429            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    430            *                 the configuration information for the specified DMA Channel.
    431            * @retval HAL status
    432            */

   \                                 In section .text, align 2, keep-with-next
    433          HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
    434          {
   \                     HAL_DMA_Abort_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    435            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2400             MOVS     R4,#+0
    436          
    437            if(HAL_DMA_STATE_BUSY != hdma->State)
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x2325             MOVS     R3,#+37
   \        0xA   0x5CC3             LDRB     R3,[R0, R3]
   \        0xC   0x2B02             CMP      R3,#+2
   \        0xE   0xD003             BEQ      ??HAL_DMA_Abort_IT_0
    438            {
    439              /* no transfer ongoing */
    440              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \       0x10   0x2204             MOVS     R2,#+4
   \       0x12   0x63C2             STR      R2,[R0, #+60]
    441          
    442              status = HAL_ERROR;
   \       0x14   0x2401             MOVS     R4,#+1
   \       0x16   0xE018             B        ??HAL_DMA_Abort_IT_1
    443            }
    444            else
    445            {
    446              /* Disable DMA IT */
    447              __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
   \                     ??HAL_DMA_Abort_IT_0: (+1)
   \       0x18   0x6803             LDR      R3,[R0, #+0]
   \       0x1A   0x681D             LDR      R5,[R3, #+0]
   \       0x1C   0x260E             MOVS     R6,#+14
   \       0x1E   0x43B5             BICS     R5,R5,R6
   \       0x20   0x601D             STR      R5,[R3, #+0]
    448          
    449              /* Disable the channel */
    450              __HAL_DMA_DISABLE(hdma);
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0x681D             LDR      R5,[R3, #+0]
   \       0x26   0x438D             BICS     R5,R5,R1
   \       0x28   0x601D             STR      R5,[R3, #+0]
    451          
    452              /* Clear all flags */
    453              hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
   \       0x2A   0x2344             MOVS     R3,#+68
   \       0x2C   0x5CC3             LDRB     R3,[R0, R3]
   \       0x2E   0x251C             MOVS     R5,#+28
   \       0x30   0x401D             ANDS     R5,R5,R3
   \       0x32   0x2301             MOVS     R3,#+1
   \       0x34   0x40AB             LSLS     R3,R3,R5
   \       0x36   0x6C05             LDR      R5,[R0, #+64]
   \       0x38   0x606B             STR      R3,[R5, #+4]
    454          
    455              /* Change the DMA state */
    456              hdma->State = HAL_DMA_STATE_READY;
   \       0x3A   0x2325             MOVS     R3,#+37
   \       0x3C   0x54C1             STRB     R1,[R0, R3]
    457          
    458              /* Process Unlocked */
    459              __HAL_UNLOCK(hdma);
   \       0x3E   0x2124             MOVS     R1,#+36
   \       0x40   0x5442             STRB     R2,[R0, R1]
    460          
    461              /* Call User Abort callback */
    462              if(hdma->XferAbortCallback != NULL)
   \       0x42   0x6B81             LDR      R1,[R0, #+56]
   \       0x44   0x2900             CMP      R1,#+0
   \       0x46   0xD000             BEQ      ??HAL_DMA_Abort_IT_1
    463              {
    464                hdma->XferAbortCallback(hdma);
   \       0x48   0x4788             BLX      R1
    465              }
    466            }
    467            return status;
   \                     ??HAL_DMA_Abort_IT_1: (+1)
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0xBD70             POP      {R4-R6,PC}       ;; return
    468          }
    469          
    470          /**
    471            * @brief  Polling for transfer complete.
    472            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    473            *                  the configuration information for the specified DMA Channel.
    474            * @param  CompleteLevel Specifies the DMA level complete.
    475            * @param  Timeout       Timeout duration.
    476            * @retval HAL status
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
    479          {
   \                     HAL_DMA_PollForTransfer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0015             MOVS     R5,R2
    480            uint32_t temp;
    481            uint32_t tickstart;
    482          
    483            if(HAL_DMA_STATE_BUSY != hdma->State)
   \        0x6   0x2025             MOVS     R0,#+37
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD002             BEQ      ??HAL_DMA_PollForTransfer_0
    484            {
    485              /* no transfer ongoing */
    486              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \        0xE   0x2004             MOVS     R0,#+4
   \       0x10   0x63E0             STR      R0,[R4, #+60]
    487              __HAL_UNLOCK(hdma);
   \       0x12   0xE03E             B.N      ??HAL_DMA_PollForTransfer_1
    488              return HAL_ERROR;
    489            }
    490          
    491            /* Polling mode not supported in circular mode */
    492            if (0U != (hdma->Instance->CCR & DMA_CCR_CIRC))
   \                     ??HAL_DMA_PollForTransfer_0: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x0680             LSLS     R0,R0,#+26
   \       0x1A   0xD503             BPL      ??HAL_DMA_PollForTransfer_2
    493            {
    494              hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
   \       0x1C   0x2080             MOVS     R0,#+128
   \       0x1E   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \       0x20   0x63E0             STR      R0,[R4, #+60]
    495              return HAL_ERROR;
   \       0x22   0xE039             B.N      ??HAL_DMA_PollForTransfer_3
    496            }
   \                     ??HAL_DMA_PollForTransfer_2: (+1)
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x7001             STRB     R1,[R0, #+0]
    497          
    498            /* Get the level transfer complete flag */
    499            if (HAL_DMA_FULL_TRANSFER == CompleteLevel)
   \       0x28   0x2044             MOVS     R0,#+68
   \       0x2A   0x5C21             LDRB     R1,[R4, R0]
   \       0x2C   0x201C             MOVS     R0,#+28
   \       0x2E   0x4008             ANDS     R0,R0,R1
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x7809             LDRB     R1,[R1, #+0]
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD101             BNE      ??HAL_DMA_PollForTransfer_4
    500            {
    501              /* Transfer Complete flag */
    502              temp = DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU);
   \       0x38   0x2702             MOVS     R7,#+2
   \       0x3A   0xE000             B        ??HAL_DMA_PollForTransfer_5
    503            }
    504            else
    505            {
    506              /* Half Transfer Complete flag */
    507              temp = DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU);
   \                     ??HAL_DMA_PollForTransfer_4: (+1)
   \       0x3C   0x2704             MOVS     R7,#+4
   \                     ??HAL_DMA_PollForTransfer_5: (+1)
   \       0x3E   0x4087             LSLS     R7,R7,R0
    508            }
    509          
    510            /* Get tick */
    511            tickstart = HAL_GetTick();
   \       0x40   0x....'....        BL       HAL_GetTick
   \       0x44   0x0006             MOVS     R6,R0
    512          
    513            while(0U == (hdma->DmaBaseAddress->ISR & temp))
   \                     ??HAL_DMA_PollForTransfer_6: (+1)
   \       0x46   0x2044             MOVS     R0,#+68
   \       0x48   0x5C21             LDRB     R1,[R4, R0]
   \       0x4A   0x201C             MOVS     R0,#+28
   \       0x4C   0x4008             ANDS     R0,R0,R1
   \       0x4E   0x6C21             LDR      R1,[R4, #+64]
   \       0x50   0x680A             LDR      R2,[R1, #+0]
   \       0x52   0x403A             ANDS     R2,R2,R7
   \       0x54   0xD122             BNE      ??HAL_DMA_PollForTransfer_7
    514            {
    515              if((0U != (hdma->DmaBaseAddress->ISR & (DMA_FLAG_TE1 << (hdma->ChannelIndex& 0x1cU)))))
   \       0x56   0x6809             LDR      R1,[R1, #+0]
   \       0x58   0x2208             MOVS     R2,#+8
   \       0x5A   0x4082             LSLS     R2,R2,R0
   \       0x5C   0x400A             ANDS     R2,R2,R1
   \       0x5E   0xD008             BEQ      ??HAL_DMA_PollForTransfer_8
    516              {
    517                /* When a DMA transfer error occurs */
    518                /* A hardware clear of its EN bits is performed */
    519                /* Clear all flags */
    520                hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
   \       0x60   0x2101             MOVS     R1,#+1
   \       0x62   0x2201             MOVS     R2,#+1
   \       0x64   0x4082             LSLS     R2,R2,R0
   \       0x66   0x6C20             LDR      R0,[R4, #+64]
   \       0x68   0x6042             STR      R2,[R0, #+4]
    521          
    522                /* Update error code */
    523                hdma->ErrorCode = HAL_DMA_ERROR_TE;
   \       0x6A   0x63E1             STR      R1,[R4, #+60]
    524          
    525                /* Change the DMA state */
    526                hdma->State= HAL_DMA_STATE_READY;
   \       0x6C   0x2025             MOVS     R0,#+37
   \       0x6E   0x5421             STRB     R1,[R4, R0]
    527          
    528                /* Process Unlocked */
    529                __HAL_UNLOCK(hdma);
   \       0x70   0xE00F             B.N      ??HAL_DMA_PollForTransfer_1
    530          
    531                return HAL_ERROR;
    532              }
    533              /* Check for the Timeout */
    534              if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA_PollForTransfer_8: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x76   0x4285             CMP      R5,R0
   \       0x78   0xD0E5             BEQ      ??HAL_DMA_PollForTransfer_6
    535              {
    536                if(((HAL_GetTick() - tickstart) > Timeout) ||  (Timeout == 0U))
   \       0x7A   0x....'....        BL       HAL_GetTick
   \       0x7E   0x1B80             SUBS     R0,R0,R6
   \       0x80   0x4285             CMP      R5,R0
   \       0x82   0xD301             BCC      ??HAL_DMA_PollForTransfer_9
   \       0x84   0x2D00             CMP      R5,#+0
   \       0x86   0xD1DE             BNE      ??HAL_DMA_PollForTransfer_6
    537                {
    538                  /* Update error code */
    539                  hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
   \                     ??HAL_DMA_PollForTransfer_9: (+1)
   \       0x88   0x2020             MOVS     R0,#+32
   \       0x8A   0x63E0             STR      R0,[R4, #+60]
    540          
    541                  /* Change the DMA state */
    542                  hdma->State = HAL_DMA_STATE_READY;
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0x2125             MOVS     R1,#+37
   \       0x90   0x5460             STRB     R0,[R4, R1]
    543          
    544                  /* Process Unlocked */
    545                  __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_PollForTransfer_1: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x2124             MOVS     R1,#+36
   \       0x96   0x5460             STRB     R0,[R4, R1]
    546          
    547                  return HAL_ERROR;
   \                     ??HAL_DMA_PollForTransfer_3: (+1)
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0xBDF2             POP      {R1,R4-R7,PC}
    548                }
    549              }
    550            }
    551          
    552            if(HAL_DMA_FULL_TRANSFER == CompleteLevel)
   \                     ??HAL_DMA_PollForTransfer_7: (+1)
   \       0x9C   0x4669             MOV      R1,SP
   \       0x9E   0x7809             LDRB     R1,[R1, #+0]
   \       0xA0   0x2900             CMP      R1,#+0
   \       0xA2   0xD107             BNE      ??HAL_DMA_PollForTransfer_10
    553            {
    554              /* Clear the transfer complete flag */
    555              hdma->DmaBaseAddress->IFCR = (DMA_FLAG_TC1 << (hdma->ChannelIndex& 0x1cU));
   \       0xA4   0x2102             MOVS     R1,#+2
   \       0xA6   0x4081             LSLS     R1,R1,R0
   \       0xA8   0x6C20             LDR      R0,[R4, #+64]
   \       0xAA   0x6041             STR      R1,[R0, #+4]
    556          
    557              /* The selected Channelx EN bit is cleared (DMA is disabled and
    558              all transfers are complete) */
    559              hdma->State = HAL_DMA_STATE_READY;
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0x2125             MOVS     R1,#+37
   \       0xB0   0x5460             STRB     R0,[R4, R1]
   \       0xB2   0xE003             B        ??HAL_DMA_PollForTransfer_11
    560            }
    561            else
    562            {
    563              /* Clear the half transfer complete flag */
    564              hdma->DmaBaseAddress->IFCR = (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU));
   \                     ??HAL_DMA_PollForTransfer_10: (+1)
   \       0xB4   0x2104             MOVS     R1,#+4
   \       0xB6   0x4081             LSLS     R1,R1,R0
   \       0xB8   0x6C20             LDR      R0,[R4, #+64]
   \       0xBA   0x6041             STR      R1,[R0, #+4]
    565            }
    566          
    567            /* Process unlocked */
    568            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_PollForTransfer_11: (+1)
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0x2124             MOVS     R1,#+36
   \       0xC0   0x5460             STRB     R0,[R4, R1]
    569          
    570            return HAL_OK;
   \       0xC2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    571          }
    572          
    573          /**
    574            * @brief  Handle DMA interrupt request.
    575            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    576            *               the configuration information for the specified DMA Channel.
    577            * @retval None
    578            */

   \                                 In section .text, align 2, keep-with-next
    579          void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
    580          {
   \                     HAL_DMA_IRQHandler: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
    581            uint32_t flag_it = hdma->DmaBaseAddress->ISR;
   \        0x2   0x6C01             LDR      R1,[R0, #+64]
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x9102             STR      R1,[SP, #+8]
    582            uint32_t source_it = hdma->Instance->CCR;
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x9201             STR      R2,[SP, #+4]
    583          
    584            /* Half Transfer Complete Interrupt management ******************************/
    585            if ((0U != (flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_HT)))
   \        0xE   0x2244             MOVS     R2,#+68
   \       0x10   0x5C82             LDRB     R2,[R0, R2]
   \       0x12   0x231C             MOVS     R3,#+28
   \       0x14   0x4013             ANDS     R3,R3,R2
   \       0x16   0x466A             MOV      R2,SP
   \       0x18   0x7013             STRB     R3,[R2, #+0]
   \       0x1A   0x2304             MOVS     R3,#+4
   \       0x1C   0x2220             MOVS     R2,#+32
   \       0x1E   0x9C02             LDR      R4,[SP, #+8]
   \       0x20   0x466D             MOV      R5,SP
   \       0x22   0x782D             LDRB     R5,[R5, #+0]
   \       0x24   0x2604             MOVS     R6,#+4
   \       0x26   0x40AE             LSLS     R6,R6,R5
   \       0x28   0x4026             ANDS     R6,R6,R4
   \       0x2A   0xD014             BEQ      ??HAL_DMA_IRQHandler_0
   \       0x2C   0x9C01             LDR      R4,[SP, #+4]
   \       0x2E   0x401C             ANDS     R4,R4,R3
   \       0x30   0xD011             BEQ      ??HAL_DMA_IRQHandler_0
    586            {
    587                /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    588                if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
   \       0x32   0x680C             LDR      R4,[R1, #+0]
   \       0x34   0x4022             ANDS     R2,R2,R4
   \       0x36   0xD102             BNE      ??HAL_DMA_IRQHandler_1
    589                {
    590                  /* Disable the half transfer interrupt */
    591                  __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
   \       0x38   0x680A             LDR      R2,[R1, #+0]
   \       0x3A   0x439A             BICS     R2,R2,R3
   \       0x3C   0x600A             STR      R2,[R1, #+0]
    592                }
    593                /* Clear the half transfer complete flag */
    594                hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1cU);
   \                     ??HAL_DMA_IRQHandler_1: (+1)
   \       0x3E   0x2144             MOVS     R1,#+68
   \       0x40   0x5C41             LDRB     R1,[R0, R1]
   \       0x42   0x221C             MOVS     R2,#+28
   \       0x44   0x400A             ANDS     R2,R2,R1
   \       0x46   0x4093             LSLS     R3,R3,R2
   \       0x48   0x6C01             LDR      R1,[R0, #+64]
   \       0x4A   0x604B             STR      R3,[R1, #+4]
    595          
    596                /* DMA peripheral state is not updated in Half Transfer */
    597                /* but in Transfer Complete case */
    598          
    599               if(hdma->XferHalfCpltCallback != NULL)
   \       0x4C   0x6B01             LDR      R1,[R0, #+48]
   \       0x4E   0x2900             CMP      R1,#+0
   \       0x50   0xD047             BEQ      ??HAL_DMA_IRQHandler_2
    600                {
    601                  /* Half transfer callback */
    602                  hdma->XferHalfCpltCallback(hdma);
   \       0x52   0x4788             BLX      R1
   \       0x54   0xBDF7             POP      {R0-R2,R4-R7,PC}
    603                }
    604            }
    605          
    606            /* Transfer Complete Interrupt management ***********************************/
    607            else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_TC)))
   \                     ??HAL_DMA_IRQHandler_0: (+1)
   \       0x56   0x2301             MOVS     R3,#+1
   \       0x58   0x2402             MOVS     R4,#+2
   \       0x5A   0x2500             MOVS     R5,#+0
   \       0x5C   0x9E02             LDR      R6,[SP, #+8]
   \       0x5E   0x46B4             MOV      R12,R6
   \       0x60   0x466E             MOV      R6,SP
   \       0x62   0x7836             LDRB     R6,[R6, #+0]
   \       0x64   0x2702             MOVS     R7,#+2
   \       0x66   0x40B7             LSLS     R7,R7,R6
   \       0x68   0x4666             MOV      R6,R12
   \       0x6A   0x4037             ANDS     R7,R7,R6
   \       0x6C   0xD019             BEQ      ??HAL_DMA_IRQHandler_3
   \       0x6E   0x9E01             LDR      R6,[SP, #+4]
   \       0x70   0x4026             ANDS     R6,R6,R4
   \       0x72   0xD016             BEQ      ??HAL_DMA_IRQHandler_3
    608            {
    609              if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
   \       0x74   0x680E             LDR      R6,[R1, #+0]
   \       0x76   0x4032             ANDS     R2,R2,R6
   \       0x78   0xD105             BNE      ??HAL_DMA_IRQHandler_4
    610              {
    611                /* Disable the transfer complete and error interrupt */
    612                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
   \       0x7A   0x680A             LDR      R2,[R1, #+0]
   \       0x7C   0x260A             MOVS     R6,#+10
   \       0x7E   0x43B2             BICS     R2,R2,R6
   \       0x80   0x600A             STR      R2,[R1, #+0]
    613          
    614                /* Change the DMA state */
    615                hdma->State = HAL_DMA_STATE_READY;
   \       0x82   0x2125             MOVS     R1,#+37
   \       0x84   0x5443             STRB     R3,[R0, R1]
    616              }
    617              /* Clear the transfer complete flag */
    618              hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1cU));
   \                     ??HAL_DMA_IRQHandler_4: (+1)
   \       0x86   0x2144             MOVS     R1,#+68
   \       0x88   0x5C41             LDRB     R1,[R0, R1]
   \       0x8A   0x221C             MOVS     R2,#+28
   \       0x8C   0x400A             ANDS     R2,R2,R1
   \       0x8E   0x4094             LSLS     R4,R4,R2
   \       0x90   0x6C01             LDR      R1,[R0, #+64]
   \       0x92   0x604C             STR      R4,[R1, #+4]
    619          
    620              /* Process Unlocked */
    621              __HAL_UNLOCK(hdma);
   \       0x94   0x2124             MOVS     R1,#+36
   \       0x96   0x5445             STRB     R5,[R0, R1]
    622          
    623              if(hdma->XferCpltCallback != NULL)
   \       0x98   0x6AC1             LDR      R1,[R0, #+44]
   \       0x9A   0x2900             CMP      R1,#+0
   \       0x9C   0xD021             BEQ      ??HAL_DMA_IRQHandler_2
    624              {
    625                /* Transfer complete callback */
    626                hdma->XferCpltCallback(hdma);
   \       0x9E   0x4788             BLX      R1
   \       0xA0   0xBDF7             POP      {R0-R2,R4-R7,PC}
    627              }
    628            }
    629          
    630            /* Transfer Error Interrupt management **************************************/
    631            else if ((0U != (flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_TE)))
   \                     ??HAL_DMA_IRQHandler_3: (+1)
   \       0xA2   0x2208             MOVS     R2,#+8
   \       0xA4   0x4664             MOV      R4,R12
   \       0xA6   0x466E             MOV      R6,SP
   \       0xA8   0x7836             LDRB     R6,[R6, #+0]
   \       0xAA   0x2708             MOVS     R7,#+8
   \       0xAC   0x40B7             LSLS     R7,R7,R6
   \       0xAE   0x4027             ANDS     R7,R7,R4
   \       0xB0   0xD017             BEQ      ??HAL_DMA_IRQHandler_2
   \       0xB2   0x9C01             LDR      R4,[SP, #+4]
   \       0xB4   0x4022             ANDS     R2,R2,R4
   \       0xB6   0xD014             BEQ      ??HAL_DMA_IRQHandler_2
    632            {
    633              /* When a DMA transfer error occurs */
    634              /* A hardware clear of its EN bits is performed */
    635              /* Disable ALL DMA IT */
    636              __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
   \       0xB8   0x680A             LDR      R2,[R1, #+0]
   \       0xBA   0x240E             MOVS     R4,#+14
   \       0xBC   0x43A2             BICS     R2,R2,R4
   \       0xBE   0x600A             STR      R2,[R1, #+0]
    637          
    638              /* Clear all flags */
    639              hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
   \       0xC0   0x2144             MOVS     R1,#+68
   \       0xC2   0x5C41             LDRB     R1,[R0, R1]
   \       0xC4   0x221C             MOVS     R2,#+28
   \       0xC6   0x400A             ANDS     R2,R2,R1
   \       0xC8   0x2101             MOVS     R1,#+1
   \       0xCA   0x4091             LSLS     R1,R1,R2
   \       0xCC   0x6C02             LDR      R2,[R0, #+64]
   \       0xCE   0x6051             STR      R1,[R2, #+4]
    640          
    641              /* Update error code */
    642              hdma->ErrorCode = HAL_DMA_ERROR_TE;
   \       0xD0   0x63C3             STR      R3,[R0, #+60]
    643          
    644              /* Change the DMA state */
    645              hdma->State = HAL_DMA_STATE_READY;
   \       0xD2   0x2125             MOVS     R1,#+37
   \       0xD4   0x5443             STRB     R3,[R0, R1]
    646          
    647              /* Process Unlocked */
    648              __HAL_UNLOCK(hdma);
   \       0xD6   0x2124             MOVS     R1,#+36
   \       0xD8   0x5445             STRB     R5,[R0, R1]
    649          
    650              if (hdma->XferErrorCallback != NULL)
   \       0xDA   0x6B41             LDR      R1,[R0, #+52]
   \       0xDC   0x2900             CMP      R1,#+0
   \       0xDE   0xD000             BEQ      ??HAL_DMA_IRQHandler_2
    651              {
    652                /* Transfer error callback */
    653                hdma->XferErrorCallback(hdma);
   \       0xE0   0x4788             BLX      R1
    654              }
    655            }
    656            else
    657            {
    658              /* Nothing To Do */
    659            }
    660            return;
   \                     ??HAL_DMA_IRQHandler_2: (+1)
   \       0xE2   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    661          }
    662          
    663          /**
    664            * @brief  Register callbacks
    665            * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
    666            *                               the configuration information for the specified DMA Channel.
    667            * @param  CallbackID           User Callback identifer
    668            *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
    669            * @param  pCallback            pointer to private callbacsk function which has pointer to
    670            *                               a DMA_HandleTypeDef structure as parameter.
    671            * @retval HAL status
    672            */

   \                                 In section .text, align 2, keep-with-next
    673          HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _hdma))
    674          {
   \                     HAL_DMA_RegisterCallback: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0013             MOVS     R3,R2
    675            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2200             MOVS     R2,#+0
    676          
    677            /* Process locked */
    678            __HAL_LOCK(hdma);
   \        0x8   0x2524             MOVS     R5,#+36
   \        0xA   0x5D45             LDRB     R5,[R0, R5]
   \        0xC   0x2D01             CMP      R5,#+1
   \        0xE   0xD101             BNE      ??HAL_DMA_RegisterCallback_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_DMA_RegisterCallback_0: (+1)
   \       0x14   0x0005             MOVS     R5,R0
   \       0x16   0x3524             ADDS     R5,R5,#+36
   \       0x18   0x2601             MOVS     R6,#+1
   \       0x1A   0x702E             STRB     R6,[R5, #+0]
    679          
    680            if(HAL_DMA_STATE_READY == hdma->State)
   \       0x1C   0x2725             MOVS     R7,#+37
   \       0x1E   0x5DC7             LDRB     R7,[R0, R7]
   \       0x20   0x2F01             CMP      R7,#+1
   \       0x22   0xD10F             BNE      ??HAL_DMA_RegisterCallback_1
    681            {
    682              switch (CallbackID)
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD005             BEQ      ??HAL_DMA_RegisterCallback_2
   \       0x28   0x2902             CMP      R1,#+2
   \       0x2A   0xD007             BEQ      ??HAL_DMA_RegisterCallback_3
   \       0x2C   0xD304             BCC      ??HAL_DMA_RegisterCallback_4
   \       0x2E   0x2903             CMP      R1,#+3
   \       0x30   0xD006             BEQ      ??HAL_DMA_RegisterCallback_5
   \       0x32   0xE007             B        ??HAL_DMA_RegisterCallback_1
    683              {
    684               case  HAL_DMA_XFER_CPLT_CB_ID:
    685                     hdma->XferCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_2: (+1)
   \       0x34   0x62C3             STR      R3,[R0, #+44]
    686                     break;
   \       0x36   0xE006             B        ??HAL_DMA_RegisterCallback_6
    687          
    688               case  HAL_DMA_XFER_HALFCPLT_CB_ID:
    689                     hdma->XferHalfCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_4: (+1)
   \       0x38   0x6303             STR      R3,[R0, #+48]
    690                     break;
   \       0x3A   0xE004             B        ??HAL_DMA_RegisterCallback_6
    691          
    692               case  HAL_DMA_XFER_ERROR_CB_ID:
    693                     hdma->XferErrorCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_3: (+1)
   \       0x3C   0x6343             STR      R3,[R0, #+52]
    694                     break;
   \       0x3E   0xE002             B        ??HAL_DMA_RegisterCallback_6
    695          
    696               case  HAL_DMA_XFER_ABORT_CB_ID:
    697                     hdma->XferAbortCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_5: (+1)
   \       0x40   0x6383             STR      R3,[R0, #+56]
    698                     break;
   \       0x42   0xE000             B        ??HAL_DMA_RegisterCallback_6
    699          
    700               default:
    701                     status = HAL_ERROR;
    702                     break;
    703              }
    704            }
    705            else
    706            {
    707              status = HAL_ERROR;
   \                     ??HAL_DMA_RegisterCallback_1: (+1)
   \       0x44   0x2201             MOVS     R2,#+1
    708            }
    709          
    710            /* Release Lock */
    711            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_RegisterCallback_6: (+1)
   \       0x46   0x702C             STRB     R4,[R5, #+0]
    712          
    713            return status;
   \       0x48   0x0010             MOVS     R0,R2
   \       0x4A   0xBDF0             POP      {R4-R7,PC}       ;; return
    714          }
    715          
    716          /**
    717            * @brief  UnRegister callbacks
    718            * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
    719            *                               the configuration information for the specified DMA Channel.
    720            * @param  CallbackID           User Callback identifer
    721            *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
    722            * @retval HAL status
    723            */

   \                                 In section .text, align 2, keep-with-next
    724          HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
    725          {
   \                     HAL_DMA_UnRegisterCallback: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0002             MOVS     R2,R0
    726            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x2000             MOVS     R0,#+0
    727          
    728              /* Process locked */
    729            __HAL_LOCK(hdma);
   \        0x8   0x2424             MOVS     R4,#+36
   \        0xA   0x5D14             LDRB     R4,[R2, R4]
   \        0xC   0x2C01             CMP      R4,#+1
   \        0xE   0xD101             BNE      ??HAL_DMA_UnRegisterCallback_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_DMA_UnRegisterCallback_0: (+1)
   \       0x14   0x0014             MOVS     R4,R2
   \       0x16   0x3424             ADDS     R4,R4,#+36
   \       0x18   0x2501             MOVS     R5,#+1
   \       0x1A   0x7025             STRB     R5,[R4, #+0]
    730          
    731            if(HAL_DMA_STATE_READY == hdma->State)
   \       0x1C   0x2625             MOVS     R6,#+37
   \       0x1E   0x5D96             LDRB     R6,[R2, R6]
   \       0x20   0x2E01             CMP      R6,#+1
   \       0x22   0xD113             BNE      ??HAL_DMA_UnRegisterCallback_1
    732            {
    733              switch (CallbackID)
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD006             BEQ      ??HAL_DMA_UnRegisterCallback_2
   \       0x28   0x2902             CMP      R1,#+2
   \       0x2A   0xD008             BEQ      ??HAL_DMA_UnRegisterCallback_3
   \       0x2C   0xD305             BCC      ??HAL_DMA_UnRegisterCallback_4
   \       0x2E   0x2904             CMP      R1,#+4
   \       0x30   0xD007             BEQ      ??HAL_DMA_UnRegisterCallback_5
   \       0x32   0xD309             BCC      ??HAL_DMA_UnRegisterCallback_6
   \       0x34   0xE00A             B        ??HAL_DMA_UnRegisterCallback_1
    734              {
    735               case  HAL_DMA_XFER_CPLT_CB_ID:
    736                     hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_2: (+1)
   \       0x36   0x62D3             STR      R3,[R2, #+44]
    737                     break;
   \       0x38   0xE009             B        ??HAL_DMA_UnRegisterCallback_7
    738          
    739               case  HAL_DMA_XFER_HALFCPLT_CB_ID:
    740                     hdma->XferHalfCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_4: (+1)
   \       0x3A   0x6313             STR      R3,[R2, #+48]
    741                     break;
   \       0x3C   0xE007             B        ??HAL_DMA_UnRegisterCallback_7
    742          
    743               case  HAL_DMA_XFER_ERROR_CB_ID:
    744                     hdma->XferErrorCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_3: (+1)
   \       0x3E   0x6353             STR      R3,[R2, #+52]
    745                     break;
   \       0x40   0xE005             B        ??HAL_DMA_UnRegisterCallback_7
    746          
    747               case  HAL_DMA_XFER_ABORT_CB_ID:
    748                     hdma->XferAbortCallback = NULL;
    749                     break;
    750          
    751              case   HAL_DMA_XFER_ALL_CB_ID:
    752                     hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_5: (+1)
   \       0x42   0x62D3             STR      R3,[R2, #+44]
    753                     hdma->XferHalfCpltCallback = NULL;
   \       0x44   0x6313             STR      R3,[R2, #+48]
    754                     hdma->XferErrorCallback = NULL;
   \       0x46   0x6353             STR      R3,[R2, #+52]
    755                     hdma->XferAbortCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_6: (+1)
   \       0x48   0x6393             STR      R3,[R2, #+56]
    756                     break;
   \       0x4A   0xE000             B        ??HAL_DMA_UnRegisterCallback_7
    757          
    758              default:
    759                     status = HAL_ERROR;
    760                     break;
    761              }
    762            }
    763            else
    764            {
    765              status = HAL_ERROR;
   \                     ??HAL_DMA_UnRegisterCallback_1: (+1)
   \       0x4C   0x2001             MOVS     R0,#+1
    766            }
    767          
    768            /* Release Lock */
    769            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_UnRegisterCallback_7: (+1)
   \       0x4E   0x7023             STRB     R3,[R4, #+0]
    770          
    771            return status;
   \       0x50   0xBD70             POP      {R4-R6,PC}       ;; return
    772          }
    773          
    774          /**
    775            * @}
    776            */
    777          
    778          
    779          
    780          /** @defgroup DMA_Exported_Functions_Group3 Peripheral State and Errors functions
    781           *  @brief    Peripheral State and Errors functions
    782           *
    783          @verbatim
    784           ===============================================================================
    785                      ##### Peripheral State and Errors functions #####
    786           ===============================================================================
    787              [..]
    788              This subsection provides functions allowing to
    789                (+) Check the DMA state
    790                (+) Get error code
    791          
    792          @endverbatim
    793            * @{
    794            */
    795          
    796          /**
    797            * @brief  Return the DMA handle state.
    798            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    799            *               the configuration information for the specified DMA Channel.
    800            * @retval HAL state
    801            */

   \                                 In section .text, align 2, keep-with-next
    802          HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
    803          {
    804            /* Return DMA handle state */
    805            return hdma->State;
   \                     HAL_DMA_GetState: (+1)
   \        0x0   0x2125             MOVS     R1,#+37
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
    806          }
    807          
    808          /**
    809            * @brief  Return the DMA error code.
    810            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
    811            *              the configuration information for the specified DMA Channel.
    812            * @retval DMA Error Code
    813            */

   \                                 In section .text, align 2, keep-with-next
    814          uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
    815          {
    816            return hdma->ErrorCode;
   \                     HAL_DMA_GetError: (+1)
   \        0x0   0x6BC0             LDR      R0,[R0, #+60]
   \        0x2   0x4770             BX       LR               ;; return
    817          }
    818          
    819          /**
    820            * @}
    821            */
    822          
    823          /**
    824            * @}
    825            */
    826          
    827          /** @addtogroup DMA_Private_Functions
    828            * @{
    829            */
    830          
    831          /**
    832            * @brief  Sets the DMA Transfer parameter.
    833            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
    834            *                     the configuration information for the specified DMA Channel.
    835            * @param  SrcAddress The source memory Buffer address
    836            * @param  DstAddress The destination memory Buffer address
    837            * @param  DataLength The length of data to be transferred from source to destination
    838            * @retval HAL status
    839            */

   \                                 In section .text, align 2, keep-with-next
    840          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    841          {
   \                     DMA_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    842            /* Clear all flags */
    843            hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
   \        0x2   0x2401             MOVS     R4,#+1
   \        0x4   0x2544             MOVS     R5,#+68
   \        0x6   0x5D45             LDRB     R5,[R0, R5]
   \        0x8   0x261C             MOVS     R6,#+28
   \        0xA   0x402E             ANDS     R6,R6,R5
   \        0xC   0x40B4             LSLS     R4,R4,R6
   \        0xE   0x6C05             LDR      R5,[R0, #+64]
   \       0x10   0x606C             STR      R4,[R5, #+4]
    844          
    845            /* Configure DMA Channel data length */
    846            hdma->Instance->CNDTR = DataLength;
   \       0x12   0x6804             LDR      R4,[R0, #+0]
   \       0x14   0x6063             STR      R3,[R4, #+4]
    847          
    848            /* Memory to Peripheral */
    849            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
   \       0x16   0x6880             LDR      R0,[R0, #+8]
   \       0x18   0x2810             CMP      R0,#+16
   \       0x1A   0xD102             BNE      ??DMA_SetConfig_0
    850            {
    851              /* Configure DMA Channel destination address */
    852              hdma->Instance->CPAR = DstAddress;
   \       0x1C   0x60A2             STR      R2,[R4, #+8]
    853          
    854              /* Configure DMA Channel source address */
    855              hdma->Instance->CMAR = SrcAddress;
   \       0x1E   0x60E1             STR      R1,[R4, #+12]
   \       0x20   0xBD70             POP      {R4-R6,PC}
    856            }
    857            /* Peripheral to Memory */
    858            else
    859            {
    860              /* Configure DMA Channel source address */
    861              hdma->Instance->CPAR = SrcAddress;
   \                     ??DMA_SetConfig_0: (+1)
   \       0x22   0x60A1             STR      R1,[R4, #+8]
    862          
    863              /* Configure DMA Channel destination address */
    864              hdma->Instance->CMAR = DstAddress;
   \       0x24   0x60E2             STR      R2,[R4, #+12]
    865            }
    866          }
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0xBFFD'FFF8        DC32     0xbffdfff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x4002'0000        DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0xFFFF'800F        DC32     0xffff800f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x4002'00A8        DC32     0x400200a8
    867          
    868          /**
    869            * @}
    870            */
    871          
    872          /**
    873            * @}
    874            */
    875          
    876          #endif /* HAL_DMA_MODULE_ENABLED */
    877          /**
    878            * @}
    879            */
    880          
    881          /**
    882            * @}
    883            */
    884          
    885          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DMA_SetConfig
      12   HAL_DMA_Abort
      16   HAL_DMA_Abort_IT
        16   -- Indirect call
      16   HAL_DMA_DeInit
        16 __aeabi_uidiv
       0   HAL_DMA_GetError
       0   HAL_DMA_GetState
      32   HAL_DMA_IRQHandler
        32   -- Indirect call
      16   HAL_DMA_Init
        16 __aeabi_uidiv
      24   HAL_DMA_PollForTransfer
        24   -> HAL_GetTick
      20   HAL_DMA_RegisterCallback
      24   HAL_DMA_Start
        24   -> DMA_SetConfig
      24   HAL_DMA_Start_IT
        24   -> DMA_SetConfig
      16   HAL_DMA_UnRegisterCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
      40  DMA_SetConfig
      74  HAL_DMA_Abort
      78  HAL_DMA_Abort_IT
      96  HAL_DMA_DeInit
       4  HAL_DMA_GetError
       6  HAL_DMA_GetState
     228  HAL_DMA_IRQHandler
     136  HAL_DMA_Init
     196  HAL_DMA_PollForTransfer
      76  HAL_DMA_RegisterCallback
      80  HAL_DMA_Start
     110  HAL_DMA_Start_IT
      82  HAL_DMA_UnRegisterCallback

 
 1'222 bytes in section .text
 
 1'222 bytes of CODE memory

Errors: none
Warnings: none
