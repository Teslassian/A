###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  13:02:31
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rtc_ex.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW6A22.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rtc_ex.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal_rtc_ex.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal_rtc_ex.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rtc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_rtc_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended RTC HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Real Time Clock (RTC) Extended peripheral:
      8            *           + RTC Time Stamp functions
      9            *           + RTC Tamper functions
     10            *           + RTC Wake-up functions
     11            *           + Extended Control functions
     12            *           + Extended RTC features functions
     13            *
     14            @verbatim
     15            ==============================================================================
     16                            ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19              (+) Enable the RTC domain access.
     20              (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour
     21                  format using the HAL_RTC_Init() function.
     22          
     23            *** RTC Wakeup configuration ***
     24            ================================
     25            [..]
     26              (+) To configure the RTC Wakeup Clock source and Counter use the HAL_RTCEx_SetWakeUpTimer()
     27                  function. You can also configure the RTC Wakeup timer with interrupt mode
     28                  using the HAL_RTCEx_SetWakeUpTimer_IT() function.
     29              (+) To read the RTC WakeUp Counter register, use the HAL_RTCEx_GetWakeUpTimer()
     30                  function.
     31          
     32            *** Outputs configuration ***
     33            =============================
     34            [..] The RTC has 2 different outputs:
     35              (+) RTC_ALARM: this output is used to manage the RTC Alarm A, Alarm B
     36                  and WaKeUp signals.
     37                  To output the selected RTC signal, use the HAL_RTC_Init() function.
     38              (+) RTC_CALIB: this output is 512Hz signal or 1Hz.
     39                  To enable the RTC_CALIB, use the HAL_RTCEx_SetCalibrationOutPut() function.
     40              (+) Two pins can be used as RTC_ALARM or RTC_CALIB (PC13, PB14) for STM32L05x/6x/7x/8x
     41                and (PA2, PB14) for STM32L03x/4x managed on the RTC_OR register.
     42              (+) When the RTC_CALIB or RTC_ALARM output is selected, the RTC_OUT pin is
     43                  automatically configured in output alternate function.
     44          
     45            *** Smooth digital Calibration configuration ***
     46            ================================================
     47            [..]
     48              (+) Configure the RTC Original Digital Calibration Value and the corresponding
     49                  calibration cycle period (32s,16s and 8s) using the HAL_RTCEx_SetSmoothCalib()
     50                  function.
     51          
     52            *** TimeStamp configuration ***
     53            ===============================
     54            [..]
     55              (+) Configure the RTC_AF trigger and enable the RTC TimeStamp using the
     56                  HAL_RTCEx_SetTimeStamp() function. You can also configure the RTC TimeStamp with
     57                  interrupt mode using the HAL_RTCEx_SetTimeStamp_IT() function.
     58              (+) To read the RTC TimeStamp Time and Date register, use the HAL_RTCEx_GetTimeStamp()
     59                  function.
     60          
     61            *** Tamper configuration ***
     62            ============================
     63            [..]
     64                  (+) Enable the RTC Tamper and configure the Tamper filter count, trigger Edge
     65                  or Level according to the Tamper filter (if equal to 0 Edge else Level)
     66                  value, sampling frequency, NoErase, MaskFlag,  precharge or discharge and
     67                  Pull-UP using the HAL_RTCEx_SetTamper() function. You can configure RTC Tamper
     68                  with interrupt mode using HAL_RTCEx_SetTamper_IT() function.
     69              (+) The default configuration of the Tamper erases the backup registers. To avoid
     70                  erase, enable the NoErase field on the RTC_TAMPCR register.
     71          
     72            *** Backup Data Registers configuration ***
     73            ===========================================
     74            [..]
     75              (+) To write to the RTC Backup Data registers, use the HAL_RTCEx_BKUPWrite()
     76                  function.
     77              (+) To read the RTC Backup Data registers, use the HAL_RTCEx_BKUPRead()
     78                  function.
     79          
     80             @endverbatim
     81            ******************************************************************************
     82            * @attention
     83            *
     84            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     85            * All rights reserved.</center></h2>
     86            *
     87            * This software component is licensed by ST under BSD 3-Clause license,
     88            * the "License"; You may not use this file except in compliance with the
     89            * License. You may obtain a copy of the License at:
     90            *                        opensource.org/licenses/BSD-3-Clause
     91            *
     92            ******************************************************************************
     93            */
     94          
     95          /* Includes ------------------------------------------------------------------*/
     96          #include "stm32l0xx_hal.h"
     97          
     98          /** @addtogroup STM32L0xx_HAL_Driver
     99            * @{
    100            */
    101          
    102          /** @addtogroup RTCEx
    103            * @brief RTC Extended HAL module driver
    104            * @{
    105            */
    106          
    107          #ifdef HAL_RTC_MODULE_ENABLED
    108          
    109          /* Private typedef -----------------------------------------------------------*/
    110          /* Private define ------------------------------------------------------------*/
    111          
    112          /** @defgroup RTCEx_Private_Constants RTCEx Private Constants
    113            * @{
    114            */
    115          #if defined(RTC_TAMPER1_SUPPORT) && defined(RTC_TAMPER3_SUPPORT)
    116          #define RTC_TAMPCR_MASK               ((uint32_t)RTC_TAMPCR_TAMPTS    |\
    117                                                 (uint32_t)RTC_TAMPCR_TAMPFREQ  | (uint32_t)RTC_TAMPCR_TAMPFLT      | (uint32_t)RTC_TAMPCR_TAMPPRCH |\
    118                                                 (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE                                       |\
    119                                                 (uint32_t)RTC_TAMPCR_TAMP1IE   | (uint32_t)RTC_TAMPCR_TAMP1NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF  |\
    120                                                 (uint32_t)RTC_TAMPCR_TAMP2IE   | (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP2MF  |\
    121                                                 (uint32_t)RTC_TAMPCR_TAMP3IE   | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP3MF)
    122          #elif defined(RTC_TAMPER1_SUPPORT)
    123          #define RTC_TAMPCR_MASK               ((uint32_t)RTC_TAMPCR_TAMPTS    |\
    124                                                 (uint32_t)RTC_TAMPCR_TAMPFREQ  | (uint32_t)RTC_TAMPCR_TAMPFLT      | (uint32_t)RTC_TAMPCR_TAMPPRCH |\
    125                                                 (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE                                       |\
    126                                                 (uint32_t)RTC_TAMPCR_TAMP1IE   | (uint32_t)RTC_TAMPCR_TAMP1NOERASE | (uint32_t)RTC_TAMPCR_TAMP1MF  |\
    127                                                 (uint32_t)RTC_TAMPCR_TAMP2IE   | (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP2MF)
    128          #elif defined(RTC_TAMPER3_SUPPORT)
    129          #define RTC_TAMPCR_MASK               ((uint32_t)RTC_TAMPCR_TAMPTS    |\
    130                                                 (uint32_t)RTC_TAMPCR_TAMPFREQ  | (uint32_t)RTC_TAMPCR_TAMPFLT      | (uint32_t)RTC_TAMPCR_TAMPPRCH |\
    131                                                 (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE                                       |\
    132                                                 (uint32_t)RTC_TAMPCR_TAMP2IE   | (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP2MF  |\
    133                                                 (uint32_t)RTC_TAMPCR_TAMP3IE   | (uint32_t)RTC_TAMPCR_TAMP3NOERASE | (uint32_t)RTC_TAMPCR_TAMP3MF)
    134          #else
    135          #define RTC_TAMPCR_MASK               ((uint32_t)RTC_TAMPCR_TAMPTS    |\
    136                                                 (uint32_t)RTC_TAMPCR_TAMPFREQ  | (uint32_t)RTC_TAMPCR_TAMPFLT      | (uint32_t)RTC_TAMPCR_TAMPPRCH |\
    137                                                 (uint32_t)RTC_TAMPCR_TAMPPUDIS | (uint32_t)RTC_TAMPCR_TAMPIE                                       |\
    138                                                 (uint32_t)RTC_TAMPCR_TAMP2IE   | (uint32_t)RTC_TAMPCR_TAMP2NOERASE | (uint32_t)RTC_TAMPCR_TAMP2MF)
    139          #endif /* RTC_TAMPER1_SUPPORT && RTC_TAMPER3_SUPPORT */
    140          /**
    141            * @}
    142            */
    143          
    144          /* Private macro -------------------------------------------------------------*/
    145          /* Private variables ---------------------------------------------------------*/
    146          /* Private function prototypes -----------------------------------------------*/
    147          /* Exported functions --------------------------------------------------------*/
    148          
    149          /** @addtogroup RTCEx_Exported_Functions
    150            * @{
    151            */
    152          
    153          
    154          /** @addtogroup RTCEx_Exported_Functions_Group1
    155           *  @brief   RTC TimeStamp and Tamper functions
    156            *
    157          @verbatim
    158           ===============================================================================
    159                           ##### RTC TimeStamp and Tamper functions #####
    160           ===============================================================================
    161          
    162           [..] This section provides functions allowing to configure TimeStamp feature
    163          
    164          @endverbatim
    165            * @{
    166            */
    167          
    168          /**
    169            * @brief  Set TimeStamp.
    170            * @note   This API must be called before enabling the TimeStamp feature.
    171            * @param  hrtc RTC handle
    172            * @param  TimeStampEdge Specifies the pin edge on which the TimeStamp is
    173            *         activated.
    174            *          This parameter can be one of the following values:
    175            *             @arg RTC_TIMESTAMPEDGE_RISING: the Time stamp event occurs on the
    176            *                                        rising edge of the related pin.
    177            *             @arg RTC_TIMESTAMPEDGE_FALLING: the Time stamp event occurs on the
    178            *                                         falling edge of the related pin.
    179            * @param  RTC_TimeStampPin specifies the RTC TimeStamp Pin.
    180            *          This parameter can be one of the following values:
    181            *             @arg RTC_TIMESTAMPPIN_DEFAULT: PC13 is selected as RTC TimeStamp Pin on STM32L05x/6x/7x/8x
    182            *                                            and PA2 on STM32L03x/4x/2x/1x.
    183            * @retval HAL status
    184            */

   \                                 In section .text, align 2, keep-with-next
    185          HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
    186          {
   \                     HAL_RTCEx_SetTimeStamp: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    187            uint32_t tmpreg;
    188          
    189            /* Check the parameters */
    190            assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
    191            assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
    192          
    193            /* Process Locked */
    194            __HAL_LOCK(hrtc);
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x5C82             LDRB     R2,[R0, R2]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_SetTimeStamp_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_RTCEx_SetTimeStamp_0: (+1)
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x2320             MOVS     R3,#+32
   \       0x12   0x54C2             STRB     R2,[R0, R3]
    195          
    196            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2302             MOVS     R3,#+2
   \       0x16   0x2421             MOVS     R4,#+33
   \       0x18   0x5503             STRB     R3,[R0, R4]
    197          
    198            /* Get the RTC_CR register and clear the bits to be configured */
    199            tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   \       0x1A   0x6804             LDR      R4,[R0, #+0]
   \       0x1C   0x68A3             LDR      R3,[R4, #+8]
    200          
    201            tmpreg |= TimeStampEdge;
    202          
    203            /* Disable the write protection for RTC registers */
    204            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1E   0x25CA             MOVS     R5,#+202
   \       0x20   0x6265             STR      R5,[R4, #+36]
   \       0x22   0x2453             MOVS     R4,#+83
   \       0x24   0x6805             LDR      R5,[R0, #+0]
   \       0x26   0x626C             STR      R4,[R5, #+36]
    205          
    206            /* Clear the Timestamp Flag */
    207            __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
   \       0x28   0x6805             LDR      R5,[R0, #+0]
   \       0x2A   0x2480             MOVS     R4,#+128
   \       0x2C   0x68EE             LDR      R6,[R5, #+12]
   \       0x2E   0x4026             ANDS     R6,R6,R4
   \       0x30   0x....             LDR      R7,??DataTable5  ;; 0xfffff77f
   \       0x32   0x4337             ORRS     R7,R7,R6
   \       0x34   0x60EF             STR      R7,[R5, #+12]
    208          
    209            /* Clear the Timestamp overrun Flag */
    210            __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
   \       0x36   0x6805             LDR      R5,[R0, #+0]
   \       0x38   0x68EE             LDR      R6,[R5, #+12]
   \       0x3A   0x4034             ANDS     R4,R4,R6
   \       0x3C   0x....             LDR      R6,??DataTable5_1  ;; 0xffffef7f
   \       0x3E   0x4326             ORRS     R6,R6,R4
   \       0x40   0x60EE             STR      R6,[R5, #+12]
    211          
    212            /* Configure the Time Stamp TSEDGE and Enable bits */
    213            hrtc->Instance->CR = (uint32_t)tmpreg;
   \       0x42   0x....             LDR      R4,??DataTable6  ;; 0xfffff7f7
   \       0x44   0x401C             ANDS     R4,R4,R3
   \       0x46   0x4321             ORRS     R1,R1,R4
   \       0x48   0x6803             LDR      R3,[R0, #+0]
   \       0x4A   0x6099             STR      R1,[R3, #+8]
    214          
    215            __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0x688B             LDR      R3,[R1, #+8]
   \       0x50   0x02D4             LSLS     R4,R2,#+11
   \       0x52   0x431C             ORRS     R4,R4,R3
   \       0x54   0x608C             STR      R4,[R1, #+8]
    216          
    217            /* Enable the write protection for RTC registers */
    218            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x56   0x....             B.N      ?Subroutine0
    219          
    220            /* Change RTC state */
    221            hrtc->State = HAL_RTC_STATE_READY;
    222          
    223            /* Process Unlocked */
    224            __HAL_UNLOCK(hrtc);
    225          
    226            return HAL_OK;
    227          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x21FF             MOVS     R1,#+255
   \        0x2   0x6803             LDR      R3,[R0, #+0]
   \        0x4   0x6259             STR      R1,[R3, #+36]
   \        0x6   0x2121             MOVS     R1,#+33
   \        0x8   0x5442             STRB     R2,[R0, R1]
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x2220             MOVS     R2,#+32
   \        0xE   0x5481             STRB     R1,[R0, R2]
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBDF0             POP      {R4-R7,PC}       ;; return
    228          
    229          /**
    230            * @brief  Set TimeStamp with Interrupt.
    231            * @param  hrtc RTC handle
    232            * @note   This API must be called before enabling the TimeStamp feature.
    233            * @param  TimeStampEdge Specifies the pin edge on which the TimeStamp is
    234            *         activated.
    235            *          This parameter can be one of the following values:
    236            *             @arg RTC_TIMESTAMPEDGE_RISING: the Time stamp event occurs on the
    237            *                                        rising edge of the related pin.
    238            *             @arg RTC_TIMESTAMPEDGE_FALLING: the Time stamp event occurs on the
    239            *                                         falling edge of the related pin.
    240            * @param  RTC_TimeStampPin Specifies the RTC TimeStamp Pin.
    241            *          This parameter can be one of the following values:
    242            *             @arg RTC_TIMESTAMPPIN_DEFAULT: PC13 is selected as RTC TimeStamp Pin on STM32L05x/6x/7x/8x
    243            *                                            and PA2 on STM32L03x/4x/2x/1x.
    244            * @retval HAL status
    245            */

   \                                 In section .text, align 2, keep-with-next
    246          HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
    247          {
   \                     HAL_RTCEx_SetTimeStamp_IT: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    248            uint32_t tmpreg;
    249          
    250            /* Check the parameters */
    251            assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
    252            assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
    253          
    254            /* Process Locked */
    255            __HAL_LOCK(hrtc);
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x5C82             LDRB     R2,[R0, R2]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_SetTimeStamp_IT_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_RTCEx_SetTimeStamp_IT_0: (+1)
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x2320             MOVS     R3,#+32
   \       0x12   0x54C2             STRB     R2,[R0, R3]
    256          
    257            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2302             MOVS     R3,#+2
   \       0x16   0x2421             MOVS     R4,#+33
   \       0x18   0x5503             STRB     R3,[R0, R4]
    258          
    259            /* Get the RTC_CR register and clear the bits to be configured */
    260            tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   \       0x1A   0x6804             LDR      R4,[R0, #+0]
   \       0x1C   0x68A3             LDR      R3,[R4, #+8]
    261          
    262            tmpreg |= TimeStampEdge;
    263          
    264            /* Disable the write protection for RTC registers */
    265            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1E   0x25CA             MOVS     R5,#+202
   \       0x20   0x6265             STR      R5,[R4, #+36]
   \       0x22   0x2453             MOVS     R4,#+83
   \       0x24   0x6805             LDR      R5,[R0, #+0]
   \       0x26   0x626C             STR      R4,[R5, #+36]
    266          
    267            /* Clear the Timestamp Flag */
    268            __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
   \       0x28   0x6805             LDR      R5,[R0, #+0]
   \       0x2A   0x2480             MOVS     R4,#+128
   \       0x2C   0x68EE             LDR      R6,[R5, #+12]
   \       0x2E   0x4026             ANDS     R6,R6,R4
   \       0x30   0x....             LDR      R7,??DataTable5  ;; 0xfffff77f
   \       0x32   0x4337             ORRS     R7,R7,R6
   \       0x34   0x60EF             STR      R7,[R5, #+12]
    269          
    270            /* Clear the Timestamp overrun Flag */
    271            __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
   \       0x36   0x6805             LDR      R5,[R0, #+0]
   \       0x38   0x68EE             LDR      R6,[R5, #+12]
   \       0x3A   0x4034             ANDS     R4,R4,R6
   \       0x3C   0x....             LDR      R6,??DataTable5_1  ;; 0xffffef7f
   \       0x3E   0x4326             ORRS     R6,R6,R4
   \       0x40   0x60EE             STR      R6,[R5, #+12]
    272          
    273            /* Configure the Time Stamp TSEDGE and Enable bits */
    274            hrtc->Instance->CR = (uint32_t)tmpreg;
   \       0x42   0x....             LDR      R4,??DataTable6  ;; 0xfffff7f7
   \       0x44   0x401C             ANDS     R4,R4,R3
   \       0x46   0x4321             ORRS     R1,R1,R4
   \       0x48   0x6803             LDR      R3,[R0, #+0]
   \       0x4A   0x6099             STR      R1,[R3, #+8]
    275          
    276            __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0x688B             LDR      R3,[R1, #+8]
   \       0x50   0x02D4             LSLS     R4,R2,#+11
   \       0x52   0x431C             ORRS     R4,R4,R3
   \       0x54   0x608C             STR      R4,[R1, #+8]
    277          
    278            /* Enable IT timestamp */
    279            __HAL_RTC_TIMESTAMP_ENABLE_IT(hrtc, RTC_IT_TS);
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0x688B             LDR      R3,[R1, #+8]
   \       0x5A   0x03D4             LSLS     R4,R2,#+15
   \       0x5C   0x431C             ORRS     R4,R4,R3
   \       0x5E   0x608C             STR      R4,[R1, #+8]
    280          
    281            /* RTC timestamp Interrupt Configuration: EXTI configuration */
    282            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
   \       0x60   0x04D1             LSLS     R1,R2,#+19
   \       0x62   0x....             LDR      R3,??DataTable6_1  ;; 0x40010400
   \       0x64   0x681C             LDR      R4,[R3, #+0]
   \       0x66   0x430C             ORRS     R4,R4,R1
   \       0x68   0x601C             STR      R4,[R3, #+0]
    283          
    284            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
   \       0x6A   0x689C             LDR      R4,[R3, #+8]
   \       0x6C   0x4321             ORRS     R1,R1,R4
   \       0x6E   0x6099             STR      R1,[R3, #+8]
    285          
    286            /* Enable the write protection for RTC registers */
    287            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x70                      REQUIRE ?Subroutine0
   \       0x70                      ;; // Fall through to label ?Subroutine0
    288          
    289            hrtc->State = HAL_RTC_STATE_READY;
    290          
    291            /* Process Unlocked */
    292            __HAL_UNLOCK(hrtc);
    293          
    294            return HAL_OK;
    295          }
    296          
    297          /**
    298            * @brief  Deactivate TimeStamp.
    299            * @param  hrtc RTC handle
    300            * @retval HAL status
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
    303          {
   \                     HAL_RTCEx_DeactivateTimeStamp: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    304            uint32_t tmpreg;
    305          
    306            /* Process Locked */
    307            __HAL_LOCK(hrtc);
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x5C41             LDRB     R1,[R0, R1]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_DeactivateTimeStamp_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD10             POP      {R4,PC}
   \                     ??HAL_RTCEx_DeactivateTimeStamp_0: (+1)
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x2220             MOVS     R2,#+32
   \       0x12   0x5481             STRB     R1,[R0, R2]
    308          
    309            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2202             MOVS     R2,#+2
   \       0x16   0x2321             MOVS     R3,#+33
   \       0x18   0x54C2             STRB     R2,[R0, R3]
    310          
    311            /* Disable the write protection for RTC registers */
    312            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1A   0x22CA             MOVS     R2,#+202
   \       0x1C   0x6803             LDR      R3,[R0, #+0]
   \       0x1E   0x625A             STR      R2,[R3, #+36]
   \       0x20   0x2253             MOVS     R2,#+83
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0x625A             STR      R2,[R3, #+36]
    313          
    314            /* In case of interrupt mode is used, the interrupt source must disabled */
    315            __HAL_RTC_TIMESTAMP_DISABLE_IT(hrtc, RTC_IT_TS);
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6893             LDR      R3,[R2, #+8]
   \       0x2A   0x....             LDR      R4,??DataTable7  ;; 0xffff7fff
   \       0x2C   0x401C             ANDS     R4,R4,R3
   \       0x2E   0x6094             STR      R4,[R2, #+8]
    316          
    317            /* Get the RTC_CR register and clear the bits to be configured */
    318            tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   \       0x30   0x6802             LDR      R2,[R0, #+0]
   \       0x32   0x6893             LDR      R3,[R2, #+8]
    319          
    320            /* Configure the Time Stamp TSEDGE and Enable bits */
    321            hrtc->Instance->CR = (uint32_t)tmpreg;
   \       0x34   0x....             LDR      R4,??DataTable6  ;; 0xfffff7f7
   \       0x36   0x....             B.N      ?Subroutine2
    322          
    323            /* Enable the write protection for RTC registers */
    324            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    325          
    326            hrtc->State = HAL_RTC_STATE_READY;
    327          
    328            /* Process Unlocked */
    329            __HAL_UNLOCK(hrtc);
    330          
    331            return HAL_OK;
    332          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x401C             ANDS     R4,R4,R3
   \                     ??Subroutine2_0: (+1)
   \        0x2   0x6094             STR      R4,[R2, #+8]
   \        0x4   0x22FF             MOVS     R2,#+255
   \        0x6   0x6803             LDR      R3,[R0, #+0]
   \        0x8   0x625A             STR      R2,[R3, #+36]
   \        0xA   0x2221             MOVS     R2,#+33
   \        0xC   0x5481             STRB     R1,[R0, R2]
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x2220             MOVS     R2,#+32
   \       0x12   0x5481             STRB     R1,[R0, R2]
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD10             POP      {R4,PC}          ;; return
    333          
    334          /**
    335            * @brief  Get the RTC TimeStamp value.
    336            * @param  hrtc RTC handle
    337            * @param  sTimeStamp Pointer to Time structure
    338            * @param  sTimeStampDate Pointer to Date structure
    339            * @param  Format specifies the format of the entered parameters.
    340            *          This parameter can be one of the following values:
    341            *             @arg RTC_FORMAT_BIN: Binary data format
    342            *             @arg RTC_FORMAT_BCD: BCD data format
    343            * @retval HAL status
    344            */

   \                                 In section .text, align 2, keep-with-next
    345          HAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTimeStamp, RTC_DateTypeDef *sTimeStampDate, uint32_t Format)
    346          {
   \                     HAL_RTCEx_GetTimeStamp: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
    347            uint32_t tmptime, tmpdate;
    348          
    349            /* Check the parameters */
    350            assert_param(IS_RTC_FORMAT(Format));
    351          
    352            /* Get the TimeStamp time and date registers values */
    353            tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
   \        0x8   0x6831             LDR      R1,[R6, #+0]
   \        0xA   0x6B0A             LDR      R2,[R1, #+48]
   \        0xC   0x....             LDR      R0,??DataTable7_1  ;; 0x7f7f7f
   \        0xE   0x4010             ANDS     R0,R0,R2
    354            tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);
   \       0x10   0x6B4A             LDR      R2,[R1, #+52]
   \       0x12   0x....             LDR      R1,??DataTable7_2  ;; 0xffff3f
   \       0x14   0x4011             ANDS     R1,R1,R2
    355          
    356            /* Fill the Time structure fields with the read parameters */
    357            sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
   \       0x16   0x0C02             LSRS     R2,R0,#+16
   \       0x18   0x0697             LSLS     R7,R2,#+26
   \       0x1A   0x0EBF             LSRS     R7,R7,#+26
   \       0x1C   0x7027             STRB     R7,[R4, #+0]
    358            sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
   \       0x1E   0x0A07             LSRS     R7,R0,#+8
   \       0x20   0x7067             STRB     R7,[R4, #+1]
    359            sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
   \       0x22   0x70A0             STRB     R0,[R4, #+2]
    360            sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16U);
   \       0x24   0x2040             MOVS     R0,#+64
   \       0x26   0x4002             ANDS     R2,R2,R0
   \       0x28   0x70E2             STRB     R2,[R4, #+3]
    361            sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;
   \       0x2A   0x6830             LDR      R0,[R6, #+0]
   \       0x2C   0x6B80             LDR      R0,[R0, #+56]
   \       0x2E   0x6060             STR      R0,[R4, #+4]
    362          
    363            /* Fill the Date structure fields with the read parameters */
    364            sTimeStampDate->Year = 0U;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x70E8             STRB     R0,[R5, #+3]
    365            sTimeStampDate->Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
   \       0x34   0x04C8             LSLS     R0,R1,#+19
   \       0x36   0x0EC0             LSRS     R0,R0,#+27
   \       0x38   0x7068             STRB     R0,[R5, #+1]
    366            sTimeStampDate->Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
   \       0x3A   0x70A9             STRB     R1,[R5, #+2]
    367            sTimeStampDate->WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13U);
   \       0x3C   0x0408             LSLS     R0,R1,#+16
   \       0x3E   0x0F40             LSRS     R0,R0,#+29
   \       0x40   0x7028             STRB     R0,[R5, #+0]
    368          
    369            /* Check the input parameters format */
    370            if (Format == RTC_FORMAT_BIN)
   \       0x42   0x2B00             CMP      R3,#+0
   \       0x44   0xD117             BNE      ??HAL_RTCEx_GetTimeStamp_0
    371            {
    372              /* Convert the TimeStamp structure parameters to Binary format */
    373              sTimeStamp->Hours = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Hours);
   \       0x46   0x7820             LDRB     R0,[R4, #+0]
   \       0x48   0x....'....        BL       RTC_Bcd2ToByte
   \       0x4C   0x7020             STRB     R0,[R4, #+0]
    374              sTimeStamp->Minutes = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Minutes);
   \       0x4E   0x7860             LDRB     R0,[R4, #+1]
   \       0x50   0x....'....        BL       RTC_Bcd2ToByte
   \       0x54   0x7060             STRB     R0,[R4, #+1]
    375              sTimeStamp->Seconds = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Seconds);
   \       0x56   0x78A0             LDRB     R0,[R4, #+2]
   \       0x58   0x....'....        BL       RTC_Bcd2ToByte
   \       0x5C   0x70A0             STRB     R0,[R4, #+2]
    376          
    377              /* Convert the DateTimeStamp structure parameters to Binary format */
    378              sTimeStampDate->Month = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Month);
   \       0x5E   0x7868             LDRB     R0,[R5, #+1]
   \       0x60   0x....'....        BL       RTC_Bcd2ToByte
   \       0x64   0x7068             STRB     R0,[R5, #+1]
    379              sTimeStampDate->Date = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Date);
   \       0x66   0x78A8             LDRB     R0,[R5, #+2]
   \       0x68   0x....'....        BL       RTC_Bcd2ToByte
   \       0x6C   0x70A8             STRB     R0,[R5, #+2]
    380              sTimeStampDate->WeekDay = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->WeekDay);
   \       0x6E   0x7828             LDRB     R0,[R5, #+0]
   \       0x70   0x....'....        BL       RTC_Bcd2ToByte
   \       0x74   0x7028             STRB     R0,[R5, #+0]
    381            }
    382          
    383            /* Clear the TIMESTAMP Flags */
    384            __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
   \                     ??HAL_RTCEx_GetTimeStamp_0: (+1)
   \       0x76   0x6830             LDR      R0,[R6, #+0]
   \       0x78   0x68C1             LDR      R1,[R0, #+12]
   \       0x7A   0x2280             MOVS     R2,#+128
   \       0x7C   0x4011             ANDS     R1,R1,R2
   \       0x7E   0x....             LDR      R2,??DataTable5  ;; 0xfffff77f
   \       0x80   0x430A             ORRS     R2,R2,R1
   \       0x82   0x60C2             STR      R2,[R0, #+12]
    385          
    386            return HAL_OK;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    387          }
    388          
    389          /**
    390            * @brief  Set Tamper
    391            * @note   By calling this API we disable the tamper interrupt for all tampers.
    392            * @param  hrtc RTC handle
    393            * @param  sTamper Pointer to Tamper Structure.
    394            * @retval HAL status
    395            */

   \                                 In section .text, align 2, keep-with-next
    396          HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef *sTamper)
    397          {
   \                     HAL_RTCEx_SetTamper: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    398            uint32_t tmpreg;
    399          
    400            /* Check the parameters */
    401            assert_param(IS_RTC_TAMPER(sTamper->Tamper));
    402            assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
    403            assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));
    404            assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));
    405            assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
    406            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));
    407            assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
    408            assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
    409            assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
    410          
    411            /* Process Locked */
    412            __HAL_LOCK(hrtc);
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x5C82             LDRB     R2,[R0, R2]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_SetTamper_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_RTCEx_SetTamper_0: (+1)
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x2420             MOVS     R4,#+32
   \       0x12   0x5502             STRB     R2,[R0, R4]
    413          
    414            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2302             MOVS     R3,#+2
   \       0x16   0x2421             MOVS     R4,#+33
   \       0x18   0x5503             STRB     R3,[R0, R4]
    415          
    416            /* Configure the tamper trigger */
    417            if (sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
   \       0x1A   0x680C             LDR      R4,[R1, #+0]
   \       0x1C   0x688B             LDR      R3,[R1, #+8]
   \       0x1E   0x2B00             CMP      R3,#+0
   \       0x20   0xD001             BEQ      ??HAL_RTCEx_SetTamper_1
    418            {
    419              sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1U);
   \       0x22   0x0063             LSLS     R3,R4,#+1
   \       0x24   0x608B             STR      R3,[R1, #+8]
   \                     ??HAL_RTCEx_SetTamper_1: (+1)
   \       0x26   0x68CE             LDR      R6,[R1, #+12]
    420            }
    421          
    422            if (sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x2508             MOVS     R5,#+8
   \       0x2C   0x2E00             CMP      R6,#+0
   \       0x2E   0xD008             BEQ      ??HAL_RTCEx_SetTamper_2
    423            {
    424              sTamper->NoErase = 0U;
   \       0x30   0x2600             MOVS     R6,#+0
    425          #if defined(RTC_TAMPER1_SUPPORT)
    426              if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)
   \       0x32   0x4214             TST      R4,R2
   \       0x34   0xD000             BEQ      ??HAL_RTCEx_SetTamper_3
    427              {
    428                sTamper->NoErase |= RTC_TAMPCR_TAMP1NOERASE;
   \       0x36   0x0456             LSLS     R6,R2,#+17
    429              }
    430          #endif /* RTC_TAMPER1_SUPPORT */
    431              if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)
   \                     ??HAL_RTCEx_SetTamper_3: (+1)
   \       0x38   0x422C             TST      R4,R5
   \       0x3A   0xD002             BEQ      ??HAL_RTCEx_SetTamper_2
    432              {
    433                sTamper->NoErase |= RTC_TAMPCR_TAMP2NOERASE;
   \       0x3C   0x0037             MOVS     R7,R6
   \       0x3E   0x0516             LSLS     R6,R2,#+20
   \       0x40   0x433E             ORRS     R6,R6,R7
   \                     ??HAL_RTCEx_SetTamper_2: (+1)
   \       0x42   0x60CE             STR      R6,[R1, #+12]
   \       0x44   0x690E             LDR      R6,[R1, #+16]
    434              }
    435          #if defined(RTC_TAMPER3_SUPPORT)
    436              if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)
    437              {
    438                sTamper->NoErase |= RTC_TAMPCR_TAMP3NOERASE;
    439              }
    440          #endif /* RTC_TAMPER3_SUPPORT */
    441            }
    442          
    443            if (sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)
   \       0x46   0x2E00             CMP      R6,#+0
   \       0x48   0xD008             BEQ      ??HAL_RTCEx_SetTamper_4
    444            {
    445              sTamper->MaskFlag = 0U;
   \       0x4A   0x2600             MOVS     R6,#+0
    446          #if defined(RTC_TAMPER1_SUPPORT)
    447              if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)
   \       0x4C   0x4214             TST      R4,R2
   \       0x4E   0xD000             BEQ      ??HAL_RTCEx_SetTamper_5
    448              {
    449                sTamper->MaskFlag |= RTC_TAMPCR_TAMP1MF;
   \       0x50   0x0496             LSLS     R6,R2,#+18
    450              }
    451          #endif /* RTC_TAMPER1_SUPPORT */
    452              if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)
   \                     ??HAL_RTCEx_SetTamper_5: (+1)
   \       0x52   0x4025             ANDS     R5,R5,R4
   \       0x54   0xD002             BEQ      ??HAL_RTCEx_SetTamper_4
    453              {
    454                sTamper->MaskFlag |= RTC_TAMPCR_TAMP2MF;
   \       0x56   0x0035             MOVS     R5,R6
   \       0x58   0x0556             LSLS     R6,R2,#+21
   \       0x5A   0x432E             ORRS     R6,R6,R5
   \                     ??HAL_RTCEx_SetTamper_4: (+1)
   \       0x5C   0x610E             STR      R6,[R1, #+16]
    455              }
    456          #if defined(RTC_TAMPER3_SUPPORT)
    457              if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)
    458              {
    459                sTamper->MaskFlag |= RTC_TAMPCR_TAMP3MF;
    460              }
    461          #endif /* RTC_TAMPER3_SUPPORT */
    462            }
    463          
    464            /* Configure the RTC_TAMPCR register */
    465            tmpreg = (uint32_t)((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase | \
    466                                (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency | \
    467                                (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | (uint32_t)sTamper->TimeStampOnTamperDetection);
   \       0x5E   0x688D             LDR      R5,[R1, #+8]
   \       0x60   0x4325             ORRS     R5,R5,R4
   \       0x62   0x68CE             LDR      R6,[R1, #+12]
   \       0x64   0x432E             ORRS     R6,R6,R5
   \       0x66   0x690D             LDR      R5,[R1, #+16]
   \       0x68   0x4335             ORRS     R5,R5,R6
   \       0x6A   0x694E             LDR      R6,[R1, #+20]
   \       0x6C   0x432E             ORRS     R6,R6,R5
   \       0x6E   0x698D             LDR      R5,[R1, #+24]
   \       0x70   0x4335             ORRS     R5,R5,R6
   \       0x72   0x69CE             LDR      R6,[R1, #+28]
   \       0x74   0x432E             ORRS     R6,R6,R5
   \       0x76   0x6A0D             LDR      R5,[R1, #+32]
   \       0x78   0x4335             ORRS     R5,R5,R6
   \       0x7A   0x6A49             LDR      R1,[R1, #+36]
   \       0x7C   0x4329             ORRS     R1,R1,R5
    468          
    469            hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | RTC_TAMPCR_MASK);
   \       0x7E   0x6805             LDR      R5,[R0, #+0]
   \       0x80   0x6C2F             LDR      R7,[R5, #+64]
   \       0x82   0x0066             LSLS     R6,R4,#+1
   \       0x84   0x4326             ORRS     R6,R6,R4
   \       0x86   0x....             LDR      R4,??DataTable11  ;; 0x3fff84
   \       0x88   0x4334             ORRS     R4,R4,R6
   \       0x8A   0x43A7             BICS     R7,R7,R4
   \       0x8C   0x642F             STR      R7,[R5, #+64]
    470          
    471            hrtc->Instance->TAMPCR |= tmpreg;
   \       0x8E   0x6804             LDR      R4,[R0, #+0]
   \       0x90   0x6C25             LDR      R5,[R4, #+64]
   \       0x92   0x4329             ORRS     R1,R1,R5
   \       0x94   0x6421             STR      R1,[R4, #+64]
    472          
    473            hrtc->State = HAL_RTC_STATE_READY;
   \       0x96   0x....             B.N      ?Subroutine1
    474          
    475            /* Process Unlocked */
    476            __HAL_UNLOCK(hrtc);
    477          
    478            return HAL_OK;
    479          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2121             MOVS     R1,#+33
   \        0x2   0x5442             STRB     R2,[R0, R1]
   \        0x4   0x2120             MOVS     R1,#+32
   \        0x6   0x5443             STRB     R3,[R0, R1]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBDF0             POP      {R4-R7,PC}       ;; return
    480          
    481          /**
    482            * @brief  Set Tamper with interrupt.
    483            * @note   By calling this API we force the tamper interrupt for all tampers.
    484            * @param  hrtc RTC handle
    485            * @param  sTamper Pointer to RTC Tamper.
    486            * @retval HAL status
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef *sTamper)
    489          {
   \                     HAL_RTCEx_SetTamper_IT: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    490            uint32_t tmpreg;
    491          
    492            /* Check the parameters */
    493            assert_param(IS_RTC_TAMPER(sTamper->Tamper));
    494            assert_param(IS_RTC_TAMPER_INTERRUPT(sTamper->Interrupt));
    495            assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
    496            assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));
    497            assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));
    498            assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
    499            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));
    500            assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
    501            assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
    502            assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
    503          
    504            /* Process Locked */
    505            __HAL_LOCK(hrtc);
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x5C82             LDRB     R2,[R0, R2]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_SetTamper_IT_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_RTCEx_SetTamper_IT_0: (+1)
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x2420             MOVS     R4,#+32
   \       0x12   0x5502             STRB     R2,[R0, R4]
    506          
    507            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2302             MOVS     R3,#+2
   \       0x16   0x2421             MOVS     R4,#+33
   \       0x18   0x5503             STRB     R3,[R0, R4]
    508          
    509            /* Configure the tamper trigger */
    510            if (sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
   \       0x1A   0x680C             LDR      R4,[R1, #+0]
   \       0x1C   0x688B             LDR      R3,[R1, #+8]
   \       0x1E   0x2B00             CMP      R3,#+0
   \       0x20   0xD001             BEQ      ??HAL_RTCEx_SetTamper_IT_1
    511            {
    512              sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1U);
   \       0x22   0x0063             LSLS     R3,R4,#+1
   \       0x24   0x608B             STR      R3,[R1, #+8]
   \                     ??HAL_RTCEx_SetTamper_IT_1: (+1)
   \       0x26   0x68CE             LDR      R6,[R1, #+12]
    513            }
    514          
    515            if (sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x2508             MOVS     R5,#+8
   \       0x2C   0x2E00             CMP      R6,#+0
   \       0x2E   0xD008             BEQ      ??HAL_RTCEx_SetTamper_IT_2
    516            {
    517              sTamper->NoErase = 0U;
   \       0x30   0x2600             MOVS     R6,#+0
    518          #if defined(RTC_TAMPER1_SUPPORT)
    519              if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)
   \       0x32   0x4214             TST      R4,R2
   \       0x34   0xD000             BEQ      ??HAL_RTCEx_SetTamper_IT_3
    520              {
    521                sTamper->NoErase |= RTC_TAMPCR_TAMP1NOERASE;
   \       0x36   0x0456             LSLS     R6,R2,#+17
    522              }
    523          #endif /* RTC_TAMPER1_SUPPORT */
    524              if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)
   \                     ??HAL_RTCEx_SetTamper_IT_3: (+1)
   \       0x38   0x422C             TST      R4,R5
   \       0x3A   0xD002             BEQ      ??HAL_RTCEx_SetTamper_IT_2
    525              {
    526                sTamper->NoErase |= RTC_TAMPCR_TAMP2NOERASE;
   \       0x3C   0x0037             MOVS     R7,R6
   \       0x3E   0x0516             LSLS     R6,R2,#+20
   \       0x40   0x433E             ORRS     R6,R6,R7
   \                     ??HAL_RTCEx_SetTamper_IT_2: (+1)
   \       0x42   0x60CE             STR      R6,[R1, #+12]
   \       0x44   0x690E             LDR      R6,[R1, #+16]
    527              }
    528          #if defined(RTC_TAMPER3_SUPPORT)
    529              if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)
    530              {
    531                sTamper->NoErase |= RTC_TAMPCR_TAMP3NOERASE;
    532              }
    533          #endif /* RTC_TAMPER3_SUPPORT */
    534            }
    535          
    536            if (sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)
   \       0x46   0x2E00             CMP      R6,#+0
   \       0x48   0xD008             BEQ      ??HAL_RTCEx_SetTamper_IT_4
    537            {
    538              sTamper->MaskFlag = 0U;
   \       0x4A   0x2600             MOVS     R6,#+0
    539          #if defined(RTC_TAMPER1_SUPPORT)
    540              if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)
   \       0x4C   0x4214             TST      R4,R2
   \       0x4E   0xD000             BEQ      ??HAL_RTCEx_SetTamper_IT_5
    541              {
    542                sTamper->MaskFlag |= RTC_TAMPCR_TAMP1MF;
   \       0x50   0x0496             LSLS     R6,R2,#+18
    543              }
    544          #endif /* RTC_TAMPER1_SUPPORT */
    545              if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)
   \                     ??HAL_RTCEx_SetTamper_IT_5: (+1)
   \       0x52   0x4025             ANDS     R5,R5,R4
   \       0x54   0xD002             BEQ      ??HAL_RTCEx_SetTamper_IT_4
    546              {
    547                sTamper->MaskFlag |= RTC_TAMPCR_TAMP2MF;
   \       0x56   0x0035             MOVS     R5,R6
   \       0x58   0x0556             LSLS     R6,R2,#+21
   \       0x5A   0x432E             ORRS     R6,R6,R5
   \                     ??HAL_RTCEx_SetTamper_IT_4: (+1)
   \       0x5C   0x610E             STR      R6,[R1, #+16]
    548              }
    549          #if defined(RTC_TAMPER3_SUPPORT)
    550              if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)
    551              {
    552                sTamper->MaskFlag |= RTC_TAMPCR_TAMP3MF;
    553              }
    554          #endif /* RTC_TAMPER3_SUPPORT */
    555            }
    556          
    557            /* Configure the RTC_TAMPCR register */
    558            tmpreg = (uint32_t)((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Interrupt | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase | \
    559                                (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency                                | \
    560                                (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | (uint32_t)sTamper->TimeStampOnTamperDetection);
   \       0x5E   0x684D             LDR      R5,[R1, #+4]
   \       0x60   0x4325             ORRS     R5,R5,R4
   \       0x62   0x688E             LDR      R6,[R1, #+8]
   \       0x64   0x432E             ORRS     R6,R6,R5
   \       0x66   0x68CD             LDR      R5,[R1, #+12]
   \       0x68   0x4335             ORRS     R5,R5,R6
   \       0x6A   0x690E             LDR      R6,[R1, #+16]
   \       0x6C   0x432E             ORRS     R6,R6,R5
   \       0x6E   0x694D             LDR      R5,[R1, #+20]
   \       0x70   0x4335             ORRS     R5,R5,R6
   \       0x72   0x698E             LDR      R6,[R1, #+24]
   \       0x74   0x432E             ORRS     R6,R6,R5
   \       0x76   0x69CD             LDR      R5,[R1, #+28]
   \       0x78   0x4335             ORRS     R5,R5,R6
   \       0x7A   0x6A0E             LDR      R6,[R1, #+32]
   \       0x7C   0x432E             ORRS     R6,R6,R5
   \       0x7E   0x6A49             LDR      R1,[R1, #+36]
   \       0x80   0x4331             ORRS     R1,R1,R6
    561          
    562            hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1) | RTC_TAMPCR_MASK);
   \       0x82   0x6805             LDR      R5,[R0, #+0]
   \       0x84   0x6C2F             LDR      R7,[R5, #+64]
   \       0x86   0x0066             LSLS     R6,R4,#+1
   \       0x88   0x4326             ORRS     R6,R6,R4
   \       0x8A   0x....             LDR      R4,??DataTable11  ;; 0x3fff84
   \       0x8C   0x4334             ORRS     R4,R4,R6
   \       0x8E   0x43A7             BICS     R7,R7,R4
   \       0x90   0x642F             STR      R7,[R5, #+64]
    563          
    564            hrtc->Instance->TAMPCR |= tmpreg;
   \       0x92   0x6804             LDR      R4,[R0, #+0]
   \       0x94   0x6C25             LDR      R5,[R4, #+64]
   \       0x96   0x4329             ORRS     R1,R1,R5
   \       0x98   0x6421             STR      R1,[R4, #+64]
    565          
    566            /* RTC Tamper Interrupt Configuration: EXTI configuration */
    567            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
   \       0x9A   0x04D1             LSLS     R1,R2,#+19
   \       0x9C   0x....             LDR      R4,??DataTable6_1  ;; 0x40010400
   \       0x9E   0x6825             LDR      R5,[R4, #+0]
   \       0xA0   0x430D             ORRS     R5,R5,R1
   \       0xA2   0x6025             STR      R5,[R4, #+0]
    568          
    569            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
   \       0xA4   0x68A5             LDR      R5,[R4, #+8]
   \       0xA6   0x4329             ORRS     R1,R1,R5
   \       0xA8   0x60A1             STR      R1,[R4, #+8]
    570          
    571            hrtc->State = HAL_RTC_STATE_READY;
   \       0xAA                      REQUIRE ?Subroutine1
   \       0xAA                      ;; // Fall through to label ?Subroutine1
    572          
    573            /* Process Unlocked */
    574            __HAL_UNLOCK(hrtc);
    575          
    576            return HAL_OK;
    577          }
    578          
    579          /**
    580            * @brief  Deactivate Tamper.
    581            * @param  hrtc RTC handle
    582            * @param  Tamper Selected tamper pin.
    583            *          This parameter can be any combination of RTC_TAMPER_1, RTC_TAMPER_2 and RTC_TAMPER_3.
    584            * @retval HAL status
    585            */

   \                                 In section .text, align 2, keep-with-next
    586          HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
    587          {
   \                     HAL_RTCEx_DeactivateTamper: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    588            assert_param(IS_RTC_TAMPER(Tamper));
    589          
    590            /* Process Locked */
    591            __HAL_LOCK(hrtc);
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x5C82             LDRB     R2,[R0, R2]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_DeactivateTamper_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD30             POP      {R4,R5,PC}
   \                     ??HAL_RTCEx_DeactivateTamper_0: (+1)
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x2420             MOVS     R4,#+32
   \       0x12   0x5502             STRB     R2,[R0, R4]
    592          
    593            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2302             MOVS     R3,#+2
   \       0x16   0x2421             MOVS     R4,#+33
   \       0x18   0x5503             STRB     R3,[R0, R4]
    594          
    595            /* Disable the selected Tamper pin */
    596            hrtc->Instance->TAMPCR &= ((uint32_t)~Tamper);
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0x6C1C             LDR      R4,[R3, #+64]
   \       0x1E   0x438C             BICS     R4,R4,R1
   \       0x20   0x641C             STR      R4,[R3, #+64]
    597          
    598          #if defined(RTC_TAMPER1_SUPPORT)
    599            if ((Tamper & RTC_TAMPER_1) != 0U)
   \       0x22   0x4211             TST      R1,R2
   \       0x24   0xD004             BEQ      ??HAL_RTCEx_DeactivateTamper_1
    600            {
    601              /* Disable the Tamper1 interrupt */
    602              hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP1));
   \       0x26   0x6803             LDR      R3,[R0, #+0]
   \       0x28   0x6C1C             LDR      R4,[R3, #+64]
   \       0x2A   0x....             LDR      R5,??DataTable11_1  ;; 0xfffefffb
   \       0x2C   0x4025             ANDS     R5,R5,R4
   \       0x2E   0x641D             STR      R5,[R3, #+64]
    603            }
    604          #endif /* RTC_TAMPER1_SUPPORT */
    605            if ((Tamper & RTC_TAMPER_2) != 0U)
   \                     ??HAL_RTCEx_DeactivateTamper_1: (+1)
   \       0x30   0x0709             LSLS     R1,R1,#+28
   \       0x32   0xD504             BPL      ??HAL_RTCEx_DeactivateTamper_2
    606            {
    607              /* Disable the Tamper2 interrupt */
    608              hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP2));
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0x6C0B             LDR      R3,[R1, #+64]
   \       0x38   0x....             LDR      R4,??DataTable12  ;; 0xfff7fffb
   \       0x3A   0x401C             ANDS     R4,R4,R3
   \       0x3C   0x640C             STR      R4,[R1, #+64]
    609            }
    610          #if defined(RTC_TAMPER3_SUPPORT)
    611            if ((Tamper & RTC_TAMPER_3) != 0U)
    612            {
    613              /* Disable the Tamper3 interrupt */
    614              hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP3));
    615            }
    616          
    617          #endif /* RTC_TAMPER3_SUPPORT */
    618          
    619            hrtc->State = HAL_RTC_STATE_READY;
   \                     ??HAL_RTCEx_DeactivateTamper_2: (+1)
   \       0x3E   0x....             B.N      ?Subroutine7
    620          
    621            /* Process Unlocked */
    622            __HAL_UNLOCK(hrtc);
    623          
    624            return HAL_OK;
    625          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2121             MOVS     R1,#+33
   \        0x2   0x5442             STRB     R2,[R0, R1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2220             MOVS     R2,#+32
   \        0x8   0x5481             STRB     R1,[R0, R2]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD30             POP      {R4,R5,PC}       ;; return
    626          
    627          /**
    628            * @brief  Handle TimeStamp interrupt request.
    629            * @param  hrtc RTC handle
    630            * @retval None
    631            */

   \                                 In section .text, align 2, keep-with-next
    632          void HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)
    633          {
   \                     HAL_RTCEx_TamperTimeStampIRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    634            /* Get the TimeStamp interrupt source enable status */
    635            if (__HAL_RTC_TIMESTAMP_GET_IT_SOURCE(hrtc, RTC_IT_TS) != 0U)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2580             MOVS     R5,#+128
   \        0x8   0x6881             LDR      R1,[R0, #+8]
   \        0xA   0x0409             LSLS     R1,R1,#+16
   \        0xC   0xD50B             BPL      ??HAL_RTCEx_TamperTimeStampIRQHandler_0
    636            {
    637              /* Get the pending status of the TIMESTAMP Interrupt */
    638              if (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) != 0U)
   \        0xE   0x68C0             LDR      R0,[R0, #+12]
   \       0x10   0x0500             LSLS     R0,R0,#+20
   \       0x12   0xD508             BPL      ??HAL_RTCEx_TamperTimeStampIRQHandler_0
    639              {
    640                /* TIMESTAMP callback */
    641          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    642                hrtc->TimeStampEventCallback(hrtc);
    643          #else
    644                HAL_RTCEx_TimeStampEventCallback(hrtc);
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x....'....        BL       HAL_RTCEx_TimeStampEventCallback
    645          #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
    646          
    647                /* Clear the TIMESTAMP interrupt pending bit */
    648                __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C1             LDR      R1,[R0, #+12]
   \       0x1E   0x4029             ANDS     R1,R1,R5
   \       0x20   0x....             LDR      R2,??DataTable12_1  ;; 0xfffff77f
   \       0x22   0x430A             ORRS     R2,R2,R1
   \       0x24   0x60C2             STR      R2,[R0, #+12]
    649              }
    650            }
    651          
    652          #if defined(RTC_TAMPER1_SUPPORT)
    653            /* Get the Tamper1 interrupts source enable status */
    654            if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP1) != 0U)
   \                     ??HAL_RTCEx_TamperTimeStampIRQHandler_0: (+1)
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6C01             LDR      R1,[R0, #+64]
   \       0x2A   0x....             LDR      R2,??DataTable12_2  ;; 0x10004
   \       0x2C   0x400A             ANDS     R2,R2,R1
   \       0x2E   0xD00B             BEQ      ??HAL_RTCEx_TamperTimeStampIRQHandler_1
    655            {
    656              /* Get the pending status of the Tamper1 Interrupt */
    657              if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != 0U)
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0x0480             LSLS     R0,R0,#+18
   \       0x34   0xD508             BPL      ??HAL_RTCEx_TamperTimeStampIRQHandler_1
    658              {
    659                /* Tamper1 callback */
    660          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    661                hrtc->Tamper1EventCallback(hrtc);
    662          #else
    663                HAL_RTCEx_Tamper1EventCallback(hrtc);
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x....'....        BL       HAL_RTCEx_Tamper1EventCallback
    664          #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
    665          
    666                /* Clear the Tamper1 interrupt pending bit */
    667                __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x68C1             LDR      R1,[R0, #+12]
   \       0x40   0x4029             ANDS     R1,R1,R5
   \       0x42   0x....             LDR      R2,??DataTable12_3  ;; 0xffffdf7f
   \       0x44   0x430A             ORRS     R2,R2,R1
   \       0x46   0x60C2             STR      R2,[R0, #+12]
    668              }
    669            }
    670          #endif /* RTC_TAMPER1_SUPPORT */
    671          
    672          
    673            /* Get the Tamper2 interrupts source enable status */
    674            if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP2) != 0U)
   \                     ??HAL_RTCEx_TamperTimeStampIRQHandler_1: (+1)
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6C01             LDR      R1,[R0, #+64]
   \       0x4C   0x....             LDR      R2,??DataTable12_4  ;; 0x80004
   \       0x4E   0x400A             ANDS     R2,R2,R1
   \       0x50   0xD00B             BEQ      ??HAL_RTCEx_TamperTimeStampIRQHandler_2
    675            {
    676              /* Get the pending status of the Tamper2 Interrupt */
    677              if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) != 0U)
   \       0x52   0x68C0             LDR      R0,[R0, #+12]
   \       0x54   0x0440             LSLS     R0,R0,#+17
   \       0x56   0xD508             BPL      ??HAL_RTCEx_TamperTimeStampIRQHandler_2
    678              {
    679                /* Tamper2 callback */
    680          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    681                hrtc->Tamper2EventCallback(hrtc);
    682          #else
    683                HAL_RTCEx_Tamper2EventCallback(hrtc);
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x....'....        BL       HAL_RTCEx_Tamper2EventCallback
    684          #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
    685          
    686                /* Clear the Tamper2 interrupt pending bit */
    687                __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x68C1             LDR      R1,[R0, #+12]
   \       0x62   0x400D             ANDS     R5,R5,R1
   \       0x64   0x....             LDR      R1,??DataTable12_5  ;; 0xffffbf7f
   \       0x66   0x4329             ORRS     R1,R1,R5
   \       0x68   0x60C1             STR      R1,[R0, #+12]
    688              }
    689            }
    690          
    691          #if defined(RTC_TAMPER3_SUPPORT)
    692            /* Get the Tamper3 interrupts source enable status */
    693            if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP3) != 0U)
    694            {
    695              /* Get the pending status of the Tamper3 Interrupt */
    696              if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) != 0U)
    697              {
    698                /* Tamper3 callback */
    699          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    700                hrtc->Tamper3EventCallback(hrtc);
    701          #else
    702                HAL_RTCEx_Tamper3EventCallback(hrtc);
    703          #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
    704          
    705                /* Clear the Tamper3 interrupt pending bit */
    706                __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
    707              }
    708            }
    709          #endif /* RTC_TAMPER3_SUPPORT */
    710          
    711            /* Clear the EXTI's Flag for RTC TimeStamp and Tamper */
    712            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();
   \                     ??HAL_RTCEx_TamperTimeStampIRQHandler_2: (+1)
   \       0x6A   0x2080             MOVS     R0,#+128
   \       0x6C   0x0300             LSLS     R0,R0,#+12       ;; #+524288
   \       0x6E   0x....             LDR      R1,??DataTable13  ;; 0x40010414
   \       0x70   0x6008             STR      R0,[R1, #+0]
    713          
    714            /* Change RTC state */
    715            hrtc->State = HAL_RTC_STATE_READY;
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x2121             MOVS     R1,#+33
   \       0x76   0x5460             STRB     R0,[R4, R1]
    716          }
   \       0x78   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    717          
    718          /**
    719            * @brief  TimeStamp callback.
    720            * @param  hrtc RTC handle
    721            * @retval None
    722            */

   \                                 In section .text, align 2
    723          __weak void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc)
    724          {
    725            /* Prevent unused argument(s) compilation warning */
    726            UNUSED(hrtc);
    727          
    728            /* NOTE : This function should not be modified, when the callback is needed,
    729                      the HAL_RTCEx_TimeStampEventCallback could be implemented in the user file
    730            */
    731          }
   \                     HAL_RTCEx_TimeStampEventCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    732          
    733          #if defined(RTC_TAMPER1_SUPPORT)
    734          /**
    735            * @brief  Tamper 1 callback.
    736            * @param  hrtc RTC handle
    737            * @retval None
    738            */

   \                                 In section .text, align 2
    739          __weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
    740          {
    741            /* Prevent unused argument(s) compilation warning */
    742            UNUSED(hrtc);
    743          
    744            /* NOTE : This function should not be modified, when the callback is needed,
    745                      the HAL_RTCEx_Tamper1EventCallback could be implemented in the user file
    746             */
    747          }
   \                     HAL_RTCEx_Tamper1EventCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    748          #endif /* RTC_TAMPER1_SUPPORT */
    749          
    750          /**
    751            * @brief  Tamper 2 callback.
    752            * @param  hrtc RTC handle
    753            * @retval None
    754            */

   \                                 In section .text, align 2
    755          __weak void HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc)
    756          {
    757            /* Prevent unused argument(s) compilation warning */
    758            UNUSED(hrtc);
    759          
    760            /* NOTE : This function should not be modified, when the callback is needed,
    761                      the HAL_RTCEx_Tamper2EventCallback could be implemented in the user file
    762             */
    763          }
   \                     HAL_RTCEx_Tamper2EventCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    764          
    765          #if defined(RTC_TAMPER3_SUPPORT)
    766          /**
    767            * @brief  Tamper 3 callback.
    768            * @param  hrtc RTC handle
    769            * @retval None
    770            */
    771          __weak void HAL_RTCEx_Tamper3EventCallback(RTC_HandleTypeDef *hrtc)
    772          {
    773            /* Prevent unused argument(s) compilation warning */
    774            UNUSED(hrtc);
    775          
    776            /* NOTE : This function should not be modified, when the callback is needed,
    777                      the HAL_RTCEx_Tamper3EventCallback could be implemented in the user file
    778             */
    779          }
    780          #endif /* RTC_TAMPER3_SUPPORT */
    781          
    782          /**
    783            * @brief  Handle TimeStamp polling request.
    784            * @param  hrtc RTC handle
    785            * @param  Timeout Timeout duration
    786            * @retval HAL status
    787            */

   \                                 In section .text, align 2, keep-with-next
    788          HAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
    789          {
   \                     HAL_RTCEx_PollForTimeStampEvent: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    790            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
    791          
    792            while (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == 0U)
   \                     ??HAL_RTCEx_PollForTimeStampEvent_0: (+1)
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x0509             LSLS     R1,R1,#+20
   \       0x12   0xD419             BMI      ??HAL_RTCEx_PollForTimeStampEvent_1
    793            {
    794              if (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != 0U)
   \       0x14   0x68C1             LDR      R1,[R0, #+12]
   \       0x16   0x04C9             LSLS     R1,R1,#+19
   \       0x18   0xD50A             BPL      ??HAL_RTCEx_PollForTimeStampEvent_2
    795              {
    796                /* Clear the TIMESTAMP OverRun Flag */
    797                __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
   \       0x1A   0x68C1             LDR      R1,[R0, #+12]
   \       0x1C   0x2280             MOVS     R2,#+128
   \       0x1E   0x4011             ANDS     R1,R1,R2
   \       0x20   0x....             LDR      R2,??DataTable14  ;; 0xffffef7f
   \       0x22   0x430A             ORRS     R2,R2,R1
   \       0x24   0x60C2             STR      R2,[R0, #+12]
    798          
    799                /* Change TIMESTAMP state */
    800                hrtc->State = HAL_RTC_STATE_ERROR;
   \       0x26   0x2004             MOVS     R0,#+4
   \       0x28   0x2121             MOVS     R1,#+33
   \       0x2A   0x5468             STRB     R0,[R5, R1]
    801          
    802                return HAL_ERROR;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
    803              }
    804          
    805              if (Timeout != HAL_MAX_DELAY)
   \                     ??HAL_RTCEx_PollForTimeStampEvent_2: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x34   0x4284             CMP      R4,R0
   \       0x36   0xD0E9             BEQ      ??HAL_RTCEx_PollForTimeStampEvent_0
    806              {
    807                if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x38   0x....'....        BL       HAL_GetTick
   \       0x3C   0x1B80             SUBS     R0,R0,R6
   \       0x3E   0x4284             CMP      R4,R0
   \       0x40   0xD301             BCC      ??HAL_RTCEx_PollForTimeStampEvent_3
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD1E2             BNE      ??HAL_RTCEx_PollForTimeStampEvent_0
    808                {
    809                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \                     ??HAL_RTCEx_PollForTimeStampEvent_3: (+1)
   \       0x46   0x....             B.N      ?Subroutine9
    810                  return HAL_TIMEOUT;
    811                }
    812              }
    813            }
    814          
    815            /* Change RTC state */
    816            hrtc->State = HAL_RTC_STATE_READY;
   \                     ??HAL_RTCEx_PollForTimeStampEvent_1: (+1)
   \       0x48   0x....             B.N      ??Subroutine8_0
    817          
    818            return HAL_OK;
    819          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x2003             MOVS     R0,#+3
   \        0x2   0x2121             MOVS     R1,#+33
   \        0x4   0x5468             STRB     R0,[R5, R1]
   \        0x6   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x430A             ORRS     R2,R2,R1
   \        0x2   0x60C2             STR      R2,[R0, #+12]
   \                     ??Subroutine8_0: (+1)
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x2121             MOVS     R1,#+33
   \        0x8   0x5468             STRB     R0,[R5, R1]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD70             POP      {R4-R6,PC}       ;; return
    820          
    821          #if defined(RTC_TAMPER1_SUPPORT)
    822          /**
    823            * @brief  Handle Tamper 1 Polling.
    824            * @param  hrtc RTC handle
    825            * @param  Timeout Timeout duration
    826            * @retval HAL status
    827            */

   \                                 In section .text, align 2, keep-with-next
    828          HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
    829          {
   \                     HAL_RTCEx_PollForTamper1Event: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    830            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
    831          
    832            /* Get the status of the Interrupt */
    833            while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) == 0U)
   \                     ??HAL_RTCEx_PollForTamper1Event_0: (+1)
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x0489             LSLS     R1,R1,#+18
   \       0x12   0xD40B             BMI      ??HAL_RTCEx_PollForTamper1Event_1
    834            {
    835              if (Timeout != HAL_MAX_DELAY)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD0F7             BEQ      ??HAL_RTCEx_PollForTamper1Event_0
    836              {
    837                if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x1C   0x....'....        BL       HAL_GetTick
   \       0x20   0x1B80             SUBS     R0,R0,R6
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD301             BCC      ??HAL_RTCEx_PollForTamper1Event_2
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD1F0             BNE      ??HAL_RTCEx_PollForTamper1Event_0
    838                {
    839                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \                     ??HAL_RTCEx_PollForTamper1Event_2: (+1)
   \       0x2A   0x....             B.N      ?Subroutine9
    840                  return HAL_TIMEOUT;
    841                }
    842              }
    843            }
    844          
    845            /* Clear the Tamper Flag */
    846            __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
   \                     ??HAL_RTCEx_PollForTamper1Event_1: (+1)
   \       0x2C   0x68C1             LDR      R1,[R0, #+12]
   \       0x2E   0x2280             MOVS     R2,#+128
   \       0x30   0x4011             ANDS     R1,R1,R2
   \       0x32   0x....             LDR      R2,??DataTable12_3  ;; 0xffffdf7f
   \       0x34   0x....             B.N      ?Subroutine8
    847          
    848            /* Change RTC state */
    849            hrtc->State = HAL_RTC_STATE_READY;
    850          
    851            return HAL_OK;
    852          }
    853          #endif /* RTC_TAMPER1_SUPPORT */
    854          
    855          /**
    856            * @brief  Handle Tamper 2 Polling.
    857            * @param  hrtc RTC handle
    858            * @param  Timeout Timeout duration
    859            * @retval HAL status
    860            */

   \                                 In section .text, align 2, keep-with-next
    861          HAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
    862          {
   \                     HAL_RTCEx_PollForTamper2Event: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    863            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
    864          
    865            /* Get the status of the Interrupt */
    866            while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == 0U)
   \                     ??HAL_RTCEx_PollForTamper2Event_0: (+1)
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x0449             LSLS     R1,R1,#+17
   \       0x12   0xD40B             BMI      ??HAL_RTCEx_PollForTamper2Event_1
    867            {
    868              if (Timeout != HAL_MAX_DELAY)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD0F7             BEQ      ??HAL_RTCEx_PollForTamper2Event_0
    869              {
    870                if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x1C   0x....'....        BL       HAL_GetTick
   \       0x20   0x1B80             SUBS     R0,R0,R6
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD301             BCC      ??HAL_RTCEx_PollForTamper2Event_2
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD1F0             BNE      ??HAL_RTCEx_PollForTamper2Event_0
    871                {
    872                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \                     ??HAL_RTCEx_PollForTamper2Event_2: (+1)
   \       0x2A   0x....             B.N      ?Subroutine9
    873                  return HAL_TIMEOUT;
    874                }
    875              }
    876            }
    877          
    878            /* Clear the Tamper Flag */
    879            __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
   \                     ??HAL_RTCEx_PollForTamper2Event_1: (+1)
   \       0x2C   0x68C1             LDR      R1,[R0, #+12]
   \       0x2E   0x2280             MOVS     R2,#+128
   \       0x30   0x4011             ANDS     R1,R1,R2
   \       0x32   0x....             LDR      R2,??DataTable12_5  ;; 0xffffbf7f
   \       0x34                      REQUIRE ?Subroutine8
   \       0x34                      ;; // Fall through to label ?Subroutine8
    880          
    881            /* Change RTC state */
    882            hrtc->State = HAL_RTC_STATE_READY;
    883          
    884            return HAL_OK;
    885          }
    886          
    887          #if defined(RTC_TAMPER3_SUPPORT)
    888          /**
    889            * @brief  Handle Tamper 3 Polling.
    890            * @param  hrtc RTC handle
    891            * @param  Timeout Timeout duration
    892            * @retval HAL status
    893            */
    894          HAL_StatusTypeDef HAL_RTCEx_PollForTamper3Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
    895          {
    896            uint32_t tickstart = HAL_GetTick();
    897          
    898            /* Get the status of the Interrupt */
    899            while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) == 0U)
    900            {
    901              if (Timeout != HAL_MAX_DELAY)
    902              {
    903                if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    904                {
    905                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
    906                  return HAL_TIMEOUT;
    907                }
    908              }
    909            }
    910          
    911            /* Clear the Tamper Flag */
    912            __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
    913          
    914            /* Change RTC state */
    915            hrtc->State = HAL_RTC_STATE_READY;
    916          
    917            return HAL_OK;
    918          }
    919          #endif /* RTC_TAMPER3_SUPPORT */
    920          
    921          /**
    922            * @}
    923            */
    924          
    925          /** @addtogroup RTCEx_Exported_Functions_Group2
    926            * @brief    RTC Wake-up functions
    927            *
    928          @verbatim
    929           ===============================================================================
    930                                  ##### RTC Wake-up functions #####
    931           ===============================================================================
    932          
    933           [..] This section provides functions allowing to configure Wake-up feature
    934          
    935          @endverbatim
    936            * @{
    937            */
    938          
    939          /**
    940            * @brief  Set wake up timer.
    941            * @param  hrtc RTC handle
    942            * @param  WakeUpCounter Wake up counter
    943            * @param  WakeUpClock Wake up clock
    944            * @retval HAL status
    945            */

   \                                 In section .text, align 2, keep-with-next
    946          HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
    947          {
   \                     HAL_RTCEx_SetWakeUpTimer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0016             MOVS     R6,R2
    948            uint32_t tickstart;
    949          
    950            /* Check the parameters */
    951            assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
    952            assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
    953          
    954            /* Process Locked */
    955            __HAL_LOCK(hrtc);
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_RTCEx_SetWakeUpTimer_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTCEx_SetWakeUpTimer_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x2120             MOVS     R1,#+32
   \       0x18   0x5460             STRB     R0,[R4, R1]
    956          
    957            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x2121             MOVS     R1,#+33
   \       0x1E   0x5460             STRB     R0,[R4, R1]
    958          
    959            /* Disable the write protection for RTC registers */
    960            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x20   0x20CA             MOVS     R0,#+202
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x6248             STR      R0,[R1, #+36]
   \       0x26   0x2053             MOVS     R0,#+83
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6248             STR      R0,[R1, #+36]
    961          
    962            /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
    963            if ((hrtc->Instance->CR & RTC_CR_WUTE) != 0U)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0x0540             LSLS     R0,R0,#+21
   \       0x32   0xD50D             BPL      ??HAL_RTCEx_SetWakeUpTimer_1
    964            {
    965              tickstart = HAL_GetTick();
   \       0x34   0x....'....        BL       HAL_GetTick
   \       0x38   0x0005             MOVS     R5,R0
    966          
    967              /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    968              while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 1U)
   \                     ??HAL_RTCEx_SetWakeUpTimer_2: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x68C0             LDR      R0,[R0, #+12]
   \       0x3E   0x0740             LSLS     R0,R0,#+29
   \       0x40   0xD506             BPL      ??HAL_RTCEx_SetWakeUpTimer_1
    969              {
    970                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x42   0x....'....        BL       HAL_GetTick
   \       0x46   0x1B40             SUBS     R0,R0,R5
   \       0x48   0x....             LDR      R1,??DataTable16  ;; 0x3e9
   \       0x4A   0x4288             CMP      R0,R1
   \       0x4C   0xD3F5             BCC      ??HAL_RTCEx_SetWakeUpTimer_2
   \       0x4E   0xE012             B        ??HAL_RTCEx_SetWakeUpTimer_3
    971                {
    972                  /* Enable the write protection for RTC registers */
    973                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    974          
    975                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
    976          
    977                  /* Process Unlocked */
    978                  __HAL_UNLOCK(hrtc);
    979          
    980                  return HAL_TIMEOUT;
    981                }
    982              }
    983            }
    984          
    985            __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
   \                     ??HAL_RTCEx_SetWakeUpTimer_1: (+1)
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6881             LDR      R1,[R0, #+8]
   \       0x54   0x....             LDR      R2,??DataTable16_1  ;; 0xfffffbff
   \       0x56   0x400A             ANDS     R2,R2,R1
   \       0x58   0x6082             STR      R2,[R0, #+8]
    986          
    987            tickstart = HAL_GetTick();
   \       0x5A   0x....'....        BL       HAL_GetTick
   \       0x5E   0x003D             MOVS     R5,R7
   \       0x60   0x0007             MOVS     R7,R0
    988          
    989            /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    990            while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)
   \                     ??HAL_RTCEx_SetWakeUpTimer_4: (+1)
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x68C1             LDR      R1,[R0, #+12]
   \       0x66   0x0749             LSLS     R1,R1,#+29
   \       0x68   0xD406             BMI      ??HAL_RTCEx_SetWakeUpTimer_5
    991            {
    992              if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x6A   0x....'....        BL       HAL_GetTick
   \       0x6E   0x1BC0             SUBS     R0,R0,R7
   \       0x70   0x....             LDR      R1,??DataTable16  ;; 0x3e9
   \       0x72   0x4288             CMP      R0,R1
   \       0x74   0xD3F5             BCC      ??HAL_RTCEx_SetWakeUpTimer_4
    993              {
    994                /* Enable the write protection for RTC registers */
    995                __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTCEx_SetWakeUpTimer_3: (+1)
   \       0x76   0x....             B.N      ?Subroutine5
    996          
    997                hrtc->State = HAL_RTC_STATE_TIMEOUT;
    998          
    999                /* Process Unlocked */
   1000                __HAL_UNLOCK(hrtc);
   1001          
   1002                return HAL_TIMEOUT;
   1003              }
   1004            }
   1005          
   1006            /* Clear the Wakeup Timer clock source bits in CR register */
   1007            hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   \                     ??HAL_RTCEx_SetWakeUpTimer_5: (+1)
   \       0x78   0x6881             LDR      R1,[R0, #+8]
   \       0x7A   0x2207             MOVS     R2,#+7
   \       0x7C   0x4391             BICS     R1,R1,R2
   \       0x7E   0x6081             STR      R1,[R0, #+8]
   1008          
   1009            /* Configure the clock source */
   1010            hrtc->Instance->CR |= (uint32_t)WakeUpClock;
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6881             LDR      R1,[R0, #+8]
   \       0x84   0x430E             ORRS     R6,R6,R1
   \       0x86   0x6086             STR      R6,[R0, #+8]
   1011          
   1012            /* Configure the Wakeup Timer counter */
   1013            hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6145             STR      R5,[R0, #+20]
   1014          
   1015            /* Enable the Wakeup Timer */
   1016            __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
   \       0x8C   0x....             B.N      ?Subroutine3
   1017          
   1018            /* Enable the write protection for RTC registers */
   1019            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1020          
   1021            hrtc->State = HAL_RTC_STATE_READY;
   1022          
   1023            /* Process Unlocked */
   1024            __HAL_UNLOCK(hrtc);
   1025          
   1026            return HAL_OK;
   1027          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x20FF             MOVS     R0,#+255
   \        0x2   0x6821             LDR      R1,[R4, #+0]
   \        0x4   0x6248             STR      R0,[R1, #+36]
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x2121             MOVS     R1,#+33
   \        0xA   0x5460             STRB     R0,[R4, R1]
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x2120             MOVS     R1,#+32
   \       0x10   0x5460             STRB     R0,[R4, R1]
   \       0x12   0x2003             MOVS     R0,#+3
   \       0x14   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6881             LDR      R1,[R0, #+8]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x6082             STR      R2,[R0, #+8]
   \        0xC   0x20FF             MOVS     R0,#+255
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x6248             STR      R0,[R1, #+36]
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x2121             MOVS     R1,#+33
   \       0x16   0x5460             STRB     R0,[R4, R1]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x2120             MOVS     R1,#+32
   \       0x1C   0x5460             STRB     R0,[R4, R1]
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1028          
   1029          /**
   1030            * @brief  Set wake up timer with interrupt.
   1031            * @param  hrtc RTC handle
   1032            * @param  WakeUpCounter Wake up counter
   1033            * @param  WakeUpClock Wake up clock
   1034            * @retval HAL status
   1035            */

   \                                 In section .text, align 2, keep-with-next
   1036          HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
   1037          {
   \                     HAL_RTCEx_SetWakeUpTimer_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0016             MOVS     R6,R2
   1038            uint32_t tickstart;
   1039          
   1040            /* Check the parameters */
   1041            assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
   1042            assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
   1043          
   1044            /* Process Locked */
   1045            __HAL_LOCK(hrtc);
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_RTCEx_SetWakeUpTimer_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTCEx_SetWakeUpTimer_IT_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x2120             MOVS     R1,#+32
   \       0x18   0x5460             STRB     R0,[R4, R1]
   1046          
   1047            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x2121             MOVS     R1,#+33
   \       0x1E   0x5460             STRB     R0,[R4, R1]
   1048          
   1049            /* Disable the write protection for RTC registers */
   1050            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x20   0x20CA             MOVS     R0,#+202
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x6248             STR      R0,[R1, #+36]
   \       0x26   0x2053             MOVS     R0,#+83
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6248             STR      R0,[R1, #+36]
   1051          
   1052            /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
   1053            if ((hrtc->Instance->CR & RTC_CR_WUTE) != 0U)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0x0540             LSLS     R0,R0,#+21
   \       0x32   0xD50D             BPL      ??HAL_RTCEx_SetWakeUpTimer_IT_1
   1054            {
   1055              tickstart = HAL_GetTick();
   \       0x34   0x....'....        BL       HAL_GetTick
   \       0x38   0x0005             MOVS     R5,R0
   1056          
   1057              /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
   1058              while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 1U)
   \                     ??HAL_RTCEx_SetWakeUpTimer_IT_2: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x68C0             LDR      R0,[R0, #+12]
   \       0x3E   0x0740             LSLS     R0,R0,#+29
   \       0x40   0xD506             BPL      ??HAL_RTCEx_SetWakeUpTimer_IT_1
   1059              {
   1060                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x42   0x....'....        BL       HAL_GetTick
   \       0x46   0x1B40             SUBS     R0,R0,R5
   \       0x48   0x....             LDR      R1,??DataTable16  ;; 0x3e9
   \       0x4A   0x4288             CMP      R0,R1
   \       0x4C   0xD3F5             BCC      ??HAL_RTCEx_SetWakeUpTimer_IT_2
   \       0x4E   0xE019             B        ??HAL_RTCEx_SetWakeUpTimer_IT_3
   1061                {
   1062                  /* Enable the write protection for RTC registers */
   1063                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1064          
   1065                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1066          
   1067                  /* Process Unlocked */
   1068                  __HAL_UNLOCK(hrtc);
   1069          
   1070                  return HAL_TIMEOUT;
   1071                }
   1072              }
   1073            }
   1074            /* Disable the Wake-Up timer */
   1075            __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
   \                     ??HAL_RTCEx_SetWakeUpTimer_IT_1: (+1)
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6881             LDR      R1,[R0, #+8]
   \       0x54   0x....             LDR      R2,??DataTable16_1  ;; 0xfffffbff
   \       0x56   0x400A             ANDS     R2,R2,R1
   \       0x58   0x6082             STR      R2,[R0, #+8]
   1076          
   1077            /* Clear flag Wake-Up */
   1078            __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x68C1             LDR      R1,[R0, #+12]
   \       0x5E   0x2280             MOVS     R2,#+128
   \       0x60   0x4011             ANDS     R1,R1,R2
   \       0x62   0x....             LDR      R2,??DataTable18  ;; 0xfffffb7f
   \       0x64   0x430A             ORRS     R2,R2,R1
   \       0x66   0x60C2             STR      R2,[R0, #+12]
   1079          
   1080            tickstart = HAL_GetTick();
   \       0x68   0x....'....        BL       HAL_GetTick
   \       0x6C   0x003D             MOVS     R5,R7
   \       0x6E   0x0007             MOVS     R7,R0
   1081          
   1082            /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1083            while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)
   \                     ??HAL_RTCEx_SetWakeUpTimer_IT_4: (+1)
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x68C1             LDR      R1,[R0, #+12]
   \       0x74   0x0749             LSLS     R1,R1,#+29
   \       0x76   0xD406             BMI      ??HAL_RTCEx_SetWakeUpTimer_IT_5
   1084            {
   1085              if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x78   0x....'....        BL       HAL_GetTick
   \       0x7C   0x1BC0             SUBS     R0,R0,R7
   \       0x7E   0x....             LDR      R1,??DataTable16  ;; 0x3e9
   \       0x80   0x4288             CMP      R0,R1
   \       0x82   0xD3F5             BCC      ??HAL_RTCEx_SetWakeUpTimer_IT_4
   1086              {
   1087                /* Enable the write protection for RTC registers */
   1088                __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTCEx_SetWakeUpTimer_IT_3: (+1)
   \       0x84   0x....             B.N      ?Subroutine5
   1089          
   1090                hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1091          
   1092                /* Process Unlocked */
   1093                __HAL_UNLOCK(hrtc);
   1094          
   1095                return HAL_TIMEOUT;
   1096              }
   1097            }
   1098          
   1099            /* Configure the Wakeup Timer counter */
   1100            hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
   \                     ??HAL_RTCEx_SetWakeUpTimer_IT_5: (+1)
   \       0x86   0x6145             STR      R5,[R0, #+20]
   1101          
   1102            /* Clear the Wakeup Timer clock source bits in CR register */
   1103            hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6881             LDR      R1,[R0, #+8]
   \       0x8C   0x2207             MOVS     R2,#+7
   \       0x8E   0x4391             BICS     R1,R1,R2
   \       0x90   0x6081             STR      R1,[R0, #+8]
   1104          
   1105            /* Configure the clock source */
   1106            hrtc->Instance->CR |= (uint32_t)WakeUpClock;
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6881             LDR      R1,[R0, #+8]
   \       0x96   0x430E             ORRS     R6,R6,R1
   \       0x98   0x6086             STR      R6,[R0, #+8]
   1107          
   1108            /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
   1109            __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
   \       0x9A   0x2080             MOVS     R0,#+128
   \       0x9C   0x0340             LSLS     R0,R0,#+13       ;; #+1048576
   \       0x9E   0x....             LDR      R1,??DataTable19  ;; 0x40010400
   \       0xA0   0x680A             LDR      R2,[R1, #+0]
   \       0xA2   0x4302             ORRS     R2,R2,R0
   \       0xA4   0x600A             STR      R2,[R1, #+0]
   1110          
   1111            __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();
   \       0xA6   0x688A             LDR      R2,[R1, #+8]
   \       0xA8   0x4310             ORRS     R0,R0,R2
   \       0xAA   0x6088             STR      R0,[R1, #+8]
   1112          
   1113            /* Configure the Interrupt in the RTC_CR register */
   1114            __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc, RTC_IT_WUT);
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x6881             LDR      R1,[R0, #+8]
   \       0xB0   0x2280             MOVS     R2,#+128
   \       0xB2   0x01D2             LSLS     R2,R2,#+7        ;; #+16384
   \       0xB4   0x430A             ORRS     R2,R2,R1
   \       0xB6   0x6082             STR      R2,[R0, #+8]
   1115          
   1116            /* Enable the Wakeup Timer */
   1117            __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
   \       0xB8   0x....             B.N      ?Subroutine3
   1118          
   1119            /* Enable the write protection for RTC registers */
   1120            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1121          
   1122            hrtc->State = HAL_RTC_STATE_READY;
   1123          
   1124            /* Process Unlocked */
   1125            __HAL_UNLOCK(hrtc);
   1126          
   1127            return HAL_OK;
   1128          }
   1129          
   1130          /**
   1131            * @brief  Deactivate wake up timer counter.
   1132            * @param  hrtc RTC handle
   1133            * @retval HAL status
   1134            */

   \                                 In section .text, align 2, keep-with-next
   1135          HAL_StatusTypeDef HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
   1136          {
   \                     HAL_RTCEx_DeactivateWakeUpTimer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1137            uint32_t tickstart;
   1138          
   1139            /* Process Locked */
   1140            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C28             LDRB     R0,[R5, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTCEx_DeactivateWakeUpTimer_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??HAL_RTCEx_DeactivateWakeUpTimer_0: (+1)
   \       0x10   0x2401             MOVS     R4,#+1
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0x542C             STRB     R4,[R5, R0]
   1141          
   1142            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2121             MOVS     R1,#+33
   \       0x1A   0x5468             STRB     R0,[R5, R1]
   1143          
   1144            /* Disable the write protection for RTC registers */
   1145            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1C   0x20CA             MOVS     R0,#+202
   \       0x1E   0x6829             LDR      R1,[R5, #+0]
   \       0x20   0x6248             STR      R0,[R1, #+36]
   \       0x22   0x2053             MOVS     R0,#+83
   \       0x24   0x6829             LDR      R1,[R5, #+0]
   \       0x26   0x6248             STR      R0,[R1, #+36]
   1146          
   1147            /* Disable the Wakeup Timer */
   1148            __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
   \       0x28   0x6828             LDR      R0,[R5, #+0]
   \       0x2A   0x6881             LDR      R1,[R0, #+8]
   \       0x2C   0x....             LDR      R2,??DataTable16_1  ;; 0xfffffbff
   \       0x2E   0x400A             ANDS     R2,R2,R1
   \       0x30   0x6082             STR      R2,[R0, #+8]
   1149          
   1150            /* In case of interrupt mode is used, the interrupt source must disabled */
   1151            __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc, RTC_IT_WUT);
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x6881             LDR      R1,[R0, #+8]
   \       0x36   0x....             LDR      R2,??DataTable19_1  ;; 0xffffbfff
   \       0x38   0x400A             ANDS     R2,R2,R1
   \       0x3A   0x6082             STR      R2,[R0, #+8]
   1152          
   1153            tickstart = HAL_GetTick();
   \       0x3C   0x....'....        BL       HAL_GetTick
   \       0x40   0x0006             MOVS     R6,R0
   1154            /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1155            while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)
   \                     ??HAL_RTCEx_DeactivateWakeUpTimer_1: (+1)
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0x68C1             LDR      R1,[R0, #+12]
   \       0x46   0x0749             LSLS     R1,R1,#+29
   \       0x48   0xD410             BMI      ??HAL_RTCEx_DeactivateWakeUpTimer_2
   1156            {
   1157              if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x4A   0x....'....        BL       HAL_GetTick
   \       0x4E   0x1B80             SUBS     R0,R0,R6
   \       0x50   0x....             LDR      R1,??DataTable17  ;; 0x3e9
   \       0x52   0x4288             CMP      R0,R1
   \       0x54   0xD3F5             BCC      ??HAL_RTCEx_DeactivateWakeUpTimer_1
   1158              {
   1159                /* Enable the write protection for RTC registers */
   1160                __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x56   0x20FF             MOVS     R0,#+255
   \       0x58   0x6829             LDR      R1,[R5, #+0]
   \       0x5A   0x6248             STR      R0,[R1, #+36]
   1161          
   1162                hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \       0x5C   0x2003             MOVS     R0,#+3
   \       0x5E   0x2121             MOVS     R1,#+33
   \       0x60   0x5468             STRB     R0,[R5, R1]
   1163          
   1164                /* Process Unlocked */
   1165                __HAL_UNLOCK(hrtc);
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x2120             MOVS     R1,#+32
   \       0x66   0x5468             STRB     R0,[R5, R1]
   1166          
   1167                return HAL_TIMEOUT;
   \       0x68   0x2003             MOVS     R0,#+3
   \       0x6A   0xBD70             POP      {R4-R6,PC}
   1168              }
   1169            }
   1170          
   1171            /* Enable the write protection for RTC registers */
   1172            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTCEx_DeactivateWakeUpTimer_2: (+1)
   \       0x6C   0x21FF             MOVS     R1,#+255
   \       0x6E   0x6241             STR      R1,[R0, #+36]
   1173          
   1174            hrtc->State = HAL_RTC_STATE_READY;
   \       0x70   0x2021             MOVS     R0,#+33
   \       0x72   0x542C             STRB     R4,[R5, R0]
   1175          
   1176            /* Process Unlocked */
   1177            __HAL_UNLOCK(hrtc);
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x2120             MOVS     R1,#+32
   \       0x78   0x5468             STRB     R0,[R5, R1]
   1178          
   1179            return HAL_OK;
   \       0x7A   0xBD70             POP      {R4-R6,PC}
   1180          }
   1181          
   1182          /**
   1183            * @brief  Get wake up timer counter.
   1184            * @param  hrtc RTC handle
   1185            * @retval Counter value
   1186            */

   \                                 In section .text, align 2, keep-with-next
   1187          uint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc)
   1188          {
   1189            /* Get the counter value */
   1190            return ((uint32_t)(hrtc->Instance->WUTR & RTC_WUTR_WUT));
   \                     HAL_RTCEx_GetWakeUpTimer: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x6940             LDR      R0,[R0, #+20]
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x4770             BX       LR               ;; return
   1191          }
   1192          
   1193          /**
   1194            * @brief  Handle Wake Up Timer interrupt request.
   1195            * @param  hrtc RTC handle
   1196            * @retval None
   1197            */

   \                                 In section .text, align 2, keep-with-next
   1198          void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
   1199          {
   \                     HAL_RTCEx_WakeUpTimerIRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1200            /* Get the pending status of the WAKEUPTIMER Interrupt */
   1201            if (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != 0U)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0x0540             LSLS     R0,R0,#+21
   \        0xA   0xD509             BPL      ??HAL_RTCEx_WakeUpTimerIRQHandler_0
   1202            {
   1203              /* WAKEUPTIMER callback */
   1204          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
   1205              hrtc->WakeUpTimerEventCallback(hrtc);
   1206          #else
   1207              HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x....'....        BL       HAL_RTCEx_WakeUpTimerEventCallback
   1208          #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
   1209          
   1210              /* Clear the WAKEUPTIMER interrupt pending bit */
   1211              __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C1             LDR      R1,[R0, #+12]
   \       0x16   0x2280             MOVS     R2,#+128
   \       0x18   0x4011             ANDS     R1,R1,R2
   \       0x1A   0x....             LDR      R2,??DataTable18  ;; 0xfffffb7f
   \       0x1C   0x430A             ORRS     R2,R2,R1
   \       0x1E   0x60C2             STR      R2,[R0, #+12]
   1212            }
   1213          
   1214            /* Clear the EXTI's line Flag for RTC WakeUpTimer */
   1215            __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
   \                     ??HAL_RTCEx_WakeUpTimerIRQHandler_0: (+1)
   \       0x20   0x2080             MOVS     R0,#+128
   \       0x22   0x0340             LSLS     R0,R0,#+13       ;; #+1048576
   \       0x24   0x....             LDR      R1,??DataTable19_2  ;; 0x40010414
   \       0x26   0x6008             STR      R0,[R1, #+0]
   1216          
   1217            /* Change RTC state */
   1218            hrtc->State = HAL_RTC_STATE_READY;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x2121             MOVS     R1,#+33
   \       0x2C   0x5460             STRB     R0,[R4, R1]
   1219          }
   \       0x2E   0xBD10             POP      {R4,PC}          ;; return
   1220          
   1221          /**
   1222            * @brief  Wake Up Timer callback.
   1223            * @param  hrtc RTC handle
   1224            * @retval None
   1225            */

   \                                 In section .text, align 2
   1226          __weak void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
   1227          {
   1228            /* Prevent unused argument(s) compilation warning */
   1229            UNUSED(hrtc);
   1230          
   1231            /* NOTE : This function should not be modified, when the callback is needed,
   1232                      the HAL_RTCEx_WakeUpTimerEventCallback could be implemented in the user file
   1233             */
   1234          }
   \                     HAL_RTCEx_WakeUpTimerEventCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1235          
   1236          
   1237          /**
   1238            * @brief  Handle Wake Up Timer Polling.
   1239            * @param  hrtc RTC handle
   1240            * @param  Timeout Timeout duration
   1241            * @retval HAL status
   1242            */

   \                                 In section .text, align 2, keep-with-next
   1243          HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
   1244          {
   \                     HAL_RTCEx_PollForWakeUpTimerEvent: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1245            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
   1246          
   1247            while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == 0U)
   \                     ??HAL_RTCEx_PollForWakeUpTimerEvent_0: (+1)
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x0549             LSLS     R1,R1,#+21
   \       0x12   0xD40B             BMI      ??HAL_RTCEx_PollForWakeUpTimerEvent_1
   1248            {
   1249              if (Timeout != HAL_MAX_DELAY)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD0F7             BEQ      ??HAL_RTCEx_PollForWakeUpTimerEvent_0
   1250              {
   1251                if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x1C   0x....'....        BL       HAL_GetTick
   \       0x20   0x1B80             SUBS     R0,R0,R6
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD301             BCC      ??HAL_RTCEx_PollForWakeUpTimerEvent_2
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD1F0             BNE      ??HAL_RTCEx_PollForWakeUpTimerEvent_0
   1252                {
   1253                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \                     ??HAL_RTCEx_PollForWakeUpTimerEvent_2: (+1)
   \       0x2A   0x....             B.N      ?Subroutine9
   1254          
   1255                  return HAL_TIMEOUT;
   1256                }
   1257              }
   1258            }
   1259          
   1260            /* Clear the WAKEUPTIMER Flag */
   1261            __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
   \                     ??HAL_RTCEx_PollForWakeUpTimerEvent_1: (+1)
   \       0x2C   0x68C1             LDR      R1,[R0, #+12]
   \       0x2E   0x2280             MOVS     R2,#+128
   \       0x30   0x4011             ANDS     R1,R1,R2
   \       0x32   0x....             LDR      R2,??DataTable18  ;; 0xfffffb7f
   \       0x34   0x....             B.N      ?Subroutine8
   1262          
   1263            /* Change RTC state */
   1264            hrtc->State = HAL_RTC_STATE_READY;
   1265          
   1266            return HAL_OK;
   1267          }
   1268          
   1269          /**
   1270            * @}
   1271            */
   1272          
   1273          
   1274          /** @addtogroup RTCEx_Exported_Functions_Group3
   1275            * @brief    Extended Peripheral Control functions
   1276            *
   1277          @verbatim
   1278           ===============================================================================
   1279                        ##### Extended Peripheral Control functions #####
   1280           ===============================================================================
   1281              [..]
   1282              This subsection provides functions allowing to
   1283                (+) Write a data in a specified RTC Backup data register
   1284                (+) Read a data in a specified RTC Backup data register
   1285                (+) Set the Coarse calibration parameters.
   1286                (+) Deactivate the Coarse calibration parameters
   1287                (+) Set the Smooth calibration parameters.
   1288                (+) Configure the Synchronization Shift Control Settings.
   1289                (+) Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1290                (+) Deactivate the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1291                (+) Enable the RTC reference clock detection.
   1292                (+) Disable the RTC reference clock detection.
   1293                (+) Enable the Bypass Shadow feature.
   1294                (+) Disable the Bypass Shadow feature.
   1295          
   1296          @endverbatim
   1297            * @{
   1298            */
   1299          
   1300          /**
   1301            * @brief  Write a data in a specified RTC Backup data register.
   1302            * @param  hrtc RTC handle
   1303            * @param  BackupRegister RTC Backup data Register number.
   1304            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to
   1305            *                                 specify the register.
   1306            * @param  Data Data to be written in the specified RTC Backup data register.
   1307            * @retval None
   1308            */

   \                                 In section .text, align 2, keep-with-next
   1309          void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
   1310          {
   1311            uint32_t tmp;
   1312          
   1313            /* Check the parameters */
   1314            assert_param(IS_RTC_BKP(BackupRegister));
   1315          
   1316            tmp = (uint32_t) & (hrtc->Instance->BKP0R);
   1317            tmp += (BackupRegister * 4U);
   1318          
   1319            /* Write the specified register */
   1320            *(__IO uint32_t *)tmp = (uint32_t)Data;
   \                     HAL_RTCEx_BKUPWrite: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x3050             ADDS     R0,R0,#+80
   \        0x4   0x0089             LSLS     R1,R1,#+2
   \        0x6   0x1840             ADDS     R0,R0,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
   1321          }
   \        0xA   0x4770             BX       LR               ;; return
   1322          
   1323          /**
   1324            * @brief  Reads data from the specified RTC Backup data Register.
   1325            * @param  hrtc RTC handle
   1326            * @param  BackupRegister RTC Backup data Register number.
   1327            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to
   1328            *                                 specify the register.
   1329            * @retval Read value
   1330            */

   \                                 In section .text, align 2, keep-with-next
   1331          uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
   1332          {
   1333            uint32_t tmp;
   1334          
   1335            /* Check the parameters */
   1336            assert_param(IS_RTC_BKP(BackupRegister));
   1337          
   1338            tmp = (uint32_t) & (hrtc->Instance->BKP0R);
   1339            tmp += (BackupRegister * 4U);
   1340          
   1341            /* Read the specified register */
   1342            return (*(__IO uint32_t *)tmp);
   \                     HAL_RTCEx_BKUPRead: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x3050             ADDS     R0,R0,#+80
   \        0x4   0x0089             LSLS     R1,R1,#+2
   \        0x6   0x1840             ADDS     R0,R0,R1
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x4770             BX       LR               ;; return
   1343          }
   1344          
   1345          /**
   1346            * @brief  Set the Smooth calibration parameters.
   1347            * @param  hrtc RTC handle
   1348            * @param  SmoothCalibPeriod Select the Smooth Calibration Period.
   1349            *          This parameter can be can be one of the following values :
   1350            *             @arg RTC_SMOOTHCALIB_PERIOD_32SEC: The smooth calibration period is 32s.
   1351            *             @arg RTC_SMOOTHCALIB_PERIOD_16SEC: The smooth calibration period is 16s.
   1352            *             @arg RTC_SMOOTHCALIB_PERIOD_8SEC: The smooth calibration period is 8s.
   1353            * @param  SmoothCalibPlusPulses Select to Set or reset the CALP bit.
   1354            *          This parameter can be one of the following values:
   1355            *             @arg RTC_SMOOTHCALIB_PLUSPULSES_SET: Add one RTCCLK pulse every 2*11 pulses.
   1356            *             @arg RTC_SMOOTHCALIB_PLUSPULSES_RESET: No RTCCLK pulses are added.
   1357            * @param  SmoothCalibMinusPulsesValue Select the value of CALM[8:0] bits.
   1358            *          This parameter can be one any value from 0 to 0x000001FF.
   1359            * @note   To deactivate the smooth calibration, the field SmoothCalibPlusPulses
   1360            *         must be equal to SMOOTHCALIB_PLUSPULSES_RESET and the field
   1361            *         SmoothCalibMinusPulsesValue mut be equal to 0.
   1362            * @retval HAL status
   1363            */

   \                                 In section .text, align 2, keep-with-next
   1364          HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef *hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmoothCalibMinusPulsesValue)
   1365          {
   \                     HAL_RTCEx_SetSmoothCalib: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1366            uint32_t tickstart;
   1367          
   1368            /* Check the parameters */
   1369            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
   1370            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
   1371            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));
   1372          
   1373            /* Process Locked */
   1374            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C28             LDRB     R0,[R5, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTCEx_SetSmoothCalib_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_RTCEx_SetSmoothCalib_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x2120             MOVS     R1,#+32
   \       0x14   0x5468             STRB     R0,[R5, R1]
   1375          
   1376            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2121             MOVS     R1,#+33
   \       0x1A   0x5468             STRB     R0,[R5, R1]
   1377          
   1378            /* Disable the write protection for RTC registers */
   1379            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1C   0x20CA             MOVS     R0,#+202
   \       0x1E   0x6829             LDR      R1,[R5, #+0]
   \       0x20   0x6248             STR      R0,[R1, #+36]
   \       0x22   0x2053             MOVS     R0,#+83
   \       0x24   0x6829             LDR      R1,[R5, #+0]
   \       0x26   0x6248             STR      R0,[R1, #+36]
   1380          
   1381            /* check if a calibration is pending*/
   1382            if ((hrtc->Instance->ISR & RTC_ISR_RECALPF) != 0U)
   \       0x28   0x27FF             MOVS     R7,#+255
   \       0x2A   0x2400             MOVS     R4,#+0
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x68C0             LDR      R0,[R0, #+12]
   \       0x30   0x03C0             LSLS     R0,R0,#+15
   \       0x32   0xD515             BPL      ??HAL_RTCEx_SetSmoothCalib_1
   1383            {
   1384              tickstart = HAL_GetTick();
   \       0x34   0x....'....        BL       HAL_GetTick
   \       0x38   0x0006             MOVS     R6,R0
   1385          
   1386              /* check if a calibration is pending*/
   1387              while ((hrtc->Instance->ISR & RTC_ISR_RECALPF) != 0U)
   \                     ??HAL_RTCEx_SetSmoothCalib_2: (+1)
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x68C0             LDR      R0,[R0, #+12]
   \       0x3E   0x03C0             LSLS     R0,R0,#+15
   \       0x40   0xD50E             BPL      ??HAL_RTCEx_SetSmoothCalib_1
   1388              {
   1389                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x42   0x....'....        BL       HAL_GetTick
   \       0x46   0x1B80             SUBS     R0,R0,R6
   \       0x48   0x....             LDR      R1,??DataTable17  ;; 0x3e9
   \       0x4A   0x4288             CMP      R0,R1
   \       0x4C   0xD3F5             BCC      ??HAL_RTCEx_SetSmoothCalib_2
   1390                {
   1391                  /* Enable the write protection for RTC registers */
   1392                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x6247             STR      R7,[R0, #+36]
   1393          
   1394                  /* Change RTC state */
   1395                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0x2121             MOVS     R1,#+33
   \       0x56   0x5468             STRB     R0,[R5, R1]
   1396          
   1397                  /* Process Unlocked */
   1398                  __HAL_UNLOCK(hrtc);
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0x542C             STRB     R4,[R5, R0]
   1399          
   1400                  return HAL_TIMEOUT;
   \       0x5C   0x2003             MOVS     R0,#+3
   \       0x5E   0xBDFE             POP      {R1-R7,PC}
   1401                }
   1402              }
   1403            }
   \                     ??HAL_RTCEx_SetSmoothCalib_1: (+1)
   \       0x60   0x9A02             LDR      R2,[SP, #+8]
   \       0x62   0x9901             LDR      R1,[SP, #+4]
   \       0x64   0x9800             LDR      R0,[SP, #+0]
   1404          
   1405            /* Configure the Smooth calibration settings */
   1406            hrtc->Instance->CALR = (uint32_t)((uint32_t)SmoothCalibPeriod | (uint32_t)SmoothCalibPlusPulses | (uint32_t)SmoothCalibMinusPulsesValue);
   \       0x66   0x4301             ORRS     R1,R1,R0
   \       0x68   0x430A             ORRS     R2,R2,R1
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x63C2             STR      R2,[R0, #+60]
   1407          
   1408            /* Enable the write protection for RTC registers */
   1409            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x6E   0x6828             LDR      R0,[R5, #+0]
   \       0x70   0x6247             STR      R7,[R0, #+36]
   1410          
   1411            /* Change RTC state */
   1412            hrtc->State = HAL_RTC_STATE_READY;
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x2121             MOVS     R1,#+33
   \       0x76   0x5468             STRB     R0,[R5, R1]
   1413          
   1414            /* Process Unlocked */
   1415            __HAL_UNLOCK(hrtc);
   \       0x78   0x2020             MOVS     R0,#+32
   \       0x7A   0x542C             STRB     R4,[R5, R0]
   1416          
   1417            return HAL_OK;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xBDFE             POP      {R1-R7,PC}       ;; return
   1418          }
   1419          
   1420          /**
   1421            * @brief  Configure the Synchronization Shift Control Settings.
   1422            * @note   When REFCKON is set, firmware must not write to Shift control register.
   1423            * @param  hrtc RTC handle
   1424            * @param  ShiftAdd1S Select to add or not 1 second to the time calendar.
   1425            *          This parameter can be one of the following values :
   1426            *             @arg RTC_SHIFTADD1S_SET: Add one second to the clock calendar.
   1427            *             @arg RTC_SHIFTADD1S_RESET: No effect.
   1428            * @param  ShiftSubFS Select the number of Second Fractions to substitute.
   1429            *          This parameter can be one any value from 0 to 0x7FFF.
   1430            * @retval HAL status
   1431            */

   \                                 In section .text, align 2, keep-with-next
   1432          HAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef *hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS)
   1433          {
   \                     HAL_RTCEx_SetSynchroShift: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1434            uint32_t tickstart;
   1435          
   1436            /* Check the parameters */
   1437            assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
   1438            assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));
   1439          
   1440            /* Process Locked */
   1441            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTCEx_SetSynchroShift_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_RTCEx_SetSynchroShift_0: (+1)
   \       0x10   0x2701             MOVS     R7,#+1
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0x5427             STRB     R7,[R4, R0]
   1442          
   1443            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2121             MOVS     R1,#+33
   \       0x1A   0x5460             STRB     R0,[R4, R1]
   1444          
   1445            /* Disable the write protection for RTC registers */
   1446            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1C   0x20CA             MOVS     R0,#+202
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x6248             STR      R0,[R1, #+36]
   \       0x22   0x2053             MOVS     R0,#+83
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x6248             STR      R0,[R1, #+36]
   1447          
   1448            tickstart = HAL_GetTick();
   \       0x28   0x....'....        BL       HAL_GetTick
   \       0x2C   0x0005             MOVS     R5,R0
   1449          
   1450            /* Wait until the shift is completed*/
   1451            while ((hrtc->Instance->ISR & RTC_ISR_SHPF) != 0U)
   \                     ??HAL_RTCEx_SetSynchroShift_1: (+1)
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68C1             LDR      R1,[R0, #+12]
   \       0x32   0x0709             LSLS     R1,R1,#+28
   \       0x34   0xD510             BPL      ??HAL_RTCEx_SetSynchroShift_2
   1452            {
   1453              if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x36   0x....'....        BL       HAL_GetTick
   \       0x3A   0x1B40             SUBS     R0,R0,R5
   \       0x3C   0x....             LDR      R1,??DataTable17  ;; 0x3e9
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD3F5             BCC      ??HAL_RTCEx_SetSynchroShift_1
   1454              {
   1455                /* Enable the write protection for RTC registers */
   1456                __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x42   0x20FF             MOVS     R0,#+255
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x6248             STR      R0,[R1, #+36]
   1457          
   1458                hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \       0x48   0x2003             MOVS     R0,#+3
   \       0x4A   0x2121             MOVS     R1,#+33
   \       0x4C   0x5460             STRB     R0,[R4, R1]
   1459          
   1460                /* Process Unlocked */
   1461                __HAL_UNLOCK(hrtc);
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x2120             MOVS     R1,#+32
   \       0x52   0x5460             STRB     R0,[R4, R1]
   1462          
   1463                return HAL_TIMEOUT;
   \       0x54   0x2003             MOVS     R0,#+3
   \       0x56   0xBDFE             POP      {R1-R7,PC}
   1464              }
   1465            }
   1466          
   1467            /* Check if the reference clock detection is disabled */
   1468            if ((hrtc->Instance->CR & RTC_CR_REFCKON) == 0U)
   \                     ??HAL_RTCEx_SetSynchroShift_2: (+1)
   \       0x58   0x25FF             MOVS     R5,#+255
   \       0x5A   0x2600             MOVS     R6,#+0
   \       0x5C   0x6881             LDR      R1,[R0, #+8]
   \       0x5E   0x06C9             LSLS     R1,R1,#+27
   \       0x60   0xD414             BMI      ??HAL_RTCEx_SetSynchroShift_3
   \       0x62   0x9A02             LDR      R2,[SP, #+8]
   \       0x64   0x9901             LDR      R1,[SP, #+4]
   1469            {
   1470              /* Configure the Shift settings */
   1471              hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);
   \       0x66   0x4311             ORRS     R1,R1,R2
   \       0x68   0x62C1             STR      R1,[R0, #+44]
   1472          
   1473              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
   1474              if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6880             LDR      R0,[R0, #+8]
   \       0x6E   0x0680             LSLS     R0,R0,#+26
   \       0x70   0xD404             BMI      ??HAL_RTCEx_SetSynchroShift_4
   1475              {
   1476                if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x....'....        BL       HAL_RTC_WaitForSynchro
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD107             BNE      ??HAL_RTCEx_SetSynchroShift_3
   1477                {
   1478                  /* Enable the write protection for RTC registers */
   1479                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1480          
   1481                  hrtc->State = HAL_RTC_STATE_ERROR;
   1482          
   1483                  /* Process Unlocked */
   1484                  __HAL_UNLOCK(hrtc);
   1485          
   1486                  return HAL_ERROR;
   1487                }
   1488              }
   1489            }
   1490            else
   1491            {
   1492              /* Enable the write protection for RTC registers */
   1493              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1494          
   1495              /* Change RTC state */
   1496              hrtc->State = HAL_RTC_STATE_ERROR;
   1497          
   1498              /* Process Unlocked */
   1499              __HAL_UNLOCK(hrtc);
   1500          
   1501              return HAL_ERROR;
   1502            }
   1503          
   1504            /* Enable the write protection for RTC registers */
   1505            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTCEx_SetSynchroShift_4: (+1)
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6245             STR      R5,[R0, #+36]
   1506          
   1507            /* Change RTC state */
   1508            hrtc->State = HAL_RTC_STATE_READY;
   \       0x80   0x2021             MOVS     R0,#+33
   \       0x82   0x5427             STRB     R7,[R4, R0]
   1509          
   1510            /* Process Unlocked */
   1511            __HAL_UNLOCK(hrtc);
   \       0x84   0x2020             MOVS     R0,#+32
   \       0x86   0x5426             STRB     R6,[R4, R0]
   1512          
   1513            return HAL_OK;
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_RTCEx_SetSynchroShift_3: (+1)
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6245             STR      R5,[R0, #+36]
   \       0x90   0x2004             MOVS     R0,#+4
   \       0x92   0x2121             MOVS     R1,#+33
   \       0x94   0x5460             STRB     R0,[R4, R1]
   \       0x96   0x2020             MOVS     R0,#+32
   \       0x98   0x5426             STRB     R6,[R4, R0]
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xBDFE             POP      {R1-R7,PC}       ;; return
   1514          }
   1515          
   1516          /**
   1517            * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1518            * @param  hrtc RTC handle
   1519            * @param  CalibOutput : Select the Calibration output Selection .
   1520            *          This parameter can be one of the following values:
   1521            *             @arg RTC_CALIBOUTPUT_512HZ: A signal has a regular waveform at 512Hz.
   1522            *             @arg RTC_CALIBOUTPUT_1HZ: A signal has a regular waveform at 1Hz.
   1523            * @retval HAL status
   1524            */

   \                                 In section .text, align 2, keep-with-next
   1525          HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef *hrtc, uint32_t CalibOutput)
   1526          {
   \                     HAL_RTCEx_SetCalibrationOutPut: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   1527            /* Check the parameters */
   1528            assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));
   1529          
   1530            /* Process Locked */
   1531            __HAL_LOCK(hrtc);
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x5C82             LDRB     R2,[R0, R2]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_SetCalibrationOutPut_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD30             POP      {R4,R5,PC}
   \                     ??HAL_RTCEx_SetCalibrationOutPut_0: (+1)
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x2320             MOVS     R3,#+32
   \       0x12   0x54C2             STRB     R2,[R0, R3]
   1532          
   1533            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2302             MOVS     R3,#+2
   \       0x16   0x2421             MOVS     R4,#+33
   \       0x18   0x5503             STRB     R3,[R0, R4]
   1534          
   1535            /* Disable the write protection for RTC registers */
   1536            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1A   0x23CA             MOVS     R3,#+202
   \       0x1C   0x6804             LDR      R4,[R0, #+0]
   \       0x1E   0x6263             STR      R3,[R4, #+36]
   \       0x20   0x2353             MOVS     R3,#+83
   \       0x22   0x6804             LDR      R4,[R0, #+0]
   \       0x24   0x6263             STR      R3,[R4, #+36]
   1537          
   1538            /* Clear flags before config */
   1539            hrtc->Instance->CR &= (uint32_t)~RTC_CR_COSEL;
   \       0x26   0x6803             LDR      R3,[R0, #+0]
   \       0x28   0x689C             LDR      R4,[R3, #+8]
   \       0x2A   0x....             LDR      R5,??DataTable20  ;; 0xfff7ffff
   \       0x2C   0x4025             ANDS     R5,R5,R4
   \       0x2E   0x609D             STR      R5,[R3, #+8]
   1540          
   1541            /* Configure the RTC_CR register */
   1542            hrtc->Instance->CR |= (uint32_t)CalibOutput;
   \       0x30   0x6803             LDR      R3,[R0, #+0]
   \       0x32   0x689C             LDR      R4,[R3, #+8]
   \       0x34   0x4321             ORRS     R1,R1,R4
   \       0x36   0x6099             STR      R1,[R3, #+8]
   1543          
   1544            __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x688B             LDR      R3,[R1, #+8]
   \       0x3C   0x05D4             LSLS     R4,R2,#+23
   \       0x3E   0x431C             ORRS     R4,R4,R3
   \       0x40   0x608C             STR      R4,[R1, #+8]
   1545          
   1546            /* Enable the write protection for RTC registers */
   1547            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x42   0x21FF             MOVS     R1,#+255
   \       0x44   0x6803             LDR      R3,[R0, #+0]
   \       0x46   0x6259             STR      R1,[R3, #+36]
   1548          
   1549            /* Change RTC state */
   1550            hrtc->State = HAL_RTC_STATE_READY;
   \       0x48                      REQUIRE ?Subroutine7
   \       0x48                      ;; // Fall through to label ?Subroutine7
   1551          
   1552            /* Process Unlocked */
   1553            __HAL_UNLOCK(hrtc);
   1554          
   1555            return HAL_OK;
   1556          }
   1557          
   1558          /**
   1559            * @brief  Deactivate the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1560            * @param  hrtc RTC handle
   1561            * @retval HAL status
   1562            */

   \                                 In section .text, align 2, keep-with-next
   1563          HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef *hrtc)
   1564          {
   \                     HAL_RTCEx_DeactivateCalibrationOutPut: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1565            /* Process Locked */
   1566            __HAL_LOCK(hrtc);
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x5C41             LDRB     R1,[R0, R1]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_DeactivateCalibrationOutPut_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD10             POP      {R4,PC}
   \                     ??HAL_RTCEx_DeactivateCalibrationOutPut_0: (+1)
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x2220             MOVS     R2,#+32
   \       0x12   0x5481             STRB     R1,[R0, R2]
   1567          
   1568            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2202             MOVS     R2,#+2
   \       0x16   0x2321             MOVS     R3,#+33
   \       0x18   0x54C2             STRB     R2,[R0, R3]
   1569          
   1570            /* Disable the write protection for RTC registers */
   1571            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1A   0x22CA             MOVS     R2,#+202
   \       0x1C   0x6803             LDR      R3,[R0, #+0]
   \       0x1E   0x625A             STR      R2,[R3, #+36]
   \       0x20   0x2253             MOVS     R2,#+83
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0x625A             STR      R2,[R3, #+36]
   1572          
   1573            __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6893             LDR      R3,[R2, #+8]
   \       0x2A   0x....             LDR      R4,??DataTable20_1  ;; 0xff7fffff
   \       0x2C                      REQUIRE ?Subroutine2
   \       0x2C                      ;; // Fall through to label ?Subroutine2
   1574          
   1575            /* Enable the write protection for RTC registers */
   1576            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1577          
   1578            /* Change RTC state */
   1579            hrtc->State = HAL_RTC_STATE_READY;
   1580          
   1581            /* Process Unlocked */
   1582            __HAL_UNLOCK(hrtc);
   1583          
   1584            return HAL_OK;
   1585          }
   1586          
   1587          /**
   1588            * @brief  Enable the RTC reference clock detection.
   1589            * @param  hrtc RTC handle
   1590            * @retval HAL status
   1591            */

   \                                 In section .text, align 2, keep-with-next
   1592          HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef *hrtc)
   1593          {
   \                     HAL_RTCEx_SetRefClock: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1594            /* Process Locked */
   1595            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTCEx_SetRefClock_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTCEx_SetRefClock_0: (+1)
   \       0x10   0x2701             MOVS     R7,#+1
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0x5427             STRB     R7,[R4, R0]
   1596          
   1597            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2121             MOVS     R1,#+33
   \       0x1A   0x5460             STRB     R0,[R4, R1]
   1598          
   1599            /* Disable the write protection for RTC registers */
   1600            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1C   0x20CA             MOVS     R0,#+202
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x6248             STR      R0,[R1, #+36]
   \       0x22   0x2053             MOVS     R0,#+83
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x6248             STR      R0,[R1, #+36]
   1601          
   1602            /* Set Initialization mode */
   1603            if (RTC_EnterInitMode(hrtc) != HAL_OK)
   \       0x28   0x25FF             MOVS     R5,#+255
   \       0x2A   0x2600             MOVS     R6,#+0
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x....'....        BL       RTC_EnterInitMode
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0xD000             BEQ      ??HAL_RTCEx_SetRefClock_1
   1604            {
   1605              /* Enable the write protection for RTC registers */
   1606              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x38   0x....             B.N      ?Subroutine6
   1607          
   1608              /* Set RTC state*/
   1609              hrtc->State = HAL_RTC_STATE_ERROR;
   1610          
   1611              /* Process Unlocked */
   1612              __HAL_UNLOCK(hrtc);
   1613          
   1614              return HAL_ERROR;
   1615            }
   1616            else
   1617            {
   1618              __HAL_RTC_CLOCKREF_DETECTION_ENABLE(hrtc);
   \                     ??HAL_RTCEx_SetRefClock_1: (+1)
   \       0x3A   0x6881             LDR      R1,[R0, #+8]
   \       0x3C   0x2210             MOVS     R2,#+16
   \       0x3E   0x430A             ORRS     R2,R2,R1
   \       0x40   0x6082             STR      R2,[R0, #+8]
   1619          
   1620              /* Exit Initialization mode */
   1621              hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
   \       0x42   0x....             B.N      ?Subroutine4
   1622            }
   1623          
   1624            /* Enable the write protection for RTC registers */
   1625            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1626          
   1627            /* Change RTC state */
   1628            hrtc->State = HAL_RTC_STATE_READY;
   1629          
   1630            /* Process Unlocked */
   1631            __HAL_UNLOCK(hrtc);
   1632          
   1633            return HAL_OK;
   1634          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x6245             STR      R5,[R0, #+36]
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x2121             MOVS     R1,#+33
   \        0x6   0x5460             STRB     R0,[R4, R1]
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0x5426             STRB     R6,[R4, R0]
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x4391             BICS     R1,R1,R2
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6245             STR      R5,[R0, #+36]
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0x5427             STRB     R7,[R4, R0]
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0x5426             STRB     R6,[R4, R0]
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1635          
   1636          /**
   1637            * @brief  Disable the RTC reference clock detection.
   1638            * @param  hrtc RTC handle
   1639            * @retval HAL status
   1640            */

   \                                 In section .text, align 2, keep-with-next
   1641          HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef *hrtc)
   1642          {
   \                     HAL_RTCEx_DeactivateRefClock: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1643            /* Process Locked */
   1644            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTCEx_DeactivateRefClock_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTCEx_DeactivateRefClock_0: (+1)
   \       0x10   0x2701             MOVS     R7,#+1
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0x5427             STRB     R7,[R4, R0]
   1645          
   1646            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2121             MOVS     R1,#+33
   \       0x1A   0x5460             STRB     R0,[R4, R1]
   1647          
   1648            /* Disable the write protection for RTC registers */
   1649            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1C   0x20CA             MOVS     R0,#+202
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x6248             STR      R0,[R1, #+36]
   \       0x22   0x2053             MOVS     R0,#+83
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x6248             STR      R0,[R1, #+36]
   1650          
   1651            /* Set Initialization mode */
   1652            if (RTC_EnterInitMode(hrtc) != HAL_OK)
   \       0x28   0x25FF             MOVS     R5,#+255
   \       0x2A   0x2600             MOVS     R6,#+0
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x....'....        BL       RTC_EnterInitMode
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0xD000             BEQ      ??HAL_RTCEx_DeactivateRefClock_1
   1653            {
   1654              /* Enable the write protection for RTC registers */
   1655              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x38   0x....             B.N      ?Subroutine6
   1656          
   1657              /* Set RTC state*/
   1658              hrtc->State = HAL_RTC_STATE_ERROR;
   1659          
   1660              /* Process Unlocked */
   1661              __HAL_UNLOCK(hrtc);
   1662          
   1663              return HAL_ERROR;
   1664            }
   1665            else
   1666            {
   1667              __HAL_RTC_CLOCKREF_DETECTION_DISABLE(hrtc);
   \                     ??HAL_RTCEx_DeactivateRefClock_1: (+1)
   \       0x3A   0x6881             LDR      R1,[R0, #+8]
   \       0x3C   0x2210             MOVS     R2,#+16
   \       0x3E   0x4391             BICS     R1,R1,R2
   \       0x40   0x6081             STR      R1,[R0, #+8]
   1668          
   1669              /* Exit Initialization mode */
   1670              hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
   \       0x42   0x....             B.N      ?Subroutine4
   1671            }
   1672          
   1673            /* Enable the write protection for RTC registers */
   1674            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1675          
   1676            /* Change RTC state */
   1677            hrtc->State = HAL_RTC_STATE_READY;
   1678          
   1679            /* Process Unlocked */
   1680            __HAL_UNLOCK(hrtc);
   1681          
   1682            return HAL_OK;
   1683          }
   1684          
   1685          /**
   1686            * @brief  Enable the Bypass Shadow feature.
   1687            * @param  hrtc RTC handle
   1688            * @note   When the Bypass Shadow is enabled the calendar value are taken
   1689            *         directly from the Calendar counter.
   1690            * @retval HAL status
   1691            */

   \                                 In section .text, align 2, keep-with-next
   1692          HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
   1693          {
   \                     HAL_RTCEx_EnableBypassShadow: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1694            /* Process Locked */
   1695            __HAL_LOCK(hrtc);
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x5C41             LDRB     R1,[R0, R1]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_EnableBypassShadow_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD10             POP      {R4,PC}
   \                     ??HAL_RTCEx_EnableBypassShadow_0: (+1)
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x2220             MOVS     R2,#+32
   \       0x12   0x5481             STRB     R1,[R0, R2]
   1696          
   1697            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2202             MOVS     R2,#+2
   \       0x16   0x2321             MOVS     R3,#+33
   \       0x18   0x54C2             STRB     R2,[R0, R3]
   1698          
   1699            /* Disable the write protection for RTC registers */
   1700            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1A   0x22CA             MOVS     R2,#+202
   \       0x1C   0x6803             LDR      R3,[R0, #+0]
   \       0x1E   0x625A             STR      R2,[R3, #+36]
   \       0x20   0x2253             MOVS     R2,#+83
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0x625A             STR      R2,[R3, #+36]
   1701          
   1702            /* Set the BYPSHAD bit */
   1703            hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6893             LDR      R3,[R2, #+8]
   \       0x2A   0x2420             MOVS     R4,#+32
   \       0x2C   0x431C             ORRS     R4,R4,R3
   \       0x2E   0x....             B.N      ??Subroutine2_0
   1704          
   1705            /* Enable the write protection for RTC registers */
   1706            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1707          
   1708            /* Change RTC state */
   1709            hrtc->State = HAL_RTC_STATE_READY;
   1710          
   1711            /* Process Unlocked */
   1712            __HAL_UNLOCK(hrtc);
   1713          
   1714            return HAL_OK;
   1715          }
   1716          
   1717          /**
   1718            * @brief  Disable the Bypass Shadow feature.
   1719            * @param  hrtc RTC handle
   1720            * @note   When the Bypass Shadow is enabled the calendar value are taken
   1721            *         directly from the Calendar counter.
   1722            * @retval HAL status
   1723            */

   \                                 In section .text, align 2, keep-with-next
   1724          HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef *hrtc)
   1725          {
   \                     HAL_RTCEx_DisableBypassShadow: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1726            /* Process Locked */
   1727            __HAL_LOCK(hrtc);
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x5C41             LDRB     R1,[R0, R1]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD101             BNE      ??HAL_RTCEx_DisableBypassShadow_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD10             POP      {R4,PC}
   \                     ??HAL_RTCEx_DisableBypassShadow_0: (+1)
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x2220             MOVS     R2,#+32
   \       0x12   0x5481             STRB     R1,[R0, R2]
   1728          
   1729            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x14   0x2202             MOVS     R2,#+2
   \       0x16   0x2321             MOVS     R3,#+33
   \       0x18   0x54C2             STRB     R2,[R0, R3]
   1730          
   1731            /* Disable the write protection for RTC registers */
   1732            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1A   0x22CA             MOVS     R2,#+202
   \       0x1C   0x6803             LDR      R3,[R0, #+0]
   \       0x1E   0x625A             STR      R2,[R3, #+36]
   \       0x20   0x2253             MOVS     R2,#+83
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0x625A             STR      R2,[R3, #+36]
   1733          
   1734            /* Reset the BYPSHAD bit */
   1735            hrtc->Instance->CR &= ((uint8_t)~RTC_CR_BYPSHAD);
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6893             LDR      R3,[R2, #+8]
   \       0x2A   0x24DF             MOVS     R4,#+223
   \       0x2C   0x....             B.N      ?Subroutine2
   1736          
   1737            /* Enable the write protection for RTC registers */
   1738            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1739          
   1740            /* Change RTC state */
   1741            hrtc->State = HAL_RTC_STATE_READY;
   1742          
   1743            /* Process Unlocked */
   1744            __HAL_UNLOCK(hrtc);
   1745          
   1746            return HAL_OK;
   1747          }
   1748          
   1749          /**
   1750            * @}
   1751            */
   1752          
   1753          /** @addtogroup RTCEx_Exported_Functions_Group4
   1754            * @brief    Extended features functions
   1755            *
   1756          @verbatim
   1757           ===============================================================================
   1758                           ##### Extended features functions #####
   1759           ===============================================================================
   1760              [..]  This section provides functions allowing to:
   1761                (+) RTC Alram B callback
   1762                (+) RTC Poll for Alarm B request
   1763          
   1764          @endverbatim
   1765            * @{
   1766            */
   1767          
   1768          /**
   1769            * @brief  Alarm B callback.
   1770            * @param  hrtc RTC handle
   1771            * @retval None
   1772            */

   \                                 In section .text, align 2
   1773          __weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
   1774          {
   1775            /* Prevent unused argument(s) compilation warning */
   1776            UNUSED(hrtc);
   1777          
   1778            /* NOTE : This function should not be modified, when the callback is needed,
   1779                      the HAL_RTCEx_AlarmBEventCallback could be implemented in the user file
   1780             */
   1781          }
   \                     HAL_RTCEx_AlarmBEventCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1782          
   1783          /**
   1784            * @brief  Handle Alarm B Polling request.
   1785            * @param  hrtc RTC handle
   1786            * @param  Timeout Timeout duration
   1787            * @retval HAL status
   1788            */

   \                                 In section .text, align 2, keep-with-next
   1789          HAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
   1790          {
   \                     HAL_RTCEx_PollForAlarmBEvent: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1791            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
   1792          
   1793            while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == 0U)
   \                     ??HAL_RTCEx_PollForAlarmBEvent_0: (+1)
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x0589             LSLS     R1,R1,#+22
   \       0x12   0xD40B             BMI      ??HAL_RTCEx_PollForAlarmBEvent_1
   1794            {
   1795              if (Timeout != HAL_MAX_DELAY)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD0F7             BEQ      ??HAL_RTCEx_PollForAlarmBEvent_0
   1796              {
   1797                if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x1C   0x....'....        BL       HAL_GetTick
   \       0x20   0x1B80             SUBS     R0,R0,R6
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD301             BCC      ??HAL_RTCEx_PollForAlarmBEvent_2
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD1F0             BNE      ??HAL_RTCEx_PollForAlarmBEvent_0
   1798                {
   1799                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \                     ??HAL_RTCEx_PollForAlarmBEvent_2: (+1)
   \       0x2A   0x....             B.N      ?Subroutine9
   1800                  return HAL_TIMEOUT;
   1801                }
   1802              }
   1803            }
   1804          
   1805            /* Clear the Alarm Flag */
   1806            __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
   \                     ??HAL_RTCEx_PollForAlarmBEvent_1: (+1)
   \       0x2C   0x68C1             LDR      R1,[R0, #+12]
   \       0x2E   0x2280             MOVS     R2,#+128
   \       0x30   0x4011             ANDS     R1,R1,R2
   \       0x32   0x....             LDR      R2,??DataTable20_2  ;; 0xfffffd7f
   \       0x34   0x....             B.N      ?Subroutine8
   1807          
   1808            /* Change RTC state */
   1809            hrtc->State = HAL_RTC_STATE_READY;
   1810          
   1811            return HAL_OK;
   1812          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0xFFFF'F77F        DC32     0xfffff77f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0xFFFF'EF7F        DC32     0xffffef7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0xFFFF'F7F7        DC32     0xfffff7f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x007F'7F7F        DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x00FF'FF3F        DC32     0xffff3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x003F'FF84        DC32     0x3fff84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0xFFFE'FFFB        DC32     0xfffefffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xFFF7'FFFB        DC32     0xfff7fffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0xFFFF'F77F        DC32     0xfffff77f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x0001'0004        DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0xFFFF'DF7F        DC32     0xffffdf7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x0008'0004        DC32     0x80004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0xFFFF'BF7F        DC32     0xffffbf7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x4001'0414        DC32     0x40010414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0xFFFF'EF7F        DC32     0xffffef7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x0000'03E9        DC32     0x3e9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x0000'03E9        DC32     0x3e9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0xFFFF'FB7F        DC32     0xfffffb7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0xFFFF'BFFF        DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x4001'0414        DC32     0x40010414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0xFFF7'FFFF        DC32     0xfff7ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0xFF7F'FFFF        DC32     0xff7fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0xFFFF'FD7F        DC32     0xfffffd7f
   1813          
   1814          /**
   1815            * @}
   1816            */
   1817          
   1818          /**
   1819            * @}
   1820            */
   1821          
   1822          #endif /* HAL_RTC_MODULE_ENABLED */
   1823          /**
   1824            * @}
   1825            */
   1826          
   1827          
   1828          /**
   1829            * @}
   1830            */
   1831          
   1832          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
   1833          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RTCEx_AlarmBEventCallback
       0   HAL_RTCEx_BKUPRead
       0   HAL_RTCEx_BKUPWrite
       8   HAL_RTCEx_DeactivateCalibrationOutPut
      24   HAL_RTCEx_DeactivateRefClock
        24   -> RTC_EnterInitMode
      12   HAL_RTCEx_DeactivateTamper
       8   HAL_RTCEx_DeactivateTimeStamp
      16   HAL_RTCEx_DeactivateWakeUpTimer
        16   -> HAL_GetTick
       8   HAL_RTCEx_DisableBypassShadow
       8   HAL_RTCEx_EnableBypassShadow
      24   HAL_RTCEx_GetTimeStamp
        24   -> RTC_Bcd2ToByte
       0   HAL_RTCEx_GetWakeUpTimer
      16   HAL_RTCEx_PollForAlarmBEvent
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForTamper1Event
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForTamper2Event
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForTimeStampEvent
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForWakeUpTimerEvent
        16   -> HAL_GetTick
      12   HAL_RTCEx_SetCalibrationOutPut
      24   HAL_RTCEx_SetRefClock
        24   -> RTC_EnterInitMode
      32   HAL_RTCEx_SetSmoothCalib
        32   -> HAL_GetTick
      32   HAL_RTCEx_SetSynchroShift
        32   -> HAL_GetTick
        32   -> HAL_RTC_WaitForSynchro
      20   HAL_RTCEx_SetTamper
      20   HAL_RTCEx_SetTamper_IT
      20   HAL_RTCEx_SetTimeStamp
      20   HAL_RTCEx_SetTimeStamp_IT
      24   HAL_RTCEx_SetWakeUpTimer
        24   -> HAL_GetTick
      24   HAL_RTCEx_SetWakeUpTimer_IT
        24   -> HAL_GetTick
       0   HAL_RTCEx_Tamper1EventCallback
       0   HAL_RTCEx_Tamper2EventCallback
      16   HAL_RTCEx_TamperTimeStampIRQHandler
        16   -> HAL_RTCEx_Tamper1EventCallback
        16   -> HAL_RTCEx_Tamper2EventCallback
        16   -> HAL_RTCEx_TimeStampEventCallback
       0   HAL_RTCEx_TimeStampEventCallback
       0   HAL_RTCEx_WakeUpTimerEventCallback
       8   HAL_RTCEx_WakeUpTimerIRQHandler
         8   -> HAL_RTCEx_WakeUpTimerEventCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
      20  ?Subroutine0
      12  ?Subroutine1
      24  ?Subroutine2
      32  ?Subroutine3
      26  ?Subroutine4
      22  ?Subroutine5
      16  ?Subroutine6
      14  ?Subroutine7
      14  ?Subroutine8
       8  ?Subroutine9
       2  HAL_RTCEx_AlarmBEventCallback
      12  HAL_RTCEx_BKUPRead
      12  HAL_RTCEx_BKUPWrite
      44  HAL_RTCEx_DeactivateCalibrationOutPut
      68  HAL_RTCEx_DeactivateRefClock
      64  HAL_RTCEx_DeactivateTamper
      56  HAL_RTCEx_DeactivateTimeStamp
     124  HAL_RTCEx_DeactivateWakeUpTimer
      46  HAL_RTCEx_DisableBypassShadow
      48  HAL_RTCEx_EnableBypassShadow
     136  HAL_RTCEx_GetTimeStamp
       8  HAL_RTCEx_GetWakeUpTimer
      54  HAL_RTCEx_PollForAlarmBEvent
      54  HAL_RTCEx_PollForTamper1Event
      52  HAL_RTCEx_PollForTamper2Event
      74  HAL_RTCEx_PollForTimeStampEvent
      54  HAL_RTCEx_PollForWakeUpTimerEvent
      72  HAL_RTCEx_SetCalibrationOutPut
      68  HAL_RTCEx_SetRefClock
     128  HAL_RTCEx_SetSmoothCalib
     158  HAL_RTCEx_SetSynchroShift
     152  HAL_RTCEx_SetTamper
     170  HAL_RTCEx_SetTamper_IT
      88  HAL_RTCEx_SetTimeStamp
     112  HAL_RTCEx_SetTimeStamp_IT
     142  HAL_RTCEx_SetWakeUpTimer
     186  HAL_RTCEx_SetWakeUpTimer_IT
       2  HAL_RTCEx_Tamper1EventCallback
       2  HAL_RTCEx_Tamper2EventCallback
     122  HAL_RTCEx_TamperTimeStampIRQHandler
       2  HAL_RTCEx_TimeStampEventCallback
       2  HAL_RTCEx_WakeUpTimerEventCallback
      48  HAL_RTCEx_WakeUpTimerIRQHandler

 
 2'658 bytes in section .text
 
 2'648 bytes of CODE memory (+ 10 bytes shared)

Errors: none
Warnings: none
