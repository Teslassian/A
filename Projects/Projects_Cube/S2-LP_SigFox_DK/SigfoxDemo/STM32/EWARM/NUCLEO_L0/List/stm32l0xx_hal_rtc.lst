###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  12:25:31
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rtc.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW855B.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rtc.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal_rtc.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal_rtc.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_rtc.c
      4            * @author  MCD Application Team
      5            * @brief   RTC HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Real-Time Clock (RTC) peripheral:
      8            *           + Initialization
      9            *           + Calendar (Time and Date) configuration
     10            *           + Alarms (Alarm A and Alarm B) configuration
     11            *           + WakeUp Timer configuration
     12            *           + TimeStamp configuration
     13            *           + Tampers configuration
     14            *           + Backup Data Registers configuration
     15            *           + RTC Tamper and TimeStamp Pins Selection
     16            *           + Interrupts and flags management
     17            *
     18            @verbatim
     19           ===============================================================================
     20                                    ##### RTC Operating Condition #####
     21           ===============================================================================
     22            [..] The real-time clock (RTC) and the RTC backup registers can be powered
     23                 from the VBAT voltage when the main VDD supply is powered off.
     24                 To retain the content of the RTC backup registers and supply the RTC
     25                 when VDD is turned off, VBAT pin can be connected to an optional
     26                 standby voltage supplied by a battery or by another source.
     27          
     28                             ##### Backup Domain Reset #####
     29           ===============================================================================
     30            [..] The backup domain reset sets all RTC registers and the RCC_BDCR register
     31                 to their reset values.
     32                 A backup domain reset is generated when one of the following events occurs:
     33              (+) Software reset, triggered by setting the BDRST bit in the
     34                  RCC Backup domain control register (RCC_BDCR).
     35              (+) VDD or VBAT power on, if both supplies have previously been powered off.
     36              (+) Tamper detection event resets all data backup registers.
     37          
     38                             ##### Backup Domain Access #####
     39           ===================================================================
     40            [..] After reset, the backup domain (RTC registers, RTC backup data
     41                 registers and backup SRAM) is protected against possible unwanted write
     42                 accesses.
     43          
     44            [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
     45              (+) Call the function HAL_RCCEx_PeriphCLKConfig with RCC_PERIPHCLK_RTC for
     46                  PeriphClockSelection and select RTCClockSelection (LSE, LSI or HSEdiv32)
     47              (+) Enable RTC Clock using the __HAL_RCC_RTC_ENABLE() macro.
     48          
     49                            ##### How to use RTC Driver #####
     50           ===================================================================
     51            [..]
     52              (+) Enable the RTC domain access (see description in the section above).
     53              (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour
     54                  format using the HAL_RTC_Init() function.
     55          
     56            *** Time and Date configuration ***
     57            ===================================
     58            [..]
     59              (+) To configure the RTC Calendar (Time and Date) use the HAL_RTC_SetTime()
     60                  and HAL_RTC_SetDate() functions.
     61              (+) To read the RTC Calendar, use the HAL_RTC_GetTime() and HAL_RTC_GetDate() functions.
     62          
     63            *** Alarm configuration ***
     64            ===========================
     65            [..]
     66              (+) To configure the RTC Alarm use the HAL_RTC_SetAlarm() function.
     67                      You can also configure the RTC Alarm with interrupt mode using the
     68                      HAL_RTC_SetAlarm_IT() function.
     69              (+) To read the RTC Alarm, use the HAL_RTC_GetAlarm() function.
     70          
     71                            ##### RTC and low power modes #####
     72            ==================================================================
     73            [..] The MCU can be woken up from a low power mode by an RTC alternate
     74                 function.
     75            [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B),
     76                 RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
     77                 These RTC alternate functions can wake up the system from the Stop and
     78                 Standby low power modes.
     79            [..] The system can also wake up from low power modes without depending
     80                 on an external interrupt (Auto-wakeup mode), by using the RTC alarm
     81                 or the RTC wakeup events.
     82            [..] The RTC provides a programmable time base for waking up from the
     83                 Stop or Standby mode at regular intervals.
     84                 Wakeup from STOP and STANDBY modes is possible only when the RTC clock source
     85                 is LSE or LSI.
     86          
     87            *** Callback registration ***
     88            =============================================
     89          
     90            The compilation define  USE_RTC_REGISTER_CALLBACKS when set to 1
     91            allows the user to configure dynamically the driver callbacks.
     92            Use Function @ref HAL_RTC_RegisterCallback() to register an interrupt callback.
     93          
     94            Function @ref HAL_RTC_RegisterCallback() allows to register following callbacks:
     95              (+) AlarmAEventCallback          : RTC Alarm A Event callback.
     96              (+) AlarmBEventCallback          : RTC Alarm B Event callback.
     97              (+) TimeStampEventCallback       : RTC TimeStamp Event callback.
     98              (+) WakeUpTimerEventCallback     : RTC WakeUpTimer Event callback.
     99              (+) Tamper1EventCallback         : RTC Tamper 1 Event callback.
    100              (+) Tamper2EventCallback         : RTC Tamper 2 Event callback.
    101              (+) Tamper3EventCallback         : RTC Tamper 3 Event callback.
    102              (+) MspInitCallback              : RTC MspInit callback.
    103              (+) MspDeInitCallback            : RTC MspDeInit callback.
    104            This function takes as parameters the HAL peripheral handle, the Callback ID
    105            and a pointer to the user callback function.
    106          
    107            Use function @ref HAL_RTC_UnRegisterCallback() to reset a callback to the default
    108            weak function.
    109            @ref HAL_RTC_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    110            and the Callback ID.
    111            This function allows to reset following callbacks:
    112              (+) AlarmAEventCallback          : RTC Alarm A Event callback.
    113              (+) AlarmBEventCallback          : RTC Alarm B Event callback.
    114              (+) TimeStampEventCallback       : RTC TimeStamp Event callback.
    115              (+) WakeUpTimerEventCallback     : RTC WakeUpTimer Event callback.
    116              (+) Tamper1EventCallback         : RTC Tamper 1 Event callback.
    117              (+) Tamper2EventCallback         : RTC Tamper 2 Event callback.
    118              (+) Tamper3EventCallback         : RTC Tamper 3 Event callback.
    119              (+) MspInitCallback              : RTC MspInit callback.
    120              (+) MspDeInitCallback            : RTC MspDeInit callback.
    121          
    122            By default, after the @ref HAL_RTC_Init() and when the state is HAL_RTC_STATE_RESET,
    123            all callbacks are set to the corresponding weak functions :
    124            examples @ref AlarmAEventCallback(), @ref WakeUpTimerEventCallback().
    125            Exception done for MspInit and MspDeInit callbacks that are reset to the legacy weak function
    126            in the @ref HAL_RTC_Init()/@ref HAL_RTC_DeInit() only when these callbacks are null
    127            (not registered beforehand).
    128            If not, MspInit or MspDeInit are not null, @ref HAL_RTC_Init()/@ref HAL_RTC_DeInit()
    129            keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
    130          
    131            Callbacks can be registered/unregistered in HAL_RTC_STATE_READY state only.
    132            Exception done MspInit/MspDeInit that can be registered/unregistered
    133            in HAL_RTC_STATE_READY or HAL_RTC_STATE_RESET state,
    134            thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    135            In that case first register the MspInit/MspDeInit user callbacks
    136            using @ref HAL_RTC_RegisterCallback() before calling @ref HAL_RTC_DeInit()
    137            or @ref HAL_RTC_Init() function.
    138          
    139            When The compilation define USE_HAL_RTC_REGISTER_CALLBACKS is set to 0 or
    140            not defined, the callback registration feature is not available and all callbacks
    141            are set to the corresponding weak functions.
    142          
    143             @endverbatim
    144          
    145            ******************************************************************************
    146            * @attention
    147            *
    148            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    149            * All rights reserved.</center></h2>
    150            *
    151            * This software component is licensed by ST under BSD 3-Clause license,
    152            * the "License"; You may not use this file except in compliance with the
    153            * License. You may obtain a copy of the License at:
    154            *                        opensource.org/licenses/BSD-3-Clause
    155            *
    156            ******************************************************************************
    157            */
    158          
    159          /* Includes ------------------------------------------------------------------*/
    160          #include "stm32l0xx_hal.h"
    161          
    162          /** @addtogroup STM32L0xx_HAL_Driver
    163            * @{
    164            */
    165          
    166          
    167          /** @addtogroup RTC
    168            * @brief RTC HAL module driver
    169            * @{
    170            */
    171          
    172          #ifdef HAL_RTC_MODULE_ENABLED
    173          
    174          /* Private typedef -----------------------------------------------------------*/
    175          /* Private define ------------------------------------------------------------*/
    176          /* Private macro -------------------------------------------------------------*/
    177          /* Private variables ---------------------------------------------------------*/
    178          /* Private function prototypes -----------------------------------------------*/
    179          /* Exported functions --------------------------------------------------------*/
    180          
    181          /** @addtogroup RTC_Exported_Functions
    182            * @{
    183            */
    184          
    185          /** @addtogroup RTC_Exported_Functions_Group1
    186           *  @brief    Initialization and Configuration functions
    187           *
    188          @verbatim
    189           ===============================================================================
    190                        ##### Initialization and de-initialization functions #####
    191           ===============================================================================
    192             [..] This section provides functions allowing to initialize and configure the
    193                   RTC Prescaler (Synchronous and Asynchronous), RTC Hour format, disable
    194                   RTC registers Write protection, enter and exit the RTC initialization mode,
    195                   RTC registers synchronization check and reference clock detection enable.
    196                   (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base.
    197                       It is split into 2 programmable prescalers to minimize power consumption.
    198                       (++) A 7-bit asynchronous prescaler and a 15-bit synchronous prescaler.
    199                       (++) When both prescalers are used, it is recommended to configure the
    200                           asynchronous prescaler to a high value to minimize power consumption.
    201                   (#) All RTC registers are Write protected. Writing to the RTC registers
    202                       is enabled by writing a key into the Write Protection register, RTC_WPR.
    203                   (#) To configure the RTC Calendar, user application should enter
    204                       initialization mode. In this mode, the calendar counter is stopped
    205                       and its value can be updated. When the initialization sequence is
    206                       complete, the calendar restarts counting after 4 RTCCLK cycles.
    207                   (#) To read the calendar through the shadow registers after Calendar
    208                       initialization, calendar update or after wakeup from low power modes
    209                       the software must first clear the RSF flag. The software must then
    210                       wait until it is set again before reading the calendar, which means
    211                       that the calendar registers have been correctly copied into the
    212                       RTC_TR and RTC_DR shadow registers.The HAL_RTC_WaitForSynchro() function
    213                       implements the above software sequence (RSF clear and RSF check).
    214          
    215          @endverbatim
    216            * @{
    217            */
    218          
    219          /**
    220            * @brief  Initialize the RTC peripheral
    221            * @param  hrtc RTC handle
    222            * @retval HAL status
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
    225          {
   \                     HAL_RTC_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    226            /* Check the RTC peripheral state */
    227            if (hrtc == NULL)
   \        0x4   0xD054             BEQ      ??HAL_RTC_Init_0
    228            {
    229              return HAL_ERROR;
    230            }
    231          
    232            /* Check the parameters */
    233            assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
    234            assert_param(IS_RTC_HOUR_FORMAT(hrtc->Init.HourFormat));
    235            assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
    236            assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
    237            assert_param(IS_RTC_OUTPUT(hrtc->Init.OutPut));
    238            assert_param(IS_RTC_OUTPUT_REMAP(hrtc->Init.OutPutRemap));
    239            assert_param(IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
    240            assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
    241          
    242          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    243            if (hrtc->State == HAL_RTC_STATE_RESET)
    244            {
    245              /* Allocate lock resource and initialize it */
    246              hrtc->Lock = HAL_UNLOCKED;
    247          
    248              hrtc->AlarmAEventCallback          =  HAL_RTC_AlarmAEventCallback;        /* Legacy weak AlarmAEventCallback      */
    249              hrtc->AlarmBEventCallback          =  HAL_RTCEx_AlarmBEventCallback;      /* Legacy weak AlarmBEventCallback      */
    250              hrtc->TimeStampEventCallback       =  HAL_RTCEx_TimeStampEventCallback;   /* Legacy weak TimeStampEventCallback   */
    251              hrtc->WakeUpTimerEventCallback     =  HAL_RTCEx_WakeUpTimerEventCallback; /* Legacy weak WakeUpTimerEventCallback */
    252          #if defined(RTC_TAMPER1_SUPPORT)
    253              hrtc->Tamper1EventCallback         =  HAL_RTCEx_Tamper1EventCallback;     /* Legacy weak Tamper1EventCallback     */
    254          #endif
    255              hrtc->Tamper2EventCallback         =  HAL_RTCEx_Tamper2EventCallback;     /* Legacy weak Tamper2EventCallback     */
    256          #if defined(RTC_TAMPER3_SUPPORT)
    257              hrtc->Tamper3EventCallback         =  HAL_RTCEx_Tamper3EventCallback;     /* Legacy weak Tamper3EventCallback     */
    258          #endif
    259          
    260              if (hrtc->MspInitCallback == NULL)
    261              {
    262                hrtc->MspInitCallback = HAL_RTC_MspInit;
    263              }
    264              /* Init the low level hardware */
    265              hrtc->MspInitCallback(hrtc);
    266          
    267              if (hrtc->MspDeInitCallback == NULL)
    268              {
    269                hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    270              }
    271            }
    272          #else
    273            if (hrtc->State == HAL_RTC_STATE_RESET)
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD104             BNE      ??HAL_RTC_Init_1
    274            {
    275              /* Allocate lock resource and initialize it */
    276              hrtc->Lock = HAL_UNLOCKED;
   \       0x10   0x2120             MOVS     R1,#+32
   \       0x12   0x5467             STRB     R7,[R4, R1]
    277          
    278              /* Initialize RTC MSP */
    279              HAL_RTC_MspInit(hrtc);
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x....'....        BL       HAL_RTC_MspInit
    280            }
    281          #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
    282          
    283            /* Set RTC state */
    284            hrtc->State = HAL_RTC_STATE_BUSY;
   \                     ??HAL_RTC_Init_1: (+1)
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x2121             MOVS     R1,#+33
   \       0x1E   0x5460             STRB     R0,[R4, R1]
    285          
    286            /* Disable the write protection for RTC registers */
    287            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x20   0x20CA             MOVS     R0,#+202
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x6248             STR      R0,[R1, #+36]
   \       0x26   0x2053             MOVS     R0,#+83
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6248             STR      R0,[R1, #+36]
    288          
    289            /* Set Initialization mode */
    290            if (RTC_EnterInitMode(hrtc) != HAL_OK)
   \       0x2C   0x2504             MOVS     R5,#+4
   \       0x2E   0x26FF             MOVS     R6,#+255
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x....'....        BL       RTC_EnterInitMode
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0xD003             BEQ      ??HAL_RTC_Init_2
    291            {
    292              /* Enable the write protection for RTC registers */
    293              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x3C   0x6246             STR      R6,[R0, #+36]
    294          
    295              /* Set RTC state */
    296              hrtc->State = HAL_RTC_STATE_ERROR;
   \       0x3E   0x2021             MOVS     R0,#+33
   \       0x40   0x5425             STRB     R5,[R4, R0]
    297          
    298              return HAL_ERROR;
   \       0x42   0xE035             B.N      ??HAL_RTC_Init_0
    299            }
    300            else
    301            {
    302              /* Clear RTC_CR FMT, OSEL and POL Bits */
    303              hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
   \                     ??HAL_RTC_Init_2: (+1)
   \       0x44   0x6881             LDR      R1,[R0, #+8]
   \       0x46   0x....             LDR      R2,??DataTable4  ;; 0xff8fffbf
   \       0x48   0x400A             ANDS     R2,R2,R1
   \       0x4A   0x6082             STR      R2,[R0, #+8]
    304              /* Set RTC_CR register */
    305              hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6881             LDR      R1,[R0, #+8]
   \       0x50   0x6863             LDR      R3,[R4, #+4]
   \       0x52   0x6922             LDR      R2,[R4, #+16]
   \       0x54   0x431A             ORRS     R2,R2,R3
   \       0x56   0x69A3             LDR      R3,[R4, #+24]
   \       0x58   0x4313             ORRS     R3,R3,R2
   \       0x5A   0x430B             ORRS     R3,R3,R1
   \       0x5C   0x6083             STR      R3,[R0, #+8]
    306          
    307              /* Configure the RTC PRER */
    308              hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
   \       0x5E   0x68E0             LDR      R0,[R4, #+12]
   \       0x60   0x6821             LDR      R1,[R4, #+0]
   \       0x62   0x6108             STR      R0,[R1, #+16]
    309              hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6901             LDR      R1,[R0, #+16]
   \       0x68   0x68A2             LDR      R2,[R4, #+8]
   \       0x6A   0x0412             LSLS     R2,R2,#+16
   \       0x6C   0x430A             ORRS     R2,R2,R1
   \       0x6E   0x6102             STR      R2,[R0, #+16]
    310          
    311              /* Exit Initialization mode */
    312              hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x68C1             LDR      R1,[R0, #+12]
   \       0x74   0x2280             MOVS     R2,#+128
   \       0x76   0x4391             BICS     R1,R1,R2
   \       0x78   0x60C1             STR      R1,[R0, #+12]
    313          
    314              hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6CC1             LDR      R1,[R0, #+76]
   \       0x7E   0x2203             MOVS     R2,#+3
   \       0x80   0x4391             BICS     R1,R1,R2
   \       0x82   0x64C1             STR      R1,[R0, #+76]
    315              hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x6CC1             LDR      R1,[R0, #+76]
   \       0x88   0x69E2             LDR      R2,[R4, #+28]
   \       0x8A   0x6963             LDR      R3,[R4, #+20]
   \       0x8C   0x4313             ORRS     R3,R3,R2
   \       0x8E   0x430B             ORRS     R3,R3,R1
   \       0x90   0x64C3             STR      R3,[R0, #+76]
    316          
    317              /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    318              if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6880             LDR      R0,[R0, #+8]
   \       0x96   0x0680             LSLS     R0,R0,#+26
   \       0x98   0xD40C             BMI      ??HAL_RTC_Init_3
    319              {
    320                if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x....'....        BL       HAL_RTC_WaitForSynchro
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD007             BEQ      ??HAL_RTC_Init_3
    321                {
    322                  /* Enable the write protection for RTC registers */
    323                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6246             STR      R6,[R0, #+36]
    324          
    325                  hrtc->State = HAL_RTC_STATE_ERROR;
   \       0xA8   0x2021             MOVS     R0,#+33
   \       0xAA   0x5425             STRB     R5,[R4, R0]
    326          
    327                  /* Process Unlocked */
    328                  __HAL_UNLOCK(hrtc);
   \       0xAC   0x2020             MOVS     R0,#+32
   \       0xAE   0x5427             STRB     R7,[R4, R0]
    329          
    330                  return HAL_ERROR;
   \                     ??HAL_RTC_Init_0: (+1)
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0xBDF2             POP      {R1,R4-R7,PC}
    331                }
    332              }
    333          
    334              /* Enable the write protection for RTC registers */
    335              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_Init_3: (+1)
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x6246             STR      R6,[R0, #+36]
    336          
    337              /* Set RTC state */
    338              hrtc->State = HAL_RTC_STATE_READY;
   \       0xB8   0x2001             MOVS     R0,#+1
   \       0xBA   0x2121             MOVS     R1,#+33
   \       0xBC   0x5460             STRB     R0,[R4, R1]
    339          
    340              return HAL_OK;
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    341            }
    342          }
    343          
    344          /**
    345            * @brief  DeInitialize the RTC peripheral.
    346            * @param  hrtc RTC handle
    347            * @note   This function doesn't reset the RTC Backup Data registers.
    348            * @retval HAL status
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
    351          {
   \                     HAL_RTC_DeInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
    352            uint32_t tickstart;
    353          
    354            /* Check the parameters */
    355            assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
    356          
    357            /* Set RTC state */
    358            hrtc->State = HAL_RTC_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x2121             MOVS     R1,#+33
   \        0x8   0x5470             STRB     R0,[R6, R1]
    359          
    360            /* Disable the write protection for RTC registers */
    361            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \        0xA   0x20CA             MOVS     R0,#+202
   \        0xC   0x6831             LDR      R1,[R6, #+0]
   \        0xE   0x6248             STR      R0,[R1, #+36]
   \       0x10   0x2053             MOVS     R0,#+83
   \       0x12   0x6831             LDR      R1,[R6, #+0]
   \       0x14   0x6248             STR      R0,[R1, #+36]
    362          
    363            /* Set Initialization mode */
    364            if (RTC_EnterInitMode(hrtc) != HAL_OK)
   \       0x16   0x24FF             MOVS     R4,#+255
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x....'....        BL       RTC_EnterInitMode
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD140             BNE      ??HAL_RTC_DeInit_0
    365            {
    366              /* Enable the write protection for RTC registers */
    367              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    368          
    369              /* Set RTC state */
    370              hrtc->State = HAL_RTC_STATE_ERROR;
    371          
    372              return HAL_ERROR;
    373            }
    374            else
    375            {
    376              /* Reset TR, DR and CR registers */
    377              hrtc->Instance->TR = (uint32_t)0x00000000U;
   \       0x22   0x2500             MOVS     R5,#+0
   \       0x24   0x6830             LDR      R0,[R6, #+0]
   \       0x26   0x6005             STR      R5,[R0, #+0]
    378              hrtc->Instance->DR = ((uint32_t)(RTC_DR_WDU_0 | RTC_DR_MU_0 | RTC_DR_DU_0));
   \       0x28   0x....             LDR      R0,??DataTable5  ;; 0x2101
   \       0x2A   0x6831             LDR      R1,[R6, #+0]
   \       0x2C   0x6048             STR      R0,[R1, #+4]
    379              /* Reset All CR bits except CR[2:0] */
    380              hrtc->Instance->CR &= RTC_CR_WUCKSEL;
   \       0x2E   0x6830             LDR      R0,[R6, #+0]
   \       0x30   0x6881             LDR      R1,[R0, #+8]
   \       0x32   0x0749             LSLS     R1,R1,#+29
   \       0x34   0x0F49             LSRS     R1,R1,#+29
   \       0x36   0x6081             STR      R1,[R0, #+8]
    381          
    382              tickstart = HAL_GetTick();
   \       0x38   0x....'....        BL       HAL_GetTick
   \       0x3C   0x0007             MOVS     R7,R0
    383          
    384              /* Wait till WUTWF flag is set and if Time out is reached exit */
    385              while (((hrtc->Instance->ISR) & RTC_ISR_WUTWF) == 0U)
   \                     ??HAL_RTC_DeInit_1: (+1)
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x68C1             LDR      R1,[R0, #+12]
   \       0x42   0x0749             LSLS     R1,R1,#+29
   \       0x44   0xD40B             BMI      ??HAL_RTC_DeInit_2
    386              {
    387                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x46   0x....'....        BL       HAL_GetTick
   \       0x4A   0x1BC0             SUBS     R0,R0,R7
   \       0x4C   0x....             LDR      R1,??DataTable5_1  ;; 0x3e9
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xD3F5             BCC      ??HAL_RTC_DeInit_1
    388                {
    389                  /* Enable the write protection for RTC registers */
    390                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \       0x52   0x6830             LDR      R0,[R6, #+0]
   \       0x54   0x6244             STR      R4,[R0, #+36]
    391          
    392                  /* Set RTC state */
    393                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \       0x56   0x2003             MOVS     R0,#+3
   \       0x58   0x2121             MOVS     R1,#+33
   \       0x5A   0x5470             STRB     R0,[R6, R1]
    394          
    395                  return HAL_TIMEOUT;
   \       0x5C   0xBDF2             POP      {R1,R4-R7,PC}
    396                }
    397              }
    398          
    399              /* Reset all RTC CR register bits */
    400              hrtc->Instance->CR &= (uint32_t)0x00000000U;
   \                     ??HAL_RTC_DeInit_2: (+1)
   \       0x5E   0x6881             LDR      R1,[R0, #+8]
   \       0x60   0x6085             STR      R5,[R0, #+8]
    401              hrtc->Instance->WUTR = RTC_WUTR_WUT;
   \       0x62   0x....             LDR      R0,??DataTable5_2  ;; 0xffff
   \       0x64   0x6831             LDR      R1,[R6, #+0]
   \       0x66   0x6148             STR      R0,[R1, #+20]
    402              hrtc->Instance->PRER = ((uint32_t)(RTC_PRER_PREDIV_A | 0x000000FFU));
   \       0x68   0x....             LDR      R0,??DataTable5_3  ;; 0x7f00ff
   \       0x6A   0x6831             LDR      R1,[R6, #+0]
   \       0x6C   0x6108             STR      R0,[R1, #+16]
    403              hrtc->Instance->ALRMAR = (uint32_t)0x00000000U;
   \       0x6E   0x6830             LDR      R0,[R6, #+0]
   \       0x70   0x61C5             STR      R5,[R0, #+28]
    404              hrtc->Instance->ALRMBR = (uint32_t)0x00000000U;
   \       0x72   0x6830             LDR      R0,[R6, #+0]
   \       0x74   0x6205             STR      R5,[R0, #+32]
    405              hrtc->Instance->SHIFTR = (uint32_t)0x00000000U;
   \       0x76   0x6830             LDR      R0,[R6, #+0]
   \       0x78   0x62C5             STR      R5,[R0, #+44]
    406              hrtc->Instance->CALR = (uint32_t)0x00000000U;
   \       0x7A   0x6830             LDR      R0,[R6, #+0]
   \       0x7C   0x63C5             STR      R5,[R0, #+60]
    407              hrtc->Instance->ALRMASSR = (uint32_t)0x00000000U;
   \       0x7E   0x6830             LDR      R0,[R6, #+0]
   \       0x80   0x6445             STR      R5,[R0, #+68]
    408              hrtc->Instance->ALRMBSSR = (uint32_t)0x00000000U;
   \       0x82   0x6830             LDR      R0,[R6, #+0]
   \       0x84   0x6485             STR      R5,[R0, #+72]
    409          
    410              /* Reset ISR register and exit initialization mode */
    411              hrtc->Instance->ISR = (uint32_t)0x00000000U;
   \       0x86   0x6830             LDR      R0,[R6, #+0]
   \       0x88   0x60C5             STR      R5,[R0, #+12]
    412          
    413              /* Reset Tamper configuration register */
    414              hrtc->Instance->TAMPCR = 0x00000000U;
   \       0x8A   0x6830             LDR      R0,[R6, #+0]
   \       0x8C   0x6405             STR      R5,[R0, #+64]
    415          
    416              /* Reset Option register */
    417              hrtc->Instance->OR = 0x00000000U;
   \       0x8E   0x6830             LDR      R0,[R6, #+0]
   \       0x90   0x64C5             STR      R5,[R0, #+76]
    418          
    419              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    420              if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
   \       0x92   0x6830             LDR      R0,[R6, #+0]
   \       0x94   0x6880             LDR      R0,[R0, #+8]
   \       0x96   0x0680             LSLS     R0,R0,#+26
   \       0x98   0xD40B             BMI      ??HAL_RTC_DeInit_3
    421              {
    422                if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0x....'....        BL       HAL_RTC_WaitForSynchro
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD006             BEQ      ??HAL_RTC_DeInit_3
    423                {
    424                  /* Enable the write protection for RTC registers */
    425                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_DeInit_0: (+1)
   \       0xA4   0x6830             LDR      R0,[R6, #+0]
   \       0xA6   0x6244             STR      R4,[R0, #+36]
    426          
    427                  hrtc->State = HAL_RTC_STATE_ERROR;
   \       0xA8   0x2004             MOVS     R0,#+4
   \       0xAA   0x2121             MOVS     R1,#+33
   \       0xAC   0x5470             STRB     R0,[R6, R1]
    428          
    429                  return HAL_ERROR;
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0xBDF2             POP      {R1,R4-R7,PC}
    430                }
    431              }
    432            }
    433          
    434            /* Enable the write protection for RTC registers */
    435            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_DeInit_3: (+1)
   \       0xB2   0x6830             LDR      R0,[R6, #+0]
   \       0xB4   0x6244             STR      R4,[R0, #+36]
    436          
    437          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    438            if (hrtc->MspDeInitCallback == NULL)
    439            {
    440              hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    441            }
    442          
    443            /* DeInit the low level hardware: CLOCK, NVIC.*/
    444            hrtc->MspDeInitCallback(hrtc);
    445          
    446          #else
    447            /* De-Initialize RTC MSP */
    448            HAL_RTC_MspDeInit(hrtc);
   \       0xB6   0x0030             MOVS     R0,R6
   \       0xB8   0x....'....        BL       HAL_RTC_MspDeInit
    449          #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
    450          
    451            hrtc->State = HAL_RTC_STATE_RESET;
   \       0xBC   0x2121             MOVS     R1,#+33
   \       0xBE   0x5475             STRB     R5,[R6, R1]
    452          
    453            /* Release Lock */
    454            __HAL_UNLOCK(hrtc);
   \       0xC0   0x2020             MOVS     R0,#+32
   \       0xC2   0x5435             STRB     R5,[R6, R0]
    455          
    456            return HAL_OK;
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    457          }
    458          
    459          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    460          /**
    461            * @brief  Register a User RTC Callback
    462            *         To be used instead of the weak predefined callback
    463            * @param  hrtc RTC handle
    464            * @param  CallbackID ID of the callback to be registered
    465            *         This parameter can be one of the following values:
    466            *          @arg @ref HAL_RTC_ALARM_A_EVENT_CB_ID          Alarm A Event Callback ID
    467            *          @arg @ref HAL_RTC_ALARM_B_EVENT_CB_ID          Alarm B Event Callback ID
    468            *          @arg @ref HAL_RTC_TIMESTAMP_EVENT_CB_ID        TimeStamp Event Callback ID
    469            *          @arg @ref HAL_RTC_WAKEUPTIMER_EVENT_CB_ID      WakeUp Timer Event Callback ID
    470            *          @arg @ref HAL_RTC_TAMPER1_EVENT_CB_ID          Tamper 1 Callback ID
    471            *          @arg @ref HAL_RTC_TAMPER2_EVENT_CB_ID          Tamper 2 Callback ID
    472            *          @arg @ref HAL_RTC_TAMPER3_EVENT_CB_ID          Tamper 3 Callback ID
    473            *          @arg @ref HAL_RTC_MSPINIT_CB_ID                Msp Init callback ID
    474            *          @arg @ref HAL_RTC_MSPDEINIT_CB_ID              Msp DeInit callback ID
    475            * @param  pCallback pointer to the Callback function
    476            * @retval HAL status
    477            */
    478          HAL_StatusTypeDef HAL_RTC_RegisterCallback(RTC_HandleTypeDef *hrtc, HAL_RTC_CallbackIDTypeDef CallbackID, pRTC_CallbackTypeDef pCallback)
    479          {
    480            HAL_StatusTypeDef status = HAL_OK;
    481          
    482            if (pCallback == NULL)
    483            {
    484              return HAL_ERROR;
    485            }
    486          
    487            /* Process locked */
    488            __HAL_LOCK(hrtc);
    489          
    490            if (HAL_RTC_STATE_READY == hrtc->State)
    491            {
    492              switch (CallbackID)
    493              {
    494                case HAL_RTC_ALARM_A_EVENT_CB_ID :
    495                  hrtc->AlarmAEventCallback = pCallback;
    496                  break;
    497          
    498                case HAL_RTC_ALARM_B_EVENT_CB_ID :
    499                  hrtc->AlarmBEventCallback = pCallback;
    500                  break;
    501          
    502                case HAL_RTC_TIMESTAMP_EVENT_CB_ID :
    503                  hrtc->TimeStampEventCallback = pCallback;
    504                  break;
    505          
    506                case HAL_RTC_WAKEUPTIMER_EVENT_CB_ID :
    507                  hrtc->WakeUpTimerEventCallback = pCallback;
    508                  break;
    509          
    510                case HAL_RTC_TAMPER1_EVENT_CB_ID :
    511                  hrtc->Tamper1EventCallback = pCallback;
    512                  break;
    513          
    514                case HAL_RTC_TAMPER2_EVENT_CB_ID :
    515                  hrtc->Tamper2EventCallback = pCallback;
    516                  break;
    517          
    518                case HAL_RTC_TAMPER3_EVENT_CB_ID :
    519                  hrtc->Tamper3EventCallback = pCallback;
    520                  break;
    521          
    522                case HAL_RTC_MSPINIT_CB_ID :
    523                  hrtc->MspInitCallback = pCallback;
    524                  break;
    525          
    526                case HAL_RTC_MSPDEINIT_CB_ID :
    527                  hrtc->MspDeInitCallback = pCallback;
    528                  break;
    529          
    530                default :
    531                  /* Return error status */
    532                  status =  HAL_ERROR;
    533                  break;
    534              }
    535            }
    536            else if (HAL_RTC_STATE_RESET == hrtc->State)
    537            {
    538              switch (CallbackID)
    539              {
    540                case HAL_RTC_MSPINIT_CB_ID :
    541                  hrtc->MspInitCallback = pCallback;
    542                  break;
    543          
    544                case HAL_RTC_MSPDEINIT_CB_ID :
    545                  hrtc->MspDeInitCallback = pCallback;
    546                  break;
    547          
    548                default :
    549                  /* Return error status */
    550                  status =  HAL_ERROR;
    551                  break;
    552              }
    553            }
    554            else
    555            {
    556              /* Return error status */
    557              status =  HAL_ERROR;
    558            }
    559          
    560            /* Release Lock */
    561            __HAL_UNLOCK(hrtc);
    562          
    563            return status;
    564          }
    565          
    566          /**
    567            * @brief  Unregister an RTC Callback
    568            *         RTC callabck is redirected to the weak predefined callback
    569            * @param  hrtc RTC handle
    570            * @param  CallbackID ID of the callback to be unregistered
    571            *         This parameter can be one of the following values:
    572            *          @arg @ref HAL_RTC_ALARM_A_EVENT_CB_ID          Alarm A Event Callback ID
    573            *          @arg @ref HAL_RTC_ALARM_B_EVENT_CB_ID          Alarm B Event Callback ID
    574            *          @arg @ref HAL_RTC_TIMESTAMP_EVENT_CB_ID        TimeStamp Event Callback ID
    575            *          @arg @ref HAL_RTC_WAKEUPTIMER_EVENT_CB_ID      WakeUp Timer Event Callback ID
    576            *          @arg @ref HAL_RTC_TAMPER1_EVENT_CB_ID          Tamper 1 Callback ID
    577            *          @arg @ref HAL_RTC_TAMPER2_EVENT_CB_ID          Tamper 2 Callback ID
    578            *          @arg @ref HAL_RTC_TAMPER3_EVENT_CB_ID          Tamper 3 Callback ID
    579            *          @arg @ref HAL_RTC_MSPINIT_CB_ID Msp Init callback ID
    580            *          @arg @ref HAL_RTC_MSPDEINIT_CB_ID Msp DeInit callback ID
    581            * @retval HAL status
    582            */
    583          HAL_StatusTypeDef HAL_RTC_UnRegisterCallback(RTC_HandleTypeDef *hrtc, HAL_RTC_CallbackIDTypeDef CallbackID)
    584          {
    585            HAL_StatusTypeDef status = HAL_OK;
    586          
    587            /* Process locked */
    588            __HAL_LOCK(hrtc);
    589          
    590            if (HAL_RTC_STATE_READY == hrtc->State)
    591            {
    592              switch (CallbackID)
    593              {
    594                case HAL_RTC_ALARM_A_EVENT_CB_ID :
    595                  hrtc->AlarmAEventCallback = HAL_RTC_AlarmAEventCallback;         /* Legacy weak AlarmAEventCallback    */
    596                  break;
    597          
    598                case HAL_RTC_ALARM_B_EVENT_CB_ID :
    599                  hrtc->AlarmBEventCallback = HAL_RTCEx_AlarmBEventCallback;          /* Legacy weak AlarmBEventCallback */
    600                  break;
    601          
    602                case HAL_RTC_TIMESTAMP_EVENT_CB_ID :
    603                  hrtc->TimeStampEventCallback = HAL_RTCEx_TimeStampEventCallback;    /* Legacy weak TimeStampEventCallback    */
    604                  break;
    605          
    606                case HAL_RTC_WAKEUPTIMER_EVENT_CB_ID :
    607                  hrtc->WakeUpTimerEventCallback = HAL_RTCEx_WakeUpTimerEventCallback; /* Legacy weak WakeUpTimerEventCallback */
    608                  break;
    609          
    610                case HAL_RTC_TAMPER1_EVENT_CB_ID :
    611                  hrtc->Tamper1EventCallback = HAL_RTCEx_Tamper1EventCallback;         /* Legacy weak Tamper1EventCallback   */
    612                  break;
    613          
    614                case HAL_RTC_TAMPER2_EVENT_CB_ID :
    615                  hrtc->Tamper2EventCallback = HAL_RTCEx_Tamper2EventCallback;         /* Legacy weak Tamper2EventCallback         */
    616                  break;
    617          
    618                case HAL_RTC_TAMPER3_EVENT_CB_ID :
    619                  hrtc->Tamper3EventCallback = HAL_RTCEx_Tamper3EventCallback;         /* Legacy weak Tamper3EventCallback         */
    620                  break;
    621          
    622                case HAL_RTC_MSPINIT_CB_ID :
    623                  hrtc->MspInitCallback = HAL_RTC_MspInit;
    624                  break;
    625          
    626                case HAL_RTC_MSPDEINIT_CB_ID :
    627                  hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    628                  break;
    629          
    630                default :
    631                  /* Return error status */
    632                  status =  HAL_ERROR;
    633                  break;
    634              }
    635            }
    636            else if (HAL_RTC_STATE_RESET == hrtc->State)
    637            {
    638              switch (CallbackID)
    639              {
    640                case HAL_RTC_MSPINIT_CB_ID :
    641                  hrtc->MspInitCallback = HAL_RTC_MspInit;
    642                  break;
    643          
    644                case HAL_RTC_MSPDEINIT_CB_ID :
    645                  hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    646                  break;
    647          
    648                default :
    649                  /* Return error status */
    650                  status =  HAL_ERROR;
    651                  break;
    652              }
    653            }
    654            else
    655            {
    656              /* Return error status */
    657              status =  HAL_ERROR;
    658            }
    659          
    660            /* Release Lock */
    661            __HAL_UNLOCK(hrtc);
    662          
    663            return status;
    664          }
    665          #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
    666          
    667          /**
    668            * @brief  Initialize the RTC MSP.
    669            * @param  hrtc RTC handle
    670            * @retval None
    671            */

   \                                 In section .text, align 2
    672          __weak void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
    673          {
    674            /* Prevent unused argument(s) compilation warning */
    675            UNUSED(hrtc);
    676          
    677            /* NOTE : This function should not be modified, when the callback is needed,
    678                      the HAL_RTC_MspInit could be implemented in the user file
    679             */
    680          }
   \                     HAL_RTC_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    681          
    682          /**
    683            * @brief  DeInitialize the RTC MSP.
    684            * @param  hrtc RTC handle
    685            * @retval None
    686            */

   \                                 In section .text, align 2
    687          __weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc)
    688          {
    689            /* Prevent unused argument(s) compilation warning */
    690            UNUSED(hrtc);
    691          
    692            /* NOTE : This function should not be modified, when the callback is needed,
    693                      the HAL_RTC_MspDeInit could be implemented in the user file
    694             */
    695          }
   \                     HAL_RTC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    696          
    697          /**
    698            * @}
    699            */
    700          
    701          /** @addtogroup RTC_Exported_Functions_Group2
    702           *  @brief   RTC Time and Date functions
    703           *
    704          @verbatim
    705           ===============================================================================
    706                           ##### RTC Time and Date functions #####
    707           ===============================================================================
    708          
    709           [..] This section provides functions allowing to configure Time and Date features
    710          
    711          @endverbatim
    712            * @{
    713            */
    714          
    715          /**
    716            * @brief  Set RTC current time.
    717            * @param  hrtc RTC handle
    718            * @param  sTime Pointer to Time structure
    719            * @param  Format Specifies the format of the entered parameters.
    720            *          This parameter can be one of the following values:
    721            *            @arg RTC_FORMAT_BIN: Binary data format
    722            *            @arg RTC_FORMAT_BCD: BCD data format
    723            * @retval HAL status
    724            */

   \                                 In section .text, align 2, keep-with-next
    725          HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
    726          {
   \                     HAL_RTC_SetTime: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    727            uint32_t tmpreg;
    728          
    729            /* Check the parameters */
    730            assert_param(IS_RTC_FORMAT(Format));
    731            assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
    732            assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));
    733          
    734            /* Process Locked */
    735            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTC_SetTime_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTC_SetTime_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x2320             MOVS     R3,#+32
   \       0x14   0x54E0             STRB     R0,[R4, R3]
    736          
    737            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2321             MOVS     R3,#+33
   \       0x1A   0x54E0             STRB     R0,[R4, R3]
    738          
    739            if (Format == RTC_FORMAT_BIN)
   \       0x1C   0x6823             LDR      R3,[R4, #+0]
   \       0x1E   0x2040             MOVS     R0,#+64
   \       0x20   0x2500             MOVS     R5,#+0
   \       0x22   0x9100             STR      R1,[SP, #+0]
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0x6899             LDR      R1,[R3, #+8]
   \       0x28   0xD115             BNE      ??HAL_RTC_SetTime_1
    740            {
    741              if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
   \       0x2A   0x4008             ANDS     R0,R0,R1
   \       0x2C   0xD101             BNE      ??HAL_RTC_SetTime_2
    742              {
    743                assert_param(IS_RTC_HOUR12(sTime->Hours));
    744                assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    745              }
    746              else
    747              {
    748                sTime->TimeFormat = 0x00U;
   \       0x2E   0x9900             LDR      R1,[SP, #+0]
   \       0x30   0x70CD             STRB     R5,[R1, #+3]
    749                assert_param(IS_RTC_HOUR24(sTime->Hours));
    750              }
    751              assert_param(IS_RTC_MINUTES(sTime->Minutes));
    752              assert_param(IS_RTC_SECONDS(sTime->Seconds));
    753          
    754              tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
    755                                  ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
    756                                  ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
    757                                  (((uint32_t)sTime->TimeFormat) << 16U));
   \                     ??HAL_RTC_SetTime_2: (+1)
   \       0x32   0x9800             LDR      R0,[SP, #+0]
   \       0x34   0x7800             LDRB     R0,[R0, #+0]
   \       0x36   0x....'....        BL       RTC_ByteToBcd2
   \       0x3A   0x0406             LSLS     R6,R0,#+16
   \       0x3C   0x9800             LDR      R0,[SP, #+0]
   \       0x3E   0x7840             LDRB     R0,[R0, #+1]
   \       0x40   0x....'....        BL       RTC_ByteToBcd2
   \       0x44   0x0200             LSLS     R0,R0,#+8
   \       0x46   0x4330             ORRS     R0,R0,R6
   \       0x48   0x0006             MOVS     R6,R0
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
   \       0x4C   0x7880             LDRB     R0,[R0, #+2]
   \       0x4E   0x....'....        BL       RTC_ByteToBcd2
   \       0x52   0x4330             ORRS     R0,R0,R6
   \       0x54   0xE00D             B        ??HAL_RTC_SetTime_3
    758            }
    759            else
    760            {
    761              if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
   \                     ??HAL_RTC_SetTime_1: (+1)
   \       0x56   0x4008             ANDS     R0,R0,R1
   \       0x58   0xD101             BNE      ??HAL_RTC_SetTime_4
    762              {
    763                assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
    764                assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    765              }
    766              else
    767              {
    768                sTime->TimeFormat = 0x00U;
   \       0x5A   0x9900             LDR      R1,[SP, #+0]
   \       0x5C   0x70CD             STRB     R5,[R1, #+3]
    769                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    770              }
    771              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    772              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    773              tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
    774                        ((uint32_t)(sTime->Minutes) << 8U) | \
    775                        ((uint32_t)sTime->Seconds) | \
    776                        ((uint32_t)(sTime->TimeFormat) << 16U));
   \                     ??HAL_RTC_SetTime_4: (+1)
   \       0x5E   0x9800             LDR      R0,[SP, #+0]
   \       0x60   0x7800             LDRB     R0,[R0, #+0]
   \       0x62   0x0400             LSLS     R0,R0,#+16
   \       0x64   0x9900             LDR      R1,[SP, #+0]
   \       0x66   0x7849             LDRB     R1,[R1, #+1]
   \       0x68   0x0209             LSLS     R1,R1,#+8
   \       0x6A   0x4301             ORRS     R1,R1,R0
   \       0x6C   0x9800             LDR      R0,[SP, #+0]
   \       0x6E   0x7880             LDRB     R0,[R0, #+2]
   \       0x70   0x4308             ORRS     R0,R0,R1
   \                     ??HAL_RTC_SetTime_3: (+1)
   \       0x72   0x9900             LDR      R1,[SP, #+0]
   \       0x74   0x78C9             LDRB     R1,[R1, #+3]
   \       0x76   0x040F             LSLS     R7,R1,#+16
   \       0x78   0x4307             ORRS     R7,R7,R0
    777            }
    778            UNUSED(tmpreg);
    779            /* Disable the write protection for RTC registers */
    780            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x7A   0x20CA             MOVS     R0,#+202
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x6248             STR      R0,[R1, #+36]
   \       0x80   0x2053             MOVS     R0,#+83
   \       0x82   0x6821             LDR      R1,[R4, #+0]
   \       0x84   0x6248             STR      R0,[R1, #+36]
    781          
    782            /* Set Initialization mode */
    783            if (RTC_EnterInitMode(hrtc) != HAL_OK)
   \       0x86   0x26FF             MOVS     R6,#+255
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x....'....        BL       RTC_EnterInitMode
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD11F             BNE      ??HAL_RTC_SetTime_5
    784            {
    785              /* Enable the write protection for RTC registers */
    786              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    787          
    788              /* Set RTC state */
    789              hrtc->State = HAL_RTC_STATE_ERROR;
    790          
    791              /* Process Unlocked */
    792              __HAL_UNLOCK(hrtc);
    793          
    794              return HAL_ERROR;
    795            }
    796            else
    797            {
    798              /* Set the RTC_TR register */
    799              hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
   \       0x92   0x....             LDR      R0,??DataTable6  ;; 0x7f7f7f
   \       0x94   0x4038             ANDS     R0,R0,R7
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x6008             STR      R0,[R1, #+0]
    800          
    801              /* Clear the bits to be configured */
    802              hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BKP);
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6881             LDR      R1,[R0, #+8]
   \       0x9E   0x....             LDR      R2,??DataTable6_1  ;; 0xfffbffff
   \       0xA0   0x400A             ANDS     R2,R2,R1
   \       0xA2   0x6082             STR      R2,[R0, #+8]
    803          
    804              /* Configure the RTC_CR register */
    805              hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6881             LDR      R1,[R0, #+8]
   \       0xA8   0x9A00             LDR      R2,[SP, #+0]
   \       0xAA   0x68D2             LDR      R2,[R2, #+12]
   \       0xAC   0x9B00             LDR      R3,[SP, #+0]
   \       0xAE   0x691B             LDR      R3,[R3, #+16]
   \       0xB0   0x4313             ORRS     R3,R3,R2
   \       0xB2   0x430B             ORRS     R3,R3,R1
   \       0xB4   0x6083             STR      R3,[R0, #+8]
    806          
    807              /* Exit Initialization mode */
    808              hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x68C1             LDR      R1,[R0, #+12]
   \       0xBA   0x2280             MOVS     R2,#+128
   \       0xBC   0x4391             BICS     R1,R1,R2
   \       0xBE   0x60C1             STR      R1,[R0, #+12]
    809          
    810              /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    811              if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
   \       0xC0   0x6820             LDR      R0,[R4, #+0]
   \       0xC2   0x6880             LDR      R0,[R0, #+8]
   \       0xC4   0x0680             LSLS     R0,R0,#+26
   \       0xC6   0xD40D             BMI      ??HAL_RTC_SetTime_6
    812              {
    813                if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   \       0xC8   0x0020             MOVS     R0,R4
   \       0xCA   0x....'....        BL       HAL_RTC_WaitForSynchro
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD008             BEQ      ??HAL_RTC_SetTime_6
    814                {
    815                  /* Enable the write protection for RTC registers */
    816                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetTime_5: (+1)
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x6246             STR      R6,[R0, #+36]
    817          
    818                  hrtc->State = HAL_RTC_STATE_ERROR;
   \       0xD6   0x2004             MOVS     R0,#+4
   \       0xD8   0x2121             MOVS     R1,#+33
   \       0xDA   0x5460             STRB     R0,[R4, R1]
    819          
    820                  /* Process Unlocked */
    821                  __HAL_UNLOCK(hrtc);
   \       0xDC   0x2020             MOVS     R0,#+32
   \       0xDE   0x5425             STRB     R5,[R4, R0]
    822          
    823                  return HAL_ERROR;
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0xBDF2             POP      {R1,R4-R7,PC}
    824                }
    825              }
    826          
    827              /* Enable the write protection for RTC registers */
    828              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetTime_6: (+1)
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x6246             STR      R6,[R0, #+36]
    829          
    830              hrtc->State = HAL_RTC_STATE_READY;
   \       0xE8   0x....             B.N      ?Subroutine2
    831          
    832              __HAL_UNLOCK(hrtc);
    833          
    834              return HAL_OK;
    835            }
    836          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x2121             MOVS     R1,#+33
   \        0x4   0x5460             STRB     R0,[R4, R1]
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0x5425             STRB     R5,[R4, R0]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    837          
    838          /**
    839            * @brief  Get RTC current time.
    840            * @param  hrtc RTC handle
    841            * @param  sTime Pointer to Time structure with Hours, Minutes and Seconds fields returned
    842            *                with input format (BIN or BCD), also SubSeconds field returning the
    843            *                RTC_SSR register content and SecondFraction field the Synchronous pre-scaler
    844            *                factor to be used for second fraction ratio computation.
    845            * @param  Format Specifies the format of the entered parameters.
    846            *          This parameter can be one of the following values:
    847            *            @arg RTC_FORMAT_BIN: Binary data format
    848            *            @arg RTC_FORMAT_BCD: BCD data format
    849            * @note  You can use SubSeconds and SecondFraction (sTime structure fields returned) to convert SubSeconds
    850            *        value in second fraction ratio with time unit following generic formula:
    851            *        Second fraction ratio * time_unit= [(SecondFraction-SubSeconds)/(SecondFraction+1)] * time_unit
    852            *        This conversion can be performed only if no shift operation is pending (ie. SHFP=0) when PREDIV_S >= SS
    853            * @note  You must call HAL_RTC_GetDate() after HAL_RTC_GetTime() to unlock the values
    854            *        in the higher-order calendar shadow registers to ensure consistency between the time and date values.
    855            *        Reading RTC current time locks the values in calendar shadow registers until Current date is read
    856            *        to ensure consistency between the time and date values.
    857            * @retval HAL status
    858            */

   \                                 In section .text, align 2, keep-with-next
    859          HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
    860          {
   \                     HAL_RTC_GetTime: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
    861            uint32_t tmpreg;
    862          
    863            /* Check the parameters */
    864            assert_param(IS_RTC_FORMAT(Format));
    865          
    866            /* Get subseconds structure field from the corresponding register*/
    867            sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x6A81             LDR      R1,[R0, #+40]
   \        0x8   0x6061             STR      R1,[R4, #+4]
    868          
    869            /* Get SecondFraction structure field from the corresponding register field*/
    870            sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
   \        0xA   0x6901             LDR      R1,[R0, #+16]
   \        0xC   0x0449             LSLS     R1,R1,#+17
   \        0xE   0x0C49             LSRS     R1,R1,#+17
   \       0x10   0x60A1             STR      R1,[R4, #+8]
    871          
    872            /* Get the TR register */
    873            tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x....             LDR      R0,??DataTable6  ;; 0x7f7f7f
   \       0x16   0x4008             ANDS     R0,R0,R1
    874          
    875            /* Fill the structure fields with the read parameters */
    876            sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
   \       0x18   0x0C01             LSRS     R1,R0,#+16
   \       0x1A   0x068B             LSLS     R3,R1,#+26
   \       0x1C   0x0E9B             LSRS     R3,R3,#+26
   \       0x1E   0x7023             STRB     R3,[R4, #+0]
    877            sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
   \       0x20   0x0A03             LSRS     R3,R0,#+8
   \       0x22   0x7063             STRB     R3,[R4, #+1]
    878            sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
   \       0x24   0x70A0             STRB     R0,[R4, #+2]
    879            sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16U);
   \       0x26   0x2040             MOVS     R0,#+64
   \       0x28   0x4001             ANDS     R1,R1,R0
   \       0x2A   0x70E1             STRB     R1,[R4, #+3]
    880          
    881            /* Check the input parameters format */
    882            if (Format == RTC_FORMAT_BIN)
   \       0x2C   0x2A00             CMP      R2,#+0
   \       0x2E   0xD10B             BNE      ??HAL_RTC_GetTime_0
    883            {
    884              /* Convert the time structure parameters to Binary format */
    885              sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0x....'....        BL       RTC_Bcd2ToByte
   \       0x36   0x7020             STRB     R0,[R4, #+0]
    886              sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
   \       0x38   0x7860             LDRB     R0,[R4, #+1]
   \       0x3A   0x....'....        BL       RTC_Bcd2ToByte
   \       0x3E   0x7060             STRB     R0,[R4, #+1]
    887              sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
   \       0x40   0x78A0             LDRB     R0,[R4, #+2]
   \       0x42   0x....'....        BL       RTC_Bcd2ToByte
   \       0x46   0x70A0             STRB     R0,[R4, #+2]
    888            }
    889          
    890            return HAL_OK;
   \                     ??HAL_RTC_GetTime_0: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
    891          }
    892          
    893          /**
    894            * @brief  Set RTC current date.
    895            * @param  hrtc RTC handle
    896            * @param  sDate Pointer to date structure
    897            * @param  Format specifies the format of the entered parameters.
    898            *          This parameter can be one of the following values:
    899            *            @arg RTC_FORMAT_BIN: Binary data format
    900            *            @arg RTC_FORMAT_BCD: BCD data format
    901            * @retval HAL status
    902            */

   \                                 In section .text, align 2, keep-with-next
    903          HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
    904          {
   \                     HAL_RTC_SetDate: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    905            uint32_t datetmpreg;
    906          
    907            /* Check the parameters */
    908            assert_param(IS_RTC_FORMAT(Format));
    909          
    910            /* Process Locked */
    911            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTC_SetDate_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTC_SetDate_0: (+1)
   \       0x10   0x000D             MOVS     R5,R1
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x2120             MOVS     R1,#+32
   \       0x16   0x5460             STRB     R0,[R4, R1]
    912          
    913            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x2121             MOVS     R1,#+33
   \       0x1C   0x5460             STRB     R0,[R4, R1]
    914          
    915            if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
   \       0x1E   0x7868             LDRB     R0,[R5, #+1]
   \       0x20   0x2A00             CMP      R2,#+0
   \       0x22   0xD13E             BNE      ??HAL_RTC_SetDate_1
   \       0x24   0x06C1             LSLS     R1,R0,#+27
   \       0x26   0xD503             BPL      ??HAL_RTC_SetDate_2
    916            {
    917              sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
   \       0x28   0x21EF             MOVS     R1,#+239
   \       0x2A   0x4001             ANDS     R1,R1,R0
   \       0x2C   0x310A             ADDS     R1,R1,#+10
   \       0x2E   0x7069             STRB     R1,[R5, #+1]
    918            }
    919          
    920            assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));
    921          
    922            if (Format == RTC_FORMAT_BIN)
    923            {
    924              assert_param(IS_RTC_YEAR(sDate->Year));
    925              assert_param(IS_RTC_MONTH(sDate->Month));
    926              assert_param(IS_RTC_DATE(sDate->Date));
    927          
    928              datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
    929                            ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
    930                            ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
    931                            ((uint32_t)sDate->WeekDay << 13U));
   \                     ??HAL_RTC_SetDate_2: (+1)
   \       0x30   0x78E8             LDRB     R0,[R5, #+3]
   \       0x32   0x....'....        BL       RTC_ByteToBcd2
   \       0x36   0x0406             LSLS     R6,R0,#+16
   \       0x38   0x7868             LDRB     R0,[R5, #+1]
   \       0x3A   0x....'....        BL       RTC_ByteToBcd2
   \       0x3E   0x0200             LSLS     R0,R0,#+8
   \       0x40   0x4330             ORRS     R0,R0,R6
   \       0x42   0x0006             MOVS     R6,R0
   \       0x44   0x78A8             LDRB     R0,[R5, #+2]
   \       0x46   0x....'....        BL       RTC_ByteToBcd2
   \       0x4A   0x4330             ORRS     R0,R0,R6
   \       0x4C   0x7829             LDRB     R1,[R5, #+0]
   \       0x4E   0x034F             LSLS     R7,R1,#+13
   \       0x50   0x4307             ORRS     R7,R7,R0
    932            }
    933            else
    934            {
    935              assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    936              assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    937              assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
    938          
    939              datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
    940                            (((uint32_t)sDate->Month) << 8U) | \
    941                            ((uint32_t)sDate->Date) | \
    942                            (((uint32_t)sDate->WeekDay) << 13U));
    943            }
    944          
    945            /* Disable the write protection for RTC registers */
    946            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \                     ??HAL_RTC_SetDate_3: (+1)
   \       0x52   0x20CA             MOVS     R0,#+202
   \       0x54   0x6821             LDR      R1,[R4, #+0]
   \       0x56   0x6248             STR      R0,[R1, #+36]
   \       0x58   0x2053             MOVS     R0,#+83
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6248             STR      R0,[R1, #+36]
    947          
    948            /* Set Initialization mode */
    949            if (RTC_EnterInitMode(hrtc) != HAL_OK)
   \       0x5E   0x25FF             MOVS     R5,#+255
   \       0x60   0x2600             MOVS     R6,#+0
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x....'....        BL       RTC_EnterInitMode
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD111             BNE      ??HAL_RTC_SetDate_4
    950            {
    951              /* Enable the write protection for RTC registers */
    952              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    953          
    954              /* Set RTC state*/
    955              hrtc->State = HAL_RTC_STATE_ERROR;
    956          
    957              /* Process Unlocked */
    958              __HAL_UNLOCK(hrtc);
    959          
    960              return HAL_ERROR;
    961            }
    962            else
    963            {
    964              /* Set the RTC_DR register */
    965              hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
   \       0x6C   0x....             LDR      R0,??DataTable7  ;; 0xffff3f
   \       0x6E   0x4038             ANDS     R0,R0,R7
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0x6048             STR      R0,[R1, #+4]
    966          
    967              /* Exit Initialization mode */
    968              hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x68C1             LDR      R1,[R0, #+12]
   \       0x78   0x2280             MOVS     R2,#+128
   \       0x7A   0x4391             BICS     R1,R1,R2
   \       0x7C   0x60C1             STR      R1,[R0, #+12]
    969          
    970              /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    971              if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x6880             LDR      R0,[R0, #+8]
   \       0x82   0x0680             LSLS     R0,R0,#+26
   \       0x84   0xD417             BMI      ??HAL_RTC_SetDate_5
    972              {
    973                if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x....'....        BL       HAL_RTC_WaitForSynchro
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD012             BEQ      ??HAL_RTC_SetDate_5
    974                {
    975                  /* Enable the write protection for RTC registers */
    976                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetDate_4: (+1)
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x6245             STR      R5,[R0, #+36]
    977          
    978                  hrtc->State = HAL_RTC_STATE_ERROR;
   \       0x94   0x2004             MOVS     R0,#+4
   \       0x96   0x2121             MOVS     R1,#+33
   \       0x98   0x5460             STRB     R0,[R4, R1]
    979          
    980                  /* Process Unlocked */
    981                  __HAL_UNLOCK(hrtc);
   \       0x9A   0x2020             MOVS     R0,#+32
   \       0x9C   0x5426             STRB     R6,[R4, R0]
    982          
    983                  return HAL_ERROR;
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0xBDF2             POP      {R1,R4-R7,PC}
    984                }
    985              }
   \                     ??HAL_RTC_SetDate_1: (+1)
   \       0xA2   0x78E9             LDRB     R1,[R5, #+3]
   \       0xA4   0x0409             LSLS     R1,R1,#+16
   \       0xA6   0x0200             LSLS     R0,R0,#+8
   \       0xA8   0x4308             ORRS     R0,R0,R1
   \       0xAA   0x78A9             LDRB     R1,[R5, #+2]
   \       0xAC   0x4301             ORRS     R1,R1,R0
   \       0xAE   0x7828             LDRB     R0,[R5, #+0]
   \       0xB0   0x0347             LSLS     R7,R0,#+13
   \       0xB2   0x430F             ORRS     R7,R7,R1
   \       0xB4   0xE7CD             B        ??HAL_RTC_SetDate_3
    986          
    987              /* Enable the write protection for RTC registers */
    988              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetDate_5: (+1)
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x6245             STR      R5,[R0, #+36]
    989          
    990              hrtc->State = HAL_RTC_STATE_READY ;
   \       0xBA   0x2001             MOVS     R0,#+1
   \       0xBC   0x2121             MOVS     R1,#+33
   \       0xBE   0x5460             STRB     R0,[R4, R1]
    991          
    992              /* Process Unlocked */
    993              __HAL_UNLOCK(hrtc);
   \       0xC0   0x2020             MOVS     R0,#+32
   \       0xC2   0x5426             STRB     R6,[R4, R0]
    994          
    995              return HAL_OK;
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    996            }
    997          }
    998          
    999          /**
   1000            * @brief  Get RTC current date.
   1001            * @param  hrtc RTC handle
   1002            * @param  sDate Pointer to Date structure
   1003            * @param  Format Specifies the format of the entered parameters.
   1004            *          This parameter can be one of the following values:
   1005            *            @arg RTC_FORMAT_BIN:  Binary data format
   1006            *            @arg RTC_FORMAT_BCD:  BCD data format
   1007            * @note  You must call HAL_RTC_GetDate() after HAL_RTC_GetTime() to unlock the values
   1008            *        in the higher-order calendar shadow registers to ensure consistency between the time and date values.
   1009            *        Reading RTC current time locks the values in calendar shadow registers until Current date is read.
   1010            * @retval HAL status
   1011            */

   \                                 In section .text, align 2, keep-with-next
   1012          HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
   1013          {
   \                     HAL_RTC_GetDate: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
   1014            uint32_t datetmpreg;
   1015          
   1016            /* Check the parameters */
   1017            assert_param(IS_RTC_FORMAT(Format));
   1018          
   1019            /* Get the DR register */
   1020            datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0x....             LDR      R0,??DataTable7  ;; 0xffff3f
   \        0xA   0x4008             ANDS     R0,R0,R1
   1021          
   1022            /* Fill the structure fields with the read parameters */
   1023            sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16U);
   \        0xC   0x0C01             LSRS     R1,R0,#+16
   \        0xE   0x70E1             STRB     R1,[R4, #+3]
   1024            sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
   \       0x10   0x04C1             LSLS     R1,R0,#+19
   \       0x12   0x0EC9             LSRS     R1,R1,#+27
   \       0x14   0x7061             STRB     R1,[R4, #+1]
   1025            sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
   \       0x16   0x70A0             STRB     R0,[R4, #+2]
   1026            sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13U);
   \       0x18   0x0400             LSLS     R0,R0,#+16
   \       0x1A   0x0F40             LSRS     R0,R0,#+29
   \       0x1C   0x7020             STRB     R0,[R4, #+0]
   1027          
   1028            /* Check the input parameters format */
   1029            if (Format == RTC_FORMAT_BIN)
   \       0x1E   0x2A00             CMP      R2,#+0
   \       0x20   0xD10B             BNE      ??HAL_RTC_GetDate_0
   1030            {
   1031              /* Convert the date structure parameters to Binary format */
   1032              sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
   \       0x22   0x78E0             LDRB     R0,[R4, #+3]
   \       0x24   0x....'....        BL       RTC_Bcd2ToByte
   \       0x28   0x70E0             STRB     R0,[R4, #+3]
   1033              sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
   \       0x2A   0x7860             LDRB     R0,[R4, #+1]
   \       0x2C   0x....'....        BL       RTC_Bcd2ToByte
   \       0x30   0x7060             STRB     R0,[R4, #+1]
   1034              sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
   \       0x32   0x78A0             LDRB     R0,[R4, #+2]
   \       0x34   0x....'....        BL       RTC_Bcd2ToByte
   \       0x38   0x70A0             STRB     R0,[R4, #+2]
   1035            }
   1036            return HAL_OK;
   \                     ??HAL_RTC_GetDate_0: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
   1037          }
   1038          
   1039          /**
   1040            * @}
   1041            */
   1042          
   1043          /** @addtogroup RTC_Exported_Functions_Group3
   1044           *  @brief   RTC Alarm functions
   1045           *
   1046          @verbatim
   1047           ===============================================================================
   1048                           ##### RTC Alarm functions #####
   1049           ===============================================================================
   1050          
   1051           [..] This section provides functions allowing to configure Alarm feature
   1052          
   1053          @endverbatim
   1054            * @{
   1055            */
   1056          /**
   1057            * @brief  Set the specified RTC Alarm.
   1058            * @param  hrtc RTC handle
   1059            * @param  sAlarm Pointer to Alarm structure
   1060            * @param  Format Specifies the format of the entered parameters.
   1061            *          This parameter can be one of the following values:
   1062            *             @arg RTC_FORMAT_BIN: Binary data format
   1063            *             @arg RTC_FORMAT_BCD: BCD data format
   1064            * @retval HAL status
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
   1067          {
   \                     HAL_RTC_SetAlarm: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   1068            uint32_t tickstart;
   1069            uint32_t tmpreg, subsecondtmpreg;
   1070          
   1071            /* Check the parameters */
   1072            assert_param(IS_RTC_FORMAT(Format));
   1073            assert_param(IS_RTC_ALARM(sAlarm->Alarm));
   1074            assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
   1075            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
   1076            assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
   1077            assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
   1078          
   1079            /* Process Locked */
   1080            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C38             LDRB     R0,[R7, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTC_SetAlarm_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTC_SetAlarm_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x2320             MOVS     R3,#+32
   \       0x14   0x54F8             STRB     R0,[R7, R3]
   1081          
   1082            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x9000             STR      R0,[SP, #+0]
   \       0x1A   0x2321             MOVS     R3,#+33
   \       0x1C   0x54F8             STRB     R0,[R7, R3]
   1083          
   1084            if (Format == RTC_FORMAT_BIN)
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x2340             MOVS     R3,#+64
   \       0x22   0x000D             MOVS     R5,R1
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0x6880             LDR      R0,[R0, #+8]
   \       0x28   0xD119             BNE      ??HAL_RTC_SetAlarm_1
   1085            {
   1086              if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
   \       0x2A   0x4003             ANDS     R3,R3,R0
   \       0x2C   0xD101             BNE      ??HAL_RTC_SetAlarm_2
   1087              {
   1088                assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
   1089                assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
   1090              }
   1091              else
   1092              {
   1093                sAlarm->AlarmTime.TimeFormat = 0x00U;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x70E8             STRB     R0,[R5, #+3]
   1094                assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
   1095              }
   1096              assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
   1097              assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
   1098          
   1099              if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
   1100              {
   1101                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
   1102              }
   1103              else
   1104              {
   1105                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
   1106              }
   1107          
   1108              tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
   1109                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
   1110                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
   1111                        ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
   1112                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
   1113                        ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
   1114                        ((uint32_t)sAlarm->AlarmMask));
   \                     ??HAL_RTC_SetAlarm_2: (+1)
   \       0x32   0x7828             LDRB     R0,[R5, #+0]
   \       0x34   0x....'....        BL       RTC_ByteToBcd2
   \       0x38   0x0404             LSLS     R4,R0,#+16
   \       0x3A   0x7868             LDRB     R0,[R5, #+1]
   \       0x3C   0x....'....        BL       RTC_ByteToBcd2
   \       0x40   0x0206             LSLS     R6,R0,#+8
   \       0x42   0x4326             ORRS     R6,R6,R4
   \       0x44   0x78A8             LDRB     R0,[R5, #+2]
   \       0x46   0x....'....        BL       RTC_ByteToBcd2
   \       0x4A   0x0004             MOVS     R4,R0
   \       0x4C   0x2020             MOVS     R0,#+32
   \       0x4E   0x5C28             LDRB     R0,[R5, R0]
   \       0x50   0x....'....        BL       RTC_ByteToBcd2
   \       0x54   0x4334             ORRS     R4,R4,R6
   \       0x56   0x78E9             LDRB     R1,[R5, #+3]
   \       0x58   0x0409             LSLS     R1,R1,#+16
   \       0x5A   0x4321             ORRS     R1,R1,R4
   \       0x5C   0xE00F             B        ??HAL_RTC_SetAlarm_3
   1115            }
   1116            else
   1117            {
   1118              if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
   \                     ??HAL_RTC_SetAlarm_1: (+1)
   \       0x5E   0x4003             ANDS     R3,R3,R0
   \       0x60   0xD101             BNE      ??HAL_RTC_SetAlarm_4
   1119              {
   1120                assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
   1121                assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
   1122              }
   1123              else
   1124              {
   1125                sAlarm->AlarmTime.TimeFormat = 0x00U;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x70E8             STRB     R0,[R5, #+3]
   1126                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
   1127              }
   1128          
   1129              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
   1130              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
   1131          
   1132              if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
   1133              {
   1134                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
   1135              }
   1136              else
   1137              {
   1138                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
   1139              }
   1140          
   1141              tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
   1142                        ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
   1143                        ((uint32_t) sAlarm->AlarmTime.Seconds) | \
   1144                        ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
   1145                        ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
   1146                        ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
   1147                        ((uint32_t)sAlarm->AlarmMask));
   \                     ??HAL_RTC_SetAlarm_4: (+1)
   \       0x66   0x7828             LDRB     R0,[R5, #+0]
   \       0x68   0x0400             LSLS     R0,R0,#+16
   \       0x6A   0x7869             LDRB     R1,[R5, #+1]
   \       0x6C   0x0209             LSLS     R1,R1,#+8
   \       0x6E   0x4301             ORRS     R1,R1,R0
   \       0x70   0x78A8             LDRB     R0,[R5, #+2]
   \       0x72   0x4308             ORRS     R0,R0,R1
   \       0x74   0x78E9             LDRB     R1,[R5, #+3]
   \       0x76   0x0409             LSLS     R1,R1,#+16
   \       0x78   0x4301             ORRS     R1,R1,R0
   \       0x7A   0x2020             MOVS     R0,#+32
   \       0x7C   0x5C28             LDRB     R0,[R5, R0]
   \                     ??HAL_RTC_SetAlarm_3: (+1)
   \       0x7E   0x0600             LSLS     R0,R0,#+24
   \       0x80   0x4308             ORRS     R0,R0,R1
   \       0x82   0x69E9             LDR      R1,[R5, #+28]
   \       0x84   0x4301             ORRS     R1,R1,R0
   \       0x86   0x696C             LDR      R4,[R5, #+20]
   \       0x88   0x430C             ORRS     R4,R4,R1
   1148            }
   1149          
   1150            /* Configure the Alarm A or Alarm B Sub Second registers */
   1151            subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
   \       0x8A   0x6868             LDR      R0,[R5, #+4]
   \       0x8C   0x69AE             LDR      R6,[R5, #+24]
   \       0x8E   0x4306             ORRS     R6,R6,R0
   1152          
   1153            /* Disable the write protection for RTC registers */
   1154            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x90   0x20CA             MOVS     R0,#+202
   \       0x92   0x6839             LDR      R1,[R7, #+0]
   \       0x94   0x6248             STR      R0,[R1, #+36]
   \       0x96   0x2053             MOVS     R0,#+83
   \       0x98   0x6839             LDR      R1,[R7, #+0]
   \       0x9A   0x6248             STR      R0,[R1, #+36]
   1155          
   1156            /* Configure the Alarm register */
   1157            if (sAlarm->Alarm == RTC_ALARM_A)
   \       0x9C   0x6838             LDR      R0,[R7, #+0]
   \       0x9E   0x6A69             LDR      R1,[R5, #+36]
   \       0xA0   0x2280             MOVS     R2,#+128
   \       0xA2   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \       0xA4   0x4291             CMP      R1,R2
   \       0xA6   0x6881             LDR      R1,[R0, #+8]
   \       0xA8   0xD11E             BNE      ??HAL_RTC_SetAlarm_5
   1158            {
   1159              /* Disable the Alarm A interrupt */
   1160              __HAL_RTC_ALARMA_DISABLE(hrtc);
   \       0xAA   0x....             LDR      R2,??DataTable8  ;; 0xfffffeff
   \       0xAC   0x400A             ANDS     R2,R2,R1
   \       0xAE   0x6082             STR      R2,[R0, #+8]
   1161          
   1162              /* In case of interrupt mode is used, the interrupt source must disabled */
   1163              __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
   \       0xB0   0x6838             LDR      R0,[R7, #+0]
   \       0xB2   0x6881             LDR      R1,[R0, #+8]
   \       0xB4   0x....             LDR      R2,??DataTable8_1  ;; 0xffffefff
   \       0xB6   0x400A             ANDS     R2,R2,R1
   \       0xB8   0x6082             STR      R2,[R0, #+8]
   1164          
   1165              tickstart = HAL_GetTick();
   \       0xBA   0x....'....        BL       HAL_GetTick
   \       0xBE   0x0035             MOVS     R5,R6
   \       0xC0   0x0006             MOVS     R6,R0
   1166              /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
   1167              while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
   \                     ??HAL_RTC_SetAlarm_6: (+1)
   \       0xC2   0x6838             LDR      R0,[R7, #+0]
   \       0xC4   0x68C1             LDR      R1,[R0, #+12]
   \       0xC6   0x07C9             LSLS     R1,R1,#+31
   \       0xC8   0xD406             BMI      ??HAL_RTC_SetAlarm_7
   1168              {
   1169                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0xCA   0x....'....        BL       HAL_GetTick
   \       0xCE   0x1B80             SUBS     R0,R0,R6
   \       0xD0   0x....             LDR      R1,??DataTable9  ;; 0x3e9
   \       0xD2   0x4288             CMP      R0,R1
   \       0xD4   0xD3F5             BCC      ??HAL_RTC_SetAlarm_6
   1170                {
   1171                  /* Enable the write protection for RTC registers */
   1172                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1173          
   1174                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1175          
   1176                  /* Process Unlocked */
   1177                  __HAL_UNLOCK(hrtc);
   1178          
   1179                  return HAL_TIMEOUT;
   1180                }
   1181              }
   1182          
   1183              hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
   1184              /* Configure the Alarm A Sub Second register */
   1185              hrtc->Instance->ALRMASSR = subsecondtmpreg;
   1186              /* Configure the Alarm state: Enable Alarm */
   1187              __HAL_RTC_ALARMA_ENABLE(hrtc);
   1188            }
   1189            else
   1190            {
   1191              /* Disable the Alarm B interrupt */
   1192              __HAL_RTC_ALARMB_DISABLE(hrtc);
   1193          
   1194              /* In case of interrupt mode is used, the interrupt source must disabled */
   1195              __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
   1196          
   1197              tickstart = HAL_GetTick();
   1198              /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
   1199              while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
   1200              {
   1201                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   1202                {
   1203                  /* Enable the write protection for RTC registers */
   1204                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetAlarm_8: (+1)
   \       0xD6   0x....             B.N      ?Subroutine0
   1205          
   1206                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1207          
   1208                  /* Process Unlocked */
   1209                  __HAL_UNLOCK(hrtc);
   1210          
   1211                  return HAL_TIMEOUT;
   1212                }
   \                     ??HAL_RTC_SetAlarm_7: (+1)
   \       0xD8   0x61C4             STR      R4,[R0, #+28]
   \       0xDA   0x6838             LDR      R0,[R7, #+0]
   \       0xDC   0x6445             STR      R5,[R0, #+68]
   \       0xDE   0x6838             LDR      R0,[R7, #+0]
   \       0xE0   0x6881             LDR      R1,[R0, #+8]
   \       0xE2   0x2280             MOVS     R2,#+128
   \       0xE4   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \       0xE6   0xE01E             B        ??HAL_RTC_SetAlarm_9
   \                     ??HAL_RTC_SetAlarm_5: (+1)
   \       0xE8   0x....             LDR      R2,??DataTable8_2  ;; 0xfffffdff
   \       0xEA   0x400A             ANDS     R2,R2,R1
   \       0xEC   0x6082             STR      R2,[R0, #+8]
   \       0xEE   0x6838             LDR      R0,[R7, #+0]
   \       0xF0   0x6881             LDR      R1,[R0, #+8]
   \       0xF2   0x....             LDR      R2,??DataTable8_3  ;; 0xffffdfff
   \       0xF4   0x400A             ANDS     R2,R2,R1
   \       0xF6   0x6082             STR      R2,[R0, #+8]
   \       0xF8   0x....'....        BL       HAL_GetTick
   \       0xFC   0x0035             MOVS     R5,R6
   \       0xFE   0x0006             MOVS     R6,R0
   \                     ??HAL_RTC_SetAlarm_10: (+1)
   \      0x100   0x6838             LDR      R0,[R7, #+0]
   \      0x102   0x68C1             LDR      R1,[R0, #+12]
   \      0x104   0x9A00             LDR      R2,[SP, #+0]
   \      0x106   0x400A             ANDS     R2,R2,R1
   \      0x108   0xD106             BNE      ??HAL_RTC_SetAlarm_11
   \      0x10A   0x....'....        BL       HAL_GetTick
   \      0x10E   0x1B80             SUBS     R0,R0,R6
   \      0x110   0x....             LDR      R1,??DataTable9  ;; 0x3e9
   \      0x112   0x4288             CMP      R0,R1
   \      0x114   0xD3F4             BCC      ??HAL_RTC_SetAlarm_10
   \      0x116   0xE7DE             B        ??HAL_RTC_SetAlarm_8
   1213              }
   1214          
   1215              hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
   \                     ??HAL_RTC_SetAlarm_11: (+1)
   \      0x118   0x6204             STR      R4,[R0, #+32]
   1216              /* Configure the Alarm B Sub Second register */
   1217              hrtc->Instance->ALRMBSSR = subsecondtmpreg;
   \      0x11A   0x6838             LDR      R0,[R7, #+0]
   \      0x11C   0x6485             STR      R5,[R0, #+72]
   1218              /* Configure the Alarm state: Enable Alarm */
   1219              __HAL_RTC_ALARMB_ENABLE(hrtc);
   \      0x11E   0x6838             LDR      R0,[R7, #+0]
   \      0x120   0x6881             LDR      R1,[R0, #+8]
   \      0x122   0x2280             MOVS     R2,#+128
   \      0x124   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \                     ??HAL_RTC_SetAlarm_9: (+1)
   \      0x126   0x430A             ORRS     R2,R2,R1
   \      0x128   0x6082             STR      R2,[R0, #+8]
   1220            }
   1221          
   1222            /* Enable the write protection for RTC registers */
   1223            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \      0x12A   0x....             B.N      ?Subroutine1
   1224          
   1225            /* Change RTC state */
   1226            hrtc->State = HAL_RTC_STATE_READY;
   1227          
   1228            /* Process Unlocked */
   1229            __HAL_UNLOCK(hrtc);
   1230          
   1231            return HAL_OK;
   1232          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x20FF             MOVS     R0,#+255
   \        0x2   0x6839             LDR      R1,[R7, #+0]
   \        0x4   0x6248             STR      R0,[R1, #+36]
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x2121             MOVS     R1,#+33
   \        0xA   0x5478             STRB     R0,[R7, R1]
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x2120             MOVS     R1,#+32
   \       0x10   0x5478             STRB     R0,[R7, R1]
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x20FF             MOVS     R0,#+255
   \        0x2   0x6839             LDR      R1,[R7, #+0]
   \        0x4   0x6248             STR      R0,[R1, #+36]
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x2121             MOVS     R1,#+33
   \        0xA   0x5478             STRB     R0,[R7, R1]
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x2120             MOVS     R1,#+32
   \       0x10   0x5478             STRB     R0,[R7, R1]
   \       0x12   0x2003             MOVS     R0,#+3
   \       0x14   0xBDF2             POP      {R1,R4-R7,PC}
   1233          
   1234          /**
   1235            * @brief  Set the specified RTC Alarm with Interrupt.
   1236            * @param  hrtc RTC handle
   1237            * @param  sAlarm Pointer to Alarm structure
   1238            * @param  Format Specifies the format of the entered parameters.
   1239            *          This parameter can be one of the following values:
   1240            *             @arg RTC_FORMAT_BIN: Binary data format
   1241            *             @arg RTC_FORMAT_BCD: BCD data format
   1242            * @note   The Alarm register can only be written when the corresponding Alarm
   1243            *         is disabled (Use the HAL_RTC_DeactivateAlarm()).
   1244            * @note   The HAL_RTC_SetTime() must be called before enabling the Alarm feature.
   1245            * @retval HAL status
   1246            */

   \                                 In section .text, align 2, keep-with-next
   1247          HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
   1248          {
   \                     HAL_RTC_SetAlarm_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   1249            uint32_t tickstart;
   1250            uint32_t tmpreg, subsecondtmpreg;
   1251          
   1252            /* Check the parameters */
   1253            assert_param(IS_RTC_FORMAT(Format));
   1254            assert_param(IS_RTC_ALARM(sAlarm->Alarm));
   1255            assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
   1256            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
   1257            assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
   1258            assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
   1259          
   1260            /* Process Locked */
   1261            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C38             LDRB     R0,[R7, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTC_SetAlarm_IT_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTC_SetAlarm_IT_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x2320             MOVS     R3,#+32
   \       0x14   0x54F8             STRB     R0,[R7, R3]
   1262          
   1263            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x9000             STR      R0,[SP, #+0]
   \       0x1A   0x2321             MOVS     R3,#+33
   \       0x1C   0x54F8             STRB     R0,[R7, R3]
   1264          
   1265            if (Format == RTC_FORMAT_BIN)
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x2340             MOVS     R3,#+64
   \       0x22   0x000D             MOVS     R5,R1
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0x6880             LDR      R0,[R0, #+8]
   \       0x28   0xD119             BNE      ??HAL_RTC_SetAlarm_IT_1
   1266            {
   1267              if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
   \       0x2A   0x4003             ANDS     R3,R3,R0
   \       0x2C   0xD101             BNE      ??HAL_RTC_SetAlarm_IT_2
   1268              {
   1269                assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
   1270                assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
   1271              }
   1272              else
   1273              {
   1274                sAlarm->AlarmTime.TimeFormat = 0x00U;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x70E8             STRB     R0,[R5, #+3]
   1275                assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
   1276              }
   1277              assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
   1278              assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
   1279          
   1280              if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
   1281              {
   1282                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
   1283              }
   1284              else
   1285              {
   1286                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
   1287              }
   1288              tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
   1289                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
   1290                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
   1291                        ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
   1292                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
   1293                        ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
   1294                        ((uint32_t)sAlarm->AlarmMask));
   \                     ??HAL_RTC_SetAlarm_IT_2: (+1)
   \       0x32   0x7828             LDRB     R0,[R5, #+0]
   \       0x34   0x....'....        BL       RTC_ByteToBcd2
   \       0x38   0x0404             LSLS     R4,R0,#+16
   \       0x3A   0x7868             LDRB     R0,[R5, #+1]
   \       0x3C   0x....'....        BL       RTC_ByteToBcd2
   \       0x40   0x0206             LSLS     R6,R0,#+8
   \       0x42   0x4326             ORRS     R6,R6,R4
   \       0x44   0x78A8             LDRB     R0,[R5, #+2]
   \       0x46   0x....'....        BL       RTC_ByteToBcd2
   \       0x4A   0x0004             MOVS     R4,R0
   \       0x4C   0x2020             MOVS     R0,#+32
   \       0x4E   0x5C28             LDRB     R0,[R5, R0]
   \       0x50   0x....'....        BL       RTC_ByteToBcd2
   \       0x54   0x4334             ORRS     R4,R4,R6
   \       0x56   0x78E9             LDRB     R1,[R5, #+3]
   \       0x58   0x0409             LSLS     R1,R1,#+16
   \       0x5A   0x4321             ORRS     R1,R1,R4
   \       0x5C   0xE00F             B        ??HAL_RTC_SetAlarm_IT_3
   1295            }
   1296            else
   1297            {
   1298              if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
   \                     ??HAL_RTC_SetAlarm_IT_1: (+1)
   \       0x5E   0x4003             ANDS     R3,R3,R0
   \       0x60   0xD101             BNE      ??HAL_RTC_SetAlarm_IT_4
   1299              {
   1300                assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
   1301                assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
   1302              }
   1303              else
   1304              {
   1305                sAlarm->AlarmTime.TimeFormat = 0x00U;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x70E8             STRB     R0,[R5, #+3]
   1306                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
   1307              }
   1308          
   1309              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
   1310              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
   1311          
   1312              if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
   1313              {
   1314                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
   1315              }
   1316              else
   1317              {
   1318                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
   1319              }
   1320              tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
   1321                        ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
   1322                        ((uint32_t) sAlarm->AlarmTime.Seconds) | \
   1323                        ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
   1324                        ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
   1325                        ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
   1326                        ((uint32_t)sAlarm->AlarmMask));
   \                     ??HAL_RTC_SetAlarm_IT_4: (+1)
   \       0x66   0x7828             LDRB     R0,[R5, #+0]
   \       0x68   0x0400             LSLS     R0,R0,#+16
   \       0x6A   0x7869             LDRB     R1,[R5, #+1]
   \       0x6C   0x0209             LSLS     R1,R1,#+8
   \       0x6E   0x4301             ORRS     R1,R1,R0
   \       0x70   0x78A8             LDRB     R0,[R5, #+2]
   \       0x72   0x4308             ORRS     R0,R0,R1
   \       0x74   0x78E9             LDRB     R1,[R5, #+3]
   \       0x76   0x0409             LSLS     R1,R1,#+16
   \       0x78   0x4301             ORRS     R1,R1,R0
   \       0x7A   0x2020             MOVS     R0,#+32
   \       0x7C   0x5C28             LDRB     R0,[R5, R0]
   \                     ??HAL_RTC_SetAlarm_IT_3: (+1)
   \       0x7E   0x0600             LSLS     R0,R0,#+24
   \       0x80   0x4308             ORRS     R0,R0,R1
   \       0x82   0x69E9             LDR      R1,[R5, #+28]
   \       0x84   0x4301             ORRS     R1,R1,R0
   \       0x86   0x696C             LDR      R4,[R5, #+20]
   \       0x88   0x430C             ORRS     R4,R4,R1
   1327            }
   1328            /* Configure the Alarm A or Alarm B Sub Second registers */
   1329            subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
   \       0x8A   0x6868             LDR      R0,[R5, #+4]
   \       0x8C   0x69AE             LDR      R6,[R5, #+24]
   \       0x8E   0x4306             ORRS     R6,R6,R0
   1330          
   1331            /* Disable the write protection for RTC registers */
   1332            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x90   0x20CA             MOVS     R0,#+202
   \       0x92   0x6839             LDR      R1,[R7, #+0]
   \       0x94   0x6248             STR      R0,[R1, #+36]
   \       0x96   0x2053             MOVS     R0,#+83
   \       0x98   0x6839             LDR      R1,[R7, #+0]
   \       0x9A   0x6248             STR      R0,[R1, #+36]
   1333          
   1334            /* Configure the Alarm register */
   1335            if (sAlarm->Alarm == RTC_ALARM_A)
   \       0x9C   0x6839             LDR      R1,[R7, #+0]
   \       0x9E   0x2080             MOVS     R0,#+128
   \       0xA0   0x6A6A             LDR      R2,[R5, #+36]
   \       0xA2   0x0043             LSLS     R3,R0,#+1
   \       0xA4   0x429A             CMP      R2,R3
   \       0xA6   0x688A             LDR      R2,[R1, #+8]
   \       0xA8   0xD125             BNE      ??HAL_RTC_SetAlarm_IT_5
   1336            {
   1337              /* Disable the Alarm A interrupt */
   1338              __HAL_RTC_ALARMA_DISABLE(hrtc);
   \       0xAA   0x....             LDR      R3,??DataTable8  ;; 0xfffffeff
   \       0xAC   0x4013             ANDS     R3,R3,R2
   \       0xAE   0x608B             STR      R3,[R1, #+8]
   1339          
   1340              /* Clear flag alarm A */
   1341              __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
   \       0xB0   0x6839             LDR      R1,[R7, #+0]
   \       0xB2   0x68CA             LDR      R2,[R1, #+12]
   \       0xB4   0x4010             ANDS     R0,R0,R2
   \       0xB6   0x....             LDR      R2,??DataTable11  ;; 0xfffffe7f
   \       0xB8   0x4302             ORRS     R2,R2,R0
   \       0xBA   0x60CA             STR      R2,[R1, #+12]
   1342          
   1343              tickstart = HAL_GetTick();
   \       0xBC   0x....'....        BL       HAL_GetTick
   \       0xC0   0x0035             MOVS     R5,R6
   \       0xC2   0x0006             MOVS     R6,R0
   1344              /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
   1345              while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
   \                     ??HAL_RTC_SetAlarm_IT_6: (+1)
   \       0xC4   0x6838             LDR      R0,[R7, #+0]
   \       0xC6   0x68C1             LDR      R1,[R0, #+12]
   \       0xC8   0x07C9             LSLS     R1,R1,#+31
   \       0xCA   0xD406             BMI      ??HAL_RTC_SetAlarm_IT_7
   1346              {
   1347                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0xCC   0x....'....        BL       HAL_GetTick
   \       0xD0   0x1B80             SUBS     R0,R0,R6
   \       0xD2   0x....             LDR      R1,??DataTable9  ;; 0x3e9
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xD3F5             BCC      ??HAL_RTC_SetAlarm_IT_6
   1348                {
   1349                  /* Enable the write protection for RTC registers */
   1350                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1351          
   1352                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1353          
   1354                  /* Process Unlocked */
   1355                  __HAL_UNLOCK(hrtc);
   1356          
   1357                  return HAL_TIMEOUT;
   1358                }
   1359              }
   1360          
   1361              hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
   1362              /* Configure the Alarm A Sub Second register */
   1363              hrtc->Instance->ALRMASSR = subsecondtmpreg;
   1364              /* Configure the Alarm state: Enable Alarm */
   1365              __HAL_RTC_ALARMA_ENABLE(hrtc);
   1366              /* Configure the Alarm interrupt */
   1367              __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRA);
   1368            }
   1369            else
   1370            {
   1371              /* Disable the Alarm B interrupt */
   1372              __HAL_RTC_ALARMB_DISABLE(hrtc);
   1373          
   1374              /* Clear flag alarm B */
   1375              __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
   1376          
   1377              tickstart = HAL_GetTick();
   1378              /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
   1379              while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
   1380              {
   1381                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   1382                {
   1383                  /* Enable the write protection for RTC registers */
   1384                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetAlarm_IT_8: (+1)
   \       0xD8   0x....             B.N      ?Subroutine0
   1385          
   1386                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1387          
   1388                  /* Process Unlocked */
   1389                  __HAL_UNLOCK(hrtc);
   1390          
   1391                  return HAL_TIMEOUT;
   1392                }
   \                     ??HAL_RTC_SetAlarm_IT_7: (+1)
   \       0xDA   0x61C4             STR      R4,[R0, #+28]
   \       0xDC   0x6838             LDR      R0,[R7, #+0]
   \       0xDE   0x6445             STR      R5,[R0, #+68]
   \       0xE0   0x6838             LDR      R0,[R7, #+0]
   \       0xE2   0x6881             LDR      R1,[R0, #+8]
   \       0xE4   0x2280             MOVS     R2,#+128
   \       0xE6   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \       0xE8   0x430A             ORRS     R2,R2,R1
   \       0xEA   0x6082             STR      R2,[R0, #+8]
   \       0xEC   0x6838             LDR      R0,[R7, #+0]
   \       0xEE   0x6881             LDR      R1,[R0, #+8]
   \       0xF0   0x2280             MOVS     R2,#+128
   \       0xF2   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \       0xF4   0xE025             B        ??HAL_RTC_SetAlarm_IT_9
   \                     ??HAL_RTC_SetAlarm_IT_5: (+1)
   \       0xF6   0x....             LDR      R3,??DataTable8_2  ;; 0xfffffdff
   \       0xF8   0x4013             ANDS     R3,R3,R2
   \       0xFA   0x608B             STR      R3,[R1, #+8]
   \       0xFC   0x6839             LDR      R1,[R7, #+0]
   \       0xFE   0x68CA             LDR      R2,[R1, #+12]
   \      0x100   0x4010             ANDS     R0,R0,R2
   \      0x102   0x....             LDR      R2,??DataTable12  ;; 0xfffffd7f
   \      0x104   0x4302             ORRS     R2,R2,R0
   \      0x106   0x60CA             STR      R2,[R1, #+12]
   \      0x108   0x....'....        BL       HAL_GetTick
   \      0x10C   0x0035             MOVS     R5,R6
   \      0x10E   0x0006             MOVS     R6,R0
   \                     ??HAL_RTC_SetAlarm_IT_10: (+1)
   \      0x110   0x6838             LDR      R0,[R7, #+0]
   \      0x112   0x68C1             LDR      R1,[R0, #+12]
   \      0x114   0x9A00             LDR      R2,[SP, #+0]
   \      0x116   0x400A             ANDS     R2,R2,R1
   \      0x118   0xD106             BNE      ??HAL_RTC_SetAlarm_IT_11
   \      0x11A   0x....'....        BL       HAL_GetTick
   \      0x11E   0x1B80             SUBS     R0,R0,R6
   \      0x120   0x....             LDR      R1,??DataTable9  ;; 0x3e9
   \      0x122   0x4288             CMP      R0,R1
   \      0x124   0xD3F4             BCC      ??HAL_RTC_SetAlarm_IT_10
   \      0x126   0xE7D7             B        ??HAL_RTC_SetAlarm_IT_8
   1393              }
   1394          
   1395              hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
   \                     ??HAL_RTC_SetAlarm_IT_11: (+1)
   \      0x128   0x6204             STR      R4,[R0, #+32]
   1396              /* Configure the Alarm B Sub Second register */
   1397              hrtc->Instance->ALRMBSSR = subsecondtmpreg;
   \      0x12A   0x6838             LDR      R0,[R7, #+0]
   \      0x12C   0x6485             STR      R5,[R0, #+72]
   1398              /* Configure the Alarm state: Enable Alarm */
   1399              __HAL_RTC_ALARMB_ENABLE(hrtc);
   \      0x12E   0x6838             LDR      R0,[R7, #+0]
   \      0x130   0x6881             LDR      R1,[R0, #+8]
   \      0x132   0x2280             MOVS     R2,#+128
   \      0x134   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \      0x136   0x430A             ORRS     R2,R2,R1
   \      0x138   0x6082             STR      R2,[R0, #+8]
   1400              /* Configure the Alarm interrupt */
   1401              __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
   \      0x13A   0x6838             LDR      R0,[R7, #+0]
   \      0x13C   0x6881             LDR      R1,[R0, #+8]
   \      0x13E   0x2280             MOVS     R2,#+128
   \      0x140   0x0192             LSLS     R2,R2,#+6        ;; #+8192
   \                     ??HAL_RTC_SetAlarm_IT_9: (+1)
   \      0x142   0x430A             ORRS     R2,R2,R1
   \      0x144   0x6082             STR      R2,[R0, #+8]
   1402            }
   1403          
   1404            /* RTC Alarm Interrupt Configuration: EXTI configuration */
   1405            __HAL_RTC_ALARM_EXTI_ENABLE_IT();
   \      0x146   0x2080             MOVS     R0,#+128
   \      0x148   0x0280             LSLS     R0,R0,#+10       ;; #+131072
   \      0x14A   0x....             LDR      R1,??DataTable13  ;; 0x40010400
   \      0x14C   0x680A             LDR      R2,[R1, #+0]
   \      0x14E   0x4302             ORRS     R2,R2,R0
   \      0x150   0x600A             STR      R2,[R1, #+0]
   1406          
   1407            __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
   \      0x152   0x688A             LDR      R2,[R1, #+8]
   \      0x154   0x4310             ORRS     R0,R0,R2
   \      0x156   0x6088             STR      R0,[R1, #+8]
   1408          
   1409            /* Enable the write protection for RTC registers */
   1410            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \      0x158                      REQUIRE ?Subroutine1
   \      0x158                      ;; // Fall through to label ?Subroutine1
   1411          
   1412            hrtc->State = HAL_RTC_STATE_READY;
   1413          
   1414            /* Process Unlocked */
   1415            __HAL_UNLOCK(hrtc);
   1416          
   1417            return HAL_OK;
   1418          }
   1419          
   1420          /**
   1421            * @brief  Deactivate the specified RTC Alarm.
   1422            * @param  hrtc RTC handle
   1423            * @param  Alarm Specifies the Alarm.
   1424            *          This parameter can be one of the following values:
   1425            *            @arg RTC_ALARM_A:  AlarmA
   1426            *            @arg RTC_ALARM_B:  AlarmB
   1427            * @retval HAL status
   1428            */

   \                                 In section .text, align 2, keep-with-next
   1429          HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
   1430          {
   \                     HAL_RTC_DeactivateAlarm: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1431            uint32_t tickstart;
   1432          
   1433            /* Check the parameters */
   1434            assert_param(IS_RTC_ALARM(Alarm));
   1435          
   1436            /* Process Locked */
   1437            __HAL_LOCK(hrtc);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_RTC_DeactivateAlarm_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTC_DeactivateAlarm_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x2220             MOVS     R2,#+32
   \       0x14   0x54A0             STRB     R0,[R4, R2]
   1438          
   1439            hrtc->State = HAL_RTC_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x2221             MOVS     R2,#+33
   \       0x1A   0x54A0             STRB     R0,[R4, R2]
   1440          
   1441            /* Disable the write protection for RTC registers */
   1442            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \       0x1C   0x20CA             MOVS     R0,#+202
   \       0x1E   0x6822             LDR      R2,[R4, #+0]
   \       0x20   0x6250             STR      R0,[R2, #+36]
   \       0x22   0x2053             MOVS     R0,#+83
   \       0x24   0x6822             LDR      R2,[R4, #+0]
   \       0x26   0x6250             STR      R0,[R2, #+36]
   1443          
   1444            if (Alarm == RTC_ALARM_A)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x27FF             MOVS     R7,#+255
   \       0x2C   0x2500             MOVS     R5,#+0
   \       0x2E   0x1C7A             ADDS     R2,R7,#+1
   \       0x30   0x4291             CMP      R1,R2
   \       0x32   0x6881             LDR      R1,[R0, #+8]
   \       0x34   0xD11D             BNE      ??HAL_RTC_DeactivateAlarm_1
   1445            {
   1446              /* AlarmA */
   1447              __HAL_RTC_ALARMA_DISABLE(hrtc);
   \       0x36   0x....             LDR      R2,??DataTable8  ;; 0xfffffeff
   \       0x38   0x400A             ANDS     R2,R2,R1
   \       0x3A   0x6082             STR      R2,[R0, #+8]
   1448          
   1449              /* In case of interrupt mode is used, the interrupt source must disabled */
   1450              __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6881             LDR      R1,[R0, #+8]
   \       0x40   0x....             LDR      R2,??DataTable8_1  ;; 0xffffefff
   \       0x42   0x400A             ANDS     R2,R2,R1
   \       0x44   0x6082             STR      R2,[R0, #+8]
   1451          
   1452              tickstart = HAL_GetTick();
   \       0x46   0x....'....        BL       HAL_GetTick
   \       0x4A   0x0006             MOVS     R6,R0
   1453          
   1454              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1455              while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
   \                     ??HAL_RTC_DeactivateAlarm_2: (+1)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x68C0             LDR      R0,[R0, #+12]
   \       0x50   0x07C0             LSLS     R0,R0,#+31
   \       0x52   0xD424             BMI      ??HAL_RTC_DeactivateAlarm_3
   1456              {
   1457                if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x54   0x....'....        BL       HAL_GetTick
   \       0x58   0x1B80             SUBS     R0,R0,R6
   \       0x5A   0x....             LDR      R1,??DataTable9  ;; 0x3e9
   \       0x5C   0x4288             CMP      R0,R1
   \       0x5E   0xD3F5             BCC      ??HAL_RTC_DeactivateAlarm_2
   1458                {
   1459                  /* Enable the write protection for RTC registers */
   1460                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1461          
   1462                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1463          
   1464                  /* Process Unlocked */
   1465                  __HAL_UNLOCK(hrtc);
   1466          
   1467                  return HAL_TIMEOUT;
   1468                }
   1469              }
   1470            }
   1471            else
   1472            {
   1473              /* AlarmB */
   1474              __HAL_RTC_ALARMB_DISABLE(hrtc);
   1475          
   1476              /* In case of interrupt mode is used, the interrupt source must disabled */
   1477              __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
   1478          
   1479              tickstart = HAL_GetTick();
   1480          
   1481              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1482              while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
   1483              {
   1484                if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   1485                {
   1486                  /* Enable the write protection for RTC registers */
   1487                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_DeactivateAlarm_4: (+1)
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6247             STR      R7,[R0, #+36]
   1488          
   1489                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \       0x64   0x2003             MOVS     R0,#+3
   \       0x66   0x2121             MOVS     R1,#+33
   \       0x68   0x5460             STRB     R0,[R4, R1]
   1490          
   1491                  /* Process Unlocked */
   1492                  __HAL_UNLOCK(hrtc);
   \       0x6A   0x2020             MOVS     R0,#+32
   \       0x6C   0x5425             STRB     R5,[R4, R0]
   1493          
   1494                  return HAL_TIMEOUT;
   \       0x6E   0x2003             MOVS     R0,#+3
   \       0x70   0xBDF2             POP      {R1,R4-R7,PC}
   1495                }
   \                     ??HAL_RTC_DeactivateAlarm_1: (+1)
   \       0x72   0x....             LDR      R2,??DataTable8_2  ;; 0xfffffdff
   \       0x74   0x400A             ANDS     R2,R2,R1
   \       0x76   0x6082             STR      R2,[R0, #+8]
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6881             LDR      R1,[R0, #+8]
   \       0x7C   0x....             LDR      R2,??DataTable8_3  ;; 0xffffdfff
   \       0x7E   0x400A             ANDS     R2,R2,R1
   \       0x80   0x6082             STR      R2,[R0, #+8]
   \       0x82   0x....'....        BL       HAL_GetTick
   \       0x86   0x0006             MOVS     R6,R0
   \                     ??HAL_RTC_DeactivateAlarm_5: (+1)
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x68C0             LDR      R0,[R0, #+12]
   \       0x8C   0x0780             LSLS     R0,R0,#+30
   \       0x8E   0xD406             BMI      ??HAL_RTC_DeactivateAlarm_3
   \       0x90   0x....'....        BL       HAL_GetTick
   \       0x94   0x1B80             SUBS     R0,R0,R6
   \       0x96   0x....             LDR      R1,??DataTable9  ;; 0x3e9
   \       0x98   0x4288             CMP      R0,R1
   \       0x9A   0xD3F5             BCC      ??HAL_RTC_DeactivateAlarm_5
   \       0x9C   0xE7E0             B        ??HAL_RTC_DeactivateAlarm_4
   1496              }
   1497            }
   1498            /* Enable the write protection for RTC registers */
   1499            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_DeactivateAlarm_3: (+1)
   \       0x9E   0x6820             LDR      R0,[R4, #+0]
   \       0xA0   0x6247             STR      R7,[R0, #+36]
   1500          
   1501            hrtc->State = HAL_RTC_STATE_READY;
   \       0xA2                      REQUIRE ?Subroutine2
   \       0xA2                      ;; // Fall through to label ?Subroutine2
   1502          
   1503            /* Process Unlocked */
   1504            __HAL_UNLOCK(hrtc);
   1505          
   1506            return HAL_OK;
   1507          }
   1508          
   1509          /**
   1510            * @brief  Get the RTC Alarm value and masks.
   1511            * @param  hrtc RTC handle
   1512            * @param  sAlarm Pointer to Date structure
   1513            * @param  Alarm Specifies the Alarm.
   1514            *          This parameter can be one of the following values:
   1515            *             @arg RTC_ALARM_A: AlarmA
   1516            *             @arg RTC_ALARM_B: AlarmB
   1517            * @param  Format Specifies the format of the entered parameters.
   1518            *          This parameter can be one of the following values:
   1519            *             @arg RTC_FORMAT_BIN: Binary data format
   1520            *             @arg RTC_FORMAT_BCD: BCD data format
   1521            * @retval HAL status
   1522            */

   \                                 In section .text, align 2, keep-with-next
   1523          HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
   1524          {
   \                     HAL_RTC_GetAlarm: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0016             MOVS     R6,R2
   1525            uint32_t tmpreg, subsecondtmpreg;
   1526          
   1527            /* Check the parameters */
   1528            assert_param(IS_RTC_FORMAT(Format));
   1529            assert_param(IS_RTC_ALARM(Alarm));
   1530          
   1531            if (Alarm == RTC_ALARM_A)
   \        0x6   0x2280             MOVS     R2,#+128
   \        0x8   0x05D2             LSLS     R2,R2,#+23       ;; #+1073741824
   \        0xA   0x....             LDR      R1,??DataTable13_1  ;; 0x7fff
   \        0xC   0x257F             MOVS     R5,#+127
   \        0xE   0x233F             MOVS     R3,#+63
   \       0x10   0x0D97             LSRS     R7,R2,#+22
   \       0x12   0x42BE             CMP      R6,R7
   \       0x14   0xD104             BNE      ??HAL_RTC_GetAlarm_0
   1532            {
   1533              /* AlarmA */
   1534              sAlarm->Alarm = RTC_ALARM_A;
   \       0x16   0x6267             STR      R7,[R4, #+36]
   1535          
   1536              tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x69C6             LDR      R6,[R0, #+28]
   1537              subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR) & RTC_ALRMASSR_SS);
   \       0x1C   0x6C40             LDR      R0,[R0, #+68]
   \       0x1E   0xE004             B        ??HAL_RTC_GetAlarm_1
   1538          
   1539              /* Fill the structure with the read parameters */
   1540              sAlarm->AlarmTime.Hours = (uint8_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16U);
   1541              sAlarm->AlarmTime.Minutes = (uint8_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8U);
   1542              sAlarm->AlarmTime.Seconds = (uint8_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
   1543              sAlarm->AlarmTime.TimeFormat = (uint8_t)((tmpreg & RTC_ALRMAR_PM) >> 16U);
   1544              sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
   1545              sAlarm->AlarmDateWeekDay = (uint8_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24U);
   1546              sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
   1547              sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);
   1548            }
   1549            else
   1550            {
   1551              sAlarm->Alarm = RTC_ALARM_B;
   \                     ??HAL_RTC_GetAlarm_0: (+1)
   \       0x20   0x0D56             LSRS     R6,R2,#+21
   \       0x22   0x6266             STR      R6,[R4, #+36]
   1552          
   1553              tmpreg = (uint32_t)(hrtc->Instance->ALRMBR);
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x6A06             LDR      R6,[R0, #+32]
   1554              subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);
   \       0x28   0x6C80             LDR      R0,[R0, #+72]
   \                     ??HAL_RTC_GetAlarm_1: (+1)
   \       0x2A   0x9001             STR      R0,[SP, #+4]
   1555          
   1556              /* Fill the structure with the read parameters */
   1557              sAlarm->AlarmTime.Hours = (uint8_t)((tmpreg & (RTC_ALRMBR_HT | RTC_ALRMBR_HU)) >> 16U);
   \       0x2C   0x0C30             LSRS     R0,R6,#+16
   \       0x2E   0x466F             MOV      R7,SP
   \       0x30   0x7038             STRB     R0,[R7, #+0]
   \       0x32   0x4668             MOV      R0,SP
   \       0x34   0x7800             LDRB     R0,[R0, #+0]
   \       0x36   0x4018             ANDS     R0,R0,R3
   \       0x38   0x70B8             STRB     R0,[R7, #+2]
   1558              sAlarm->AlarmTime.Minutes = (uint8_t)((tmpreg & (RTC_ALRMBR_MNT | RTC_ALRMBR_MNU)) >> 8U);
   \       0x3A   0x0A30             LSRS     R0,R6,#+8
   \       0x3C   0x4028             ANDS     R0,R0,R5
   1559              sAlarm->AlarmTime.Seconds = (uint8_t)(tmpreg & (RTC_ALRMBR_ST | RTC_ALRMBR_SU));
   \       0x3E   0x4035             ANDS     R5,R5,R6
   \       0x40   0x707D             STRB     R5,[R7, #+1]
   1560              sAlarm->AlarmTime.TimeFormat = (uint8_t)((tmpreg & RTC_ALRMBR_PM) >> 16U);
   \       0x42   0x466D             MOV      R5,SP
   \       0x44   0x782D             LDRB     R5,[R5, #+0]
   \       0x46   0x2740             MOVS     R7,#+64
   \       0x48   0x403D             ANDS     R5,R5,R7
   \       0x4A   0x466F             MOV      R7,SP
   \       0x4C   0x703D             STRB     R5,[R7, #+0]
   1561              sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
   \       0x4E   0x9D01             LDR      R5,[SP, #+4]
   \       0x50   0x4029             ANDS     R1,R1,R5
   1562              sAlarm->AlarmDateWeekDay = (uint8_t)((tmpreg & (RTC_ALRMBR_DT | RTC_ALRMBR_DU)) >> 24U);
   \       0x52   0x0E35             LSRS     R5,R6,#+24
   \       0x54   0x402B             ANDS     R3,R3,R5
   1563              sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMBR_WDSEL);
   \       0x56   0x4032             ANDS     R2,R2,R6
   1564              sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);
   \       0x58   0x....             LDR      R5,??DataTable13_2  ;; 0x80808080
   \       0x5A   0x4035             ANDS     R5,R5,R6
   \       0x5C   0x9E02             LDR      R6,[SP, #+8]
   \       0x5E   0x78BF             LDRB     R7,[R7, #+2]
   \       0x60   0x7027             STRB     R7,[R4, #+0]
   \       0x62   0x7060             STRB     R0,[R4, #+1]
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x7840             LDRB     R0,[R0, #+1]
   \       0x68   0x70A0             STRB     R0,[R4, #+2]
   \       0x6A   0x4668             MOV      R0,SP
   \       0x6C   0x7800             LDRB     R0,[R0, #+0]
   \       0x6E   0x70E0             STRB     R0,[R4, #+3]
   \       0x70   0x6061             STR      R1,[R4, #+4]
   \       0x72   0x6165             STR      R5,[R4, #+20]
   \       0x74   0x61E2             STR      R2,[R4, #+28]
   \       0x76   0x2020             MOVS     R0,#+32
   \       0x78   0x5423             STRB     R3,[R4, R0]
   1565            }
   1566          
   1567            if (Format == RTC_FORMAT_BIN)
   \       0x7A   0x2E00             CMP      R6,#+0
   \       0x7C   0xD111             BNE      ??HAL_RTC_GetAlarm_2
   1568            {
   1569              sAlarm->AlarmTime.Hours = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
   \       0x7E   0x7820             LDRB     R0,[R4, #+0]
   \       0x80   0x....'....        BL       RTC_Bcd2ToByte
   \       0x84   0x7020             STRB     R0,[R4, #+0]
   1570              sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);
   \       0x86   0x7860             LDRB     R0,[R4, #+1]
   \       0x88   0x....'....        BL       RTC_Bcd2ToByte
   \       0x8C   0x7060             STRB     R0,[R4, #+1]
   1571              sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);
   \       0x8E   0x78A0             LDRB     R0,[R4, #+2]
   \       0x90   0x....'....        BL       RTC_Bcd2ToByte
   \       0x94   0x70A0             STRB     R0,[R4, #+2]
   1572              sAlarm->AlarmDateWeekDay = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
   \       0x96   0x2020             MOVS     R0,#+32
   \       0x98   0x5C20             LDRB     R0,[R4, R0]
   \       0x9A   0x....'....        BL       RTC_Bcd2ToByte
   \       0x9E   0x2120             MOVS     R1,#+32
   \       0xA0   0x5460             STRB     R0,[R4, R1]
   1573            }
   1574          
   1575            return HAL_OK;
   \                     ??HAL_RTC_GetAlarm_2: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xBDFE             POP      {R1-R7,PC}       ;; return
   1576          }
   1577          
   1578          /**
   1579            * @brief  Handle Alarm interrupt request.
   1580            * @param  hrtc RTC handle
   1581            * @retval None
   1582            */

   \                                 In section .text, align 2, keep-with-next
   1583          void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
   1584          {
   \                     HAL_RTC_AlarmIRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1585            /* Get the AlarmA interrupt source enable status */
   1586            if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != 0U)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2580             MOVS     R5,#+128
   \        0x8   0x6881             LDR      R1,[R0, #+8]
   \        0xA   0x04C9             LSLS     R1,R1,#+19
   \        0xC   0xD50B             BPL      ??HAL_RTC_AlarmIRQHandler_0
   1587            {
   1588              /* Get the pending status of the AlarmA Interrupt */
   1589              if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != 0U)
   \        0xE   0x68C0             LDR      R0,[R0, #+12]
   \       0x10   0x05C0             LSLS     R0,R0,#+23
   \       0x12   0xD508             BPL      ??HAL_RTC_AlarmIRQHandler_0
   1590              {
   1591                /* AlarmA callback */
   1592          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
   1593                hrtc->AlarmAEventCallback(hrtc);
   1594          #else
   1595                HAL_RTC_AlarmAEventCallback(hrtc);
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x....'....        BL       HAL_RTC_AlarmAEventCallback
   1596          #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
   1597          
   1598                /* Clear the AlarmA interrupt pending bit */
   1599                __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C1             LDR      R1,[R0, #+12]
   \       0x1E   0x4029             ANDS     R1,R1,R5
   \       0x20   0x....             LDR      R2,??DataTable11  ;; 0xfffffe7f
   \       0x22   0x430A             ORRS     R2,R2,R1
   \       0x24   0x60C2             STR      R2,[R0, #+12]
   1600              }
   1601            }
   1602          
   1603            /* Get the AlarmB interrupt source enable status */
   1604            if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != 0U)
   \                     ??HAL_RTC_AlarmIRQHandler_0: (+1)
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6881             LDR      R1,[R0, #+8]
   \       0x2A   0x0489             LSLS     R1,R1,#+18
   \       0x2C   0xD50B             BPL      ??HAL_RTC_AlarmIRQHandler_1
   1605            {
   1606              /* Get the pending status of the AlarmB Interrupt */
   1607              if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != 0U)
   \       0x2E   0x68C0             LDR      R0,[R0, #+12]
   \       0x30   0x0580             LSLS     R0,R0,#+22
   \       0x32   0xD508             BPL      ??HAL_RTC_AlarmIRQHandler_1
   1608              {
   1609                /* AlarmB callback */
   1610          #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
   1611                hrtc->AlarmBEventCallback(hrtc);
   1612          #else
   1613                HAL_RTCEx_AlarmBEventCallback(hrtc);
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       HAL_RTCEx_AlarmBEventCallback
   1614          #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
   1615          
   1616                /* Clear the AlarmB interrupt pending bit */
   1617                __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x68C1             LDR      R1,[R0, #+12]
   \       0x3E   0x400D             ANDS     R5,R5,R1
   \       0x40   0x....             LDR      R1,??DataTable12  ;; 0xfffffd7f
   \       0x42   0x4329             ORRS     R1,R1,R5
   \       0x44   0x60C1             STR      R1,[R0, #+12]
   1618              }
   1619            }
   1620            /* Clear the EXTI's line Flag for RTC Alarm */
   1621            __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
   \                     ??HAL_RTC_AlarmIRQHandler_1: (+1)
   \       0x46   0x2080             MOVS     R0,#+128
   \       0x48   0x0280             LSLS     R0,R0,#+10       ;; #+131072
   \       0x4A   0x....             LDR      R1,??DataTable13_3  ;; 0x40010414
   \       0x4C   0x6008             STR      R0,[R1, #+0]
   1622          
   1623            /* Change RTC state */
   1624            hrtc->State = HAL_RTC_STATE_READY;
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0x2121             MOVS     R1,#+33
   \       0x52   0x5460             STRB     R0,[R4, R1]
   1625          }
   \       0x54   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1626          
   1627          /**
   1628            * @brief  Alarm A callback.
   1629            * @param  hrtc RTC handle
   1630            * @retval None
   1631            */

   \                                 In section .text, align 2
   1632          __weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
   1633          {
   1634            /* Prevent unused argument(s) compilation warning */
   1635            UNUSED(hrtc);
   1636          
   1637            /* NOTE : This function should not be modified, when the callback is needed,
   1638                      the HAL_RTC_AlarmAEventCallback could be implemented in the user file
   1639             */
   1640          }
   \                     HAL_RTC_AlarmAEventCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1641          
   1642          /**
   1643            * @brief  Handle AlarmA Polling request.
   1644            * @param  hrtc RTC handle
   1645            * @param  Timeout Timeout duration
   1646            * @retval HAL status
   1647            */

   \                                 In section .text, align 2, keep-with-next
   1648          HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
   1649          {
   \                     HAL_RTC_PollForAlarmAEvent: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1650          
   1651            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
   1652          
   1653            while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == 0U)
   \                     ??HAL_RTC_PollForAlarmAEvent_0: (+1)
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0x05C9             LSLS     R1,R1,#+23
   \       0x12   0xD40E             BMI      ??HAL_RTC_PollForAlarmAEvent_1
   1654            {
   1655              if (Timeout != HAL_MAX_DELAY)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD0F7             BEQ      ??HAL_RTC_PollForAlarmAEvent_0
   1656              {
   1657                if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x1C   0x....'....        BL       HAL_GetTick
   \       0x20   0x1B80             SUBS     R0,R0,R6
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD301             BCC      ??HAL_RTC_PollForAlarmAEvent_2
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD1F0             BNE      ??HAL_RTC_PollForAlarmAEvent_0
   1658                {
   1659                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \                     ??HAL_RTC_PollForAlarmAEvent_2: (+1)
   \       0x2A   0x2003             MOVS     R0,#+3
   \       0x2C   0x2121             MOVS     R1,#+33
   \       0x2E   0x5468             STRB     R0,[R5, R1]
   1660                  return HAL_TIMEOUT;
   \       0x30   0xBD70             POP      {R4-R6,PC}
   1661                }
   1662              }
   1663            }
   1664          
   1665            /* Clear the Alarm interrupt pending bit */
   1666            __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
   \                     ??HAL_RTC_PollForAlarmAEvent_1: (+1)
   \       0x32   0x68C1             LDR      R1,[R0, #+12]
   \       0x34   0x2280             MOVS     R2,#+128
   \       0x36   0x4011             ANDS     R1,R1,R2
   \       0x38   0x....             LDR      R2,??DataTable11  ;; 0xfffffe7f
   \       0x3A   0x430A             ORRS     R2,R2,R1
   \       0x3C   0x60C2             STR      R2,[R0, #+12]
   1667          
   1668            /* Change RTC state */
   1669            hrtc->State = HAL_RTC_STATE_READY;
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x2121             MOVS     R1,#+33
   \       0x42   0x5468             STRB     R0,[R5, R1]
   1670          
   1671            return HAL_OK;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD70             POP      {R4-R6,PC}       ;; return
   1672          }
   1673          
   1674          /**
   1675            * @}
   1676            */
   1677          
   1678          /** @addtogroup RTC_Exported_Functions_Group4
   1679           *  @brief   Peripheral Control functions
   1680           *
   1681          @verbatim
   1682           ===============================================================================
   1683                               ##### Peripheral Control functions #####
   1684           ===============================================================================
   1685              [..]
   1686              This subsection provides functions allowing to
   1687                (+) Wait for RTC Time and Date Synchronization
   1688          
   1689          @endverbatim
   1690            * @{
   1691            */
   1692          
   1693          /**
   1694            * @brief  Wait until the RTC Time and Date registers (RTC_TR and RTC_DR) are
   1695            *         synchronized with RTC APB clock.
   1696            * @note   The RTC Resynchronization mode is write protected, use the
   1697            *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
   1698            * @note   To read the calendar through the shadow registers after Calendar
   1699            *         initialization, calendar update or after wakeup from low power modes
   1700            *         the software must first clear the RSF flag.
   1701            *         The software must then wait until it is set again before reading
   1702            *         the calendar, which means that the calendar registers have been
   1703            *         correctly copied into the RTC_TR and RTC_DR shadow registers.
   1704            * @param  hrtc RTC handle
   1705            * @retval HAL status
   1706            */

   \                                 In section .text, align 2, keep-with-next
   1707          HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
   1708          {
   \                     HAL_RTC_WaitForSynchro: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1709            uint32_t tickstart;
   1710          
   1711            /* Clear RSF flag */
   1712            hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C1             LDR      R1,[R0, #+12]
   \        0x8   0x22A0             MOVS     R2,#+160
   \        0xA   0x4391             BICS     R1,R1,R2
   \        0xC   0x60C1             STR      R1,[R0, #+12]
   1713          
   1714            tickstart = HAL_GetTick();
   \        0xE   0x....'....        BL       HAL_GetTick
   \       0x12   0x0005             MOVS     R5,R0
   1715          
   1716            /* Wait the registers to be synchronised */
   1717            while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
   \                     ??HAL_RTC_WaitForSynchro_0: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C0             LDR      R0,[R0, #+12]
   \       0x18   0x0680             LSLS     R0,R0,#+26
   \       0x1A   0xD407             BMI      ??HAL_RTC_WaitForSynchro_1
   1718            {
   1719              if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x1C   0x....'....        BL       HAL_GetTick
   \       0x20   0x1B40             SUBS     R0,R0,R5
   \       0x22   0x....             LDR      R1,??DataTable12_1  ;; 0x3e9
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xD3F5             BCC      ??HAL_RTC_WaitForSynchro_0
   1720              {
   1721                return HAL_TIMEOUT;
   \       0x28   0x2003             MOVS     R0,#+3
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1722              }
   1723            }
   1724          
   1725            return HAL_OK;
   \                     ??HAL_RTC_WaitForSynchro_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
   1726          }
   1727          
   1728          /**
   1729            * @}
   1730            */
   1731          
   1732          /** @addtogroup RTC_Exported_Functions_Group5
   1733           *  @brief   Peripheral State functions
   1734           *
   1735          @verbatim
   1736           ===============================================================================
   1737                               ##### Peripheral State functions #####
   1738           ===============================================================================
   1739              [..]
   1740              This subsection provides functions allowing to
   1741                (+) Get RTC state
   1742          
   1743          @endverbatim
   1744            * @{
   1745            */
   1746          /**
   1747            * @brief  Return the RTC handle state.
   1748            * @param  hrtc RTC handle
   1749            * @retval HAL state
   1750            */

   \                                 In section .text, align 2, keep-with-next
   1751          HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc)
   1752          {
   1753            /* Return RTC handle state */
   1754            return hrtc->State;
   \                     HAL_RTC_GetState: (+1)
   \        0x0   0x2121             MOVS     R1,#+33
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   1755          }
   1756          
   1757          /**
   1758            * @}
   1759            */
   1760          /**
   1761            * @}
   1762            */
   1763          
   1764          /** @addtogroup RTC_Private_Functions
   1765            * @{
   1766            */
   1767          /**
   1768            * @brief  Enter the RTC Initialization mode.
   1769            * @note   The RTC Initialization mode is write protected, use the
   1770            *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
   1771            * @param  hrtc RTC handle
   1772            * @retval HAL status
   1773            */

   \                                 In section .text, align 2, keep-with-next
   1774          HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
   1775          {
   \                     RTC_EnterInitMode: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1776            uint32_t tickstart;
   1777          
   1778            /* Check if the Initialization mode is set */
   1779            if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0x2440             MOVS     R4,#+64
   \        0x8   0x68C1             LDR      R1,[R0, #+12]
   \        0xA   0x4021             ANDS     R1,R1,R4
   \        0xC   0xD111             BNE      ??RTC_EnterInitMode_0
   1780            {
   1781              /* Set the Initialization mode */
   1782              hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x43C9             MVNS     R1,R1            ;; #-1
   \       0x12   0x60C1             STR      R1,[R0, #+12]
   1783          
   1784              tickstart = HAL_GetTick();
   \       0x14   0x....'....        BL       HAL_GetTick
   \       0x18   0x0006             MOVS     R6,R0
   1785              /* Wait till RTC is in INIT state and if Time out is reached exit */
   1786              while ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
   \                     ??RTC_EnterInitMode_1: (+1)
   \       0x1A   0x6828             LDR      R0,[R5, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x4020             ANDS     R0,R0,R4
   \       0x20   0xD107             BNE      ??RTC_EnterInitMode_0
   1787              {
   1788                if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
   \       0x22   0x....'....        BL       HAL_GetTick
   \       0x26   0x1B80             SUBS     R0,R0,R6
   \       0x28   0x....             LDR      R1,??DataTable13_4  ;; 0x3e9
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD3F5             BCC      ??RTC_EnterInitMode_1
   1789                {
   1790                  return HAL_TIMEOUT;
   \       0x2E   0x2003             MOVS     R0,#+3
   \       0x30   0xBD70             POP      {R4-R6,PC}
   1791                }
   1792              }
   1793            }
   1794          
   1795            return HAL_OK;
   \                     ??RTC_EnterInitMode_0: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD70             POP      {R4-R6,PC}       ;; return
   1796          }
   1797          
   1798          
   1799          /**
   1800            * @brief  Convert a 2 digit decimal to BCD format.
   1801            * @param  Value Byte to be converted
   1802            * @retval Converted byte
   1803            */

   \                                 In section .text, align 2, keep-with-next
   1804          uint8_t RTC_ByteToBcd2(uint8_t Value)
   1805          {
   1806            uint32_t bcdhigh = 0U;
   \                     RTC_ByteToBcd2: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1807            uint8_t Param = Value;
   \        0x2   0xE001             B        ??RTC_ByteToBcd2_0
   1808          
   1809            while (Param >= 10U)
   1810            {
   1811              bcdhigh++;
   \                     ??RTC_ByteToBcd2_1: (+1)
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   1812              Param -= 10U;
   \        0x6   0x380A             SUBS     R0,R0,#+10
   1813            }
   \                     ??RTC_ByteToBcd2_0: (+1)
   \        0x8   0xB2C2             UXTB     R2,R0
   \        0xA   0x2A0A             CMP      R2,#+10
   \        0xC   0xD2FA             BCS      ??RTC_ByteToBcd2_1
   1814          
   1815            return ((uint8_t)(bcdhigh << 4U) | Param);
   \        0xE   0x0109             LSLS     R1,R1,#+4
   \       0x10   0x4308             ORRS     R0,R0,R1
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0x4770             BX       LR               ;; return
   1816          }
   1817          
   1818          /**
   1819            * @brief  Convert from 2 digit BCD to Binary.
   1820            * @param  Value BCD value to be converted
   1821            * @retval Converted word
   1822            */

   \                                 In section .text, align 2, keep-with-next
   1823          uint8_t RTC_Bcd2ToByte(uint8_t Value)
   1824          {
   1825            uint32_t tmp;
   1826            tmp = (((uint32_t)Value & 0xF0U) >> 4U) * 10U;
   1827            return (uint8_t)(tmp + ((uint32_t)Value & 0x0FU));
   \                     RTC_Bcd2ToByte: (+1)
   \        0x0   0x0901             LSRS     R1,R0,#+4
   \        0x2   0x220A             MOVS     R2,#+10
   \        0x4   0x4351             MULS     R1,R2,R1
   \        0x6   0x0700             LSLS     R0,R0,#+28
   \        0x8   0x0F00             LSRS     R0,R0,#+28
   \        0xA   0x1808             ADDS     R0,R1,R0
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x4770             BX       LR               ;; return
   1828          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0xFF8F'FFBF        DC32     0xff8fffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x0000'2101        DC32     0x2101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x0000'03E9        DC32     0x3e9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x0000'FFFF        DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x007F'00FF        DC32     0x7f00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x007F'7F7F        DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0xFFFB'FFFF        DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x00FF'FF3F        DC32     0xffff3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0xFFFF'DFFF        DC32     0xffffdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x0000'03E9        DC32     0x3e9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xFFFF'FE7F        DC32     0xfffffe7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xFFFF'FD7F        DC32     0xfffffd7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x0000'03E9        DC32     0x3e9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x0000'7FFF        DC32     0x7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x8080'8080        DC32     0x80808080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x4001'0414        DC32     0x40010414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x0000'03E9        DC32     0x3e9
   1829          
   1830          /**
   1831            * @}
   1832            */
   1833          
   1834          #endif /* HAL_RTC_MODULE_ENABLED */
   1835          /**
   1836            * @}
   1837            */
   1838          
   1839          /**
   1840            * @}
   1841            */
   1842          
   1843          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RTC_AlarmAEventCallback
      16   HAL_RTC_AlarmIRQHandler
        16   -> HAL_RTCEx_AlarmBEventCallback
        16   -> HAL_RTC_AlarmAEventCallback
      24   HAL_RTC_DeInit
        24   -> HAL_GetTick
        24   -> HAL_RTC_MspDeInit
        24   -> HAL_RTC_WaitForSynchro
        24   -> RTC_EnterInitMode
      24   HAL_RTC_DeactivateAlarm
        24   -> HAL_GetTick
      32   HAL_RTC_GetAlarm
        32   -> RTC_Bcd2ToByte
       8   HAL_RTC_GetDate
         8   -> RTC_Bcd2ToByte
       0   HAL_RTC_GetState
       8   HAL_RTC_GetTime
         8   -> RTC_Bcd2ToByte
      24   HAL_RTC_Init
        24   -> HAL_RTC_MspInit
        24   -> HAL_RTC_WaitForSynchro
        24   -> RTC_EnterInitMode
       0   HAL_RTC_MspDeInit
       0   HAL_RTC_MspInit
      16   HAL_RTC_PollForAlarmAEvent
        16   -> HAL_GetTick
      24   HAL_RTC_SetAlarm
        24   -> HAL_GetTick
        24   -> RTC_ByteToBcd2
      24   HAL_RTC_SetAlarm_IT
        24   -> HAL_GetTick
        24   -> RTC_ByteToBcd2
      24   HAL_RTC_SetDate
        24   -> HAL_RTC_WaitForSynchro
        24   -> RTC_ByteToBcd2
        24   -> RTC_EnterInitMode
      24   HAL_RTC_SetTime
        24   -> HAL_RTC_WaitForSynchro
        24   -> RTC_ByteToBcd2
        24   -> RTC_EnterInitMode
      16   HAL_RTC_WaitForSynchro
        16   -> HAL_GetTick
       0   RTC_Bcd2ToByte
       0   RTC_ByteToBcd2
      16   RTC_EnterInitMode
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
      22  ?Subroutine0
      20  ?Subroutine1
      14  ?Subroutine2
       2  HAL_RTC_AlarmAEventCallback
      86  HAL_RTC_AlarmIRQHandler
     200  HAL_RTC_DeInit
     162  HAL_RTC_DeactivateAlarm
     166  HAL_RTC_GetAlarm
      62  HAL_RTC_GetDate
       6  HAL_RTC_GetState
      76  HAL_RTC_GetTime
     194  HAL_RTC_Init
       2  HAL_RTC_MspDeInit
       2  HAL_RTC_MspInit
      72  HAL_RTC_PollForAlarmAEvent
     300  HAL_RTC_SetAlarm
     344  HAL_RTC_SetAlarm_IT
     200  HAL_RTC_SetDate
     234  HAL_RTC_SetTime
      48  HAL_RTC_WaitForSynchro
      16  RTC_Bcd2ToByte
      22  RTC_ByteToBcd2
      54  RTC_EnterInitMode

 
 2'388 bytes in section .text
 
 2'382 bytes of CODE memory (+ 6 bytes shared)

Errors: none
Warnings: none
