###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  12:25:12
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\mcu_api_stm32.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW3461.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\mcu_api_stm32.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\mcu_api_stm32.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\mcu_api_stm32.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\mcu_api_stm32.c
      1          /*!
      2          * \file mcu_api.c
      3          * \brief Sigfox MCU functions
      4          * \author  AMG - RF Application team
      5          * \version 2.3.6
      6          * \date July, 2019
      7          * \copyright COPYRIGHT 2018 STMicroelectronics
      8          *
      9          * This file defines the manufacturer's MCU functions to be implemented
     10          * for library usage.
     11          */
     12          
     13          /********************************************************
     14          * External API dependencies to link with this library.
     15          *
     16          * Error codes of the MCU API functions are described below.
     17          * The Manufacturer can add more error code taking care of the limits defined.
     18          *
     19          ********************************************************/
     20          
     21          #include "sigfox_stack.h"
     22          #include "SDK_EVAL_Config.h"
     23          #include "SDK_UTILS_Timers.h"
     24          #include "S2LP_Middleware_Config.h"
     25          
     26          //#define DEBUG
     27          
     28          #ifdef DEBUG
     29          void ST_dbg_CB(const char *vectcStr,...);
     30          #define PRINTF(...)     { ST_dbg_CB(__VA_ARGS__);}
     31          #else
     32          #define PRINTF(...)
     33          #endif
     34          
     35          #define DECAY_LEVEL 34
     36          
     37          #define ATOMIC_SECTION_BEGIN() uint32_t uwPRIMASK_Bit = __get_PRIMASK(); __disable_irq();
     38          
     39           /* Must be called in the same or in a lower scope of ATOMIC_SECTION_BEGIN */
     40          #define ATOMIC_SECTION_END() __set_PRIMASK(uwPRIMASK_Bit)
     41          
     42          /*!
     43          * \defgroup MCU_ERR_API_xx codes Return Error codes definition for MCU API
     44          *
     45          * \brief Can be customized to add new error codes.
     46          * All MCU_API_ error codes will be piped with SIGFOX_API_xxx return code.<BR>
     47          *
     48          * IMPORTANT : SFX_ERR_NONE return code is mandatory when no error for each MCU_API_xxx RF_API_xxx REPEATER_API_xxx or SE_API_xxx
     49          * functions.
     50          *
     51          *  @{
     52          */
     53          
     54          /* ---------------------------------------------------------------- */
     55          /* Bytes reserved for MCU API ERROR CODES : From 0x10 to 0x2F       */
     56          /* ---------------------------------------------------------------- */
     57          
     58          #define MCU_ERR_API_MALLOC                  (sfx_u8)(0x11) /*!< Error on MCU_API_malloc */
     59          #define MCU_ERR_API_FREE                    (sfx_u8)(0x12) /*!< Error on MCU_API_free */
     60          #define MCU_ERR_API_VOLT_TEMP               (sfx_u8)(0x13) /*!< Error on MCU_API_get_voltage_temperature */
     61          #define MCU_ERR_API_DLY                     (sfx_u8)(0x14) /*!< Error on MCU_API_delay */
     62          #define MCU_ERR_API_AES                     (sfx_u8)(0x15) /*!< Error on MCU_API_aes_128_cbc_encrypt */
     63          #define MCU_ERR_API_GETNVMEM                (sfx_u8)(0x16) /*!< Error on MCU_API_get_nv_mem */
     64          #define MCU_ERR_API_SETNVMEM                (sfx_u8)(0x17) /*!< Error on MCU_API_set_nv_mem */
     65          #define MCU_ERR_API_TIMER_START             (sfx_u8)(0x18) /*!< Error on MCU_API_timer_start */
     66          #define MCU_ERR_API_TIMER_START_CS          (sfx_u8)(0x19) /*!< Error on MCU_API_timer_start_carrier_sense */
     67          #define MCU_ERR_API_TIMER_STOP_CS           (sfx_u8)(0x1A) /*!< Error on MCU_API_timer_stop_carrier_sense */
     68          #define MCU_ERR_API_TIMER_STOP              (sfx_u8)(0x1B) /*!< Error on MCU_API_timer_stop */
     69          #define MCU_ERR_API_TIMER_END               (sfx_u8)(0x1C) /*!< Error on MCU_API_timer_wait_for_end */
     70          #define MCU_ERR_API_TEST_REPORT             (sfx_u8)(0x1D) /*!< Error on MCU_API_report_test_result */
     71          #define MCU_ERR_API_GET_VERSION             (sfx_u8)(0x1E) /*!< Error on MCU_API_get_version */
     72          
     73          #if defined CREDENTIALS_SECURE_ELEMENT || defined CREDENTIALS_UNCRYPTED
     74          #define MCU_ERR_API_GET_ID                  (sfx_u8)(0x1F) /*!< Error on MCU_API_get_device_id */
     75          #define MCU_ERR_API_GET_PAC                 (sfx_u8)(0x20) /*!< Error on MCU_API_get_initial_pac */
     76          #else
     77          #define MCU_ERR_API_AES_GET_CRYPT           (sfx_u8)(0x21) /*!< Error on MCU_API_get_encrypted_info */
     78          #define MCU_ERR_API_AES_DECRYPT             (sfx_u8)(0x22) /*!< Error on MCU_API_aes_128_cbc_decrypt */
     79          #endif
     80          
     81          /* ---------------------------------------------------------------- */
     82          /* Bytes reserved for RF API ERROR CODES : From 0x30 to 0x3F        */
     83          /* ---------------------------------------------------------------- */
     84          
     85          /* ---------------------------------------------------------------- */
     86          /* Bytes reserved for SE API ERROR CODES : From 0x40 to 0x5F        */
     87          /* ---------------------------------------------------------------- */
     88          
     89          /* ---------------------------------------------------------------- */
     90          /* Bytes reserved for REPEATER API ERROR CODES : From 0x60 to 0x7F  */
     91          /* ---------------------------------------------------------------- */
     92          
     93          #define ST_TRUE  1
     94          #define ST_FALSE 0
     95          
     96          #define M2S_GPIO_IRQ_PIN			S2LP_Middleware_GpioGetPin((M2SGpioPin)S2LP_GPIO_IRQ_PIN)
     97          
     98          #if defined(USE_STM32L0XX_NUCLEO) || defined(USE_STM32F0XX_NUCLEO)
     99          #define IRQ_PRIORITY 0x00
    100          #else
    101          #define IRQ_PRIORITY 0x0A
    102          #endif
    103          
    104          #define MCU_API_VER		"v2.3.8"
    105          
    106          /** @}*/
    107          

   \                                 In section .data, align 4
    108          static RTC_HandleTypeDef RtcHandler={.Instance=RTC};
    109          static volatile uint8_t rtc_irq=0, rtc_in_use=0, notify_end=0, rtc_in_use_for_cs=0;
   \                     rtc_irq:
   \        0x0   0x00               DC8 0
   \        0x1   0x00               DC8 0
   \        0x2   0x00               DC8 0
   \        0x3   0x00               DC8 0
   \        0x4   0x01               DC8 1
   \        0x5   0x00               DC8 0
   \        0x6   0x00               DC8 0
   \        0x7   0x00               DC8 0
   \        0x8   0x0947             DC16 2'375
   \        0xA   0x00 0x00          DC8 0, 0
   \        0xC   0x4000'2800        DC32 0x4000'2800
   \       0x10                      DS8 32
   \       0x30   0x0000'0000        DC32 0
   \       0x34   0x0000'0000        DC32 0
   \       0x38   0x4000'0000        DC32 0x4000'0000
   \       0x3C                      DS8 56
    110          static volatile uint8_t low_power=1,carrier_sense_tim_started=0;
    111          static volatile uint32_t next_rtc_wakeup=0,n_intermediate_tim_irq=0;
    112          static volatile int16_t rtc_presc=2375;
    113          static volatile uint8_t s2lp_irq_raised=0;
    114          static TIM_HandleTypeDef  Tim2_Handler={.Instance=TIM2};

   \                                 In section .bss, align 1
    115          static uint8_t _encryptedPayload = 0;
   \                     _encryptedPayload:
   \        0x0                      DS8 1

   \                                 In section .text, align 4, keep-with-next
    116          static const uint8_t _libVersion[] = MCU_API_VER;
   \                     _libVersion:
   \        0x0   0x76 0x32          DC8 "v2.3.8"

   \              0x2E 0x33    

   \              0x2E 0x38    

   \              0x00
   \        0x7                      DS8 1
    117          
    118          __weak void Appli_Exti_CB(uint16_t GPIO_Pin);
    119          
    120          #ifdef USE_STM32L0XX_NUCLEO

   \                                 In section .text, align 2, keep-with-next
    121          void ST_MCU_API_SetSysClock(void)
    122          {
   \                     ST_MCU_API_SetSysClock: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB093             SUB      SP,SP,#+76
    123            RCC_ClkInitTypeDef RCC_ClkInitStruct;
    124            RCC_OscInitTypeDef RCC_OscInitStruct;
    125          
    126            /* Enable Power Control clock */
    127            __HAL_RCC_PWR_CLK_ENABLE();
   \        0x4   0x....             LDR      R0,??DataTable10  ;; 0x40021038
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x2280             MOVS     R2,#+128
   \        0xA   0x0552             LSLS     R2,R2,#+21       ;; #+268435456
   \        0xC   0x430A             ORRS     R2,R2,R1
   \        0xE   0x6002             STR      R2,[R0, #+0]
    128          
    129            /* The voltage scaling allows optimizing the power consumption when the device is
    130            clocked below the maximum system frequency, to update the voltage scaling value
    131            regarding system frequency refer to product datasheet.  */
    132            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
   \       0x10   0x....             LDR      R0,??DataTable10_1  ;; 0x40007000
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x....             LDR      R2,??DataTable10_2  ;; 0xffffe7ff
   \       0x16   0x400A             ANDS     R2,R2,R1
   \       0x18   0x0CC1             LSRS     R1,R0,#+19
   \       0x1A   0x4311             ORRS     R1,R1,R2
   \       0x1C   0x6001             STR      R1,[R0, #+0]
    133          
    134            /* Enable HSI Oscillator and activate PLL with HSI as source */
    135            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x9005             STR      R0,[SP, #+20]
    136            RCC_OscInitStruct.HSEState = RCC_HSE_OFF;
   \       0x22   0x2400             MOVS     R4,#+0
   \       0x24   0x9406             STR      R4,[SP, #+24]
    137            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x9108             STR      R1,[SP, #+32]
    138            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \       0x2A   0x900F             STR      R0,[SP, #+60]
    139            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
   \       0x2C   0x9410             STR      R4,[SP, #+64]
    140            RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;
   \       0x2E   0x0440             LSLS     R0,R0,#+17
   \       0x30   0x9011             STR      R0,[SP, #+68]
    141            RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_4;
   \       0x32   0x20C0             MOVS     R0,#+192
   \       0x34   0x0400             LSLS     R0,R0,#+16       ;; #+12582912
   \       0x36   0x9012             STR      R0,[SP, #+72]
    142            RCC_OscInitStruct.HSICalibrationValue = 0x10;
   \       0x38   0x2010             MOVS     R0,#+16
   \       0x3A   0x9009             STR      R0,[SP, #+36]
    143            if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   \       0x3C   0xA805             ADD      R0,SP,#+20
   \       0x3E   0x....'....        BL       HAL_RCC_OscConfig
    144            {
    145            }
    146          
    147            /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
    148            clocks dividers */
    149            RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
   \       0x42   0x200F             MOVS     R0,#+15
   \       0x44   0x9000             STR      R0,[SP, #+0]
    150            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   \       0x46   0x2003             MOVS     R0,#+3
   \       0x48   0x9001             STR      R0,[SP, #+4]
    151            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
   \       0x4A   0x9402             STR      R4,[SP, #+8]
    152            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
   \       0x4C   0x9403             STR      R4,[SP, #+12]
    153            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
   \       0x4E   0x9404             STR      R4,[SP, #+16]
    154            if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
   \       0x50   0x2101             MOVS     R1,#+1
   \       0x52   0x4668             MOV      R0,SP
   \       0x54   0x....'....        BL       HAL_RCC_ClockConfig
    155            {
    156            }
    157          }
   \       0x58   0xB014             ADD      SP,SP,#+80
   \       0x5A   0xBD10             POP      {R4,PC}          ;; return
    158          #elif USE_STM32F0XX_NUCLEO
    159          void ST_MCU_API_SetSysClock(void)
    160          {
    161            RCC_ClkInitTypeDef RCC_ClkInitStruct;
    162            RCC_OscInitTypeDef RCC_OscInitStruct;
    163          
    164            /* Select HSI48 Oscillator as PLL source */
    165            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
    166            RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
    167            //  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    168            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    169            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI48;
    170            RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV6;
    171            RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL2;
    172            if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
    173            {
    174            }
    175          
    176            /* Select PLL as system clock source and configure the HCLK and PCLK1 clocks dividers */
    177            RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1);
    178            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    179            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    180            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    181            if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1)!= HAL_OK)
    182            {
    183            }
    184          
    185          }
    186          #elif USE_STM32F4XX_NUCLEO
    187          void ST_MCU_API_SetSysClock(void)
    188          {
    189            RCC_ClkInitTypeDef RCC_ClkInitStruct;
    190            RCC_OscInitTypeDef RCC_OscInitStruct;
    191          
    192            /* Enable Power Control clock */
    193            __HAL_RCC_PWR_CLK_ENABLE();
    194          
    195            /* The voltage scaling allows optimizing the power consumption when the device is
    196            clocked below the maximum system frequency, to update the voltage scaling value
    197            regarding system frequency refer to product datasheet.  */
    198            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
    199          
    200            /* Enable HSI Oscillator and activate PLL with HSI as source */
    201            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    202            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    203            RCC_OscInitStruct.HSICalibrationValue = 0x10;
    204            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    205            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
    206            RCC_OscInitStruct.PLL.PLLM = 16;
    207            RCC_OscInitStruct.PLL.PLLN = 64;
    208            RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
    209            RCC_OscInitStruct.PLL.PLLQ = 4;
    210            if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    211            {
    212            }
    213          
    214            /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
    215            clocks dividers */
    216            RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    217            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    218            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    219            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
    220            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    221            if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
    222            {
    223            }
    224          }
    225          #else
    226          void ST_MCU_API_SetSysClock(void)
    227          {
    228          
    229            RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
    230            RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    231          
    232            /* Enable HSE Oscillator and Activate PLL with HSE as source */
    233            RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
    234            RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
    235            RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    236            RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
    237            RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
    238            RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLL_MUL4;
    239            RCC_OscInitStruct.PLL.PLLDIV          = RCC_PLL_DIV4;
    240            HAL_RCC_OscConfig(&RCC_OscInitStruct);
    241          
    242            /* Set Voltage scale1 as MCU will run at 32MHz */
    243            __HAL_RCC_PWR_CLK_ENABLE();
    244            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
    245          
    246            /* Poll VOSF bit of in PWR_CSR. Wait until it is reset to 0 */
    247            while (__HAL_PWR_GET_FLAG(PWR_FLAG_VOS) != RESET) {};
    248          
    249            /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
    250            clocks dividers */
    251            RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    252            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    253            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    254            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    255            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    256            HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);
    257          
    258          }
    259          
    260          #endif
    261          

   \                                 In section .text, align 2, keep-with-next
    262          static void setGpioLowPower(void)
    263          {
   \                     setGpioLowPower: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    264            GPIO_InitTypeDef GPIO_InitStructure;
    265            GPIO_InitStructure.Mode       = GPIO_MODE_ANALOG;
   \        0x4   0x2403             MOVS     R4,#+3
   \        0x6   0x9401             STR      R4,[SP, #+4]
    266            GPIO_InitStructure.Pull       = GPIO_NOPULL;
   \        0x8   0x2500             MOVS     R5,#+0
   \        0xA   0x9502             STR      R5,[SP, #+8]
    267            GPIO_InitStructure.Speed      = GPIO_SPEED_HIGH;
   \        0xC   0x9403             STR      R4,[SP, #+12]
    268          
    269            GPIO_InitStructure.Pin        = EEPROM_SPI_MOSI_PIN | EEPROM_SPI_MISO_PIN;
   \        0xE   0x20C0             MOVS     R0,#+192
   \       0x10   0x9000             STR      R0,[SP, #+0]
    270            HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x12   0x4669             MOV      R1,SP
   \       0x14   0x20A0             MOVS     R0,#+160
   \       0x16   0x05C0             LSLS     R0,R0,#+23       ;; #+1342177280
   \       0x18   0x....'....        BL       HAL_GPIO_Init
    271          
    272            GPIO_InitStructure.Mode       = GPIO_MODE_ANALOG;
   \       0x1C   0x9401             STR      R4,[SP, #+4]
    273            GPIO_InitStructure.Pull       = GPIO_NOPULL;
   \       0x1E   0x9502             STR      R5,[SP, #+8]
    274            GPIO_InitStructure.Speed      = GPIO_SPEED_HIGH;
   \       0x20   0x9403             STR      R4,[SP, #+12]
    275          
    276            GPIO_InitStructure.Pin        = S2LP_SPI_SCLK_PIN;
   \       0x22   0x2008             MOVS     R0,#+8
   \       0x24   0x9000             STR      R0,[SP, #+0]
    277            HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x26   0x4669             MOV      R1,SP
   \       0x28   0x....             LDR      R0,??DataTable10_3  ;; 0x50000400
   \       0x2A   0x....'....        BL       HAL_GPIO_Init
    278          }
   \       0x2E   0xB005             ADD      SP,SP,#+20
   \       0x30   0xBD30             POP      {R4,R5,PC}       ;; return
    279          

   \                                 In section .text, align 2, keep-with-next
    280          static void setGpioRestore(void)
    281          {
   \                     setGpioRestore: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    282            /* For STM32, restore every gpio, previosly set as analog as digital */
    283          
    284            /* Restore all GPIO CLKs */
    285            STM32_GPIO_CLK_ENABLE();
   \        0x4   0x2401             MOVS     R4,#+1
   \        0x6   0x....             LDR      R0,??DataTable10_4  ;; 0x4002102c
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x4321             ORRS     R1,R1,R4
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x4021             ANDS     R1,R1,R4
   \       0x12   0x9100             STR      R1,[SP, #+0]
   \       0x14   0x9900             LDR      R1,[SP, #+0]
   \       0x16   0x2502             MOVS     R5,#+2
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x4329             ORRS     R1,R1,R5
   \       0x1C   0x6001             STR      R1,[R0, #+0]
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x4029             ANDS     R1,R1,R5
   \       0x22   0x9100             STR      R1,[SP, #+0]
   \       0x24   0x9900             LDR      R1,[SP, #+0]
   \       0x26   0x2104             MOVS     R1,#+4
   \       0x28   0x6802             LDR      R2,[R0, #+0]
   \       0x2A   0x430A             ORRS     R2,R2,R1
   \       0x2C   0x6002             STR      R2,[R0, #+0]
   \       0x2E   0x6802             LDR      R2,[R0, #+0]
   \       0x30   0x4011             ANDS     R1,R1,R2
   \       0x32   0x9100             STR      R1,[SP, #+0]
   \       0x34   0x9900             LDR      R1,[SP, #+0]
   \       0x36   0x2608             MOVS     R6,#+8
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x4331             ORRS     R1,R1,R6
   \       0x3C   0x6001             STR      R1,[R0, #+0]
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0x4030             ANDS     R0,R0,R6
   \       0x42   0x9000             STR      R0,[SP, #+0]
   \       0x44   0x9800             LDR      R0,[SP, #+0]
    286          
    287            /* SPI_MOSI/MISO */
    288            GPIO_InitTypeDef GPIO_InitStructure;
    289            GPIO_InitStructure.Mode       = GPIO_MODE_AF_PP;
   \       0x46   0x9501             STR      R5,[SP, #+4]
    290            GPIO_InitStructure.Pull       = GPIO_PULLUP;
   \       0x48   0x9402             STR      R4,[SP, #+8]
    291            GPIO_InitStructure.Speed      = GPIO_SPEED_HIGH;
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0x9003             STR      R0,[SP, #+12]
    292            GPIO_InitStructure.Alternate  = EEPROM_SPI_MISO_AF;
   \       0x4E   0x2700             MOVS     R7,#+0
   \       0x50   0x9704             STR      R7,[SP, #+16]
    293            GPIO_InitStructure.Pin        = EEPROM_SPI_MOSI_PIN | EEPROM_SPI_MISO_PIN;
   \       0x52   0x20C0             MOVS     R0,#+192
   \       0x54   0x9000             STR      R0,[SP, #+0]
    294            HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x56   0x4669             MOV      R1,SP
   \       0x58   0x20A0             MOVS     R0,#+160
   \       0x5A   0x05C0             LSLS     R0,R0,#+23       ;; #+1342177280
   \       0x5C   0x....'....        BL       HAL_GPIO_Init
    295          
    296            /* SPI_CLK*/
    297            GPIO_InitStructure.Mode       = GPIO_MODE_AF_PP;
   \       0x60   0x9501             STR      R5,[SP, #+4]
    298            GPIO_InitStructure.Pull       = GPIO_PULLUP;
   \       0x62   0x9402             STR      R4,[SP, #+8]
    299            GPIO_InitStructure.Alternate  = EEPROM_SPI_MISO_AF;
   \       0x64   0x9704             STR      R7,[SP, #+16]
    300            GPIO_InitStructure.Pin        = S2LP_SPI_SCLK_PIN;
   \       0x66   0x9600             STR      R6,[SP, #+0]
    301            HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x68   0x4669             MOV      R1,SP
   \       0x6A   0x....             LDR      R0,??DataTable10_3  ;; 0x50000400
   \       0x6C   0x....'....        BL       HAL_GPIO_Init
    302          
    303          }
   \       0x70   0xB005             ADD      SP,SP,#+20
   \       0x72   0xBDF0             POP      {R4-R7,PC}       ;; return
    304          
    305          static void handleS2LPIRQ(void){
    306              if (!ST_RF_API_Get_Continuous_TX_or_MONARCH_Scan_Flag())
    307              {
    308          	/* Avoid to refill the FIFO wile is still filling */
    309          	if (ST_RF_API_GetFIFOState()==ST_FIFO_STATE_WAITING_UNDERFLOW)
    310          	  s2lp_irq_raised=1;
    311              }
    312              else
    313                ST_RF_API_S2LP_IRQ_CB(); //If the CBPSK is implemented trigger TX State Machine
    314          }
    315          

   \                                 In section .text, align 2, keep-with-next
    316          void ST_MCU_API_GPIO_LowPower(void){setGpioLowPower();}
   \                     ST_MCU_API_GPIO_LowPower: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x....'....        BL       setGpioLowPower
   \        0x6   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    317          void ST_MCU_API_GPIO_Restore(void){setGpioRestore();}
   \                     ST_MCU_API_GPIO_Restore: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x....'....        BL       setGpioRestore
   \        0x6   0xBD01             POP      {R0,PC}          ;; return
    318          

   \                                 In section .text, align 2, keep-with-next
    319          void ST_MCU_API_WaitForInterrupt(void)
    320          {
   \                     ST_MCU_API_WaitForInterrupt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    321          #ifndef DEBUG
    322            if(low_power && (!carrier_sense_tim_started))
   \        0x2   0x....             LDR      R4,??DataTable11
   \        0x4   0x7920             LDRB     R0,[R4, #+4]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD014             BEQ      ??ST_MCU_API_WaitForInterrupt_0
   \        0xA   0x7960             LDRB     R0,[R4, #+5]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD111             BNE      ??ST_MCU_API_WaitForInterrupt_0
    323            {
    324              setGpioLowPower();
   \       0x10   0x....'....        BL       setGpioLowPower
    325          
    326              ATOMIC_SECTION_BEGIN();
   \       0x14   0xF3EF 0x8510      MRS      R5,PRIMASK
   \       0x18   0xB672             CPSID    I
    327          
    328              if (!s2lp_irq_raised) {
   \       0x1A   0x79A0             LDRB     R0,[R4, #+6]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD105             BNE      ??ST_MCU_API_WaitForInterrupt_1
    329          	HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON,PWR_STOPENTRY_WFI);
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x....'....        BL       HAL_PWR_EnterSTOPMode
    330          	ST_MCU_API_SetSysClock();
   \       0x28   0x....'....        BL       ST_MCU_API_SetSysClock
    331              }
    332          
    333              ATOMIC_SECTION_END();
   \                     ??ST_MCU_API_WaitForInterrupt_1: (+1)
   \       0x2C   0xF385 0x8810      MSR      PRIMASK,R5
    334          
    335              setGpioRestore();
   \       0x30   0x....'....        BL       setGpioRestore
    336            }
    337          #endif
    338          
    339            if(s2lp_irq_raised) {
   \                     ??ST_MCU_API_WaitForInterrupt_0: (+1)
   \       0x34   0x79A0             LDRB     R0,[R4, #+6]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD003             BEQ      ??ST_MCU_API_WaitForInterrupt_2
    340              s2lp_irq_raised=0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x71A0             STRB     R0,[R4, #+6]
    341              ST_RF_API_S2LP_IRQ_CB();
   \       0x3E   0x....'....        BL       ST_RF_API_S2LP_IRQ_CB
    342            }
    343          }
   \                     ??ST_MCU_API_WaitForInterrupt_2: (+1)
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    344          

   \                                 In section .text, align 2, keep-with-next
    345          static void Configure_RTC_Clock(void)
    346          {
   \                     Configure_RTC_Clock: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0xB097             SUB      SP,SP,#+92
    347            RCC_OscInitTypeDef        RCC_OscInitStruct;
    348            RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;
    349          
    350          #ifndef USE_STM32L0XX_NUCLEO
    351            __HAL_RCC_PWR_CLK_ENABLE();
    352          #endif
    353            HAL_PWR_EnableBkUpAccess();
   \        0x4   0x....'....        BL       HAL_PWR_EnableBkUpAccess
    354          
    355            RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
   \        0x8   0x200C             MOVS     R0,#+12
   \        0xA   0x9009             STR      R0,[SP, #+36]
    356            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9013             STR      R0,[SP, #+76]
    357            RCC_OscInitStruct.LSIState = RCC_LSI_ON;
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0x910E             STR      R1,[SP, #+56]
    358            RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
   \       0x14   0x900B             STR      R0,[SP, #+44]
    359            HAL_RCC_OscConfig(&RCC_OscInitStruct);
   \       0x16   0xA809             ADD      R0,SP,#+36
   \       0x18   0x....'....        BL       HAL_RCC_OscConfig
    360          
    361            PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
   \       0x1C   0x2020             MOVS     R0,#+32
   \       0x1E   0x9000             STR      R0,[SP, #+0]
    362            PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
   \       0x20   0x0300             LSLS     R0,R0,#+12
   \       0x22   0x9001             STR      R0,[SP, #+4]
    363            HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x....'....        BL       HAL_RCCEx_PeriphCLKConfig
    364          
    365            /* Enable RTC Clock */
    366            __HAL_RCC_RTC_ENABLE();
   \       0x2A   0x....             LDR      R0,??DataTable13  ;; 0x40021050
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x2280             MOVS     R2,#+128
   \       0x30   0x02D2             LSLS     R2,R2,#+11       ;; #+262144
   \       0x32   0x430A             ORRS     R2,R2,R1
   \       0x34   0x6002             STR      R2,[R0, #+0]
    367          
    368            HAL_NVIC_SetPriority(STM32_RTC_IRQn, 0x01, 0);
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x2101             MOVS     R1,#+1
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0x....'....        BL       HAL_NVIC_SetPriority
    369            HAL_NVIC_EnableIRQ(STM32_RTC_IRQn);
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0x....'....        BL       HAL_NVIC_EnableIRQ
    370          }
   \       0x46   0xB017             ADD      SP,SP,#+92
   \       0x48   0xBD00             POP      {PC}             ;; return
    371          

   \                                 In section .text, align 2, keep-with-next
    372          void ST_MCU_API_TimerCalibration(uint16_t duration_ms)
    373          {
   \                     ST_MCU_API_TimerCalibration: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB08F             SUB      SP,SP,#+60
   \        0x4   0x0006             MOVS     R6,R0
    374            TIM_HandleTypeDef  Tim2_Handler={.Instance=TIM2};
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x....             LDR      R1,??DataTable11_1
   \        0xA   0x223C             MOVS     R2,#+60
   \        0xC   0x....'....        BL       __aeabi_memcpy4
    375            uint16_t c;
    376            Configure_RTC_Clock();
   \       0x10   0x....'....        BL       Configure_RTC_Clock
    377            notify_end=1;
   \       0x14   0x....             LDR      R4,??DataTable11
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x70A0             STRB     R0,[R4, #+2]
    378            __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&RtcHandler, RTC_FLAG_WUTF);
   \       0x1A   0x68E0             LDR      R0,[R4, #+12]
   \       0x1C   0x68C1             LDR      R1,[R0, #+12]
   \       0x1E   0x2280             MOVS     R2,#+128
   \       0x20   0x4011             ANDS     R1,R1,R2
   \       0x22   0x....             LDR      R2,??DataTable13_1  ;; 0xfffffb7f
   \       0x24   0x430A             ORRS     R2,R2,R1
   \       0x26   0x60C2             STR      R2,[R0, #+12]
    379            __HAL_RTC_CLEAR_FLAG(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
   \       0x28   0x2080             MOVS     R0,#+128
   \       0x2A   0x0340             LSLS     R0,R0,#+13       ;; #+1048576
   \       0x2C   0x....             LDR      R1,??DataTable13_2  ;; 0x40010414
   \       0x2E   0x6008             STR      R0,[R1, #+0]
    380          
    381            next_rtc_wakeup=0;
   \       0x30   0x2500             MOVS     R5,#+0
   \       0x32   0x6325             STR      R5,[R4, #+48]
    382          
    383            SdkEvalTimersTimConfig(&Tim2_Handler, 16000-1, 65535-1);
   \       0x34   0x....             LDR      R2,??DataTable13_3  ;; 0xfffe
   \       0x36   0x....             LDR      R1,??DataTable15  ;; 0x3e7f
   \       0x38   0x4668             MOV      R0,SP
   \       0x3A   0x....'....        BL       SdkEvalTimersTimConfig
    384            __HAL_TIM_DISABLE_IT(&Tim2_Handler, TIM_IT_UPDATE);
   \       0x3E   0x9800             LDR      R0,[SP, #+0]
   \       0x40   0x68C0             LDR      R0,[R0, #+12]
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x4388             BICS     R0,R0,R1
   \       0x46   0x9900             LDR      R1,[SP, #+0]
   \       0x48   0x60C8             STR      R0,[R1, #+12]
    385            HAL_NVIC_DisableIRQ(TIM2_IRQn);
   \       0x4A   0x200F             MOVS     R0,#+15
   \       0x4C   0x....'....        BL       HAL_NVIC_DisableIRQ
    386            HAL_TIM_Base_Start(&Tim2_Handler);
   \       0x50   0x4668             MOV      R0,SP
   \       0x52   0x....'....        BL       HAL_TIM_Base_Start
    387          
    388            HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandler,rtc_presc*duration_ms/1000,RTC_WAKEUPCLOCK_RTCCLK_DIV16);
   \       0x56   0x2008             MOVS     R0,#+8
   \       0x58   0x5E20             LDRSH    R0,[R4, R0]
   \       0x5A   0x4370             MULS     R0,R6,R0
   \       0x5C   0x21FA             MOVS     R1,#+250
   \       0x5E   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x60   0x....'....        BL       __aeabi_idiv
   \       0x64   0x0001             MOVS     R1,R0
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x300C             ADDS     R0,R0,#+12
   \       0x6C   0x....'....        BL       HAL_RTCEx_SetWakeUpTimer_IT
    389            while(!rtc_irq);
   \                     ??ST_MCU_API_TimerCalibration_0: (+1)
   \       0x70   0x7820             LDRB     R0,[R4, #+0]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD0FC             BEQ      ??ST_MCU_API_TimerCalibration_0
    390            c=Tim2_Handler.Instance->CNT;
   \       0x76   0x9800             LDR      R0,[SP, #+0]
   \       0x78   0x6A47             LDR      R7,[R0, #+36]
    391            rtc_irq=0;
   \       0x7A   0x7025             STRB     R5,[R4, #+0]
    392            HAL_TIM_Base_Stop(&Tim2_Handler);
   \       0x7C   0x4668             MOV      R0,SP
   \       0x7E   0x....'....        BL       HAL_TIM_Base_Stop
    393          
    394            rtc_presc=duration_ms*rtc_presc/c;
   \       0x82   0x2008             MOVS     R0,#+8
   \       0x84   0x5E20             LDRSH    R0,[R4, R0]
   \       0x86   0x4346             MULS     R6,R0,R6
   \       0x88   0x0030             MOVS     R0,R6
   \       0x8A   0xB2B9             UXTH     R1,R7
   \       0x8C   0x....'....        BL       __aeabi_idiv
   \       0x90   0x8120             STRH     R0,[R4, #+8]
    395          }
   \       0x92   0xB00F             ADD      SP,SP,#+60
   \       0x94   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x4000'0000        DC32 0x4000'0000
   \        0x4                      DS8 56
    396          

   \                                 In section .text, align 2, keep-with-next
    397          void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    398          {
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    399            __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \        0x4   0x....             LDR      R0,??DataTable13_2  ;; 0x40010414
   \        0x6   0x6004             STR      R4,[R0, #+0]
    400          
    401            if(GPIO_Pin == M2S_GPIO_IRQ_PIN)
   \        0x8   0x2003             MOVS     R0,#+3
   \        0xA   0x....'....        BL       S2LP_Middleware_GpioGetPin
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD10E             BNE      ??HAL_GPIO_EXTI_Callback_0
    402              handleS2LPIRQ();
   \       0x12   0x....'....        BL       ST_RF_API_Get_Continuous_TX_or_MONARCH_Scan_Flag
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD107             BNE      ??HAL_GPIO_EXTI_Callback_1
   \       0x1A   0x....'....        BL       ST_RF_API_GetFIFOState
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD109             BNE      ??HAL_GPIO_EXTI_Callback_2
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x....             LDR      R1,??DataTable12
   \       0x26   0x7188             STRB     R0,[R1, #+6]
   \       0x28   0xBD10             POP      {R4,PC}
   \                     ??HAL_GPIO_EXTI_Callback_1: (+1)
   \       0x2A   0x....'....        BL       ST_RF_API_S2LP_IRQ_CB
   \       0x2E   0xBD10             POP      {R4,PC}
    403            else
    404              Appli_Exti_CB(GPIO_Pin);
   \                     ??HAL_GPIO_EXTI_Callback_0: (+1)
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x....'....        BL       Appli_Exti_CB
    405          }
   \                     ??HAL_GPIO_EXTI_Callback_2: (+1)
   \       0x36   0xBD10             POP      {R4,PC}          ;; return
    406          

   \                                 In section .text, align 2, keep-with-next
    407          void STM32_RTC_IRQHandler(void)
    408          {
   \                     RTC_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    409            Configure_RTC_Clock();
   \        0x2   0x....'....        BL       Configure_RTC_Clock
    410          
    411            PRINTF("*** RTC_IRQHandler IN\n\r");
    412          
    413            HAL_RTCEx_WakeUpTimerIRQHandler(&RtcHandler);
   \        0x6   0x....             LDR      R4,??DataTable12
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x300C             ADDS     R0,R0,#+12
   \        0xC   0x....'....        BL       HAL_RTCEx_WakeUpTimerIRQHandler
    414            HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandler);
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x300C             ADDS     R0,R0,#+12
   \       0x14   0x....'....        BL       HAL_RTCEx_DeactivateWakeUpTimer
    415          
    416            if(next_rtc_wakeup==0)
   \       0x18   0x6B20             LDR      R0,[R4, #+48]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD111             BNE      ??RTC_IRQHandler_0
    417            {
    418              rtc_irq=1;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x7020             STRB     R0,[R4, #+0]
    419              rtc_in_use=0;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x7060             STRB     R0,[R4, #+1]
    420              if(notify_end)
   \       0x26   0x78A1             LDRB     R1,[R4, #+2]
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD010             BEQ      ??RTC_IRQHandler_1
    421              {
    422          	if(rtc_in_use_for_cs)
   \       0x2C   0x78E1             LDRB     R1,[R4, #+3]
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD003             BEQ      ??RTC_IRQHandler_2
    423          	{
    424          	  rtc_in_use_for_cs=0;
   \       0x32   0x70E0             STRB     R0,[R4, #+3]
    425          	  ST_RF_API_Timer_Channel_Clear_CB();
   \       0x34   0x....'....        BL       ST_RF_API_Timer_Channel_Clear_CB
   \       0x38   0xBD10             POP      {R4,PC}
    426          	}
    427          	else
    428          	{
    429          	  ST_RF_API_Timer_CB(TIMER_STOP);
   \                     ??RTC_IRQHandler_2: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x....'....        BL       ST_RF_API_Timer_CB
   \       0x40   0xBD10             POP      {R4,PC}
    430          	}
    431              }
    432            }
    433            else
    434            {
    435              MCU_API_timer_start(next_rtc_wakeup);
   \                     ??RTC_IRQHandler_0: (+1)
   \       0x42   0x6B20             LDR      R0,[R4, #+48]
   \       0x44   0x....'....        BL       MCU_API_timer_start
    436              n_intermediate_tim_irq++;
   \       0x48   0x6B60             LDR      R0,[R4, #+52]
   \       0x4A   0x1C40             ADDS     R0,R0,#+1
   \       0x4C   0x6360             STR      R0,[R4, #+52]
    437            }
    438          }
   \                     ??RTC_IRQHandler_1: (+1)
   \       0x4E   0xBD10             POP      {R4,PC}          ;; return
    439          

   \                                 In section .text, align 2, keep-with-next
    440          void TIM2_IRQHandler(void)
    441          {
   \                     TIM2_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    442            if(__HAL_TIM_GET_IT_SOURCE(&Tim2_Handler, TIM_IT_UPDATE) !=RESET)
   \        0x2   0x....             LDR      R4,??DataTable12
   \        0x4   0x6BA0             LDR      R0,[R4, #+56]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0x07C0             LSLS     R0,R0,#+31
   \        0xA   0xD50B             BPL      ??TIM2_IRQHandler_0
    443            {
    444              ST_RF_API_Timer_Channel_Clear_CB();
   \        0xC   0x....'....        BL       ST_RF_API_Timer_Channel_Clear_CB
    445          
    446              __HAL_TIM_CLEAR_IT(&Tim2_Handler, TIM_IT_UPDATE);
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x43C0             MVNS     R0,R0            ;; #-2
   \       0x14   0x6BA1             LDR      R1,[R4, #+56]
   \       0x16   0x6108             STR      R0,[R1, #+16]
    447              SdkEvalTimersState(GP_TIMER_ID, &Tim2_Handler, DISABLE);
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x0021             MOVS     R1,R4
   \       0x1C   0x3138             ADDS     R1,R1,#+56
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x....'....        BL       SdkEvalTimersState
    448            }
    449          }
   \                     ??TIM2_IRQHandler_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    450          

   \                                 In section .text, align 2, keep-with-next
    451          static void priv_ST_MCU_API_delay(uint32_t delay_ms)
    452          {
   \                     priv_ST_MCU_API_delay: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    453            PRINTF("priv_ST_MCU_API_delay IN (%d)\n\r",delay_ms);
    454          
    455            SdkDelayMs(delay_ms);
   \        0x2   0x....'....        BL       SdkDelayMs
    456          
    457            PRINTF("priv_ST_MCU_API_delay OUT\n\r");
    458          }
   \        0x6   0xBD01             POP      {R0,PC}          ;; return
    459          

   \                                 In section .text, align 2, keep-with-next
    460          sfx_u8 MCU_API_malloc(sfx_u16 size, sfx_u8 **returned_pointer)
    461          {
    462            PRINTF("MCU_API_malloc IN\n\r");
    463          
    464            static sfx_u32 mem[500/4];
    465          
    466            if(size>500)
   \                     MCU_API_malloc: (+1)
   \        0x0   0x22FF             MOVS     R2,#+255
   \        0x2   0x32F6             ADDS     R2,R2,#+246      ;; #+501
   \        0x4   0x4290             CMP      R0,R2
   \        0x6   0xDB01             BLT      ??MCU_API_malloc_0
    467            {
    468              PRINTF("MCU_API_malloc OUT\n\r");
    469              return MCU_ERR_API_MALLOC;
   \        0x8   0x2011             MOVS     R0,#+17
   \        0xA   0x4770             BX       LR
    470            }
    471            else
    472            {
    473              (*returned_pointer)=(sfx_u8*)mem;
   \                     ??MCU_API_malloc_0: (+1)
   \        0xC   0x....             LDR      R0,??DataTable18
   \        0xE   0x6008             STR      R0,[R1, #+0]
    474            }
    475          
    476            PRINTF("MCU_API_malloc OUT\n\r");
    477          
    478            return SFX_ERR_NONE;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x4770             BX       LR               ;; return
    479          }

   \                                 In section .bss, align 4
   \                     `MCU_API_malloc::mem`:
   \        0x0                      DS8 500
    480          

   \                                 In section .text, align 2, keep-with-next
    481          sfx_u8 MCU_API_free(sfx_u8 *ptr)
    482          {
    483            PRINTF("MCU_API_free IN\n\r");
    484            PRINTF("MCU_API_free OUT\n\r");
    485            return SFX_ERR_NONE;
   \                     MCU_API_free: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
    486          }
    487          

   \                                 In section .text, align 2, keep-with-next
    488          sfx_u8 MCU_API_get_voltage_temperature(sfx_u16 *voltage_idle,
    489          				       sfx_u16 *voltage_tx,
    490          				       sfx_s16 *temperature)
    491          {
    492            PRINTF("MCU_API_get_voltage_temperature IN\n\r");
    493          
    494            /* get the idle voltage of the complete device
    495            get the temperature of the device
    496            if those values are not available : set it to 0x0000
    497            return the voltage_idle in 1/10 volt on 16bits and 1/10 degrees for the temperature */
    498            (*voltage_idle)=0;
   \                     MCU_API_get_voltage_temperature: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x8003             STRH     R3,[R0, #+0]
    499            (*voltage_tx)=0;
   \        0x4   0x800B             STRH     R3,[R1, #+0]
    500            (*temperature)=0;
   \        0x6   0x8013             STRH     R3,[R2, #+0]
    501            PRINTF("MCU_API_get_voltage_temperature OUT\n\r");
    502          
    503            return SFX_ERR_NONE;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR               ;; return
    504          }
    505          

   \                                 In section .text, align 2, keep-with-next
    506          sfx_u8 MCU_API_delay(sfx_delay_t delay_type)
    507          {
   \                     MCU_API_delay: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    508            PRINTF("MCU_API_delay IN (%d)\n\r", delay_type);
    509          
    510            switch(delay_type)
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD004             BEQ      ??MCU_API_delay_0
   \        0x6   0x2802             CMP      R0,#+2
   \        0x8   0xD00B             BEQ      ??MCU_API_delay_1
   \        0xA   0xD301             BCC      ??MCU_API_delay_0
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD110             BNE      ??MCU_API_delay_2
    511            {
    512            case SFX_DLY_INTER_FRAME_TRX:
    513            case SFX_DLY_INTER_FRAME_TX:
    514            case SFX_DLY_CS_SLEEP:
    515              /* ramping should be considered in the ramp up/down:
    516              since we have 72 samples in the ramp
    517              (18ms for each ramp, we need to compensate 36 ms)
    518              Moreover we have also 6ms of silence (2 before and 4 after packet)
    519              */
    520              priv_ST_MCU_API_delay(500-2*ST_RF_API_get_ramp_duration());
   \                     ??MCU_API_delay_0: (+1)
   \       0x10   0x....'....        BL       ST_RF_API_get_ramp_duration
   \       0x14   0x21FA             MOVS     R1,#+250
   \       0x16   0x0049             LSLS     R1,R1,#+1        ;; #+500
   \       0x18   0x0040             LSLS     R0,R0,#+1
   \       0x1A   0x1A08             SUBS     R0,R1,R0
   \       0x1C   0x....'....        BL       priv_ST_MCU_API_delay
    521              break;
   \       0x20   0xE007             B        ??MCU_API_delay_2
    522            case SFX_DLY_OOB_ACK:
    523              priv_ST_MCU_API_delay(2000-2*ST_RF_API_get_ramp_duration());
   \                     ??MCU_API_delay_1: (+1)
   \       0x22   0x....'....        BL       ST_RF_API_get_ramp_duration
   \       0x26   0x21FA             MOVS     R1,#+250
   \       0x28   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \       0x2A   0x0040             LSLS     R0,R0,#+1
   \       0x2C   0x1A08             SUBS     R0,R1,R0
   \       0x2E   0x....'....        BL       SdkDelayMs
    524              break;
    525            }
    526          
    527            PRINTF("MCU_API_delay OUT\n\r");
    528          
    529            return SFX_ERR_NONE;
   \                     ??MCU_API_delay_2: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD02             POP      {R1,PC}          ;; return
    530          }
    531          

   \                                 In section .text, align 2, keep-with-next
    532          sfx_u8 MCU_API_aes_128_cbc_encrypt(sfx_u8 *encrypted_data,
    533          				   sfx_u8 *data_to_encrypt,
    534          				   sfx_u8 aes_block_len,
    535          				   sfx_u8 key[16],
    536          				   sfx_credentials_use_key_t use_key)
    537          {
   \                     MCU_API_aes_128_cbc_encrypt: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    538            /* Let the retriever encrypts the requested buffer using the ID_KEY_RETRIEVER function.
    539            The retriever knows the KEY of this node. */
    540            PRINTF("MCU_API_aes_128_cbc_encrypt IN\n\r");
    541          
    542            enc_utils_encrypt(encrypted_data, data_to_encrypt, aes_block_len, key, use_key);
   \        0x2   0x466C             MOV      R4,SP
   \        0x4   0x7C24             LDRB     R4,[R4, #+16]
   \        0x6   0x9400             STR      R4,[SP, #+0]
   \        0x8   0x....'....        BL       enc_utils_encrypt
    543          
    544            PRINTF("MCU_API_aes_128_cbc_encrypt OUT\n\r");
    545          
    546            return SFX_ERR_NONE;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    547          }
    548          

   \                                 In section .text, align 2, keep-with-next
    549          sfx_u8 MCU_API_get_nv_mem(sfx_u8 read_data[SFX_NVMEM_BLOCK_SIZE])
    550          {
   \                     MCU_API_get_nv_mem: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    551            PRINTF("MCU_API_get_nv_mem IN\n\r");
    552          
    553            /* Read data */
    554            NVM_RW_RESULTS res = NVM_ReadRecord((uint8_t *)read_data, SFX_NVMEM_BLOCK_SIZE);
    555          
    556            PRINTF("MCU_API_get_nv_mem OUT\n\r");
    557            return res;
   \        0x2   0x2107             MOVS     R1,#+7
   \        0x4   0x....'....        BL       NVM_ReadRecord
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    558          }
    559          

   \                                 In section .text, align 2, keep-with-next
    560          sfx_u8 MCU_API_set_nv_mem(sfx_u8 data_to_write[SFX_NVMEM_BLOCK_SIZE])
    561          {
   \                     MCU_API_set_nv_mem: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    562            PRINTF("MCU_API_set_nv_mem IN\n\r");
    563          
    564            /* Write data */
    565            NVM_RW_RESULTS res = NVM_WriteRecord((uint8_t *)data_to_write, SFX_NVMEM_BLOCK_SIZE);
    566          
    567            PRINTF("MCU_API_set_nv_mem OUT\n\r");
    568            return res;
   \        0x2   0x2107             MOVS     R1,#+7
   \        0x4   0x....'....        BL       NVM_WriteRecord
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    569          }
    570          

   \                                 In section .text, align 2, keep-with-next
    571          sfx_u8 MCU_API_timer_start_carrier_sense(sfx_u16 time_duration_in_ms)
    572          {
   \                     MCU_API_timer_start_carrier_sense: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
    573            uint32_t rtc_wup_tick, next_rtc_wakeup_tick;
    574            PRINTF("MCU_API_timer_start_carrier_sense IN (rtc_in_use=%d)\n\r",rtc_in_use);
    575          
    576            carrier_sense_tim_started=1;
   \        0x4   0x2601             MOVS     R6,#+1
   \        0x6   0x....             LDR      R4,??DataTable11
   \        0x8   0x7166             STRB     R6,[R4, #+5]
    577          
    578            if(rtc_in_use)
   \        0xA   0x....             LDR      R7,??DataTable18_1  ;; 0xffff
   \        0xC   0x7860             LDRB     R0,[R4, #+1]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD01A             BEQ      ??MCU_API_timer_start_carrier_sense_0
    579            {
    580              uint32_t n = ((uint32_t)time_duration_in_ms*16000);
    581              uint16_t a,b;
    582              SdkEvalTimersFindFactors(n,&a,&b);
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0xA900             ADD      R1,SP,#+0
   \       0x16   0x1C89             ADDS     R1,R1,#+2
   \       0x18   0x20FA             MOVS     R0,#+250
   \       0x1A   0x0180             LSLS     R0,R0,#+6        ;; #+16000
   \       0x1C   0x4368             MULS     R0,R5,R0
   \       0x1E   0x....'....        BL       SdkEvalTimersFindFactors
    583              SdkEvalTimersTimConfig(&Tim2_Handler,a-1,b-1);
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x8800             LDRH     R0,[R0, #+0]
   \       0x26   0x19C2             ADDS     R2,R0,R7
   \       0x28   0xB292             UXTH     R2,R2
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x8840             LDRH     R0,[R0, #+2]
   \       0x2E   0x19C1             ADDS     R1,R0,R7
   \       0x30   0xB289             UXTH     R1,R1
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x3038             ADDS     R0,R0,#+56
   \       0x36   0x....'....        BL       SdkEvalTimersTimConfig
    584              SdkEvalTimersState(GP_TIMER_ID, &Tim2_Handler, ENABLE);
   \       0x3A   0x2201             MOVS     R2,#+1
   \       0x3C   0x0021             MOVS     R1,R4
   \       0x3E   0x3138             ADDS     R1,R1,#+56
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0x....'....        BL       SdkEvalTimersState
   \       0x46   0xE02D             B        ??MCU_API_timer_start_carrier_sense_1
    585            }
    586            else
    587            {
    588              Configure_RTC_Clock();
   \                     ??MCU_API_timer_start_carrier_sense_0: (+1)
   \       0x48   0x....'....        BL       Configure_RTC_Clock
    589              notify_end = 1;
   \       0x4C   0x70A6             STRB     R6,[R4, #+2]
    590              __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&RtcHandler, RTC_FLAG_WUTF);
   \       0x4E   0x68E0             LDR      R0,[R4, #+12]
   \       0x50   0x68C1             LDR      R1,[R0, #+12]
   \       0x52   0x2280             MOVS     R2,#+128
   \       0x54   0x4011             ANDS     R1,R1,R2
   \       0x56   0x....             LDR      R2,??DataTable13_1  ;; 0xfffffb7f
   \       0x58   0x430A             ORRS     R2,R2,R1
   \       0x5A   0x60C2             STR      R2,[R0, #+12]
    591              __HAL_RTC_CLEAR_FLAG(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
   \       0x5C   0x0530             LSLS     R0,R6,#+20
   \       0x5E   0x....             LDR      R1,??DataTable13_2  ;; 0x40010414
   \       0x60   0x6008             STR      R0,[R1, #+0]
    592              n_intermediate_tim_irq=0;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x6360             STR      R0,[R4, #+52]
    593              rtc_in_use=1;
   \       0x66   0x7066             STRB     R6,[R4, #+1]
    594              rtc_in_use_for_cs=1;
   \       0x68   0x70E6             STRB     R6,[R4, #+3]
    595              //rtc_wup_tick = time_duration_in_ms/1000*rtc_presc;
    596              rtc_wup_tick = (time_duration_in_ms*rtc_presc)/1000;
   \       0x6A   0x26FA             MOVS     R6,#+250
   \       0x6C   0x00B6             LSLS     R6,R6,#+2        ;; #+1000
   \       0x6E   0x2008             MOVS     R0,#+8
   \       0x70   0x5E20             LDRSH    R0,[R4, R0]
   \       0x72   0x4345             MULS     R5,R0,R5
   \       0x74   0x0028             MOVS     R0,R5
   \       0x76   0x0031             MOVS     R1,R6
   \       0x78   0x....'....        BL       __aeabi_idiv
   \       0x7C   0x0005             MOVS     R5,R0
    597              if(rtc_wup_tick>65535) /* Mapped register is 16bit */
   \       0x7E   0x42BD             CMP      R5,R7
   \       0x80   0xD904             BLS      ??MCU_API_timer_start_carrier_sense_2
    598              {
    599                next_rtc_wakeup_tick=rtc_wup_tick-65535;
   \       0x82   0x....             LDR      R0,??DataTable18_2  ;; 0xffff0001
   \       0x84   0x1828             ADDS     R0,R5,R0
    600                rtc_wup_tick=65535;
   \       0x86   0x003D             MOVS     R5,R7
   \       0x88   0x4370             MULS     R0,R6,R0
   \       0x8A   0xE000             B        ??MCU_API_timer_start_carrier_sense_3
    601              }
    602              else
    603              {
    604                next_rtc_wakeup_tick=0;
   \                     ??MCU_API_timer_start_carrier_sense_2: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
    605              }
    606          
    607              //next_rtc_wakeup = next_rtc_wakeup_tick/rtc_presc*1000;
    608              next_rtc_wakeup = (next_rtc_wakeup_tick*1000)/rtc_presc;
   \                     ??MCU_API_timer_start_carrier_sense_3: (+1)
   \       0x8E   0x2108             MOVS     R1,#+8
   \       0x90   0x5E61             LDRSH    R1,[R4, R1]
   \       0x92   0x....'....        BL       __aeabi_uidiv
   \       0x96   0x6320             STR      R0,[R4, #+48]
    609              HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandler, rtc_wup_tick, RTC_WAKEUPCLOCK_RTCCLK_DIV16);
   \       0x98   0x2200             MOVS     R2,#+0
   \       0x9A   0x0029             MOVS     R1,R5
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x300C             ADDS     R0,R0,#+12
   \       0xA0   0x....'....        BL       HAL_RTCEx_SetWakeUpTimer_IT
    610            }
    611          
    612            PRINTF("MCU_API_timer_start_carrier_sense OUT\n\r");
    613          
    614            return SFX_ERR_NONE;
   \                     ??MCU_API_timer_start_carrier_sense_1: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    615          }
    616          

   \                                 In section .text, align 2, keep-with-next
    617          sfx_u8 MCU_API_timer_start(sfx_u32 time_duration_in_s)
    618          {
   \                     MCU_API_timer_start: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
    619            uint32_t rtc_wup_tick, next_rtc_wakeup_tick;
    620          
    621            ST_RF_API_Timer_CB(TIMER_START); /* To notify the rf_api layer */
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x....'....        BL       ST_RF_API_Timer_CB
    622            rtc_irq=0;
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x....             LDR      R4,??DataTable12
   \        0xE   0x7025             STRB     R5,[R4, #+0]
    623          
    624            if (time_duration_in_s == DECAY_LEVEL)
   \       0x10   0x2E22             CMP      R6,#+34
   \       0x12   0xD100             BNE      ??MCU_API_timer_start_0
    625              time_duration_in_s += 2; /* In order to make RX-PROTOCOL End of Listening Window working */
   \       0x14   0x2624             MOVS     R6,#+36
    626          
    627            PRINTF("MCU_API_timer_start IN %d\n\r", time_duration_in_s);
    628          
    629            Configure_RTC_Clock();
   \                     ??MCU_API_timer_start_0: (+1)
   \       0x16   0x....'....        BL       Configure_RTC_Clock
    630            notify_end=1;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x70A0             STRB     R0,[R4, #+2]
    631            __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&RtcHandler, RTC_FLAG_WUTF);
   \       0x1E   0x68E1             LDR      R1,[R4, #+12]
   \       0x20   0x68CA             LDR      R2,[R1, #+12]
   \       0x22   0x2380             MOVS     R3,#+128
   \       0x24   0x401A             ANDS     R2,R2,R3
   \       0x26   0x....             LDR      R3,??DataTable13_1  ;; 0xfffffb7f
   \       0x28   0x4313             ORRS     R3,R3,R2
   \       0x2A   0x60CB             STR      R3,[R1, #+12]
    632            __HAL_RTC_CLEAR_FLAG(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
   \       0x2C   0x0501             LSLS     R1,R0,#+20
   \       0x2E   0x....             LDR      R2,??DataTable13_2  ;; 0x40010414
   \       0x30   0x6011             STR      R1,[R2, #+0]
    633            n_intermediate_tim_irq=0;
   \       0x32   0x6365             STR      R5,[R4, #+52]
    634            rtc_in_use=1;
   \       0x34   0x7060             STRB     R0,[R4, #+1]
    635          
    636            rtc_wup_tick = (time_duration_in_s)*rtc_presc;
   \       0x36   0x2008             MOVS     R0,#+8
   \       0x38   0x5E20             LDRSH    R0,[R4, R0]
   \       0x3A   0x4346             MULS     R6,R0,R6
   \       0x3C   0x0031             MOVS     R1,R6
    637          
    638            if(rtc_wup_tick>65535)
   \       0x3E   0x....             LDR      R0,??DataTable18_1  ;; 0xffff
   \       0x40   0x4281             CMP      R1,R0
   \       0x42   0xD902             BLS      ??MCU_API_timer_start_1
    639            {
    640              next_rtc_wakeup_tick=(rtc_wup_tick)-65535;
   \       0x44   0x....             LDR      R2,??DataTable18_2  ;; 0xffff0001
   \       0x46   0x188D             ADDS     R5,R1,R2
    641              rtc_wup_tick=65535;
   \       0x48   0x0001             MOVS     R1,R0
    642            }
    643            else
    644            {
    645              next_rtc_wakeup_tick=0;
    646            }
    647          
    648            HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandler,rtc_wup_tick,RTC_WAKEUPCLOCK_RTCCLK_DIV16);
   \                     ??MCU_API_timer_start_1: (+1)
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x300C             ADDS     R0,R0,#+12
   \       0x50   0x....'....        BL       HAL_RTCEx_SetWakeUpTimer_IT
    649          
    650            next_rtc_wakeup=next_rtc_wakeup_tick/rtc_presc;
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0x2108             MOVS     R1,#+8
   \       0x58   0x5E61             LDRSH    R1,[R4, R1]
   \       0x5A   0x....'....        BL       __aeabi_uidiv
   \       0x5E   0x6320             STR      R0,[R4, #+48]
    651          
    652            PRINTF("MCU_API_timer_start OUT %d\n\r", next_rtc_wakeup);
    653            return SFX_ERR_NONE;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xBD70             POP      {R4-R6,PC}       ;; return
    654          }
    655          

   \                                 In section .text, align 2, keep-with-next
    656          sfx_u8 MCU_API_timer_stop(void)
    657          {
   \                     MCU_API_timer_stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    658            PRINTF("MCU_API_timer_stop IN\n\r");
    659            HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandler);
   \        0x2   0x....             LDR      R4,??DataTable18_3
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x300C             ADDS     R0,R0,#+12
   \        0x8   0x....'....        BL       HAL_RTCEx_DeactivateWakeUpTimer
    660            rtc_in_use=0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x7060             STRB     R0,[R4, #+1]
    661            PRINTF("MCU_API_timer_stop OUT\n\r");
    662            return SFX_ERR_NONE;
   \       0x10   0xBD10             POP      {R4,PC}          ;; return
    663          }
    664          

   \                                 In section .text, align 2, keep-with-next
    665          sfx_u8 MCU_API_timer_stop_carrier_sense(void)
    666          {
   \                     MCU_API_timer_stop_carrier_sense: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    667            PRINTF("MCU_API_timer_stop_carrier_sense IN\n\r");
    668          
    669            if(rtc_in_use_for_cs)
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x....             LDR      R4,??DataTable18_3
   \        0x6   0x78E0             LDRB     R0,[R4, #+3]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??MCU_API_timer_stop_carrier_sense_0
    670            {
    671              HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandler);
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x300C             ADDS     R0,R0,#+12
   \       0x10   0x....'....        BL       HAL_RTCEx_DeactivateWakeUpTimer
    672              rtc_in_use=0;
   \       0x14   0x7065             STRB     R5,[R4, #+1]
    673              rtc_in_use_for_cs=0;
   \       0x16   0x70E5             STRB     R5,[R4, #+3]
   \       0x18   0xE005             B        ??MCU_API_timer_stop_carrier_sense_1
    674            }
    675            else
    676            {
    677              SdkEvalTimersState(GP_TIMER_ID, &Tim2_Handler, DISABLE);
   \                     ??MCU_API_timer_stop_carrier_sense_0: (+1)
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x0021             MOVS     R1,R4
   \       0x1E   0x3138             ADDS     R1,R1,#+56
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x....'....        BL       SdkEvalTimersState
    678            }
    679            carrier_sense_tim_started=0;
   \                     ??MCU_API_timer_stop_carrier_sense_1: (+1)
   \       0x26   0x7165             STRB     R5,[R4, #+5]
    680          
    681            PRINTF("MCU_API_timer_stop_carrier_sense OUT\n\r");
    682          
    683            return SFX_ERR_NONE;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    684          
    685          }
    686          

   \                                 In section .text, align 2, keep-with-next
    687          sfx_u8 MCU_API_timer_wait_for_end(void)
    688          {
   \                     MCU_API_timer_wait_for_end: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             LDR      R4,??DataTable18_3
   \        0x4   0xE001             B        ??MCU_API_timer_wait_for_end_0
    689            PRINTF("MCU_API_timer_wait_for_end IN\n\r");
    690          
    691            while(!rtc_irq)//(!(next_rtc_wakeup==0 || rtc_irq==1))
    692            {
    693              ST_MCU_API_WaitForInterrupt();
   \                     ??MCU_API_timer_wait_for_end_1: (+1)
   \        0x6   0x....'....        BL       ST_MCU_API_WaitForInterrupt
    694            }
   \                     ??MCU_API_timer_wait_for_end_0: (+1)
   \        0xA   0x7820             LDRB     R0,[R4, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD0FA             BEQ      ??MCU_API_timer_wait_for_end_1
    695            rtc_irq=0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x7020             STRB     R0,[R4, #+0]
    696            PRINTF("MCU_API_timer_wait_for_end OUT\n\r");
    697            return SFX_ERR_NONE;
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
    698          }
    699          
    700          void ST_MANUF_report_CB(uint8_t status, int32_t rssi);
    701          

   \                                 In section .text, align 2, keep-with-next
    702          sfx_u8 MCU_API_report_test_result(sfx_bool status, sfx_s16 rssi)
    703          {
   \                     MCU_API_report_test_result: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    704          
    705            ST_MANUF_report_CB(status, rssi);
   \        0x2   0x....'....        BL       ST_MANUF_report_CB
    706            // use this function to : print output result : status and rssi on uart if you have one or any link is available on device
    707            // or use a gpio to indicate at least the status
    708            // or to send a message over the air using any link to report the status with rssi
    709            // you could also use the RF part in specific modulation (ook ask or gfsk or else to return status and rssi
    710            return SFX_ERR_NONE;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    711          }
    712          

   \                                 In section .text, align 4, keep-with-next
    713          sfx_u8 MCU_API_get_version(sfx_u8 **version, sfx_u8 *size)
    714          {
    715            (*size) = sizeof(_libVersion);
   \                     MCU_API_get_version: (+1)
   \        0x0   0x2207             MOVS     R2,#+7
   \        0x2   0x700A             STRB     R2,[R1, #+0]
    716            (*version) = (sfx_u8*)_libVersion;
   \        0x4   0x....             ADR.N    R1,_libVersion
   \        0x6   0x6001             STR      R1,[R0, #+0]
    717          
    718            return SFX_ERR_NONE;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR               ;; return
    719          }
    720          

   \                                 In section .text, align 2, keep-with-next
    721          sfx_u8 MCU_API_get_device_id_and_payload_encryption_flag(sfx_u8 dev_id[ID_LENGTH], sfx_bool *payload_encryption_enabled)
    722          {
   \                     MCU_API_get_device_id_and_payload_encryption_flag: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
    723            PRINTF("MCU_API_get_device_id_and_payload_encryption_flag IN\n\r");
    724            enc_utils_get_id(dev_id);
   \        0x4   0x....'....        BL       enc_utils_get_id
    725            (*payload_encryption_enabled) = _encryptedPayload;
   \        0x8   0x....             LDR      R0,??DataTable18_4
   \        0xA   0x7800             LDRB     R0,[R0, #+0]
   \        0xC   0x7020             STRB     R0,[R4, #+0]
    726            PRINTF("MCU_API_get_device_id_and_payload_encryption_flag OUT\n\r");
    727            return SFX_ERR_NONE;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD10             POP      {R4,PC}          ;; return
    728          }
    729          

   \                                 In section .text, align 2, keep-with-next
    730          sfx_u8 MCU_API_get_initial_pac(sfx_u8 initial_pac[PAC_LENGTH])
    731          {
   \                     MCU_API_get_initial_pac: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    732            PRINTF("MCU_API_get_initial_pac IN\n\r");
    733            enc_utils_get_initial_pac(initial_pac);
   \        0x2   0x....'....        BL       enc_utils_get_initial_pac
    734            PRINTF("MCU_API_get_initial_pac OUT\n\r");
    735            return SFX_ERR_NONE;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    736          }
    737          

   \                                 In section .text, align 2, keep-with-next
    738          void ST_MCU_API_LowPower(sfx_u8 low_power_flag)
    739          {
    740            low_power=low_power_flag;
   \                     ST_MCU_API_LowPower: (+1)
   \        0x0   0x....             LDR      R1,??DataTable18_3
   \        0x2   0x7108             STRB     R0,[R1, #+4]
    741          }
   \        0x4   0x4770             BX       LR               ;; return
    742          

   \                                 In section .text, align 2, keep-with-next
    743          void ST_MCU_API_GpioIRQ(sfx_u8 new_state, sfx_u8 trigger)
    744          {
   \                     ST_MCU_API_GpioIRQ: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    745            /* configure the MCU IRQ connected to the specified S2-LP GPIO */
    746            /* trigger 1: rising, 0: falling (default) */
    747            S2LPIRQEnableEx(new_state, trigger);
   \        0x2   0x....'....        BL       S2LPIRQEnableEx
    748          }
   \        0x6   0xBD01             POP      {R0,PC}          ;; return
    749          

   \                                 In section .text, align 2, keep-with-next
    750          void ST_MCU_API_Shutdown(sfx_u8 value)
    751          {
   \                     ST_MCU_API_Shutdown: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    752            if(value==ST_TRUE)
   \        0x2   0x2801             CMP      R0,#+1
   \        0x4   0xD105             BNE      ??ST_MCU_API_Shutdown_0
    753            {
    754              S2LPShutdownEnter();
   \        0x6   0x....'....        BL       S2LPShutdownEnter
    755              TCXO_Operation(TCXO_OFF);
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x....'....        BL       TCXO_Operation
   \       0x10   0xBD01             POP      {R0,PC}
    756            }
    757            else
    758            {
    759              TCXO_Init();
   \                     ??ST_MCU_API_Shutdown_0: (+1)
   \       0x12   0x....'....        BL       TCXO_Init
    760              TCXO_Operation(TCXO_ON);
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x....'....        BL       TCXO_Operation
    761              S2LPShutdownExit();
   \       0x1C   0x....'....        BL       S2LPShutdownExit
    762            }
    763          }
   \       0x20   0xBD01             POP      {R0,PC}          ;; return
    764          

   \                                 In section .text, align 2, keep-with-next
    765          void ST_MCU_API_SpiRaw(uint8_t n_bytes, uint8_t* in_buffer, uint8_t* out_buffer, uint8_t can_return_bef_tx)
    766          {
   \                     ST_MCU_API_SpiRaw: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    767            /* in this implementation we are not interested in the value of the can_return_bef_tx flag.
    768            We always pass 0 to the S2LPSpiRaw so that the CPU will wait the DMA for the end of transfer. */
    769            S2LPSpiRaw(n_bytes,in_buffer,out_buffer,0);
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x....'....        BL       S2LPSpiRaw
    770          }
   \        0x8   0xBD01             POP      {R0,PC}          ;; return
    771          

   \                                 In section .text, align 2, keep-with-next
    772          void ST_MCU_API_SetEncryptionPayload(uint8_t ePayload)
    773          {
    774            _encryptedPayload = ePayload;
   \                     ST_MCU_API_SetEncryptionPayload: (+1)
   \        0x0   0x....             LDR      R1,??DataTable18_4
   \        0x2   0x7008             STRB     R0,[R1, #+0]
    775          }
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x4002'1038        DC32     0x40021038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x4000'7000        DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0xFFFF'E7FF        DC32     0xffffe7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x5000'0400        DC32     0x50000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x4002'102C        DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     rtc_irq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     rtc_irq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x4002'1050        DC32     0x40021050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0xFFFF'FB7F        DC32     0xfffffb7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x4001'0414        DC32     0x40010414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x0000'FFFE        DC32     0xfffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x0000'3E7F        DC32     0x3e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     `MCU_API_malloc::mem`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x0000'FFFF        DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0xFFFF'0001        DC32     0xffff0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0x....'....        DC32     rtc_irq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \        0x0   0x....'....        DC32     _encryptedPayload

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      96   Configure_RTC_Clock
        96   -> HAL_NVIC_EnableIRQ
        96   -> HAL_NVIC_SetPriority
        96   -> HAL_PWR_EnableBkUpAccess
        96   -> HAL_RCCEx_PeriphCLKConfig
        96   -> HAL_RCC_OscConfig
       8   HAL_GPIO_EXTI_Callback
         8   -> Appli_Exti_CB
         8   -> S2LP_Middleware_GpioGetPin
         8   -> ST_RF_API_GetFIFOState
         8   -> ST_RF_API_Get_Continuous_TX_or_MONARCH_Scan_Flag
         8   -> ST_RF_API_S2LP_IRQ_CB
      16   MCU_API_aes_128_cbc_encrypt
        16   -> enc_utils_encrypt
       8   MCU_API_delay
         8   -> ST_RF_API_get_ramp_duration
         8   -> SdkDelayMs
         8   -> priv_ST_MCU_API_delay
       0   MCU_API_free
       8   MCU_API_get_device_id_and_payload_encryption_flag
         8   -> enc_utils_get_id
       8   MCU_API_get_initial_pac
         8   -> enc_utils_get_initial_pac
       8   MCU_API_get_nv_mem
         8   -> NVM_ReadRecord
       0   MCU_API_get_version
       0   MCU_API_get_voltage_temperature
       0   MCU_API_malloc
       8   MCU_API_report_test_result
         8   -> ST_MANUF_report_CB
       8   MCU_API_set_nv_mem
         8   -> NVM_WriteRecord
      16   MCU_API_timer_start
        16   -> Configure_RTC_Clock
        16   -> HAL_RTCEx_SetWakeUpTimer_IT
        16   -> ST_RF_API_Timer_CB
        16 __aeabi_uidiv
      24   MCU_API_timer_start_carrier_sense
        24   -> Configure_RTC_Clock
        24   -> HAL_RTCEx_SetWakeUpTimer_IT
        24   -> SdkEvalTimersFindFactors
        24   -> SdkEvalTimersState
        24   -> SdkEvalTimersTimConfig
        24 __aeabi_idiv
        24 __aeabi_uidiv
       8   MCU_API_timer_stop
         8   -> HAL_RTCEx_DeactivateWakeUpTimer
      16   MCU_API_timer_stop_carrier_sense
        16   -> HAL_RTCEx_DeactivateWakeUpTimer
        16   -> SdkEvalTimersState
       8   MCU_API_timer_wait_for_end
         8   -> ST_MCU_API_WaitForInterrupt
       8   RTC_IRQHandler
         8   -> Configure_RTC_Clock
         8   -> HAL_RTCEx_DeactivateWakeUpTimer
         8   -> HAL_RTCEx_WakeUpTimerIRQHandler
         8   -> MCU_API_timer_start
         8   -> ST_RF_API_Timer_CB
         8   -> ST_RF_API_Timer_Channel_Clear_CB
       8   ST_MCU_API_GPIO_LowPower
         8   -> setGpioLowPower
       8   ST_MCU_API_GPIO_Restore
         8   -> setGpioRestore
       8   ST_MCU_API_GpioIRQ
         8   -> S2LPIRQEnableEx
       0   ST_MCU_API_LowPower
       0   ST_MCU_API_SetEncryptionPayload
      88   ST_MCU_API_SetSysClock
        88   -> HAL_RCC_ClockConfig
        88   -> HAL_RCC_OscConfig
       8   ST_MCU_API_Shutdown
         8   -> S2LPShutdownEnter
         8   -> S2LPShutdownExit
         8   -> TCXO_Init
         8   -> TCXO_Operation
       8   ST_MCU_API_SpiRaw
         8   -> S2LPSpiRaw
      80   ST_MCU_API_TimerCalibration
        80   -> Configure_RTC_Clock
        80   -> HAL_NVIC_DisableIRQ
        80   -> HAL_RTCEx_SetWakeUpTimer_IT
        80   -> HAL_TIM_Base_Start
        80   -> HAL_TIM_Base_Stop
        80   -> SdkEvalTimersTimConfig
        80   -> __aeabi_memcpy4
        80 __aeabi_idiv
      16   ST_MCU_API_WaitForInterrupt
        16   -> HAL_PWR_EnterSTOPMode
        16   -> ST_MCU_API_SetSysClock
        16   -> ST_RF_API_S2LP_IRQ_CB
        16   -> setGpioLowPower
        16   -> setGpioRestore
       8   TIM2_IRQHandler
         8   -> ST_RF_API_Timer_Channel_Clear_CB
         8   -> SdkEvalTimersState
       8   priv_ST_MCU_API_delay
         8   -> SdkDelayMs
      32   setGpioLowPower
        32   -> HAL_GPIO_Init
      40   setGpioRestore
        40   -> HAL_GPIO_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable15
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
      60  ?_0
      74  Configure_RTC_Clock
      56  HAL_GPIO_EXTI_Callback
      16  MCU_API_aes_128_cbc_encrypt
      54  MCU_API_delay
       4  MCU_API_free
      18  MCU_API_get_device_id_and_payload_encryption_flag
      10  MCU_API_get_initial_pac
      10  MCU_API_get_nv_mem
      12  MCU_API_get_version
      12  MCU_API_get_voltage_temperature
      20  MCU_API_malloc
      10  MCU_API_report_test_result
      10  MCU_API_set_nv_mem
     100  MCU_API_timer_start
     168  MCU_API_timer_start_carrier_sense
      18  MCU_API_timer_stop
      44  MCU_API_timer_stop_carrier_sense
      22  MCU_API_timer_wait_for_end
      80  RTC_IRQHandler
       8  ST_MCU_API_GPIO_LowPower
       8  ST_MCU_API_GPIO_Restore
       8  ST_MCU_API_GpioIRQ
       6  ST_MCU_API_LowPower
       6  ST_MCU_API_SetEncryptionPayload
      92  ST_MCU_API_SetSysClock
      34  ST_MCU_API_Shutdown
      10  ST_MCU_API_SpiRaw
     150  ST_MCU_API_TimerCalibration
      68  ST_MCU_API_WaitForInterrupt
      38  TIM2_IRQHandler
       1  _encryptedPayload
       8  _libVersion
     500  mem
       8  priv_ST_MCU_API_delay
     116  rtc_irq
          rtc_in_use
          notify_end
          rtc_in_use_for_cs
          low_power
          carrier_sense_tim_started
          s2lp_irq_raised
          rtc_presc
          RtcHandler
          next_rtc_wakeup
          n_intermediate_tim_irq
          Tim2_Handler
      50  setGpioLowPower
     116  setGpioRestore

 
   501 bytes in section .bss
   116 bytes in section .data
    60 bytes in section .rodata
 1'420 bytes in section .text
 
 1'420 bytes of CODE  memory
    60 bytes of CONST memory
   617 bytes of DATA  memory

Errors: none
Warnings: none
