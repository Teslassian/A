###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  13:02:27
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_gpio.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW5DA9.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_gpio.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal_gpio.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal_gpio.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.  
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *         
     11            @verbatim
     12            ==============================================================================
     13                              ##### GPIO Peripheral features #####
     14            ==============================================================================
     15            [..] 
     16              (+) Each port bit of the general-purpose I/O (GPIO) ports can be individually 
     17            configured by software in several modes:
     18                  (++) Input mode 
     19                  (++) Analog mode
     20                  (++) Output mode
     21                  (++) Alternate function mode
     22                  (++) External interrupt/event lines
     23           
     24              (+) During and just after reset, the alternate functions and external interrupt  
     25            lines are not active and the I/O ports are configured in input floating mode.
     26            
     27              (+) All GPIO pins have weak internal pull-up and pull-down resistors, which can be 
     28            activated or not.
     29          
     30              (+) In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     31            type and the IO speed can be selected depending on the VDD value.
     32            
     33              (+) The microcontroller IO pins are connected to onboard peripherals/modules through a 
     34                  multiplexer that allows only one peripheral alternate function (AF) connected 
     35            to an IO pin at a time. In this way, there can be no conflict between peripherals 
     36            sharing the same IO pin. 
     37          
     38              (+) All ports have external interrupt/event capability. To use external interrupt 
     39            lines, the port must be configured in input mode. All available GPIO pins are 
     40            connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     41            
     42              (+) The external interrupt/event controller consists of up to 28 edge detectors
     43            (16 lines are connected to GPIO) for generating event/interrupt requests (each 
     44            input line can be independently configured to select the type (interrupt or event) 
     45            and the corresponding trigger event (rising or falling or both). Each line can 
     46            also be masked independently. 
     47            
     48                               ##### How to use this driver #####
     49            ==============================================================================  
     50            [..]             
     51              (#) Enable the GPIO IOPORT clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). 
     52          
     53              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     54                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     55                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef 
     56                       structure.
     57                  (++) In case of Output or alternate function mode selection: the speed is 
     58                       configured through "Speed" member from GPIO_InitTypeDef structure.
     59                  (++) In alternate mode is selection, the alternate function connected to the IO
     60                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     61                  (++) Analog mode is required when a pin is to be used as ADC channel 
     62                       or DAC output.
     63                  (++) In case of external interrupt/event selection the "Mode" member from 
     64                       GPIO_InitTypeDef structure select the type (interrupt or event) and 
     65                       the corresponding trigger event (rising or falling or both).
     66             
     67              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority 
     68                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     69                  HAL_NVIC_EnableIRQ().
     70                   
     71             (#) HAL_GPIO_DeInit allows to set register values to their reset value. This function
     72                 is also to be used when unconfiguring pin which was used as an external interrupt
     73                 or in event mode. That is the only way to reset the corresponding bit in
     74                 EXTI & SYSCFG registers.
     75          
     76              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     77                      
     78              (#) To set/reset the level of a pin configured in output mode use 
     79                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     80          
     81              (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     82          
     83              (#) During and just after reset, the alternate functions are not 
     84                  active and the GPIO pins are configured in input floating mode (except JTAG
     85                  pins).
     86            
     87              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     88                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     89                  priority over the GPIO function.
     90            
     91              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     92                  general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
     93                  The HSE has priority over the GPIO function.
     94            
     95            @endverbatim
     96            ******************************************************************************
     97            * @attention
     98            *
     99            * <h2><center>&copy; Copyright(c) 2016 STMicroelectronics.
    100            * All rights reserved.</center></h2>
    101            *
    102            * This software component is licensed by ST under BSD 3-Clause license,
    103            * the "License"; You may not use this file except in compliance with the
    104            * License. You may obtain a copy of the License at:
    105            *                        opensource.org/licenses/BSD-3-Clause
    106            *
    107            ******************************************************************************  
    108            */ 
    109          
    110          /* Includes ------------------------------------------------------------------*/
    111          #include "stm32l0xx_hal.h"
    112          
    113          /** @addtogroup STM32L0xx_HAL_Driver
    114            * @{
    115            */
    116          
    117          #ifdef HAL_GPIO_MODULE_ENABLED
    118          
    119          /** @addtogroup GPIO
    120            * @brief GPIO HAL module driver
    121            * @{
    122            */
    123          
    124          /** @addtogroup GPIO_Private
    125            * @{
    126            */
    127          /* Private define ------------------------------------------------------------*/
    128          
    129           
    130          #define GPIO_MODE             ((uint32_t)0x00000003U)
    131          #define EXTI_MODE             ((uint32_t)0x10000000U)
    132          #define GPIO_MODE_IT          ((uint32_t)0x00010000U)
    133          #define GPIO_MODE_EVT         ((uint32_t)0x00020000U)
    134          #define RISING_EDGE           ((uint32_t)0x00100000U) 
    135          #define FALLING_EDGE          ((uint32_t)0x00200000U) 
    136          #define GPIO_OUTPUT_TYPE      ((uint32_t)0x00000010U)
    137          
    138          #define GPIO_NUMBER           ((uint32_t)16U)
    139          
    140          /**
    141            * @}
    142            */
    143          /** @addtogroup GPIO_Exported_Functions
    144            * @{
    145            */
    146          
    147          /** @addtogroup GPIO_Exported_Functions_Group1
    148           *  @brief    Initialization and de-initialization functions
    149           *
    150          @verbatim
    151           ===============================================================================
    152                        ##### Initialization and de-initialization functions #####
    153           ===============================================================================
    154           
    155          @endverbatim
    156            * @{
    157            */
    158          
    159          /**
    160            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    161            * @param  GPIOx where x can be (A..E and H) to select the GPIO peripheral for STM32L0XX family devices.
    162            *                Note that GPIOE is not available on all devices.
    163            * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
    164            *                    the configuration information for the specified GPIO peripheral.
    165            * @retval None
    166            */

   \                                 In section .text, align 2, keep-with-next
    167          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    168          {
   \                     HAL_GPIO_Init: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x000A             MOVS     R2,R1
    169            uint32_t position = 0x00U;
   \        0x6   0x2500             MOVS     R5,#+0
    170            uint32_t iocurrent = 0x00U;
    171            uint32_t temp = 0x00U;
    172           
    173            /* Check the parameters */
    174            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    175            assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    176            assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,(GPIO_Init->Pin)));
   \        0x8   0x....             LDR      R1,??DataTable2  ;; 0x40010400
   \        0xA   0x9101             STR      R1,[SP, #+4]
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x9103             STR      R1,[SP, #+12]
   \       0x10   0x0001             MOVS     R1,R0
   \       0x12   0xE037             B        ??HAL_GPIO_Init_0
    177          
    178            /* Configure the port pins */
    179            while (((GPIO_Init->Pin) >> position) != 0)
    180            {
    181              /* Get the IO position */
    182              iocurrent = (GPIO_Init->Pin) & (1U << position);
    183              
    184              if(iocurrent)
    185              {
    186                /*--------------------- GPIO Mode Configuration ------------------------*/
    187                /* In case of Alternate function mode selection */
    188                if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
    189                {
    190                  /* Check the Alternate function parameters */
    191                  assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    192                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    193          
    194                  /* Configure Alternate function mapped with the current IO */ 
    195                  temp = GPIOx->AFR[position >> 3U];
    196                  temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
    197                  temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U)) ;
    198                  GPIOx->AFR[position >> 3U] = temp;
    199                } 
    200          
    201                /* In case of Output or Alternate function mode selection */
    202                if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    203                   (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    204                {
    205                  /* Check the Speed parameter */
    206                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    207                  /* Configure the IO Speed */
    208                  temp = GPIOx->OSPEEDR;
    209                  temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
    210                  temp |= (GPIO_Init->Speed << (position * 2U));
    211                  GPIOx->OSPEEDR = temp;
    212          
    213                  /* Configure the IO Output Type */
    214                  temp= GPIOx->OTYPER;
    215                  temp &= ~(GPIO_OTYPER_OT_0 << position) ;
    216                  temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    217                  GPIOx->OTYPER = temp;
    218                }
    219          
    220                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    221                temp = GPIOx->MODER;
    222                temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
    223                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    224                GPIOx->MODER = temp;
    225          
    226                /* Activate the Pull-up or Pull down resistor for the current IO */
    227                temp = GPIOx->PUPDR;
    228                temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    229                temp |= ((GPIO_Init->Pull) << (position * 2U)); 
    230                GPIOx->PUPDR = temp;
    231          
    232                /*--------------------- EXTI Mode Configuration ------------------------*/
    233                /* Configure the External Interrupt or event for the current IO */
    234                if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
    235                {
    236                  /* Enable SYSCFG Clock */
    237                  __HAL_RCC_SYSCFG_CLK_ENABLE();
    238                  
    239                  temp = SYSCFG->EXTICR[position >> 2U];
    240                  CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
    241                  SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
   \                     ??HAL_GPIO_Init_1: (+1)
   \       0x14   0x2006             MOVS     R0,#+6
   \       0x16   0xE003             B        ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_3: (+1)
   \       0x18   0x....             LDR      R0,??DataTable2_1  ;; 0x50001c00
   \       0x1A   0x4281             CMP      R1,R0
   \       0x1C   0xD1FA             BNE      ??HAL_GPIO_Init_1
   \       0x1E   0x2005             MOVS     R0,#+5
    242                  SYSCFG->EXTICR[position >> 2U] = temp;
   \                     ??HAL_GPIO_Init_2: (+1)
   \       0x20   0x40A0             LSLS     R0,R0,R4
   \       0x22   0x4330             ORRS     R0,R0,R6
   \       0x24   0x6018             STR      R0,[R3, #+0]
    243                            
    244                  /* Clear EXTI line configuration */
    245                  temp = EXTI->IMR;
   \       0x26   0x9801             LDR      R0,[SP, #+4]
   \       0x28   0x6803             LDR      R3,[R0, #+0]
    246                  temp &= ~((uint32_t)iocurrent);
   \       0x2A   0x9C02             LDR      R4,[SP, #+8]
   \       0x2C   0x43E0             MVNS     R0,R4
   \       0x2E   0x4003             ANDS     R3,R3,R0
    247                  if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
   \       0x30   0x6854             LDR      R4,[R2, #+4]
   \       0x32   0x03E4             LSLS     R4,R4,#+15
   \       0x34   0xD502             BPL      ??HAL_GPIO_Init_4
    248                  {
    249                    temp |= iocurrent;
   \       0x36   0x001C             MOVS     R4,R3
   \       0x38   0x9B02             LDR      R3,[SP, #+8]
   \       0x3A   0x4323             ORRS     R3,R3,R4
    250                  }
    251                  EXTI->IMR = temp;
   \                     ??HAL_GPIO_Init_4: (+1)
   \       0x3C   0x9C01             LDR      R4,[SP, #+4]
   \       0x3E   0x6023             STR      R3,[R4, #+0]
    252          
    253                  temp = EXTI->EMR;
   \       0x40   0x9B01             LDR      R3,[SP, #+4]
   \       0x42   0x685B             LDR      R3,[R3, #+4]
    254                  temp &= ~((uint32_t)iocurrent);
   \       0x44   0x4003             ANDS     R3,R3,R0
    255                  if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
   \       0x46   0x6854             LDR      R4,[R2, #+4]
   \       0x48   0x03A4             LSLS     R4,R4,#+14
   \       0x4A   0xD502             BPL      ??HAL_GPIO_Init_5
    256                  {
    257                    temp |= iocurrent;
   \       0x4C   0x001C             MOVS     R4,R3
   \       0x4E   0x9B02             LDR      R3,[SP, #+8]
   \       0x50   0x4323             ORRS     R3,R3,R4
    258                  }
    259                  EXTI->EMR = temp;
   \                     ??HAL_GPIO_Init_5: (+1)
   \       0x52   0x9C01             LDR      R4,[SP, #+4]
   \       0x54   0x6063             STR      R3,[R4, #+4]
    260          
    261                  /* Clear Rising Falling edge configuration */
    262                  temp = EXTI->RTSR;
   \       0x56   0x9B01             LDR      R3,[SP, #+4]
   \       0x58   0x689B             LDR      R3,[R3, #+8]
    263                  temp &= ~((uint32_t)iocurrent);
   \       0x5A   0x4003             ANDS     R3,R3,R0
    264                  if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
   \       0x5C   0x6854             LDR      R4,[R2, #+4]
   \       0x5E   0x02E4             LSLS     R4,R4,#+11
   \       0x60   0xD502             BPL      ??HAL_GPIO_Init_6
    265                  {
    266                    temp |= iocurrent;
   \       0x62   0x001C             MOVS     R4,R3
   \       0x64   0x9B02             LDR      R3,[SP, #+8]
   \       0x66   0x4323             ORRS     R3,R3,R4
    267                  }
    268                  EXTI->RTSR = temp;
   \                     ??HAL_GPIO_Init_6: (+1)
   \       0x68   0x9C01             LDR      R4,[SP, #+4]
   \       0x6A   0x60A3             STR      R3,[R4, #+8]
    269          
    270                  temp = EXTI->FTSR;
   \       0x6C   0x9B01             LDR      R3,[SP, #+4]
   \       0x6E   0x68DB             LDR      R3,[R3, #+12]
    271                  temp &= ~((uint32_t)iocurrent);
   \       0x70   0x4018             ANDS     R0,R0,R3
    272                  if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
   \       0x72   0x6853             LDR      R3,[R2, #+4]
   \       0x74   0x029B             LSLS     R3,R3,#+10
   \       0x76   0xD502             BPL      ??HAL_GPIO_Init_7
    273                  {
    274                    temp |= iocurrent;
   \       0x78   0x0003             MOVS     R3,R0
   \       0x7A   0x9802             LDR      R0,[SP, #+8]
   \       0x7C   0x4318             ORRS     R0,R0,R3
    275                  }
    276                  EXTI->FTSR = temp;
   \                     ??HAL_GPIO_Init_7: (+1)
   \       0x7E   0x9B01             LDR      R3,[SP, #+4]
   \       0x80   0x60D8             STR      R0,[R3, #+12]
    277                }
    278              }
    279              position++;
   \                     ??HAL_GPIO_Init_8: (+1)
   \       0x82   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HAL_GPIO_Init_0: (+1)
   \       0x84   0x6810             LDR      R0,[R2, #+0]
   \       0x86   0x0003             MOVS     R3,R0
   \       0x88   0x40EB             LSRS     R3,R3,R5
   \       0x8A   0xD073             BEQ      ??HAL_GPIO_Init_9
   \       0x8C   0x9B03             LDR      R3,[SP, #+12]
   \       0x8E   0x40AB             LSLS     R3,R3,R5
   \       0x90   0x9304             STR      R3,[SP, #+16]
   \       0x92   0x4003             ANDS     R3,R3,R0
   \       0x94   0x9302             STR      R3,[SP, #+8]
   \       0x96   0x9802             LDR      R0,[SP, #+8]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD0F2             BEQ      ??HAL_GPIO_Init_8
   \       0x9C   0x00A8             LSLS     R0,R5,#+2
   \       0x9E   0x466B             MOV      R3,SP
   \       0xA0   0x7018             STRB     R0,[R3, #+0]
   \       0xA2   0x6850             LDR      R0,[R2, #+4]
   \       0xA4   0x2802             CMP      R0,#+2
   \       0xA6   0xD001             BEQ      ??HAL_GPIO_Init_10
   \       0xA8   0x2812             CMP      R0,#+18
   \       0xAA   0xD10E             BNE      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_10: (+1)
   \       0xAC   0x08E8             LSRS     R0,R5,#+3
   \       0xAE   0x0080             LSLS     R0,R0,#+2
   \       0xB0   0x1808             ADDS     R0,R1,R0
   \       0xB2   0x6A03             LDR      R3,[R0, #+32]
   \       0xB4   0x466C             MOV      R4,SP
   \       0xB6   0x7826             LDRB     R6,[R4, #+0]
   \       0xB8   0x241C             MOVS     R4,#+28
   \       0xBA   0x4034             ANDS     R4,R4,R6
   \       0xBC   0x260F             MOVS     R6,#+15
   \       0xBE   0x40A6             LSLS     R6,R6,R4
   \       0xC0   0x43B3             BICS     R3,R3,R6
   \       0xC2   0x6916             LDR      R6,[R2, #+16]
   \       0xC4   0x40A6             LSLS     R6,R6,R4
   \       0xC6   0x431E             ORRS     R6,R6,R3
   \       0xC8   0x6206             STR      R6,[R0, #+32]
   \                     ??HAL_GPIO_Init_11: (+1)
   \       0xCA   0x006B             LSLS     R3,R5,#+1
   \       0xCC   0x2003             MOVS     R0,#+3
   \       0xCE   0x4098             LSLS     R0,R0,R3
   \       0xD0   0x43C4             MVNS     R4,R0
   \       0xD2   0x6850             LDR      R0,[R2, #+4]
   \       0xD4   0x2801             CMP      R0,#+1
   \       0xD6   0xD005             BEQ      ??HAL_GPIO_Init_12
   \       0xD8   0x2802             CMP      R0,#+2
   \       0xDA   0xD003             BEQ      ??HAL_GPIO_Init_12
   \       0xDC   0x2811             CMP      R0,#+17
   \       0xDE   0xD001             BEQ      ??HAL_GPIO_Init_12
   \       0xE0   0x2812             CMP      R0,#+18
   \       0xE2   0xD10F             BNE      ??HAL_GPIO_Init_13
   \                     ??HAL_GPIO_Init_12: (+1)
   \       0xE4   0x6888             LDR      R0,[R1, #+8]
   \       0xE6   0x4020             ANDS     R0,R0,R4
   \       0xE8   0x68D6             LDR      R6,[R2, #+12]
   \       0xEA   0x409E             LSLS     R6,R6,R3
   \       0xEC   0x4306             ORRS     R6,R6,R0
   \       0xEE   0x608E             STR      R6,[R1, #+8]
   \       0xF0   0x6848             LDR      R0,[R1, #+4]
   \       0xF2   0x9E04             LDR      R6,[SP, #+16]
   \       0xF4   0x43B0             BICS     R0,R0,R6
   \       0xF6   0x6856             LDR      R6,[R2, #+4]
   \       0xF8   0x0936             LSRS     R6,R6,#+4
   \       0xFA   0x9F03             LDR      R7,[SP, #+12]
   \       0xFC   0x4037             ANDS     R7,R7,R6
   \       0xFE   0x40AF             LSLS     R7,R7,R5
   \      0x100   0x4307             ORRS     R7,R7,R0
   \      0x102   0x604F             STR      R7,[R1, #+4]
   \                     ??HAL_GPIO_Init_13: (+1)
   \      0x104   0x680E             LDR      R6,[R1, #+0]
   \      0x106   0x2003             MOVS     R0,#+3
   \      0x108   0x4026             ANDS     R6,R6,R4
   \      0x10A   0x6857             LDR      R7,[R2, #+4]
   \      0x10C   0x4007             ANDS     R7,R7,R0
   \      0x10E   0x409F             LSLS     R7,R7,R3
   \      0x110   0x4337             ORRS     R7,R7,R6
   \      0x112   0x600F             STR      R7,[R1, #+0]
   \      0x114   0x68CE             LDR      R6,[R1, #+12]
   \      0x116   0x4034             ANDS     R4,R4,R6
   \      0x118   0x6896             LDR      R6,[R2, #+8]
   \      0x11A   0x409E             LSLS     R6,R6,R3
   \      0x11C   0x4326             ORRS     R6,R6,R4
   \      0x11E   0x60CE             STR      R6,[R1, #+12]
   \      0x120   0x6853             LDR      R3,[R2, #+4]
   \      0x122   0x00DB             LSLS     R3,R3,#+3
   \      0x124   0xD5AD             BPL      ??HAL_GPIO_Init_8
   \      0x126   0x....             LDR      R3,??DataTable2_2  ;; 0x40021034
   \      0x128   0x681B             LDR      R3,[R3, #+0]
   \      0x12A   0x9C03             LDR      R4,[SP, #+12]
   \      0x12C   0x431C             ORRS     R4,R4,R3
   \      0x12E   0x....             LDR      R3,??DataTable2_2  ;; 0x40021034
   \      0x130   0x601C             STR      R4,[R3, #+0]
   \      0x132   0x....             LDR      R3,??DataTable2_3  ;; 0x40010008
   \      0x134   0x08AC             LSRS     R4,R5,#+2
   \      0x136   0x00A4             LSLS     R4,R4,#+2
   \      0x138   0x191B             ADDS     R3,R3,R4
   \      0x13A   0x681E             LDR      R6,[R3, #+0]
   \      0x13C   0x466C             MOV      R4,SP
   \      0x13E   0x7827             LDRB     R7,[R4, #+0]
   \      0x140   0x240C             MOVS     R4,#+12
   \      0x142   0x403C             ANDS     R4,R4,R7
   \      0x144   0x270F             MOVS     R7,#+15
   \      0x146   0x40A7             LSLS     R7,R7,R4
   \      0x148   0x43BE             BICS     R6,R6,R7
   \      0x14A   0x27A0             MOVS     R7,#+160
   \      0x14C   0x05FF             LSLS     R7,R7,#+23       ;; #+1342177280
   \      0x14E   0x42B9             CMP      R1,R7
   \      0x150   0xD101             BNE      ??HAL_GPIO_Init_14
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0xE764             B        ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_14: (+1)
   \      0x156   0x....             LDR      R7,??DataTable2_4  ;; 0x50000400
   \      0x158   0x42B9             CMP      R1,R7
   \      0x15A   0xD101             BNE      ??HAL_GPIO_Init_15
   \      0x15C   0x9803             LDR      R0,[SP, #+12]
   \      0x15E   0xE75F             B        ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_15: (+1)
   \      0x160   0x....             LDR      R7,??DataTable2_5  ;; 0x50000800
   \      0x162   0x42B9             CMP      R1,R7
   \      0x164   0xD101             BNE      ??HAL_GPIO_Init_16
   \      0x166   0x2002             MOVS     R0,#+2
   \      0x168   0xE75A             B        ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_16: (+1)
   \      0x16A   0x....             LDR      R7,??DataTable2_6  ;; 0x50000c00
   \      0x16C   0x42B9             CMP      R1,R7
   \      0x16E   0xD000             BEQ      .+4
   \      0x170   0xE752             B        ??HAL_GPIO_Init_3
   \      0x172   0xE755             B        ??HAL_GPIO_Init_2
    280            }
    281          }
   \                     ??HAL_GPIO_Init_9: (+1)
   \      0x174   0xB005             ADD      SP,SP,#+20
   \      0x176   0xBDF0             POP      {R4-R7,PC}       ;; return
    282          
    283          /**
    284            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    285            * @param  GPIOx where x can be (A..E and H) to select the GPIO peripheral for STM32L0XX family devices.
    286            *                Note that GPIOE is not available on all devices.
    287            * @param  GPIO_Pin specifies the port bit to be written.
    288            *                   This parameter can be one of GPIO_PIN_x where x can be (0..15).
    289            *                   All port bits are not necessarily available on all GPIOs.
    290            * @retval None
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    293          { 
   \                     HAL_GPIO_DeInit: (+1)
   \        0x0   0xB5FF             PUSH     {R0-R7,LR}
    294            uint32_t position = 0x00U;
    295            uint32_t iocurrent = 0x00U;
    296            uint32_t tmp = 0x00U;
    297          
    298            /* Check the parameters */
    299            assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
   \        0x2   0x2303             MOVS     R3,#+3
   \        0x4   0x9302             STR      R3,[SP, #+8]
   \        0x6   0x2301             MOVS     R3,#+1
   \        0x8   0x9301             STR      R3,[SP, #+4]
   \        0xA   0x9103             STR      R1,[SP, #+12]
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0xE01C             B        ??HAL_GPIO_DeInit_0
    300          
    301            /* Configure the port pins */
    302            while ((GPIO_Pin >> position) != 0)
    303            {
    304              /* Get the IO position */
    305              iocurrent = (GPIO_Pin) & (1U << position);
    306          
    307              if(iocurrent)
    308              {
    309                /*------------------------- GPIO Mode Configuration --------------------*/
    310                /* Configure IO Direction in Input Floting Mode */
    311                GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    312                     
    313                /* Configure the default Alternate Function in current IO */ 
    314                GPIOx->AFR[position >> 3U] &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
    315                
    316                /* Configure the default value for IO Speed */
    317                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
    318                
    319                /* Configure the default value IO Output Type */
    320                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
    321                
    322                /* Deactivate the Pull-up oand Pull-down resistor for the current IO */
    323                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    324                
    325                /*------------------------- EXTI Mode Configuration --------------------*/
    326                /* Clear the External Interrupt or Event for the current IO */
    327                
    328                tmp = SYSCFG->EXTICR[position >> 2U];
    329                tmp &= (((uint32_t)0x0FU) << (4U * (position & 0x03U)));
    330                if(tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \       0x10   0x2606             MOVS     R6,#+6
   \       0x12   0xE003             B        ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \       0x14   0x....             LDR      R6,??DataTable2_1  ;; 0x50001c00
   \       0x16   0x42B0             CMP      R0,R6
   \       0x18   0xD1FA             BNE      ??HAL_GPIO_DeInit_1
   \       0x1A   0x2605             MOVS     R6,#+5
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \       0x1C   0x40A6             LSLS     R6,R6,R4
   \       0x1E   0x42B2             CMP      R2,R6
   \       0x20   0xD112             BNE      ??HAL_GPIO_DeInit_4
    331                {
    332                  tmp = ((uint32_t)0x0FU) << (4U * (position & 0x03U));
    333                  SYSCFG->EXTICR[position >> 2U] &= ~tmp;
   \       0x22   0x681A             LDR      R2,[R3, #+0]
   \       0x24   0x43AA             BICS     R2,R2,R5
   \       0x26   0x601A             STR      R2,[R3, #+0]
    334          
    335                  /* Clear EXTI line configuration */
    336                  EXTI->IMR &= ~((uint32_t)iocurrent);
   \       0x28   0x9B00             LDR      R3,[SP, #+0]
   \       0x2A   0x43DA             MVNS     R2,R3
   \       0x2C   0x....             LDR      R3,??DataTable2  ;; 0x40010400
   \       0x2E   0x681B             LDR      R3,[R3, #+0]
   \       0x30   0x4013             ANDS     R3,R3,R2
   \       0x32   0x....             LDR      R4,??DataTable2  ;; 0x40010400
   \       0x34   0x6023             STR      R3,[R4, #+0]
    337                  EXTI->EMR &= ~((uint32_t)iocurrent);
   \       0x36   0x6863             LDR      R3,[R4, #+4]
   \       0x38   0x4013             ANDS     R3,R3,R2
   \       0x3A   0x6063             STR      R3,[R4, #+4]
    338          
    339                  /* Clear Rising Falling edge configuration */
    340                  EXTI->RTSR &= ~((uint32_t)iocurrent);
   \       0x3C   0x68A3             LDR      R3,[R4, #+8]
   \       0x3E   0x4013             ANDS     R3,R3,R2
   \       0x40   0x60A3             STR      R3,[R4, #+8]
    341                  EXTI->FTSR &= ~((uint32_t)iocurrent);
   \       0x42   0x68E3             LDR      R3,[R4, #+12]
   \       0x44   0x401A             ANDS     R2,R2,R3
   \       0x46   0x60E2             STR      R2,[R4, #+12]
    342                }
    343              }
    344               position++;
   \                     ??HAL_GPIO_DeInit_4: (+1)
   \       0x48   0x1C49             ADDS     R1,R1,#+1
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \       0x4A   0x9A03             LDR      R2,[SP, #+12]
   \       0x4C   0x40CA             LSRS     R2,R2,R1
   \       0x4E   0xD043             BEQ      ??HAL_GPIO_DeInit_5
   \       0x50   0x9A01             LDR      R2,[SP, #+4]
   \       0x52   0x408A             LSLS     R2,R2,R1
   \       0x54   0x9B03             LDR      R3,[SP, #+12]
   \       0x56   0x4013             ANDS     R3,R3,R2
   \       0x58   0x9300             STR      R3,[SP, #+0]
   \       0x5A   0x9B00             LDR      R3,[SP, #+0]
   \       0x5C   0x2B00             CMP      R3,#+0
   \       0x5E   0xD0F3             BEQ      ??HAL_GPIO_DeInit_4
   \       0x60   0x9B02             LDR      R3,[SP, #+8]
   \       0x62   0x004C             LSLS     R4,R1,#+1
   \       0x64   0x40A3             LSLS     R3,R3,R4
   \       0x66   0x6804             LDR      R4,[R0, #+0]
   \       0x68   0x431C             ORRS     R4,R4,R3
   \       0x6A   0x6004             STR      R4,[R0, #+0]
   \       0x6C   0x08CC             LSRS     R4,R1,#+3
   \       0x6E   0x00A4             LSLS     R4,R4,#+2
   \       0x70   0x1904             ADDS     R4,R0,R4
   \       0x72   0x008D             LSLS     R5,R1,#+2
   \       0x74   0x6A26             LDR      R6,[R4, #+32]
   \       0x76   0x46B4             MOV      R12,R6
   \       0x78   0x270F             MOVS     R7,#+15
   \       0x7A   0x261C             MOVS     R6,#+28
   \       0x7C   0x402E             ANDS     R6,R6,R5
   \       0x7E   0x40B7             LSLS     R7,R7,R6
   \       0x80   0x4666             MOV      R6,R12
   \       0x82   0x43BE             BICS     R6,R6,R7
   \       0x84   0x6226             STR      R6,[R4, #+32]
   \       0x86   0x43DC             MVNS     R4,R3
   \       0x88   0x6883             LDR      R3,[R0, #+8]
   \       0x8A   0x4023             ANDS     R3,R3,R4
   \       0x8C   0x6083             STR      R3,[R0, #+8]
   \       0x8E   0x6843             LDR      R3,[R0, #+4]
   \       0x90   0x4393             BICS     R3,R3,R2
   \       0x92   0x6043             STR      R3,[R0, #+4]
   \       0x94   0x68C2             LDR      R2,[R0, #+12]
   \       0x96   0x4014             ANDS     R4,R4,R2
   \       0x98   0x60C4             STR      R4,[R0, #+12]
   \       0x9A   0x....             LDR      R2,??DataTable2_3  ;; 0x40010008
   \       0x9C   0x088B             LSRS     R3,R1,#+2
   \       0x9E   0x009B             LSLS     R3,R3,#+2
   \       0xA0   0x18D3             ADDS     R3,R2,R3
   \       0xA2   0x681A             LDR      R2,[R3, #+0]
   \       0xA4   0x240C             MOVS     R4,#+12
   \       0xA6   0x402C             ANDS     R4,R4,R5
   \       0xA8   0x250F             MOVS     R5,#+15
   \       0xAA   0x40A5             LSLS     R5,R5,R4
   \       0xAC   0x402A             ANDS     R2,R2,R5
   \       0xAE   0x26A0             MOVS     R6,#+160
   \       0xB0   0x05F6             LSLS     R6,R6,#+23       ;; #+1342177280
   \       0xB2   0x42B0             CMP      R0,R6
   \       0xB4   0xD101             BNE      ??HAL_GPIO_DeInit_6
   \       0xB6   0x2600             MOVS     R6,#+0
   \       0xB8   0xE7B0             B        ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_6: (+1)
   \       0xBA   0x....             LDR      R6,??DataTable2_4  ;; 0x50000400
   \       0xBC   0x42B0             CMP      R0,R6
   \       0xBE   0xD101             BNE      ??HAL_GPIO_DeInit_7
   \       0xC0   0x9E01             LDR      R6,[SP, #+4]
   \       0xC2   0xE7AB             B        ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_7: (+1)
   \       0xC4   0x....             LDR      R6,??DataTable2_5  ;; 0x50000800
   \       0xC6   0x42B0             CMP      R0,R6
   \       0xC8   0xD101             BNE      ??HAL_GPIO_DeInit_8
   \       0xCA   0x2602             MOVS     R6,#+2
   \       0xCC   0xE7A6             B        ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_8: (+1)
   \       0xCE   0x....             LDR      R6,??DataTable2_6  ;; 0x50000c00
   \       0xD0   0x42B0             CMP      R0,R6
   \       0xD2   0xD19F             BNE      ??HAL_GPIO_DeInit_3
   \       0xD4   0x9E02             LDR      R6,[SP, #+8]
   \       0xD6   0xE7A1             B        ??HAL_GPIO_DeInit_2
    345            }
    346          }
   \                     ??HAL_GPIO_DeInit_5: (+1)
   \       0xD8   0xBDFF             POP      {R0-R7,PC}       ;; return
    347          
    348          /**
    349            * @}
    350            */
    351          
    352          /** @addtogroup GPIO_Exported_Functions_Group2
    353           *  @brief   GPIO Read and Write
    354           *
    355          @verbatim
    356           ===============================================================================
    357                                 ##### IO operation functions #####
    358           ===============================================================================
    359          
    360          @endverbatim
    361            * @{
    362            */
    363          
    364          /**
    365            * @brief  Reads the specified input port pin.
    366            * @param  GPIOx where x can be (A..E and H) to select the GPIO peripheral for STM32L0xx family devices.
    367            *                Note that GPIOE is not available on all devices.
    368            * @param  GPIO_Pin specifies the port bit to read.
    369            *                   This parameter can be GPIO_PIN_x where x can be (0..15).
    370            *                   All port bits are not necessarily available on all GPIOs.
    371            * @retval The input port pin value.
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    374          {
    375            GPIO_PinState bitstatus;
    376            
    377            /* Check the parameters */
    378            assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
    379            
    380            if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \                     HAL_GPIO_ReadPin: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0x4008             ANDS     R0,R0,R1
   \        0x4   0xD000             BEQ      ??HAL_GPIO_ReadPin_0
   \        0x6   0x2001             MOVS     R0,#+1
    381            {
    382              bitstatus = GPIO_PIN_SET;
    383            }
    384            else
    385            {
    386              bitstatus = GPIO_PIN_RESET;
    387            }
    388            return bitstatus;
   \                     ??HAL_GPIO_ReadPin_0: (+1)
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x4770             BX       LR               ;; return
    389          }
    390          
    391          /**
    392            * @brief  Sets or clears the selected data port bit.
    393            * 
    394            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify 
    395            *         accesses. In this way, there is no risk of an IRQ occurring between
    396            *         the read and the modify access.
    397            *               
    398            * @param  GPIOx where x can be (A..E and H) to select the GPIO peripheral for STM32L0xx family devices.
    399            *                Note that GPIOE is not available on all devices.
    400            * @param  GPIO_Pin specifies the port bit to be written.
    401            *                   This parameter can be one of GPIO_PIN_x where x can be (0..15).
    402            *                   All port bits are not necessarily available on all GPIOs.
    403            * @param  PinState specifies the value to be written to the selected bit.
    404            *                   This parameter can be one of the GPIO_PinState enum values:
    405            *                        GPIO_PIN_RESET: to clear the port pin
    406            *                        GPIO_PIN_SET: to set the port pin
    407            * @retval None
    408            */

   \                                 In section .text, align 2, keep-with-next
    409          void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    410          {
    411            /* Check the parameters */
    412            assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
    413            assert_param(IS_GPIO_PIN_ACTION(PinState));
    414            
    415            if(PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \        0x0   0x2A00             CMP      R2,#+0
   \        0x2   0xD001             BEQ      ??HAL_GPIO_WritePin_0
    416            {
    417              GPIOx->BSRR = GPIO_Pin;
   \        0x4   0x6181             STR      R1,[R0, #+24]
   \        0x6   0x4770             BX       LR
    418            }
    419            else
    420            {
    421              GPIOx->BRR = GPIO_Pin ;
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \        0x8   0x6281             STR      R1,[R0, #+40]
    422            }
    423          }
   \        0xA   0x4770             BX       LR               ;; return
    424          
    425          /**
    426            * @brief  Toggles the specified GPIO pins.
    427            * @param  GPIOx Where x can be (A..E and H) to select the GPIO peripheral for STM32L0xx family devices.
    428            *                Note that GPIOE is not available on all devices.
    429            *                All port bits are not necessarily available on all GPIOs.
    430            * @param  GPIO_Pin Specifies the pins to be toggled.
    431            * @retval None
    432            */

   \                                 In section .text, align 2, keep-with-next
    433          void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    434          {
    435            /* Check the parameters */
    436            assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
    437          
    438            GPIOx->ODR ^= GPIO_Pin;
   \                     HAL_GPIO_TogglePin: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
   \        0x2   0x404A             EORS     R2,R2,R1
   \        0x4   0x6142             STR      R2,[R0, #+20]
    439          }
   \        0x6   0x4770             BX       LR               ;; return
    440          
    441          /**
    442          * @brief  Locks GPIO Pins configuration registers.
    443          * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    444          *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    445          * @note   The configuration of the locked GPIO pins can no longer be modified
    446          *         until the next reset.
    447          * @param  GPIOx where x can be (A..E and H) to select the GPIO peripheral for STM32L0xx family.
    448          *                Note that GPIOE is not available on all devices.
    449          * @param  GPIO_Pin specifies the port bit to be locked.
    450          *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    451          *         All port bits are not necessarily available on all GPIOs.
    452          * @retval None
    453          */

   \                                 In section .text, align 2, keep-with-next
    454          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    455          {
   \                     HAL_GPIO_LockPin: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    456            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \        0x2   0x2280             MOVS     R2,#+128
   \        0x4   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \        0x6   0x9200             STR      R2,[SP, #+0]
    457          
    458            /* Check the parameters */
    459            assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
    460          
    461            /* Apply lock key write sequence */
    462            tmp |= GPIO_Pin;
   \        0x8   0x9B00             LDR      R3,[SP, #+0]
   \        0xA   0x430B             ORRS     R3,R3,R1
   \        0xC   0x9300             STR      R3,[SP, #+0]
    463            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    464            GPIOx->LCKR = tmp;
   \        0xE   0x9B00             LDR      R3,[SP, #+0]
   \       0x10   0x61C3             STR      R3,[R0, #+28]
    465            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    466            GPIOx->LCKR = GPIO_Pin;
   \       0x12   0x61C1             STR      R1,[R0, #+28]
    467            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    468            GPIOx->LCKR = tmp;
   \       0x14   0x9900             LDR      R1,[SP, #+0]
   \       0x16   0x61C1             STR      R1,[R0, #+28]
    469            /* Read LCKK bit*/
    470            tmp = GPIOx->LCKR;
   \       0x18   0x69C1             LDR      R1,[R0, #+28]
   \       0x1A   0x9100             STR      R1,[SP, #+0]
    471          
    472            if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
   \       0x1C   0x69C0             LDR      R0,[R0, #+28]
   \       0x1E   0x4002             ANDS     R2,R2,R0
   \       0x20   0x1E50             SUBS     R0,R2,#+1
   \       0x22   0x4180             SBCS     R0,R0,R0
   \       0x24   0x0FC0             LSRS     R0,R0,#+31
    473            {
    474              return HAL_OK;
    475            }
    476            else
    477            {
    478              return HAL_ERROR;
   \       0x26   0xB001             ADD      SP,SP,#+4
   \       0x28   0x4770             BX       LR               ;; return
    479            }
    480          }
    481          /**
    482            * @brief  This function handles EXTI interrupt request.
    483            * @param  GPIO_Pin Specifies the pins connected to the EXTI line.
    484            * @retval None
    485            */

   \                                 In section .text, align 2, keep-with-next
    486          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    487          {
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \        0x0   0x....             LDR      R2,??DataTable2_7  ;; 0x40010414
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0x4003             ANDS     R3,R3,R0
   \        0x6   0xD100             BNE      ??HAL_GPIO_EXTI_IRQHandler_0
   \        0x8   0x4770             BX       LR
   \                     ??HAL_GPIO_EXTI_IRQHandler_0: (+1)
   \        0xA   0xB580             PUSH     {R7,LR}
    488            /* EXTI line interrupt detected */
    489            if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
    490            { 
    491              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \        0xC   0x6010             STR      R0,[R2, #+0]
    492              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \        0xE   0x....'....        BL       HAL_GPIO_EXTI_Callback
    493            }
    494          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    495          
    496          /**
    497            * @brief  EXTI line detection callbacks.
    498            * @param  GPIO_Pin Specifies the pins connected to the EXTI line.
    499            * @retval None
    500            */

   \                                 In section .text, align 2
    501          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    502          {
    503            /* Prevent unused argument(s) compilation warning */
    504            UNUSED(GPIO_Pin);
    505          
    506            /* NOTE: This function Should not be modified, when the callback is needed,
    507                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    508             */ 
    509          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x5000'1C00        DC32     0x50001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x4002'1034        DC32     0x40021034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4001'0008        DC32     0x40010008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x5000'0400        DC32     0x50000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x5000'0800        DC32     0x50000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x5000'0C00        DC32     0x50000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0x4001'0414        DC32     0x40010414
    510          
    511          /**
    512            * @}
    513            */
    514          
    515          
    516          /**
    517            * @}
    518            */
    519          
    520          /**
    521            * @}
    522            */
    523          
    524          #endif /* HAL_GPIO_MODULE_ENABLED */
    525          
    526          /**
    527            * @}
    528            */
    529          
    530          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    531          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      36   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       8   HAL_GPIO_EXTI_IRQHandler
         8   -> HAL_GPIO_EXTI_Callback
      40   HAL_GPIO_Init
       4   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
     218  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      20  HAL_GPIO_EXTI_IRQHandler
     376  HAL_GPIO_Init
      42  HAL_GPIO_LockPin
      12  HAL_GPIO_ReadPin
       8  HAL_GPIO_TogglePin
      12  HAL_GPIO_WritePin

 
 722 bytes in section .text
 
 720 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none
