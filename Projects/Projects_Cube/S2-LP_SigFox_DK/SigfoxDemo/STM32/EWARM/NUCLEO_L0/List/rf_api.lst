###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  11:53:12
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\rf_api.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EWECD4.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\rf_api.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\rf_api.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\rf_api.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\rf_api.c
      1          #include "sigfox_stack.h"
      2          #include "S2LP_Middleware_Config.h"
      3          #include "SDK_EVAL_Config.h"
      4          
      5          #ifdef MONARCH_FEATURE_ENABLED
      6          #include "st_monarch_api.h"
      7          #endif
      8          
      9          /* The RAMPS_IN_RAM symbol forces the ramps to be placed in RAM. It may be
     10          useful if someone wants to use less flash occupation sacrifying some RAM */
     11          //#define RAMPS_IN_RAM
     12          
     13          /* The DEBUG symbol is used to print the names of the invoked functions */
     14          //#define DEBUG
     15          
     16          #ifdef DEBUG
     17          void ST_dbg_CB(const char *vectcStr,...);
     18          #define PRINTF(...)     { ST_dbg_CB(__VA_ARGS__);}
     19          #elif DEBUG_BLE
     20          #include "SDK_EVAL_Com.h"
     21          #define PRINTF(...) printf(__VA_ARGS__)
     22          #else
     23          #define PRINTF(...)
     24          #endif
     25          

   \                                 In section .text, align 4, keep-with-next
     26          static const uint8_t ST_RF_API_VER[ST_RF_API_VER_SIZE] = {'v','2','.','7','.','1'};
   \                     ST_RF_API_VER:
   \        0x0   0x76 0x32          DC8 118, 50, 46, 55, 46, 49, 0, 0

   \              0x2E 0x37    

   \              0x2E 0x31    

   \              0x00 0x00
     27          
     28          /* the array zeroes is used to implement waiting times in the TX FIFO */
     29          static BUFF_PLACING uint8_t zeroes[]={0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\
     30            						   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\
     31                                                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
     32          
     33          uint8_t rampBuffer[82];

   \                                 In section .bss, align 1
     34          uint8_t bfSize;
   \                     bfSize:
   \        0x0                      DS8 1
   \        0x1                      DS8 1
   \        0x2                      DS8 1

   \                                 In section .data, align 4
     35          static volatile uint8_t bSwap=0;
     36          static volatile st_fifo_state_t _s2lpFIFOState;
     37          
     38          static st_manuf_t st_manuf =
   \                     st_manuf:
   \        0x0   0x00               DC8 0
   \        0x1                      DS8 15
   \       0x10   0x00               DC8 0
   \       0x11                      DS8 3
   \       0x14   0x0000'0000        DC32 0, 50'000'000

   \              0x02FA'F080
   \       0x1C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00
   \       0x25                      DS8 1
   \       0x26   0x0000             DC16 0
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x2C                      DS8 104
   \                     rampBuffer:
   \       0x94                      DS8 84
   \       0xE8   0x00 0xFF          DC8 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xFE   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00
   \      0x115   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00
   \      0x12C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
     39          {
     40            .last_rssi_reg = 0,
     41            .priv_xtal_freq = XTAL_FREQUENCY,
     42            .lbt_thr_offset = 0,
     43            .smps_mode = 0,
     44            .tcxo_flag = 0,
     45            .pa_flag = 0,
     46            .tim_started = 0,
     47            .s2lp_irq_raised = 0,
     48            .api_timer_raised = 0,
     49            .api_timer_channel_clear_raised = 0,
     50            .manuf_state = ST_MANUF_STATE_IDLE,
     51            .rssi_offset = 0,
     52            .power_reduction = 0,
     53            .tx_is_ready = 0,
     54            .carrier_sense_tim_nested = 0
     55          };
     56          
     57          #define st_manuf_context        (&st_manuf)
     58          
     59          /* SPI functions - these functions are implemented using the priv_ST_MANUF_SpiRaw */

   \                                 In section .text, align 2, keep-with-next
     60          static void priv_ST_MANUF_SpiRaw_Ramp(uint8_t n_bytes,uint8_t* buff_in, uint8_t* buff_out, uint8_t blocking)
     61          {
   \                     priv_ST_MANUF_SpiRaw_Ramp: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB096             SUB      SP,SP,#+88
     62            if(st_manuf_context->power_reduction!=0 && buff_in!=zeroes)
   \        0x4   0x....             LDR      R2,??DataTable4
   \        0x6   0x2326             MOVS     R3,#+38
   \        0x8   0x5ED3             LDRSH    R3,[R2, R3]
   \        0xA   0x2B00             CMP      R3,#+0
   \        0xC   0xD024             BEQ      ??priv_ST_MANUF_SpiRaw_Ramp_0
   \        0xE   0x0013             MOVS     R3,R2
   \       0x10   0x33E8             ADDS     R3,R3,#+232
   \       0x12   0x4299             CMP      R1,R3
   \       0x14   0xD020             BEQ      ??priv_ST_MANUF_SpiRaw_Ramp_0
     63            {
     64              uint32_t i;
     65              uint8_t fifo_buff[82];
     66              fifo_buff[0]=buff_in[0];
   \       0x16   0xAB01             ADD      R3,SP,#+4
   \       0x18   0x780C             LDRB     R4,[R1, #+0]
   \       0x1A   0x701C             STRB     R4,[R3, #+0]
     67              fifo_buff[1]=buff_in[1];
   \       0x1C   0x784C             LDRB     R4,[R1, #+1]
   \       0x1E   0x705C             STRB     R4,[R3, #+1]
     68              for(i=2;i<n_bytes;i++)
   \       0x20   0x2602             MOVS     R6,#+2
   \       0x22   0x9100             STR      R1,[SP, #+0]
   \       0x24   0xE00F             B        ??priv_ST_MANUF_SpiRaw_Ramp_1
     69              {
     70          	if(((i%2)!=0) && (buff_in[i]+st_manuf_context->power_reduction<st_manuf_context->ramps_settings.min_power))
   \                     ??priv_ST_MANUF_SpiRaw_Ramp_2: (+1)
   \       0x26   0x9900             LDR      R1,[SP, #+0]
   \       0x28   0x5D89             LDRB     R1,[R1, R6]
   \       0x2A   0x199C             ADDS     R4,R3,R6
   \       0x2C   0x07F5             LSLS     R5,R6,#+31
   \       0x2E   0xD508             BPL      ??priv_ST_MANUF_SpiRaw_Ramp_3
   \       0x30   0x2726             MOVS     R7,#+38
   \       0x32   0x5FD7             LDRSH    R7,[R2, R7]
   \       0x34   0x19CD             ADDS     R5,R1,R7
   \       0x36   0x278D             MOVS     R7,#+141
   \       0x38   0x5DD7             LDRB     R7,[R2, R7]
   \       0x3A   0x42BD             CMP      R5,R7
   \       0x3C   0xDA01             BGE      ??priv_ST_MANUF_SpiRaw_Ramp_3
     71          	  fifo_buff[i]=buff_in[i]+st_manuf_context->power_reduction;
   \       0x3E   0x8CD5             LDRH     R5,[R2, #+38]
   \       0x40   0x1949             ADDS     R1,R1,R5
   \                     ??priv_ST_MANUF_SpiRaw_Ramp_3: (+1)
   \       0x42   0x7021             STRB     R1,[R4, #+0]
     72          	else
     73          	  fifo_buff[i]=buff_in[i];
     74              }
   \       0x44   0x1C76             ADDS     R6,R6,#+1
   \                     ??priv_ST_MANUF_SpiRaw_Ramp_1: (+1)
   \       0x46   0x4286             CMP      R6,R0
   \       0x48   0xD3ED             BCC      ??priv_ST_MANUF_SpiRaw_Ramp_2
     75              priv_ST_MANUF_SpiRaw_(n_bytes,fifo_buff,buff_out,blocking);
   \       0x4A   0xA918             ADD      R1,SP,#+96
   \       0x4C   0x780B             LDRB     R3,[R1, #+0]
   \       0x4E   0x9A17             LDR      R2,[SP, #+92]
   \       0x50   0xA901             ADD      R1,SP,#+4
   \       0x52   0x....'....        BL       ST_MCU_API_SpiRaw
   \       0x56   0xE004             B        ??priv_ST_MANUF_SpiRaw_Ramp_4
     76            }
     77            else
     78            {
     79              priv_ST_MANUF_SpiRaw_(n_bytes,buff_in,buff_out,blocking);
   \                     ??priv_ST_MANUF_SpiRaw_Ramp_0: (+1)
   \       0x58   0xAA18             ADD      R2,SP,#+96
   \       0x5A   0x7813             LDRB     R3,[R2, #+0]
   \       0x5C   0x9A17             LDR      R2,[SP, #+92]
   \       0x5E   0x....'....        BL       ST_MCU_API_SpiRaw
     80            }
     81          }
   \                     ??priv_ST_MANUF_SpiRaw_Ramp_4: (+1)
   \       0x62   0xB019             ADD      SP,SP,#+100
   \       0x64   0xBDF0             POP      {R4-R7,PC}       ;; return
     82          
     83          /* command strobe - used to strobe commands to the S2-LP */

   \                                 In section .text, align 2, keep-with-next
     84          static void priv_ST_MANUF_CmdStrobe(uint8_t cmd)
     85          {
   \                     priv_ST_MANUF_CmdStrobe: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     86            uint8_t tx_spi_buffer[2];
     87          
     88            tx_spi_buffer[0]=0x80;
   \        0x2   0x4669             MOV      R1,SP
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x700A             STRB     R2,[R1, #+0]
     89            tx_spi_buffer[1]=cmd;
   \        0x8   0x7048             STRB     R0,[R1, #+1]
     90          
     91            priv_ST_MANUF_SpiRaw(2,tx_spi_buffer,NULL);
   \        0xA   0x2300             MOVS     R3,#+0
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0x....'....        BL       ST_MCU_API_SpiRaw
     92          }
   \       0x14   0xBD01             POP      {R0,PC}          ;; return
     93          
     94          /* write registers function */

   \                                 In section .text, align 2, keep-with-next
     95          static void priv_ST_MANUF_WriteRegisters(uint8_t address, uint8_t n_bytes, uint8_t* buffer)
     96          {
   \                     priv_ST_MANUF_WriteRegisters: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0003             MOVS     R3,R0
   \        0x6   0x0008             MOVS     R0,R1
     97            uint8_t tx_spi_buffer[24];
     98          
     99            tx_spi_buffer[0]=0x00;
   \        0x8   0x2400             MOVS     R4,#+0
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x700C             STRB     R4,[R1, #+0]
    100            tx_spi_buffer[1]=address;
   \        0xE   0x704B             STRB     R3,[R1, #+1]
    101          
    102            for(uint32_t i=0;i<n_bytes;i++)
   \       0x10   0xE003             B        ??priv_ST_MANUF_WriteRegisters_0
    103            {
    104              tx_spi_buffer[i+2]=buffer[i];
   \                     ??priv_ST_MANUF_WriteRegisters_1: (+1)
   \       0x12   0x5D13             LDRB     R3,[R2, R4]
   \       0x14   0x190D             ADDS     R5,R1,R4
   \       0x16   0x70AB             STRB     R3,[R5, #+2]
    105            }
   \       0x18   0x1C64             ADDS     R4,R4,#+1
   \                     ??priv_ST_MANUF_WriteRegisters_0: (+1)
   \       0x1A   0x4284             CMP      R4,R0
   \       0x1C   0xD3F9             BCC      ??priv_ST_MANUF_WriteRegisters_1
    106          
    107            priv_ST_MANUF_SpiRaw(n_bytes+2,tx_spi_buffer,NULL);
   \       0x1E   0x2300             MOVS     R3,#+0
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x1C80             ADDS     R0,R0,#+2
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x....'....        BL       ST_MCU_API_SpiRaw
    108          }
   \       0x2A   0xB007             ADD      SP,SP,#+28
   \       0x2C   0xBD30             POP      {R4,R5,PC}       ;; return
    109          
    110          /* read registers function */

   \                                 In section .text, align 2, keep-with-next
    111          static void priv_ST_MANUF_ReadRegisters(uint8_t address, uint8_t n_bytes, uint8_t* buffer)
    112          {
   \                     priv_ST_MANUF_ReadRegisters: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB0C2             SUB      SP,SP,#+264
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
    113            uint8_t rx_spi_buffer[130],tx_spi_buffer[130];
    114          
    115            tx_spi_buffer[0]=0x01;
   \        0x8   0x466B             MOV      R3,SP
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x7019             STRB     R1,[R3, #+0]
    116            tx_spi_buffer[1]=address;
   \        0xE   0x7058             STRB     R0,[R3, #+1]
    117          
    118            for(uint32_t i=0;i<n_bytes;i++)
   \       0x10   0x0035             MOVS     R5,R6
   \       0x12   0xD004             BEQ      ??priv_ST_MANUF_ReadRegisters_0
    119            {
    120              tx_spi_buffer[i+2]=0xFF;
   \       0x14   0x22FF             MOVS     R2,#+255
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0x1C98             ADDS     R0,R3,#+2
   \       0x1A   0x....'....        BL       __aeabi_memset
    121            }
    122          
    123            priv_ST_MANUF_SpiRaw(n_bytes+2,tx_spi_buffer,rx_spi_buffer);
   \                     ??priv_ST_MANUF_ReadRegisters_0: (+1)
   \       0x1E   0x2300             MOVS     R3,#+0
   \       0x20   0xAA21             ADD      R2,SP,#+132
   \       0x22   0x4669             MOV      R1,SP
   \       0x24   0x1CB6             ADDS     R6,R6,#+2
   \       0x26   0xB2F0             UXTB     R0,R6
   \       0x28   0x....'....        BL       ST_MCU_API_SpiRaw
    124          
    125            for(uint32_t i=0;i<n_bytes;i++)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE004             B        ??priv_ST_MANUF_ReadRegisters_1
    126            {
    127              buffer[i]=rx_spi_buffer[i+2];
   \                     ??priv_ST_MANUF_ReadRegisters_2: (+1)
   \       0x30   0xA921             ADD      R1,SP,#+132
   \       0x32   0x1809             ADDS     R1,R1,R0
   \       0x34   0x7889             LDRB     R1,[R1, #+2]
   \       0x36   0x5421             STRB     R1,[R4, R0]
    128            }
   \       0x38   0x1C40             ADDS     R0,R0,#+1
   \                     ??priv_ST_MANUF_ReadRegisters_1: (+1)
   \       0x3A   0x42A8             CMP      R0,R5
   \       0x3C   0xD3F8             BCC      ??priv_ST_MANUF_ReadRegisters_2
    129          }
   \       0x3E   0xB042             ADD      SP,SP,#+264
   \       0x40   0xBD70             POP      {R4-R6,PC}       ;; return
    130          

   \                                 In section .text, align 4, keep-with-next
    131          void priv_ST_MANUF_generateFIFORampsBuffer(st_ramp_buffer_t bufferType, uint8_t *pBuffer, uint8_t *pBufferSize, ramps_settings_t *rampsSettings)
    132          {
   \                     priv_ST_MANUF_generateFIFORampsBuffer: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB0A0             SUB      SP,SP,#+128
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    133            uint8_t j = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9006             STR      R0,[SP, #+24]
    134          
    135            uint8_t auxBuff[] = {1, 1, 2, 2, 3, 4, 6, 8, 11, 14, 19, 23, 27, 31, 44, 220}; /* Default */
   \        0xC   0xA802             ADD      R0,SP,#+8
   \        0xE   0x493C             LDR      R1,??priv_ST_MANUF_generateFIFORampsBuffer_1
   \       0x10   0x2210             MOVS     R2,#+16
   \       0x12   0x....'....        BL       __aeabi_memcpy4
   \       0x16   0x2148             MOVS     R1,#+72
   \       0x18   0xA807             ADD      R0,SP,#+28
   \       0x1A   0x....'....        BL       __aeabi_memclr4
    136            uint8_t start_ramp[72] = {0};
    137            uint8_t start_ramp_tail[27] = {8,8,9,9,10,10,11,11,13,13,15,16,17,18,20,22,24,26,31,35,40,45,51,60,67,70,80};
   \       0x1E   0xA819             ADD      R0,SP,#+100
   \       0x20   0x4938             LDR      R1,??priv_ST_MANUF_generateFIFORampsBuffer_1+0x4
   \       0x22   0x221C             MOVS     R2,#+28
   \       0x24   0x....'....        BL       __aeabi_memcpy4
    138          
    139          
    140            if(rampsSettings->gainFactor1 == 0x00)
   \       0x28   0x9822             LDR      R0,[SP, #+136]
   \       0x2A   0x7940             LDRB     R0,[R0, #+5]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD10C             BNE      ??priv_ST_MANUF_generateFIFORampsBuffer_2
    141            {
    142              auxBuff[9] =  15;
   \       0x30   0x200F             MOVS     R0,#+15
   \       0x32   0xA902             ADD      R1,SP,#+8
   \       0x34   0x7248             STRB     R0,[R1, #+9]
    143              auxBuff[10] = 20;
   \       0x36   0x2014             MOVS     R0,#+20
   \       0x38   0x7288             STRB     R0,[R1, #+10]
    144              auxBuff[11] = 24;
   \       0x3A   0x2018             MOVS     R0,#+24
   \       0x3C   0x72C8             STRB     R0,[R1, #+11]
    145              auxBuff[12] = 30;
   \       0x3E   0x201E             MOVS     R0,#+30
   \       0x40   0x7308             STRB     R0,[R1, #+12]
    146              auxBuff[13] = 39;
   \       0x42   0x2027             MOVS     R0,#+39
   \       0x44   0x7348             STRB     R0,[R1, #+13]
    147              auxBuff[14] = 54;
   \       0x46   0x2036             MOVS     R0,#+54
   \       0x48   0x7388             STRB     R0,[R1, #+14]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_2: (+1)
   \       0x4A   0x4668             MOV      R0,SP
   \       0x4C   0x7104             STRB     R4,[R0, #+4]
    148            }
    149          
    150            switch (bufferType)
   \       0x4E   0x2352             MOVS     R3,#+82
   \       0x50   0x2602             MOVS     R6,#+2
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0x2107             MOVS     R1,#+7
   \       0x56   0x2205             MOVS     R2,#+5
   \       0x58   0xAC07             ADD      R4,SP,#+28
   \       0x5A   0x9500             STR      R5,[SP, #+0]
   \       0x5C   0x466D             MOV      R5,SP
   \       0x5E   0x792D             LDRB     R5,[R5, #+4]
   \       0x60   0x2D05             CMP      R5,#+5
   \       0x62   0xD84A             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_3
   \       0x64   0xA701             ADR      R7,??priv_ST_MANUF_generateFIFORampsBuffer_0
   \       0x66   0x006D             LSLS     R5,R5,#+1
   \       0x68   0x5B7F             LDRH     R7,[R7, R5]
   \       0x6A   0x44BF             ADD      PC,PC,R7
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_0:
   \       0x6C   0x000A 0x009A      DC16     0xA,0x9A,0xBE,0x16E

   \               0x00BE 0x016

   \              E
   \       0x74   0x021C 0x02B6      DC16     0x21C,0x2B6
    151            {
    152            case FIFO_RAMP_FAST:
    153              {
    154          	*pBufferSize = 82;
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_4: (+1)
   \       0x78   0x9821             LDR      R0,[SP, #+132]
   \       0x7A   0x7003             STRB     R3,[R0, #+0]
    155          
    156          	for(uint8_t i=0;i<15;i++)
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xA902             ADD      R1,SP,#+8
   \       0x80   0x9A22             LDR      R2,[SP, #+136]
    157          	  auxBuff[i] += rampsSettings->gainFactor1;
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_5: (+1)
   \       0x82   0x5C0B             LDRB     R3,[R1, R0]
   \       0x84   0x7954             LDRB     R4,[R2, #+5]
   \       0x86   0x191B             ADDS     R3,R3,R4
   \       0x88   0x540B             STRB     R3,[R1, R0]
   \       0x8A   0x1C40             ADDS     R0,R0,#+1
   \       0x8C   0x280E             CMP      R0,#+14
   \       0x8E   0xDDF8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_5
    158          
    159          	for(uint8_t i=2;i<17*2;i+=2)
   \       0x90   0xAC02             ADD      R4,SP,#+8
   \       0x92   0x9800             LDR      R0,[SP, #+0]
   \       0x94   0x9906             LDR      R1,[SP, #+24]
   \       0x96   0x1C47             ADDS     R7,R0,#+1
    160          	{
    161          	  if (i<18){
    162          	    pBuffer[i]=0;
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_6: (+1)
   \       0x98   0x2300             MOVS     R3,#+0
   \       0x9A   0x5583             STRB     R3,[R0, R6]
    163          	    pBuffer[i+1] = rampsSettings->max_power;
   \       0x9C   0x7915             LDRB     R5,[R2, #+4]
   \       0x9E   0x55BD             STRB     R5,[R7, R6]
    164          	  }
    165          
    166          	  pBuffer[16+i]=0;
   \       0xA0   0x1985             ADDS     R5,R0,R6
   \       0xA2   0x742B             STRB     R3,[R5, #+16]
    167          	  pBuffer[16+i+1]=auxBuff[j];
   \       0xA4   0xB2CB             UXTB     R3,R1
   \       0xA6   0x5CE3             LDRB     R3,[R4, R3]
   \       0xA8   0x746B             STRB     R3,[R5, #+17]
    168          
    169          	  j+=1;
   \       0xAA   0x1C49             ADDS     R1,R1,#+1
   \       0xAC   0x1CB6             ADDS     R6,R6,#+2
   \       0xAE   0x2E11             CMP      R6,#+17
   \       0xB0   0xDDF2             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_6
   \       0xB2   0x2312             MOVS     R3,#+18
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_7: (+1)
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x0004             MOVS     R4,R0
   \       0xB8   0x3410             ADDS     R4,R4,#+16
   \       0xBA   0x54E2             STRB     R2,[R4, R3]
   \       0xBC   0xAA02             ADD      R2,SP,#+8
   \       0xBE   0xB2CC             UXTB     R4,R1
   \       0xC0   0x5D14             LDRB     R4,[R2, R4]
   \       0xC2   0x0005             MOVS     R5,R0
   \       0xC4   0x3511             ADDS     R5,R5,#+17
   \       0xC6   0x54EC             STRB     R4,[R5, R3]
   \       0xC8   0x1C49             ADDS     R1,R1,#+1
    170          	}
   \       0xCA   0x1C9B             ADDS     R3,R3,#+2
   \       0xCC   0x2B22             CMP      R3,#+34
   \       0xCE   0xDBF1             BLT      ??priv_ST_MANUF_generateFIFORampsBuffer_7
    171          
    172          	j=0;
   \       0xD0   0x2100             MOVS     R1,#+0
   \       0xD2   0x2300             MOVS     R3,#+0
    173          
    174          	for(uint8_t i=0;i<16*2;i+=2)
   \       0xD4   0x2400             MOVS     R4,#+0
   \       0xD6   0x9000             STR      R0,[SP, #+0]
    175          	{
    176          	  pBuffer[82-i-2]=0;
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_8: (+1)
   \       0xD8   0x9800             LDR      R0,[SP, #+0]
   \       0xDA   0x3050             ADDS     R0,R0,#+80
   \       0xDC   0x4265             RSBS     R5,R4,#+0
   \       0xDE   0x1940             ADDS     R0,R0,R5
   \       0xE0   0x7001             STRB     R1,[R0, #+0]
    177          	  pBuffer[82-i-1]=auxBuff[j];
   \       0xE2   0xB2DD             UXTB     R5,R3
   \       0xE4   0x5D55             LDRB     R5,[R2, R5]
   \       0xE6   0x7045             STRB     R5,[R0, #+1]
    178          	  j+=1;
   \       0xE8   0x1C5B             ADDS     R3,R3,#+1
    179          	}
   \       0xEA   0x1CA4             ADDS     R4,R4,#+2
   \       0xEC   0x2C1F             CMP      R4,#+31
   \       0xEE   0xDDF3             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_8
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_9: (+1)
   \       0xF0   0x9800             LDR      R0,[SP, #+0]
    180          
    181          	pBuffer[0] = 0x00;
    182          	pBuffer[1] = 0xFF;
    183          
    184          	break;
    185              }
    186            case FIFO_CONST_FAST:
    187              {
    188          	*pBufferSize = 82;
    189          
    190          	pBuffer[0] = 0x00;
    191          	pBuffer[1] = 0xFF;
    192          
    193          	for(uint8_t i=2;i<82;i+=2){
    194          	    pBuffer[i]=0;
    195          	    pBuffer[i+1] = rampsSettings->max_power;
    196          	}
    197          
    198          	break;
    199              }
    200            case FIFO_RAMP_DOWN_1:
    201              {
    202          	*pBufferSize = 82;
    203          
    204          	for(uint8_t i=0;i<46;i++)
    205          	{
    206          	  if(i < 10)
    207          	    start_ramp[i] = 1;
    208          	  if(i > 9 && i < 18)
    209          	    start_ramp[i] = 2;
    210          	  if(i > 17 && i < 25)
    211          	    start_ramp[i] = 3;
    212          	  if(i > 24 && i < 31)
    213          	    start_ramp[i] = 4;
    214          	  if(i > 30 && i < 36)
    215          	    start_ramp[i] = 5;
    216          	  if(i > 35 && i < 41)
    217          	    start_ramp[i] = 6;
    218          	  if(i > 40 && i < 45)
    219          	    start_ramp[i] = 7;
    220          	}
    221          
    222          	memcpy(start_ramp + 45, start_ramp_tail, 27*sizeof(uint8_t));
    223          
    224          	/* Scale start_ramp values */
    225          	for(uint8_t i=0;i<72;i++)
    226          	  start_ramp[i] += rampsSettings->gainFactor1;
    227          
    228          	for(uint8_t i=2;i<18;i+=2){
    229          	  pBuffer[i]=0;
    230          	  pBuffer[i+1] = rampsSettings->max_power;
    231          	}
    232          
    233          	j=0;
    234          
    235          	for(uint8_t i=0;i<(32*2);i+=2){
    236          	  pBuffer[2*41-i-1]=start_ramp[32-j-1] + rampsSettings->gainFactor2;
    237          	  pBuffer[2*41-i-2]=0;
    238          	  j+=1;
    239          	}
    240          
    241          	pBuffer[0] = 0x00;
    242          	pBuffer[1] = 0xFF;
    243          	break;
    244              }
    245            case FIFO_RAMP_DOWN_2:
    246              {
    247          	*pBufferSize = 82;
    248          
    249          	for(uint8_t i=0;i<46;i++)
    250          	{
    251          	  if(i < 10)
    252          	    start_ramp[i] = 1;
    253          	  if(i > 9 && i < 18)
    254          	    start_ramp[i] = 2;
    255          	  if(i > 17 && i < 25)
    256          	    start_ramp[i] = 3;
    257          	  if(i > 24 && i < 31)
    258          	    start_ramp[i] = 4;
    259          	  if(i > 30 && i < 36)
    260          	    start_ramp[i] = 5;
    261          	  if(i > 35 && i < 41)
    262          	    start_ramp[i] = 6;
    263          	  if(i > 40 && i < 45)
    264          	    start_ramp[i] = 7;
    265          	}
    266          
    267          	memcpy(start_ramp + 45, start_ramp_tail, 27*sizeof(uint8_t));
    268          
    269          	/* Scale start_ramp values */
    270          	for(uint8_t i=0;i<72;i++)
    271          	  start_ramp[i] = start_ramp[i] + rampsSettings->gainFactor1;
    272          
    273          	pBuffer[0] = 0x00;
    274          	pBuffer[1] = 0xFF;
    275          
    276          	j=0;
    277          
    278          	for(uint8_t i=0;i<40*2;i+=2){
    279          	  pBuffer[2*41-i-1]=start_ramp[72-j-1] + rampsSettings->gainFactor2;
    280          	  pBuffer[2*41-i-2]=0;
    281          	  j+=1;
    282          	}
    283          
    284          	break;
    285              }
    286            case FIFO_RAMP_UP_1:
    287              {
    288          	*pBufferSize = 82;
    289          
    290          	for(uint8_t i=0;i<46;i++)
    291          	{
    292          	  if(i < 10)
    293          	    start_ramp[i] = 1;
    294          	  if(i > 9 && i < 18)
    295          	    start_ramp[i] = 2;
    296          	  if(i > 17 && i < 25)
    297          	    start_ramp[i] = 3;
    298          	  if(i > 24 && i < 31)
    299          	    start_ramp[i] = 4;
    300          	  if(i > 30 && i < 36)
    301          	    start_ramp[i] = 5;
    302          	  if(i > 35 && i < 41)
    303          	    start_ramp[i] = 6;
    304          	  if(i > 40 && i < 45)
    305          	    start_ramp[i] = 7;
    306          	}
    307          
    308          	memcpy(start_ramp + 45, start_ramp_tail, 27*sizeof(uint8_t));
    309          
    310          	/* Scale start_ramp values */
    311          	for(uint8_t i=0;i<72;i++)
    312          	  start_ramp[i] = start_ramp[i] + rampsSettings->gainFactor1;
    313          
    314          	j = 0;
    315          
    316          	for(uint8_t i=2;i<81;i+=2)
    317          	{
    318          	  pBuffer[i]=0;
    319          	  pBuffer[i+1]=start_ramp[72-j-1] + rampsSettings->gainFactor2;
    320          
    321          	  j+=1;
    322          	}
    323          
    324          	pBuffer[0] = 0x00;
    325          	pBuffer[1] = 0xFF;
    326          	break;
    327              }
    328            case FIFO_RAMP_UP_2:
    329              {
    330          	*pBufferSize = 66;
    331          
    332          	for(uint8_t i=0;i<46;i++)
    333          	{
    334          	  if(i < 10)
    335          	    start_ramp[i] = 1;
    336          	  if(i > 9 && i < 18)
    337          	    start_ramp[i] = 2;
    338          	  if(i > 17 && i < 25)
    339          	    start_ramp[i] = 3;
    340          	  if(i > 24 && i < 31)
    341          	    start_ramp[i] = 4;
    342          	  if(i > 30 && i < 36)
    343          	    start_ramp[i] = 5;
    344          	  if(i > 35 && i < 41)
    345          	    start_ramp[i] = 6;
    346          	  if(i > 40 && i < 45)
    347          	    start_ramp[i] = 7;
    348          	}
    349          
    350          	memcpy(start_ramp + 45, start_ramp_tail, 27*sizeof(uint8_t));
    351          
    352          	/* Scale start_ramp values */
    353          	for(uint8_t i=0;i<72;i++)
    354          	  start_ramp[i] = start_ramp[i] + rampsSettings->gainFactor1;
    355          
    356          	j = 40;
    357          
    358          	for(uint8_t i=2;i<65;i+=2)
    359          	{
    360          	  pBuffer[i]=0;
    361          	  pBuffer[i+1]=start_ramp[72-j-1] + rampsSettings->gainFactor2;
    362          
    363          	  j+=1;
    364          	}
    365          
    366          	pBuffer[0] = 0x00;
   \       0xF2   0x2100             MOVS     R1,#+0
   \       0xF4   0x7001             STRB     R1,[R0, #+0]
    367          	pBuffer[1] = 0xFF;
   \       0xF6   0x21FF             MOVS     R1,#+255
   \       0xF8   0x7041             STRB     R1,[R0, #+1]
    368          	break;
    369              }
    370            }
    371          }
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_3: (+1)
   \       0xFA   0xB023             ADD      SP,SP,#+140
   \       0xFC   0xBDF0             POP      {R4-R7,PC}       ;; return
   \       0xFE   0xBF00             Nop
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_1:
   \      0x100   0x....'....        DC32     ?_0
   \      0x104   0x....'....        DC32     ?_1
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_10: (+1)
   \      0x108   0x9821             LDR      R0,[SP, #+132]
   \      0x10A   0x7003             STRB     R3,[R0, #+0]
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0x9A00             LDR      R2,[SP, #+0]
   \      0x110   0x7010             STRB     R0,[R2, #+0]
   \      0x112   0x21FF             MOVS     R1,#+255
   \      0x114   0x9A00             LDR      R2,[SP, #+0]
   \      0x116   0x7051             STRB     R1,[R2, #+1]
   \      0x118   0x9900             LDR      R1,[SP, #+0]
   \      0x11A   0x9A22             LDR      R2,[SP, #+136]
   \      0x11C   0x1C4C             ADDS     R4,R1,#+1
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_11: (+1)
   \      0x11E   0x5588             STRB     R0,[R1, R6]
   \      0x120   0x7913             LDRB     R3,[R2, #+4]
   \      0x122   0x55A3             STRB     R3,[R4, R6]
   \      0x124   0x1CB6             ADDS     R6,R6,#+2
   \      0x126   0x2E51             CMP      R6,#+81
   \      0x128   0xDCE7             BGT      ??priv_ST_MANUF_generateFIFORampsBuffer_3
   \      0x12A   0xE7F8             B        ??priv_ST_MANUF_generateFIFORampsBuffer_11
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_12: (+1)
   \      0x12C   0x9D21             LDR      R5,[SP, #+132]
   \      0x12E   0x702B             STRB     R3,[R5, #+0]
   \      0x130   0x2300             MOVS     R3,#+0
   \      0x132   0xE001             B        ??priv_ST_MANUF_generateFIFORampsBuffer_13
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_14: (+1)
   \      0x134   0x2B09             CMP      R3,#+9
   \      0x136   0xDC01             BGT      ??priv_ST_MANUF_generateFIFORampsBuffer_15
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_13: (+1)
   \      0x138   0x2501             MOVS     R5,#+1
   \      0x13A   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_15: (+1)
   \      0x13C   0x001D             MOVS     R5,R3
   \      0x13E   0x3D0A             SUBS     R5,R5,#+10
   \      0x140   0x2D07             CMP      R5,#+7
   \      0x142   0xD800             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_16
   \      0x144   0x54E6             STRB     R6,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_16: (+1)
   \      0x146   0x001D             MOVS     R5,R3
   \      0x148   0x3D12             SUBS     R5,R5,#+18
   \      0x14A   0x2D06             CMP      R5,#+6
   \      0x14C   0xD800             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_17
   \      0x14E   0x54E0             STRB     R0,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_17: (+1)
   \      0x150   0x001D             MOVS     R5,R3
   \      0x152   0x3D19             SUBS     R5,R5,#+25
   \      0x154   0x2D05             CMP      R5,#+5
   \      0x156   0xD801             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_18
   \      0x158   0x2504             MOVS     R5,#+4
   \      0x15A   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_18: (+1)
   \      0x15C   0x001D             MOVS     R5,R3
   \      0x15E   0x3D1F             SUBS     R5,R5,#+31
   \      0x160   0x2D05             CMP      R5,#+5
   \      0x162   0xD200             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_19
   \      0x164   0x54E2             STRB     R2,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_19: (+1)
   \      0x166   0x001D             MOVS     R5,R3
   \      0x168   0x3D24             SUBS     R5,R5,#+36
   \      0x16A   0x2D05             CMP      R5,#+5
   \      0x16C   0xD201             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_20
   \      0x16E   0x2506             MOVS     R5,#+6
   \      0x170   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_20: (+1)
   \      0x172   0x001D             MOVS     R5,R3
   \      0x174   0x3D29             SUBS     R5,R5,#+41
   \      0x176   0x2D04             CMP      R5,#+4
   \      0x178   0xD200             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_21
   \      0x17A   0x54E1             STRB     R1,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_21: (+1)
   \      0x17C   0x1C5B             ADDS     R3,R3,#+1
   \      0x17E   0x2B2D             CMP      R3,#+45
   \      0x180   0xDDD8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_14
   \      0x182   0x221B             MOVS     R2,#+27
   \      0x184   0xA919             ADD      R1,SP,#+100
   \      0x186   0x0020             MOVS     R0,R4
   \      0x188   0x302D             ADDS     R0,R0,#+45
   \      0x18A   0x....'....        BL       __aeabi_memcpy
   \      0x18E   0x2200             MOVS     R2,#+0
   \      0x190   0x2100             MOVS     R1,#+0
   \      0x192   0x9822             LDR      R0,[SP, #+136]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_22: (+1)
   \      0x194   0x5C63             LDRB     R3,[R4, R1]
   \      0x196   0x7945             LDRB     R5,[R0, #+5]
   \      0x198   0x195B             ADDS     R3,R3,R5
   \      0x19A   0x5463             STRB     R3,[R4, R1]
   \      0x19C   0x1C49             ADDS     R1,R1,#+1
   \      0x19E   0x2947             CMP      R1,#+71
   \      0x1A0   0xDDF8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_22
   \      0x1A2   0x9900             LDR      R1,[SP, #+0]
   \      0x1A4   0x1C4D             ADDS     R5,R1,#+1
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_23: (+1)
   \      0x1A6   0x558A             STRB     R2,[R1, R6]
   \      0x1A8   0x7903             LDRB     R3,[R0, #+4]
   \      0x1AA   0x55AB             STRB     R3,[R5, R6]
   \      0x1AC   0x1CB6             ADDS     R6,R6,#+2
   \      0x1AE   0x2E11             CMP      R6,#+17
   \      0x1B0   0xDDF9             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_23
   \      0x1B2   0x2300             MOVS     R3,#+0
   \      0x1B4   0x2500             MOVS     R5,#+0
   \      0x1B6   0x9100             STR      R1,[SP, #+0]
   \      0x1B8   0x9906             LDR      R1,[SP, #+24]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_24: (+1)
   \      0x1BA   0x9A00             LDR      R2,[SP, #+0]
   \      0x1BC   0x426E             RSBS     R6,R5,#+0
   \      0x1BE   0x1992             ADDS     R2,R2,R6
   \      0x1C0   0x3250             ADDS     R2,R2,#+80
   \      0x1C2   0xB2CE             UXTB     R6,R1
   \      0x1C4   0x4277             RSBS     R7,R6,#+0
   \      0x1C6   0x19E6             ADDS     R6,R4,R7
   \      0x1C8   0x7FF6             LDRB     R6,[R6, #+31]
   \      0x1CA   0x7987             LDRB     R7,[R0, #+6]
   \      0x1CC   0x19F6             ADDS     R6,R6,R7
   \      0x1CE   0x7056             STRB     R6,[R2, #+1]
   \      0x1D0   0x7013             STRB     R3,[R2, #+0]
   \      0x1D2   0x1C49             ADDS     R1,R1,#+1
   \      0x1D4   0x1CAD             ADDS     R5,R5,#+2
   \      0x1D6   0x2D40             CMP      R5,#+64
   \      0x1D8   0xDA8A             BGE      ??priv_ST_MANUF_generateFIFORampsBuffer_9
   \      0x1DA   0xE7EE             B        ??priv_ST_MANUF_generateFIFORampsBuffer_24
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_25: (+1)
   \      0x1DC   0x9D21             LDR      R5,[SP, #+132]
   \      0x1DE   0x702B             STRB     R3,[R5, #+0]
   \      0x1E0   0x2500             MOVS     R5,#+0
   \      0x1E2   0x2300             MOVS     R3,#+0
   \      0x1E4   0xE001             B        ??priv_ST_MANUF_generateFIFORampsBuffer_26
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_27: (+1)
   \      0x1E6   0x2B09             CMP      R3,#+9
   \      0x1E8   0xDC01             BGT      ??priv_ST_MANUF_generateFIFORampsBuffer_28
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_26: (+1)
   \      0x1EA   0x2701             MOVS     R7,#+1
   \      0x1EC   0x54E7             STRB     R7,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_28: (+1)
   \      0x1EE   0x001F             MOVS     R7,R3
   \      0x1F0   0x3F0A             SUBS     R7,R7,#+10
   \      0x1F2   0x2F07             CMP      R7,#+7
   \      0x1F4   0xD800             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_29
   \      0x1F6   0x54E6             STRB     R6,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_29: (+1)
   \      0x1F8   0x001F             MOVS     R7,R3
   \      0x1FA   0x3F12             SUBS     R7,R7,#+18
   \      0x1FC   0x2F06             CMP      R7,#+6
   \      0x1FE   0xD800             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_30
   \      0x200   0x54E0             STRB     R0,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_30: (+1)
   \      0x202   0x001F             MOVS     R7,R3
   \      0x204   0x3F19             SUBS     R7,R7,#+25
   \      0x206   0x2F05             CMP      R7,#+5
   \      0x208   0xD801             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_31
   \      0x20A   0x2704             MOVS     R7,#+4
   \      0x20C   0x54E7             STRB     R7,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_31: (+1)
   \      0x20E   0x001F             MOVS     R7,R3
   \      0x210   0x3F1F             SUBS     R7,R7,#+31
   \      0x212   0x2F05             CMP      R7,#+5
   \      0x214   0xD200             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_32
   \      0x216   0x54E2             STRB     R2,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_32: (+1)
   \      0x218   0x001F             MOVS     R7,R3
   \      0x21A   0x3F24             SUBS     R7,R7,#+36
   \      0x21C   0x2F05             CMP      R7,#+5
   \      0x21E   0xD201             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_33
   \      0x220   0x2706             MOVS     R7,#+6
   \      0x222   0x54E7             STRB     R7,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_33: (+1)
   \      0x224   0x001F             MOVS     R7,R3
   \      0x226   0x3F29             SUBS     R7,R7,#+41
   \      0x228   0x2F04             CMP      R7,#+4
   \      0x22A   0xD200             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_34
   \      0x22C   0x54E1             STRB     R1,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_34: (+1)
   \      0x22E   0x1C5B             ADDS     R3,R3,#+1
   \      0x230   0x2B2D             CMP      R3,#+45
   \      0x232   0xDDD8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_27
   \      0x234   0x221B             MOVS     R2,#+27
   \      0x236   0xA919             ADD      R1,SP,#+100
   \      0x238   0x0020             MOVS     R0,R4
   \      0x23A   0x302D             ADDS     R0,R0,#+45
   \      0x23C   0x....'....        BL       __aeabi_memcpy
   \      0x240   0x2000             MOVS     R0,#+0
   \      0x242   0x9E22             LDR      R6,[SP, #+136]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_35: (+1)
   \      0x244   0x5C21             LDRB     R1,[R4, R0]
   \      0x246   0x7972             LDRB     R2,[R6, #+5]
   \      0x248   0x1889             ADDS     R1,R1,R2
   \      0x24A   0x5421             STRB     R1,[R4, R0]
   \      0x24C   0x1C40             ADDS     R0,R0,#+1
   \      0x24E   0x2847             CMP      R0,#+71
   \      0x250   0xDDF8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_35
   \      0x252   0x9900             LDR      R1,[SP, #+0]
   \      0x254   0x700D             STRB     R5,[R1, #+0]
   \      0x256   0x20FF             MOVS     R0,#+255
   \      0x258   0x9900             LDR      R1,[SP, #+0]
   \      0x25A   0x7048             STRB     R0,[R1, #+1]
   \      0x25C   0x2700             MOVS     R7,#+0
   \      0x25E   0x9806             LDR      R0,[SP, #+24]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_36: (+1)
   \      0x260   0x9900             LDR      R1,[SP, #+0]
   \      0x262   0x427A             RSBS     R2,R7,#+0
   \      0x264   0x1889             ADDS     R1,R1,R2
   \      0x266   0x3150             ADDS     R1,R1,#+80
   \      0x268   0x0022             MOVS     R2,R4
   \      0x26A   0x3247             ADDS     R2,R2,#+71
   \      0x26C   0x4694             MOV      R12,R2
   \      0x26E   0xB2C2             UXTB     R2,R0
   \      0x270   0x4253             RSBS     R3,R2,#+0
   \      0x272   0x4662             MOV      R2,R12
   \      0x274   0x5CD2             LDRB     R2,[R2, R3]
   \      0x276   0x79B3             LDRB     R3,[R6, #+6]
   \      0x278   0x18D2             ADDS     R2,R2,R3
   \      0x27A   0x704A             STRB     R2,[R1, #+1]
   \      0x27C   0x700D             STRB     R5,[R1, #+0]
   \      0x27E   0x1C40             ADDS     R0,R0,#+1
   \      0x280   0x1CBF             ADDS     R7,R7,#+2
   \      0x282   0x2F50             CMP      R7,#+80
   \      0x284   0xDB00             BLT      .+4
   \      0x286   0xE738             B        ??priv_ST_MANUF_generateFIFORampsBuffer_3
   \      0x288   0xE7EA             B        ??priv_ST_MANUF_generateFIFORampsBuffer_36
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_37: (+1)
   \      0x28A   0x9D21             LDR      R5,[SP, #+132]
   \      0x28C   0x702B             STRB     R3,[R5, #+0]
   \      0x28E   0x2300             MOVS     R3,#+0
   \      0x290   0xE001             B        ??priv_ST_MANUF_generateFIFORampsBuffer_38
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_39: (+1)
   \      0x292   0x2B09             CMP      R3,#+9
   \      0x294   0xDC01             BGT      ??priv_ST_MANUF_generateFIFORampsBuffer_40
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_38: (+1)
   \      0x296   0x2501             MOVS     R5,#+1
   \      0x298   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_40: (+1)
   \      0x29A   0x001D             MOVS     R5,R3
   \      0x29C   0x3D0A             SUBS     R5,R5,#+10
   \      0x29E   0x2D07             CMP      R5,#+7
   \      0x2A0   0xD800             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_41
   \      0x2A2   0x54E6             STRB     R6,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_41: (+1)
   \      0x2A4   0x001D             MOVS     R5,R3
   \      0x2A6   0x3D12             SUBS     R5,R5,#+18
   \      0x2A8   0x2D06             CMP      R5,#+6
   \      0x2AA   0xD800             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_42
   \      0x2AC   0x54E0             STRB     R0,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_42: (+1)
   \      0x2AE   0x001D             MOVS     R5,R3
   \      0x2B0   0x3D19             SUBS     R5,R5,#+25
   \      0x2B2   0x2D05             CMP      R5,#+5
   \      0x2B4   0xD801             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_43
   \      0x2B6   0x2504             MOVS     R5,#+4
   \      0x2B8   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_43: (+1)
   \      0x2BA   0x001D             MOVS     R5,R3
   \      0x2BC   0x3D1F             SUBS     R5,R5,#+31
   \      0x2BE   0x2D05             CMP      R5,#+5
   \      0x2C0   0xD200             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_44
   \      0x2C2   0x54E2             STRB     R2,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_44: (+1)
   \      0x2C4   0x001D             MOVS     R5,R3
   \      0x2C6   0x3D24             SUBS     R5,R5,#+36
   \      0x2C8   0x2D05             CMP      R5,#+5
   \      0x2CA   0xD201             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_45
   \      0x2CC   0x2506             MOVS     R5,#+6
   \      0x2CE   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_45: (+1)
   \      0x2D0   0x001D             MOVS     R5,R3
   \      0x2D2   0x3D29             SUBS     R5,R5,#+41
   \      0x2D4   0x2D04             CMP      R5,#+4
   \      0x2D6   0xD200             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_46
   \      0x2D8   0x54E1             STRB     R1,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_46: (+1)
   \      0x2DA   0x1C5B             ADDS     R3,R3,#+1
   \      0x2DC   0x2B2D             CMP      R3,#+45
   \      0x2DE   0xDDD8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_39
   \      0x2E0   0x221B             MOVS     R2,#+27
   \      0x2E2   0xA919             ADD      R1,SP,#+100
   \      0x2E4   0x0020             MOVS     R0,R4
   \      0x2E6   0x302D             ADDS     R0,R0,#+45
   \      0x2E8   0x....'....        BL       __aeabi_memcpy
   \      0x2EC   0x2200             MOVS     R2,#+0
   \      0x2EE   0x2100             MOVS     R1,#+0
   \      0x2F0   0x9822             LDR      R0,[SP, #+136]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_47: (+1)
   \      0x2F2   0x5C63             LDRB     R3,[R4, R1]
   \      0x2F4   0x7945             LDRB     R5,[R0, #+5]
   \      0x2F6   0x195B             ADDS     R3,R3,R5
   \      0x2F8   0x5463             STRB     R3,[R4, R1]
   \      0x2FA   0x1C49             ADDS     R1,R1,#+1
   \      0x2FC   0x2947             CMP      R1,#+71
   \      0x2FE   0xDDF8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_47
   \      0x300   0x9906             LDR      R1,[SP, #+24]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_48: (+1)
   \      0x302   0x9D00             LDR      R5,[SP, #+0]
   \      0x304   0x55AA             STRB     R2,[R5, R6]
   \      0x306   0x0023             MOVS     R3,R4
   \      0x308   0x3347             ADDS     R3,R3,#+71
   \      0x30A   0xB2CD             UXTB     R5,R1
   \      0x30C   0x426F             RSBS     R7,R5,#+0
   \      0x30E   0x5DDB             LDRB     R3,[R3, R7]
   \      0x310   0x7985             LDRB     R5,[R0, #+6]
   \      0x312   0x195B             ADDS     R3,R3,R5
   \      0x314   0x9D00             LDR      R5,[SP, #+0]
   \      0x316   0x1C6D             ADDS     R5,R5,#+1
   \      0x318   0x55AB             STRB     R3,[R5, R6]
   \      0x31A   0x1C49             ADDS     R1,R1,#+1
   \      0x31C   0x1CB6             ADDS     R6,R6,#+2
   \      0x31E   0x2E50             CMP      R6,#+80
   \      0x320   0xDC4D             BGT      ??priv_ST_MANUF_generateFIFORampsBuffer_49
   \      0x322   0xE7EE             B        ??priv_ST_MANUF_generateFIFORampsBuffer_48
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_50: (+1)
   \      0x324   0x2342             MOVS     R3,#+66
   \      0x326   0x9D21             LDR      R5,[SP, #+132]
   \      0x328   0x702B             STRB     R3,[R5, #+0]
   \      0x32A   0x2300             MOVS     R3,#+0
   \      0x32C   0xE001             B        ??priv_ST_MANUF_generateFIFORampsBuffer_51
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_52: (+1)
   \      0x32E   0x2B09             CMP      R3,#+9
   \      0x330   0xDC01             BGT      ??priv_ST_MANUF_generateFIFORampsBuffer_53
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_51: (+1)
   \      0x332   0x2501             MOVS     R5,#+1
   \      0x334   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_53: (+1)
   \      0x336   0x001D             MOVS     R5,R3
   \      0x338   0x3D0A             SUBS     R5,R5,#+10
   \      0x33A   0x2D07             CMP      R5,#+7
   \      0x33C   0xD800             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_54
   \      0x33E   0x54E6             STRB     R6,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_54: (+1)
   \      0x340   0x001D             MOVS     R5,R3
   \      0x342   0x3D12             SUBS     R5,R5,#+18
   \      0x344   0x2D06             CMP      R5,#+6
   \      0x346   0xD800             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_55
   \      0x348   0x54E0             STRB     R0,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_55: (+1)
   \      0x34A   0x001D             MOVS     R5,R3
   \      0x34C   0x3D19             SUBS     R5,R5,#+25
   \      0x34E   0x2D05             CMP      R5,#+5
   \      0x350   0xD801             BHI      ??priv_ST_MANUF_generateFIFORampsBuffer_56
   \      0x352   0x2504             MOVS     R5,#+4
   \      0x354   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_56: (+1)
   \      0x356   0x001D             MOVS     R5,R3
   \      0x358   0x3D1F             SUBS     R5,R5,#+31
   \      0x35A   0x2D05             CMP      R5,#+5
   \      0x35C   0xD200             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_57
   \      0x35E   0x54E2             STRB     R2,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_57: (+1)
   \      0x360   0x001D             MOVS     R5,R3
   \      0x362   0x3D24             SUBS     R5,R5,#+36
   \      0x364   0x2D05             CMP      R5,#+5
   \      0x366   0xD201             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_58
   \      0x368   0x2506             MOVS     R5,#+6
   \      0x36A   0x54E5             STRB     R5,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_58: (+1)
   \      0x36C   0x001D             MOVS     R5,R3
   \      0x36E   0x3D29             SUBS     R5,R5,#+41
   \      0x370   0x2D04             CMP      R5,#+4
   \      0x372   0xD200             BCS      ??priv_ST_MANUF_generateFIFORampsBuffer_59
   \      0x374   0x54E1             STRB     R1,[R4, R3]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_59: (+1)
   \      0x376   0x1C5B             ADDS     R3,R3,#+1
   \      0x378   0x2B2D             CMP      R3,#+45
   \      0x37A   0xDDD8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_52
   \      0x37C   0x221B             MOVS     R2,#+27
   \      0x37E   0xA919             ADD      R1,SP,#+100
   \      0x380   0x0020             MOVS     R0,R4
   \      0x382   0x302D             ADDS     R0,R0,#+45
   \      0x384   0x....'....        BL       __aeabi_memcpy
   \      0x388   0x2100             MOVS     R1,#+0
   \      0x38A   0x2200             MOVS     R2,#+0
   \      0x38C   0x9822             LDR      R0,[SP, #+136]
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_60: (+1)
   \      0x38E   0x5CA3             LDRB     R3,[R4, R2]
   \      0x390   0x7945             LDRB     R5,[R0, #+5]
   \      0x392   0x195B             ADDS     R3,R3,R5
   \      0x394   0x54A3             STRB     R3,[R4, R2]
   \      0x396   0x1C52             ADDS     R2,R2,#+1
   \      0x398   0x2A47             CMP      R2,#+71
   \      0x39A   0xDDF8             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_60
   \      0x39C   0x2228             MOVS     R2,#+40
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_61: (+1)
   \      0x39E   0x9D00             LDR      R5,[SP, #+0]
   \      0x3A0   0x55A9             STRB     R1,[R5, R6]
   \      0x3A2   0x0023             MOVS     R3,R4
   \      0x3A4   0x3347             ADDS     R3,R3,#+71
   \      0x3A6   0xB2D5             UXTB     R5,R2
   \      0x3A8   0x426F             RSBS     R7,R5,#+0
   \      0x3AA   0x5DDB             LDRB     R3,[R3, R7]
   \      0x3AC   0x7985             LDRB     R5,[R0, #+6]
   \      0x3AE   0x195B             ADDS     R3,R3,R5
   \      0x3B0   0x9D00             LDR      R5,[SP, #+0]
   \      0x3B2   0x1C6D             ADDS     R5,R5,#+1
   \      0x3B4   0x55AB             STRB     R3,[R5, R6]
   \      0x3B6   0x1C52             ADDS     R2,R2,#+1
   \      0x3B8   0x1CB6             ADDS     R6,R6,#+2
   \      0x3BA   0x2E40             CMP      R6,#+64
   \      0x3BC   0xDDEF             BLE      ??priv_ST_MANUF_generateFIFORampsBuffer_61
   \                     ??priv_ST_MANUF_generateFIFORampsBuffer_49: (+1)
   \      0x3BE   0xE697             B        ??priv_ST_MANUF_generateFIFORampsBuffer_9
    372          
    373          /* get XTAL frequency function */

   \                                 In section .text, align 2, keep-with-next
    374          static uint32_t privGetXtalFrequency(void)
    375          {
    376            return st_manuf_context->priv_xtal_freq;
   \                     privGetXtalFrequency: (+1)
   \        0x0   0x....             LDR      R0,??DataTable7
   \        0x2   0x6980             LDR      R0,[R0, #+24]
   \        0x4   0x4770             BX       LR               ;; return
    377          }
    378          
    379          static void priv_ST_MANUF_tx_rf_init(void)
    380          {
    381            uint8_t tmp;
    382          
    383            /* TX in direct via FIFO mode */
    384            tmp=0x04;
    385            priv_ST_MANUF_WriteRegisters(0x30, 1, &tmp);
    386          
    387            tmp=0x07;
    388            priv_ST_MANUF_WriteRegisters(0x62, 1, &tmp);
    389          
    390            /* disable NEWMODE */
    391            priv_ST_MANUF_ReadRegisters(0x63, 1, &tmp);
    392            tmp&=0xFD;
    393            priv_ST_MANUF_WriteRegisters(0x63, 1, &tmp);
    394          
    395            tmp=0xD7;
    396            priv_ST_MANUF_WriteRegisters(0x65, 1, &tmp);
    397          
    398            /* SMPS switch to 3MHz - ref. Datasheet page 23*/
    399            tmp=0x87;
    400            priv_ST_MANUF_WriteRegisters(0x76, 1, &tmp);
    401          
    402            tmp=0xFC;
    403            priv_ST_MANUF_WriteRegisters(0x77, 1, &tmp);
    404          
    405            tmp=0xC8;
    406            priv_ST_MANUF_WriteRegisters(0x64, 1, &tmp);
    407          
    408          #ifdef MON_REF_DES
    409            if (st_manuf_context->pa_flag == 0)
    410              st_manuf_context->smps_mode=7;
    411          #endif
    412          
    413            //Set the SMPS only for values from 1 to 7 (1.8V)
    414            if(st_manuf_context->smps_mode>0 && st_manuf_context->smps_mode<8)
    415            {
    416              /* (16dBm setting, SMPS to 1.8V -> smps_mode=7) */
    417              tmp=(st_manuf_context->smps_mode<<4)|0x02;
    418              priv_ST_MANUF_WriteRegisters(0x79, 1, &tmp);
    419          
    420              if(st_manuf_context->smps_mode>4)
    421              {
    422          	tmp=0x88;
    423          	priv_ST_MANUF_WriteRegisters(0x64, 1, &tmp);
    424              }
    425            }
    426          
    427            /* FIFO AE threshold to 48 bytes */
    428            tmp=48;
    429            priv_ST_MANUF_WriteRegisters(0x3F,1,&tmp);
    430          
    431            st_manuf_context->tx_is_ready=1;
    432          }
    433          

   \                                 In section .text, align 2, keep-with-next
    434          static void priv_ST_MANUF_Get_Ramps_Settings(ramps_settings_t *rSettings)
    435          {
   \                     priv_ST_MANUF_Get_Ramps_Settings: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    436            rSettings->gainFactor1 = 0x00;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x7160             STRB     R0,[R4, #+5]
    437            rSettings->gainFactor2 = 0x00;
   \        0x8   0x71A0             STRB     R0,[R4, #+6]
    438          
    439            rSettings->fdev_pos = 0x7f;
   \        0xA   0x207F             MOVS     R0,#+127
   \        0xC   0x7060             STRB     R0,[R4, #+1]
    440            rSettings->fdev_neg = 0x81;
   \        0xE   0x2081             MOVS     R0,#+129
   \       0x10   0x7020             STRB     R0,[R4, #+0]
    441            rSettings->min_power = 220;
   \       0x12   0x20DC             MOVS     R0,#+220
   \       0x14   0x70E0             STRB     R0,[R4, #+3]
    442          
    443            rSettings->ramp_start_duration = 3;
   \       0x16   0x2003             MOVS     R0,#+3
   \       0x18   0x70A0             STRB     R0,[R4, #+2]
    444          
    445            RangeExtType femType = S2LPManagementGetRangeExtender();
    446          
    447            switch(femType)
   \       0x1A   0x....'....        BL       S2LPManagementGetRangeExtender
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD00C             BEQ      ??priv_ST_MANUF_Get_Ramps_Settings_0
   \       0x22   0x2802             CMP      R0,#+2
   \       0x24   0xD002             BEQ      ??priv_ST_MANUF_Get_Ramps_Settings_1
   \       0x26   0x2803             CMP      R0,#+3
   \       0x28   0xD004             BEQ      ??priv_ST_MANUF_Get_Ramps_Settings_2
   \       0x2A   0xBD10             POP      {R4,PC}
    448            {
    449            case RANGE_EXT_NONE:
    450              rSettings->ramp_start_duration = 18;
    451              rSettings->max_power = 1;
    452              break;
    453            case RANGE_EXT_SKYWORKS_SE2435L:
    454              rSettings->gainFactor1 = 0x22;
   \                     ??priv_ST_MANUF_Get_Ramps_Settings_1: (+1)
   \       0x2C   0x2022             MOVS     R0,#+34
   \       0x2E   0x7160             STRB     R0,[R4, #+5]
    455              rSettings->max_power = 35;
   \       0x30   0x2023             MOVS     R0,#+35
   \       0x32   0xE00C             B        ??priv_ST_MANUF_Get_Ramps_Settings_3
    456              break;
    457            case RANGE_EXT_SKYWORKS_SKY66420:
    458              if (st_manuf_context->pa_flag == 0)
   \                     ??priv_ST_MANUF_Get_Ramps_Settings_2: (+1)
   \       0x34   0x....             LDR      R0,??DataTable7
   \       0x36   0x7F80             LDRB     R0,[R0, #+30]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD103             BNE      ??priv_ST_MANUF_Get_Ramps_Settings_4
    459              {
    460                rSettings->ramp_start_duration = 18;
   \                     ??priv_ST_MANUF_Get_Ramps_Settings_0: (+1)
   \       0x3C   0x2012             MOVS     R0,#+18
   \       0x3E   0x70A0             STRB     R0,[R4, #+2]
    461                rSettings->max_power = 1;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xE004             B        ??priv_ST_MANUF_Get_Ramps_Settings_3
    462              }
    463              else
    464              {
    465                rSettings->gainFactor1 = 0x04;
   \                     ??priv_ST_MANUF_Get_Ramps_Settings_4: (+1)
   \       0x44   0x2004             MOVS     R0,#+4
   \       0x46   0x7160             STRB     R0,[R4, #+5]
    466                rSettings->gainFactor2 = 0x02;
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0x71A0             STRB     R0,[R4, #+6]
    467                rSettings->max_power = 5;
   \       0x4C   0x2005             MOVS     R0,#+5
   \                     ??priv_ST_MANUF_Get_Ramps_Settings_3: (+1)
   \       0x4E   0x7120             STRB     R0,[R4, #+4]
    468              }
    469          
    470              break;
    471            }
    472          }
   \       0x50   0xBD10             POP      {R4,PC}          ;; return
    473          
    474          /* radio configuration for TX and RX */

   \                                 In section .text, align 2, keep-with-next
    475          static void priv_ST_MANUF_tx_rf_dbpsk_init(sfx_modulation_type_t type)
    476          {
   \                     priv_ST_MANUF_tx_rf_dbpsk_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x0007             MOVS     R7,R0
    477            uint32_t f_dig = privGetXtalFrequency();
   \        0x6   0x....'....        BL       privGetXtalFrequency
   \        0xA   0x0006             MOVS     R6,R0
    478            uint16_t dr_m;
    479            uint8_t mod_e,fdev_e,fdev_m;
    480            uint8_t regs[3];
    481          
    482            if(f_dig>DIG_DOMAIN_XTAL_THRESH) {
   \        0xC   0x....             LDR      R0,??DataTable8  ;; 0x1c9c381
   \        0xE   0x4286             CMP      R6,R0
   \       0x10   0xD300             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_0
    483              f_dig >>= 1;
   \       0x12   0x0876             LSRS     R6,R6,#+1
    484            }
    485          
    486            if(type==SFX_DBPSK_100BPS)
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_0: (+1)
   \       0x14   0x2F01             CMP      R7,#+1
   \       0x16   0xD000             BEQ      .+4
   \       0x18   0xE08C             B        ??priv_ST_MANUF_tx_rf_dbpsk_init_1
    487            {
    488              /* ETSI datarate is 100bps - chip datarate 500 (500*8/40=100) */
    489          
    490              /* modulation is POLAR | DR EXPONENT = 1 */
    491              mod_e=0x60|0x01;
   \       0x1A   0x2061             MOVS     R0,#+97
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x7608             STRB     R0,[R1, #+24]
    492              /* dr_num=(2**32)*500 */
    493              dr_m=(uint16_t)((uint64_t)0x1f400000000/f_dig-65536);
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x21FA             MOVS     R1,#+250
   \       0x24   0x0049             LSLS     R1,R1,#+1        ;; #+500
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x....'....        BL       __aeabi_uldivmod
   \       0x2E   0xB284             UXTH     R4,R0
    494          
    495              /* understand if we are getting the nearest integer */
    496              uint64_t tgt1,tgt2;
    497              tgt1=(uint64_t)f_dig*((uint64_t)dr_m+65536);
    498              tgt2=(uint64_t)f_dig*((uint64_t)dr_m+1+65536);
    499              dr_m=((uint64_t)0x1f400000000-tgt1>tgt2-(uint64_t)0x1f400000000)?(dr_m+1):(dr_m);
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x....             LDR      R2,??DataTable8_1  ;; 0x10001
   \       0x34   0x2300             MOVS     R3,#+0
   \       0x36   0x1912             ADDS     R2,R2,R4
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x....'....        BL       __aeabi_lmul
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x....             LDR      R3,??DataTable8_2  ;; 0xfffffe0c
   \       0x42   0x1812             ADDS     R2,R2,R0
   \       0x44   0x414B             ADCS     R3,R3,R1
   \       0x46   0x9202             STR      R2,[SP, #+8]
   \       0x48   0x9303             STR      R3,[SP, #+12]
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x21FA             MOVS     R1,#+250
   \       0x4E   0x0049             LSLS     R1,R1,#+1        ;; #+500
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x9101             STR      R1,[SP, #+4]
   \       0x54   0x0030             MOVS     R0,R6
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x2280             MOVS     R2,#+128
   \       0x5A   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \       0x5C   0x2300             MOVS     R3,#+0
   \       0x5E   0x1912             ADDS     R2,R2,R4
   \       0x60   0x....'....        BL       __aeabi_lmul
   \       0x64   0x9A00             LDR      R2,[SP, #+0]
   \       0x66   0x9B01             LDR      R3,[SP, #+4]
   \       0x68   0x1A12             SUBS     R2,R2,R0
   \       0x6A   0x418B             SBCS     R3,R3,R1
   \       0x6C   0x9802             LDR      R0,[SP, #+8]
   \       0x6E   0x9903             LDR      R1,[SP, #+12]
   \       0x70   0x4299             CMP      R1,R3
   \       0x72   0xD803             BHI      ??priv_ST_MANUF_tx_rf_dbpsk_init_2
   \       0x74   0xD301             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_3
   \       0x76   0x4290             CMP      R0,R2
   \       0x78   0xD200             BCS      ??priv_ST_MANUF_tx_rf_dbpsk_init_2
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_3: (+1)
   \       0x7A   0x1C64             ADDS     R4,R4,#+1
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_2: (+1)
   \       0x7C   0x9404             STR      R4,[SP, #+16]
    500          
    501              if(privGetXtalFrequency()>DIG_DOMAIN_XTAL_THRESH)
   \       0x7E   0x26F4             MOVS     R6,#+244
   \       0x80   0x0636             LSLS     R6,R6,#+24       ;; #-201326592
   \       0x82   0x....'....        BL       privGetXtalFrequency
   \       0x86   0x....             LDR      R1,??DataTable8  ;; 0x1c9c381
   \       0x88   0x4288             CMP      R0,R1
   \       0x8A   0xD326             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_4
    502              {
    503              	fdev_e=0;
   \       0x8C   0x2500             MOVS     R5,#+0
    504              	/* fdev_num=((2**22)*2000) */
    505              	fdev_m=(uint8_t)((uint64_t)8388608000/privGetXtalFrequency());
   \       0x8E   0x....'....        BL       privGetXtalFrequency
   \       0x92   0x0002             MOVS     R2,R0
   \       0x94   0x2300             MOVS     R3,#+0
   \       0x96   0x0030             MOVS     R0,R6
   \       0x98   0x2101             MOVS     R1,#+1
   \       0x9A   0x....'....        BL       __aeabi_uldivmod
   \       0x9E   0x0004             MOVS     R4,R0
    506              	/* understand if we are getting the nearest integer */
    507              	uint64_t tgt1,tgt2;
    508              	tgt1=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m);
   \       0xA0   0x....'....        BL       privGetXtalFrequency
   \       0xA4   0x0006             MOVS     R6,R0
    509              	tgt2=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+1);
    510              	fdev_m=((uint64_t)8388608000-tgt1>tgt2-(uint64_t)8388608000)?(fdev_m+1):(fdev_m);
   \       0xA6   0x....'....        BL       privGetXtalFrequency
   \       0xAA   0x2100             MOVS     R1,#+0
   \       0xAC   0xB2E2             UXTB     R2,R4
   \       0xAE   0x2300             MOVS     R3,#+0
   \       0xB0   0x1C52             ADDS     R2,R2,#+1
   \       0xB2   0x....'....        BL       __aeabi_lmul
   \       0xB6   0x22C0             MOVS     R2,#+192
   \       0xB8   0x0512             LSLS     R2,R2,#+20       ;; #+201326592
   \       0xBA   0x2301             MOVS     R3,#+1
   \       0xBC   0x43DB             MVNS     R3,R3            ;; #-2
   \       0xBE   0x1812             ADDS     R2,R2,R0
   \       0xC0   0x414B             ADCS     R3,R3,R1
   \       0xC2   0x9202             STR      R2,[SP, #+8]
   \       0xC4   0x9303             STR      R3,[SP, #+12]
   \       0xC6   0x20F4             MOVS     R0,#+244
   \       0xC8   0x0600             LSLS     R0,R0,#+24       ;; #-201326592
   \       0xCA   0x2101             MOVS     R1,#+1
   \       0xCC   0x9000             STR      R0,[SP, #+0]
   \       0xCE   0x9101             STR      R1,[SP, #+4]
   \       0xD0   0x0030             MOVS     R0,R6
   \       0xD2   0x2100             MOVS     R1,#+0
   \       0xD4   0xB2E2             UXTB     R2,R4
   \       0xD6   0x2300             MOVS     R3,#+0
   \       0xD8   0xE12B             B        ??priv_ST_MANUF_tx_rf_dbpsk_init_5
    511              }
    512              else
    513              {
    514              	fdev_e=1;
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_4: (+1)
   \       0xDA   0x2501             MOVS     R5,#+1
    515              	fdev_m=(uint8_t)((uint64_t)8388608000/privGetXtalFrequency()-256);
   \       0xDC   0x....'....        BL       privGetXtalFrequency
   \       0xE0   0x0002             MOVS     R2,R0
   \       0xE2   0x2300             MOVS     R3,#+0
   \       0xE4   0x0030             MOVS     R0,R6
   \       0xE6   0x2101             MOVS     R1,#+1
   \       0xE8   0x....'....        BL       __aeabi_uldivmod
   \       0xEC   0x0004             MOVS     R4,R0
    516              	/* understand if we are getting the nearest integer */
    517              	uint64_t tgt1,tgt2;
    518              	tgt1=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+256);
   \       0xEE   0x....'....        BL       privGetXtalFrequency
   \       0xF2   0x0006             MOVS     R6,R0
    519              	tgt2=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+1+256);
    520              	fdev_m=((uint64_t)8388608000-tgt1>tgt2-(uint64_t)8388608000)?(fdev_m+1):(fdev_m);
   \       0xF4   0x....'....        BL       privGetXtalFrequency
   \       0xF8   0x2100             MOVS     R1,#+0
   \       0xFA   0x9000             STR      R0,[SP, #+0]
   \       0xFC   0x9101             STR      R1,[SP, #+4]
   \       0xFE   0xB2E0             UXTB     R0,R4
   \      0x100   0x22FF             MOVS     R2,#+255
   \      0x102   0x1C92             ADDS     R2,R2,#+2        ;; #+257
   \      0x104   0x2300             MOVS     R3,#+0
   \      0x106   0x1812             ADDS     R2,R2,R0
   \      0x108   0x9800             LDR      R0,[SP, #+0]
   \      0x10A   0x....'....        BL       __aeabi_lmul
   \      0x10E   0x22C0             MOVS     R2,#+192
   \      0x110   0x0512             LSLS     R2,R2,#+20       ;; #+201326592
   \      0x112   0x2301             MOVS     R3,#+1
   \      0x114   0x43DB             MVNS     R3,R3            ;; #-2
   \      0x116   0x1812             ADDS     R2,R2,R0
   \      0x118   0x414B             ADCS     R3,R3,R1
   \      0x11A   0x9202             STR      R2,[SP, #+8]
   \      0x11C   0x9303             STR      R3,[SP, #+12]
   \      0x11E   0x20F4             MOVS     R0,#+244
   \      0x120   0x0600             LSLS     R0,R0,#+24       ;; #-201326592
   \      0x122   0x9000             STR      R0,[SP, #+0]
   \      0x124   0x9501             STR      R5,[SP, #+4]
   \      0x126   0x2100             MOVS     R1,#+0
   \      0x128   0xB2E0             UXTB     R0,R4
   \      0x12A   0x022A             LSLS     R2,R5,#+8
   \      0x12C   0x2300             MOVS     R3,#+0
   \      0x12E   0x1812             ADDS     R2,R2,R0
   \      0x130   0x0030             MOVS     R0,R6
   \      0x132   0xE0FE             B        ??priv_ST_MANUF_tx_rf_dbpsk_init_5
    521              }
    522            }
    523            else if(type==SFX_DBPSK_600BPS)
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_1: (+1)
   \      0x134   0x2F02             CMP      R7,#+2
   \      0x136   0xD000             BEQ      .+4
   \      0x138   0xE109             B        ??priv_ST_MANUF_tx_rf_dbpsk_init_6
    524            {
    525              /* FCC datarate is 600bps - chip datarate 3000 (3000*8/40=600) */
    526              if (f_dig>24500000) //To consider also a margin used to compensate static drifts
   \      0x13A   0x....             LDR      R5,??DataTable11  ;; 0x175d721
   \      0x13C   0x42AE             CMP      R6,R5
   \      0x13E   0xD329             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_7
    527              {
    528                /* modulation is POLAR | DR EXPONENT = 3 for xtal > 24 MHz */
    529                mod_e=0x60|0x03;
   \      0x140   0x2063             MOVS     R0,#+99
   \      0x142   0x4669             MOV      R1,SP
   \      0x144   0x7608             STRB     R0,[R1, #+24]
    530                /* dr_num=(2**30)*3000 */
    531                dr_m=(uint16_t)((uint64_t)0x2EE00000000/f_dig-65536);
   \      0x146   0x2000             MOVS     R0,#+0
   \      0x148   0x....             LDR      R1,??DataTable11_1  ;; 0x2ee
   \      0x14A   0x0032             MOVS     R2,R6
   \      0x14C   0x2300             MOVS     R3,#+0
   \      0x14E   0x....'....        BL       __aeabi_uldivmod
   \      0x152   0xB284             UXTH     R4,R0
    532                /* understand if we are getting the nearest integer */
    533                uint64_t tgt1,tgt2;
    534                tgt1=(uint64_t)f_dig*((uint64_t)dr_m+65536);
    535                tgt2=(uint64_t)f_dig*((uint64_t)dr_m+1+65536);
    536                dr_m=((uint64_t)0x2EE00000000-tgt1>tgt2-(uint64_t)0x2EE00000000)?(dr_m+1):(dr_m);
   \      0x154   0x2100             MOVS     R1,#+0
   \      0x156   0x....             LDR      R2,??DataTable8_1  ;; 0x10001
   \      0x158   0x2300             MOVS     R3,#+0
   \      0x15A   0x1912             ADDS     R2,R2,R4
   \      0x15C   0x0030             MOVS     R0,R6
   \      0x15E   0x....'....        BL       __aeabi_lmul
   \      0x162   0x2200             MOVS     R2,#+0
   \      0x164   0x....             LDR      R3,??DataTable11_2  ;; 0xfffffd12
   \      0x166   0x1812             ADDS     R2,R2,R0
   \      0x168   0x414B             ADCS     R3,R3,R1
   \      0x16A   0x9202             STR      R2,[SP, #+8]
   \      0x16C   0x9303             STR      R3,[SP, #+12]
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0x....             LDR      R1,??DataTable11_1  ;; 0x2ee
   \      0x172   0x9000             STR      R0,[SP, #+0]
   \      0x174   0x9101             STR      R1,[SP, #+4]
   \      0x176   0x2100             MOVS     R1,#+0
   \      0x178   0x2280             MOVS     R2,#+128
   \      0x17A   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \      0x17C   0x2300             MOVS     R3,#+0
   \      0x17E   0x1912             ADDS     R2,R2,R4
   \      0x180   0x0030             MOVS     R0,R6
   \      0x182   0x....'....        BL       __aeabi_lmul
   \      0x186   0x9A00             LDR      R2,[SP, #+0]
   \      0x188   0x9B01             LDR      R3,[SP, #+4]
   \      0x18A   0x1A12             SUBS     R2,R2,R0
   \      0x18C   0x418B             SBCS     R3,R3,R1
   \      0x18E   0x9802             LDR      R0,[SP, #+8]
   \      0x190   0x9903             LDR      R1,[SP, #+12]
   \      0x192   0xE02B             B        ??priv_ST_MANUF_tx_rf_dbpsk_init_8
    537              }
    538              else
    539              {
    540                /* modulation is POLAR | DR EXPONENT = 4 for xtal=24 MHz */
    541                mod_e=0x60|0x04;
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_7: (+1)
   \      0x194   0x2064             MOVS     R0,#+100
   \      0x196   0x4669             MOV      R1,SP
   \      0x198   0x7608             STRB     R0,[R1, #+24]
    542                /* dr_num=(2**30)*3000 */
    543                dr_m=(uint16_t)((uint64_t)0x17700000000/f_dig-65536);
   \      0x19A   0x2700             MOVS     R7,#+0
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0x21FF             MOVS     R1,#+255
   \      0x1A0   0x3178             ADDS     R1,R1,#+120      ;; #+375
   \      0x1A2   0x0032             MOVS     R2,R6
   \      0x1A4   0x2300             MOVS     R3,#+0
   \      0x1A6   0x....'....        BL       __aeabi_uldivmod
   \      0x1AA   0xB284             UXTH     R4,R0
    544                /* understand if we are getting the nearest integer */
    545                uint64_t tgt1,tgt2;
    546                tgt1=(uint64_t)f_dig*((uint64_t)dr_m+65536);
    547                tgt2=(uint64_t)f_dig*((uint64_t)dr_m+1+65536);
    548                dr_m=((uint64_t)0x17700000000-tgt1>tgt2-(uint64_t)0x17700000000)?(dr_m+1):(dr_m);
   \      0x1AC   0x2100             MOVS     R1,#+0
   \      0x1AE   0x....             LDR      R2,??DataTable8_1  ;; 0x10001
   \      0x1B0   0x2300             MOVS     R3,#+0
   \      0x1B2   0x1912             ADDS     R2,R2,R4
   \      0x1B4   0x0030             MOVS     R0,R6
   \      0x1B6   0x....'....        BL       __aeabi_lmul
   \      0x1BA   0x....             LDR      R3,??DataTable11_3  ;; 0xfffffe89
   \      0x1BC   0x183A             ADDS     R2,R7,R0
   \      0x1BE   0x414B             ADCS     R3,R3,R1
   \      0x1C0   0x9204             STR      R2,[SP, #+16]
   \      0x1C2   0x9305             STR      R3,[SP, #+20]
   \      0x1C4   0x21FF             MOVS     R1,#+255
   \      0x1C6   0x3178             ADDS     R1,R1,#+120      ;; #+375
   \      0x1C8   0x9702             STR      R7,[SP, #+8]
   \      0x1CA   0x9103             STR      R1,[SP, #+12]
   \      0x1CC   0x9600             STR      R6,[SP, #+0]
   \      0x1CE   0x9701             STR      R7,[SP, #+4]
   \      0x1D0   0x2280             MOVS     R2,#+128
   \      0x1D2   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \      0x1D4   0x2300             MOVS     R3,#+0
   \      0x1D6   0x1912             ADDS     R2,R2,R4
   \      0x1D8   0x9800             LDR      R0,[SP, #+0]
   \      0x1DA   0x2100             MOVS     R1,#+0
   \      0x1DC   0x....'....        BL       __aeabi_lmul
   \      0x1E0   0x9A02             LDR      R2,[SP, #+8]
   \      0x1E2   0x9B03             LDR      R3,[SP, #+12]
   \      0x1E4   0x1A12             SUBS     R2,R2,R0
   \      0x1E6   0x418B             SBCS     R3,R3,R1
   \      0x1E8   0x9804             LDR      R0,[SP, #+16]
   \      0x1EA   0x9905             LDR      R1,[SP, #+20]
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_8: (+1)
   \      0x1EC   0x4299             CMP      R1,R3
   \      0x1EE   0xD803             BHI      ??priv_ST_MANUF_tx_rf_dbpsk_init_9
   \      0x1F0   0xD301             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_10
   \      0x1F2   0x4290             CMP      R0,R2
   \      0x1F4   0xD200             BCS      ??priv_ST_MANUF_tx_rf_dbpsk_init_9
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_10: (+1)
   \      0x1F6   0x1C64             ADDS     R4,R4,#+1
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_9: (+1)
   \      0x1F8   0x9404             STR      R4,[SP, #+16]
    549              }
    550          
    551              if(privGetXtalFrequency()>DIG_DOMAIN_XTAL_THRESH)
   \      0x1FA   0x....'....        BL       privGetXtalFrequency
   \      0x1FE   0x....             LDR      R1,??DataTable8  ;; 0x1c9c381
   \      0x200   0x4288             CMP      R0,R1
   \      0x202   0xD337             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_11
    552              {
    553          	if(privGetXtalFrequency()<48500000) //To consider also a margin used to compensate static drifts
   \      0x204   0x....'....        BL       privGetXtalFrequency
   \      0x208   0x....             LDR      R1,??DataTable11_4  ;; 0x2e40d20
   \      0x20A   0x4288             CMP      R0,R1
   \      0x20C   0xD334             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_12
    554          	{
    555          	  fdev_e=3;
    556          	  fdev_m=(uint8_t)((uint64_t)12582912000/privGetXtalFrequency()-256);
    557          	  /* understand if we are getting the nearest integer */
    558          	  uint64_t tgt1,tgt2;
    559          	  tgt1=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+256);
    560          	  tgt2=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+1+256);
    561          	  fdev_m=((uint64_t)12582912000-tgt1>tgt2-(uint64_t)12582912000)?(fdev_m+1):(fdev_m);
    562          	}
    563          	else
    564          	{
    565          	  fdev_e=2;
   \      0x20E   0x2502             MOVS     R5,#+2
    566          	  fdev_m=(uint8_t)((uint64_t)25165824000/privGetXtalFrequency()-256);
   \      0x210   0x....'....        BL       privGetXtalFrequency
   \      0x214   0x0002             MOVS     R2,R0
   \      0x216   0x2300             MOVS     R3,#+0
   \      0x218   0x20DC             MOVS     R0,#+220
   \      0x21A   0x0600             LSLS     R0,R0,#+24       ;; #-603979776
   \      0x21C   0x2105             MOVS     R1,#+5
   \      0x21E   0x....'....        BL       __aeabi_uldivmod
   \      0x222   0x0004             MOVS     R4,R0
    567          	  /* understand if we are getting the nearest integer */
    568          	  uint64_t tgt1,tgt2;
    569          	  tgt1=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+256);
   \      0x224   0x....'....        BL       privGetXtalFrequency
   \      0x228   0x0006             MOVS     R6,R0
    570          	  tgt2=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+1+256);
    571          	  fdev_m=((uint64_t)25165824000-tgt1>tgt2-(uint64_t)25165824000)?(fdev_m+1):(fdev_m);
   \      0x22A   0x....'....        BL       privGetXtalFrequency
   \      0x22E   0x2100             MOVS     R1,#+0
   \      0x230   0x9000             STR      R0,[SP, #+0]
   \      0x232   0x9101             STR      R1,[SP, #+4]
   \      0x234   0xB2E0             UXTB     R0,R4
   \      0x236   0x22FF             MOVS     R2,#+255
   \      0x238   0x1C92             ADDS     R2,R2,#+2        ;; #+257
   \      0x23A   0x2300             MOVS     R3,#+0
   \      0x23C   0x1812             ADDS     R2,R2,R0
   \      0x23E   0x9800             LDR      R0,[SP, #+0]
   \      0x240   0x....'....        BL       __aeabi_lmul
   \      0x244   0x2290             MOVS     R2,#+144
   \      0x246   0x0592             LSLS     R2,R2,#+22       ;; #+603979776
   \      0x248   0x2305             MOVS     R3,#+5
   \      0x24A   0x43DB             MVNS     R3,R3            ;; #-6
   \      0x24C   0x1812             ADDS     R2,R2,R0
   \      0x24E   0x414B             ADCS     R3,R3,R1
   \      0x250   0x9202             STR      R2,[SP, #+8]
   \      0x252   0x9303             STR      R3,[SP, #+12]
   \      0x254   0x20DC             MOVS     R0,#+220
   \      0x256   0x0600             LSLS     R0,R0,#+24       ;; #-603979776
   \      0x258   0x2105             MOVS     R1,#+5
   \      0x25A   0x9000             STR      R0,[SP, #+0]
   \      0x25C   0x9101             STR      R1,[SP, #+4]
   \      0x25E   0x2100             MOVS     R1,#+0
   \      0x260   0xB2E0             UXTB     R0,R4
   \      0x262   0x01EA             LSLS     R2,R5,#+7
   \      0x264   0x2300             MOVS     R3,#+0
   \      0x266   0x1812             ADDS     R2,R2,R0
   \      0x268   0x0030             MOVS     R0,R6
   \      0x26A   0x....'....        BL       __aeabi_lmul
   \      0x26E   0x9A00             LDR      R2,[SP, #+0]
   \      0x270   0x2305             MOVS     R3,#+5
   \      0x272   0xE062             B        ??priv_ST_MANUF_tx_rf_dbpsk_init_13
    572          	}
    573              }
    574              else
    575              {
    576                if (f_dig>24500000) //To consider also a margin used to compensate static drifts
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_11: (+1)
   \      0x274   0x42AE             CMP      R6,R5
   \      0x276   0xD333             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_14
    577                {
    578                	fdev_e=3;
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_12: (+1)
   \      0x278   0x2503             MOVS     R5,#+3
    579                	fdev_m=(uint8_t)((uint64_t)12582912000/privGetXtalFrequency()-256);
   \      0x27A   0x....'....        BL       privGetXtalFrequency
   \      0x27E   0x0002             MOVS     R2,R0
   \      0x280   0x2300             MOVS     R3,#+0
   \      0x282   0x20EE             MOVS     R0,#+238
   \      0x284   0x0600             LSLS     R0,R0,#+24       ;; #-301989888
   \      0x286   0x2102             MOVS     R1,#+2
   \      0x288   0x....'....        BL       __aeabi_uldivmod
   \      0x28C   0x0004             MOVS     R4,R0
    580                	/* understand if we are getting the nearest integer */
    581                	uint64_t tgt1,tgt2;
    582                	tgt1=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+256);
   \      0x28E   0x....'....        BL       privGetXtalFrequency
   \      0x292   0x0006             MOVS     R6,R0
    583                	tgt2=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+1+256);
    584                	fdev_m=((uint64_t)12582912000-tgt1>tgt2-(uint64_t)12582912000)?(fdev_m+1):(fdev_m);
   \      0x294   0x....'....        BL       privGetXtalFrequency
   \      0x298   0x2100             MOVS     R1,#+0
   \      0x29A   0x9000             STR      R0,[SP, #+0]
   \      0x29C   0x9101             STR      R1,[SP, #+4]
   \      0x29E   0xB2E0             UXTB     R0,R4
   \      0x2A0   0x22FF             MOVS     R2,#+255
   \      0x2A2   0x1C92             ADDS     R2,R2,#+2        ;; #+257
   \      0x2A4   0x2300             MOVS     R3,#+0
   \      0x2A6   0x1812             ADDS     R2,R2,R0
   \      0x2A8   0x9800             LDR      R0,[SP, #+0]
   \      0x2AA   0x....'....        BL       __aeabi_lmul
   \      0x2AE   0x2290             MOVS     R2,#+144
   \      0x2B0   0x0552             LSLS     R2,R2,#+21       ;; #+301989888
   \      0x2B2   0x2302             MOVS     R3,#+2
   \      0x2B4   0x43DB             MVNS     R3,R3            ;; #-3
   \      0x2B6   0x1812             ADDS     R2,R2,R0
   \      0x2B8   0x414B             ADCS     R3,R3,R1
   \      0x2BA   0x9202             STR      R2,[SP, #+8]
   \      0x2BC   0x9303             STR      R3,[SP, #+12]
   \      0x2BE   0x20EE             MOVS     R0,#+238
   \      0x2C0   0x0600             LSLS     R0,R0,#+24       ;; #-301989888
   \      0x2C2   0x2102             MOVS     R1,#+2
   \      0x2C4   0x9000             STR      R0,[SP, #+0]
   \      0x2C6   0x9101             STR      R1,[SP, #+4]
   \      0x2C8   0x2100             MOVS     R1,#+0
   \      0x2CA   0xB2E0             UXTB     R0,R4
   \      0x2CC   0x2280             MOVS     R2,#+128
   \      0x2CE   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \      0x2D0   0x2300             MOVS     R3,#+0
   \      0x2D2   0x1812             ADDS     R2,R2,R0
   \      0x2D4   0x0030             MOVS     R0,R6
   \      0x2D6   0x....'....        BL       __aeabi_lmul
   \      0x2DA   0x9A00             LDR      R2,[SP, #+0]
   \      0x2DC   0x2302             MOVS     R3,#+2
   \      0x2DE   0xE02C             B        ??priv_ST_MANUF_tx_rf_dbpsk_init_13
    585                }
    586                else
    587                {
    588                  fdev_e=4;
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_14: (+1)
   \      0x2E0   0x2504             MOVS     R5,#+4
    589                  fdev_m=(uint8_t)((uint64_t)6291456000/privGetXtalFrequency()-256);
   \      0x2E2   0x....'....        BL       privGetXtalFrequency
   \      0x2E6   0x0002             MOVS     R2,R0
   \      0x2E8   0x2300             MOVS     R3,#+0
   \      0x2EA   0x20EE             MOVS     R0,#+238
   \      0x2EC   0x05C0             LSLS     R0,R0,#+23       ;; #+1996488704
   \      0x2EE   0x2101             MOVS     R1,#+1
   \      0x2F0   0x....'....        BL       __aeabi_uldivmod
   \      0x2F4   0x0004             MOVS     R4,R0
    590                  /* understand if we are getting the nearest integer */
    591                  uint64_t tgt1,tgt2;
    592                  tgt1=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+256);
   \      0x2F6   0x....             LDR      R0,??DataTable11_5
   \      0x2F8   0x6981             LDR      R1,[R0, #+24]
   \      0x2FA   0x9105             STR      R1,[SP, #+20]
    593                  tgt2=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+1+256);
    594                  fdev_m=((uint64_t)6291456000-tgt1>tgt2-(uint64_t)6291456000)?(fdev_m+1):(fdev_m);
   \      0x2FC   0xB2E6             UXTB     R6,R4
   \      0x2FE   0x6980             LDR      R0,[R0, #+24]
   \      0x300   0x2100             MOVS     R1,#+0
   \      0x302   0x22FF             MOVS     R2,#+255
   \      0x304   0x1C92             ADDS     R2,R2,#+2        ;; #+257
   \      0x306   0x2300             MOVS     R3,#+0
   \      0x308   0x1992             ADDS     R2,R2,R6
   \      0x30A   0x....'....        BL       __aeabi_lmul
   \      0x30E   0x2289             MOVS     R2,#+137
   \      0x310   0x0612             LSLS     R2,R2,#+24       ;; #-1996488704
   \      0x312   0x2301             MOVS     R3,#+1
   \      0x314   0x43DB             MVNS     R3,R3            ;; #-2
   \      0x316   0x1812             ADDS     R2,R2,R0
   \      0x318   0x414B             ADCS     R3,R3,R1
   \      0x31A   0x9202             STR      R2,[SP, #+8]
   \      0x31C   0x9303             STR      R3,[SP, #+12]
   \      0x31E   0x20EE             MOVS     R0,#+238
   \      0x320   0x05C0             LSLS     R0,R0,#+23       ;; #+1996488704
   \      0x322   0x2101             MOVS     R1,#+1
   \      0x324   0x9000             STR      R0,[SP, #+0]
   \      0x326   0x9101             STR      R1,[SP, #+4]
   \      0x328   0x9805             LDR      R0,[SP, #+20]
   \      0x32A   0x2100             MOVS     R1,#+0
   \      0x32C   0x01AA             LSLS     R2,R5,#+6
   \      0x32E   0x2300             MOVS     R3,#+0
   \      0x330   0x1992             ADDS     R2,R2,R6
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_5: (+1)
   \      0x332   0x....'....        BL       __aeabi_lmul
   \      0x336   0x9A00             LDR      R2,[SP, #+0]
   \      0x338   0x2301             MOVS     R3,#+1
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_13: (+1)
   \      0x33A   0x1A12             SUBS     R2,R2,R0
   \      0x33C   0x418B             SBCS     R3,R3,R1
   \      0x33E   0x9802             LDR      R0,[SP, #+8]
   \      0x340   0x9903             LDR      R1,[SP, #+12]
   \      0x342   0x4299             CMP      R1,R3
   \      0x344   0xD803             BHI      ??priv_ST_MANUF_tx_rf_dbpsk_init_6
   \      0x346   0xD301             BCC      ??priv_ST_MANUF_tx_rf_dbpsk_init_15
   \      0x348   0x4290             CMP      R0,R2
   \      0x34A   0xD200             BCS      ??priv_ST_MANUF_tx_rf_dbpsk_init_6
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_15: (+1)
   \      0x34C   0x1C64             ADDS     R4,R4,#+1
    595                }
    596              }
    597            }
    598          
    599            /* write DATARATE mantissa and exponent */
    600            regs[0]=(dr_m>>8)&0xFF;
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_init_6: (+1)
   \      0x34E   0xAE07             ADD      R6,SP,#+28
   \      0x350   0x9804             LDR      R0,[SP, #+16]
   \      0x352   0x0400             LSLS     R0,R0,#+16
   \      0x354   0x0E00             LSRS     R0,R0,#+24
   \      0x356   0x7030             STRB     R0,[R6, #+0]
    601            regs[1]=(dr_m)&0xFF;
   \      0x358   0x9804             LDR      R0,[SP, #+16]
   \      0x35A   0x7070             STRB     R0,[R6, #+1]
    602            regs[2]=mod_e;
   \      0x35C   0x4668             MOV      R0,SP
   \      0x35E   0x7E00             LDRB     R0,[R0, #+24]
   \      0x360   0x70B0             STRB     R0,[R6, #+2]
    603            priv_ST_MANUF_WriteRegisters(0x0E,3,regs);
   \      0x362   0xAA07             ADD      R2,SP,#+28
   \      0x364   0x2103             MOVS     R1,#+3
   \      0x366   0x200E             MOVS     R0,#+14
   \      0x368   0x....'....        BL       priv_ST_MANUF_WriteRegisters
    604          
    605            /* write FDEV mantissa and exponent */
    606            /* here the exponent is in | with 0x80 to enable the digital smooth of the ramps */
    607            regs[0]=fdev_e|0x80;
   \      0x36C   0x2080             MOVS     R0,#+128
   \      0x36E   0x4328             ORRS     R0,R0,R5
   \      0x370   0x7030             STRB     R0,[R6, #+0]
    608            regs[1]=fdev_m;
   \      0x372   0x7074             STRB     R4,[R6, #+1]
    609            priv_ST_MANUF_WriteRegisters(0x11,2,regs);
   \      0x374   0xAA07             ADD      R2,SP,#+28
   \      0x376   0x2102             MOVS     R1,#+2
   \      0x378   0x2011             MOVS     R0,#+17
   \      0x37A   0x....'....        BL       priv_ST_MANUF_WriteRegisters
    610          
    611            priv_ST_MANUF_Get_Ramps_Settings(&st_manuf_context->ramps_settings);
   \      0x37E   0x....             LDR      R0,??DataTable11_6
   \      0x380   0x....'....        BL       priv_ST_MANUF_Get_Ramps_Settings
    612          }
   \      0x384   0xB009             ADD      SP,SP,#+36
   \      0x386   0xBDF0             POP      {R4-R7,PC}       ;; return
    613          
    614          /* Function to generate PN9 */

   \                                 In section .text, align 2, keep-with-next
    615          void pn9_next(uint16_t *last)
    616          {
    617            uint16_t retval;
    618            retval =  (((*last & 0x20) >> 5) ^ *last) << 8;
    619            retval |= (*last >> 1) & 0xff;
    620            *last = retval & 0x1ff;
   \                     pn9_next: (+1)
   \        0x0   0x8801             LDRH     R1,[R0, #+0]
   \        0x2   0x060A             LSLS     R2,R1,#+24
   \        0x4   0x0F52             LSRS     R2,R2,#+29
   \        0x6   0x404A             EORS     R2,R2,R1
   \        0x8   0x0212             LSLS     R2,R2,#+8
   \        0xA   0x05C9             LSLS     R1,R1,#+23
   \        0xC   0x0E09             LSRS     R1,R1,#+24
   \        0xE   0x4311             ORRS     R1,R1,R2
   \       0x10   0x05C9             LSLS     R1,R1,#+23
   \       0x12   0x0DC9             LSRS     R1,R1,#+23
   \       0x14   0x8001             STRH     R1,[R0, #+0]
    621          }
   \       0x16   0x4770             BX       LR               ;; return
    622          

   \                                 In section .text, align 2, keep-with-next
    623          uint16_t pn9_next_byte(uint16_t state)
    624          {
   \                     pn9_next_byte: (+1)
   \        0x0   0xB511             PUSH     {R0,R4,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
    625            int i;
    626            for (i=0; i<8; i++) {
   \        0x4   0x2408             MOVS     R4,#+8
    627              pn9_next(&state);
   \                     ??pn9_next_byte_0: (+1)
   \        0x6   0xA801             ADD      R0,SP,#+4
   \        0x8   0x....'....        BL       pn9_next
    628            }
   \        0xC   0x1E64             SUBS     R4,R4,#+1
   \        0xE   0xD1FA             BNE      ??pn9_next_byte_0
    629            return state;
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x8880             LDRH     R0,[R0, #+4]
   \       0x14   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    630          }
    631          
    632          /* Function to transmit a single bit */

   \                                 In section .text, align 2, keep-with-next
    633          static void priv_ST_MANUF_tx_rf_dbpsk_single_bit(uint8_t bit)
    634          {
   \                     priv_ST_MANUF_tx_rf_dbpsk_single_bit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    635            if(bit==0)
   \        0x2   0x....             LDR      R5,??DataTable11_5
   \        0x4   0x002F             MOVS     R7,R5
   \        0x6   0x3794             ADDS     R7,R7,#+148
   \        0x8   0x002E             MOVS     R6,R5
   \        0xA   0x368A             ADDS     R6,R6,#+138
   \        0xC   0x....             LDR      R4,??DataTable11_7
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD10E             BNE      ??priv_ST_MANUF_tx_rf_dbpsk_single_bit_0
    636            {
    637              /* Give FDEV a peak in the FDEV_PEAK position.
    638              This value should be the opposite of the last one. */
    639              priv_ST_MANUF_generateFIFORampsBuffer(FIFO_RAMP_FAST, &rampBuffer[0], &bfSize, &st_manuf_context->ramps_settings);
   \       0x12   0x0033             MOVS     R3,R6
   \       0x14   0x0022             MOVS     R2,R4
   \       0x16   0x0039             MOVS     R1,R7
   \       0x18   0x....'....        BL       priv_ST_MANUF_generateFIFORampsBuffer
    640              bSwap=(bSwap==st_manuf_context->ramps_settings.fdev_neg)?(st_manuf_context->ramps_settings.fdev_pos):(st_manuf_context->ramps_settings.fdev_neg);
   \       0x1C   0x7830             LDRB     R0,[R6, #+0]
   \       0x1E   0x7861             LDRB     R1,[R4, #+1]
   \       0x20   0x4281             CMP      R1,R0
   \       0x22   0xD100             BNE      ??priv_ST_MANUF_tx_rf_dbpsk_single_bit_1
   \       0x24   0x7870             LDRB     R0,[R6, #+1]
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_single_bit_1: (+1)
   \       0x26   0x7060             STRB     R0,[R4, #+1]
    641              rampBuffer[82-32]=bSwap;
   \       0x28   0x7860             LDRB     R0,[R4, #+1]
   \       0x2A   0x21C6             MOVS     R1,#+198
   \       0x2C   0x5468             STRB     R0,[R5, R1]
    642              priv_ST_MANUF_SpiRaw_Ramp(bfSize, rampBuffer, NULL, 1);
   \       0x2E   0xE005             B        ??priv_ST_MANUF_tx_rf_dbpsk_single_bit_2
    643            }
    644            else
    645            {
    646              /* If the bit to be transmitted is '1' --> proceed with a constant
    647              pattern that does not change the instantaneous frequency and keeps power constant to max.
    648              fifo_const_fast stores this one. */
    649              priv_ST_MANUF_generateFIFORampsBuffer(FIFO_CONST_FAST, &rampBuffer[0], &bfSize, &st_manuf_context->ramps_settings);
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_single_bit_0: (+1)
   \       0x30   0x0033             MOVS     R3,R6
   \       0x32   0x0022             MOVS     R2,R4
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x....'....        BL       priv_ST_MANUF_generateFIFORampsBuffer
    650              priv_ST_MANUF_SpiRaw_Ramp(bfSize, rampBuffer, NULL, 1);
   \                     ??priv_ST_MANUF_tx_rf_dbpsk_single_bit_2: (+1)
   \       0x3C   0x2301             MOVS     R3,#+1
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x0039             MOVS     R1,R7
   \       0x42   0x7820             LDRB     R0,[R4, #+0]
   \       0x44   0x....'....        BL       priv_ST_MANUF_SpiRaw_Ramp
    651            }
    652          }
   \       0x48   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    653          

   \                                 In section .text, align 2, keep-with-next
    654          st_fifo_state_t ST_RF_API_GetFIFOState(void){
    655            return _s2lpFIFOState;
   \                     ST_RF_API_GetFIFOState: (+1)
   \        0x0   0x....             LDR      R0,??DataTable11_7
   \        0x2   0x7880             LDRB     R0,[R0, #+2]
   \        0x4   0x4770             BX       LR               ;; return
    656          }
    657          
    658          /* Transmission state machine */
    659          static void priv_ST_MANUF_Transmission_Tick(void)
    660          {
    661            _s2lpFIFOState = ST_FIFO_STATE_FILLING;
    662          
    663            switch(st_manuf_context->tx_packet_struct.tx_state)
    664            {
    665              /*
    666              When the state machine is here means that we have loaded the very first part of the RAMP_UP
    667              and we need to load the second part (the values of this part is stored into the variable into the fifo_start_ramp_up_2)
    668              */
    669            case ST_TX_STATE_RAMP_UP_2:
    670              {
    671          	/* load the TX_FIFO */
    672          	priv_ST_MANUF_generateFIFORampsBuffer(FIFO_RAMP_UP_2, &rampBuffer[0], &bfSize, &st_manuf_context->ramps_settings);
    673          	priv_ST_MANUF_SpiRaw_Ramp(bfSize, rampBuffer, NULL, 1);
    674          	/* prepare the next state through the following operations: */
    675          
    676          	if (st_manuf_context->tx_packet_struct.continuous_tx_monarch_flag==1)
    677          	{
    678          	  /* -  starting from the most significative bit (bit 8) */
    679          	  st_manuf_context->tx_packet_struct.bit_index=8;
    680          	  /* -  set the tx_state to TX_STATE DATA to start to modulate the data bits the next time */
    681          	  st_manuf_context->tx_packet_struct.tx_state=ST_TX_CONTINUOS_BPSK;
    682          	}
    683          	else
    684          	{
    685          	  /* -  we will need to take the first byte (index 0 of the data array) */
    686          	  st_manuf_context->tx_packet_struct.byte_index=0;
    687          	  /* -  starting from the most significative bit (bit 7) */
    688          	  st_manuf_context->tx_packet_struct.bit_index=7;
    689          	  /* -  set the tx_state to TX_STATE DATA to start to modulate the data bits the next time */
    690          	  st_manuf_context->tx_packet_struct.tx_state=ST_TX_STATE_DATA;
    691          	}
    692              }
    693              break;
    694          
    695            case ST_TX_CONTINUOS_BPSK:
    696              {
    697          	uint8_t bit=(st_manuf_context->tx_packet_struct.current_pn9>>st_manuf_context->tx_packet_struct.bit_index) & 0x01;
    698          	priv_ST_MANUF_tx_rf_dbpsk_single_bit(bit);
    699          
    700          	if(st_manuf_context->tx_packet_struct.bit_index==0)
    701          	{
    702          	  /* if yes restore the bit "pointer" to the maximum */
    703          	  st_manuf_context->tx_packet_struct.bit_index=8;
    704          	  /*GENERATE NEXT pn9()*/
    705          	  st_manuf_context->tx_packet_struct.current_pn9 = pn9_next_byte(st_manuf_context->tx_packet_struct.current_pn9);
    706          	}
    707          
    708          	else st_manuf_context->tx_packet_struct.bit_index--;
    709          
    710              }
    711              break;
    712          
    713            case ST_TX_STATE_DATA:
    714              {
    715          
    716          	/* extract the bit to modulate from the array pointed by data_to_send */
    717          	uint8_t bit=(st_manuf_context->tx_packet_struct.data_to_send[st_manuf_context->tx_packet_struct.byte_index]>>st_manuf_context->tx_packet_struct.bit_index)&0x01;
    718          	/* the sigfox protocol says that a bit '0' should be represented by a phase inversion */
    719          
    720          	priv_ST_MANUF_tx_rf_dbpsk_single_bit(bit);
    721          
    722          	/* prepare the next data: first check if we need to change byte*/
    723          	if(st_manuf_context->tx_packet_struct.bit_index==0)
    724          	{
    725          	  /* if yes restore the bit "pointer" to the maximum */
    726          	  st_manuf_context->tx_packet_struct.bit_index=7;
    727          
    728          	  /* increase the byte pointer */
    729          	  st_manuf_context->tx_packet_struct.byte_index++;
    730          
    731          	  /* check if data is over */
    732          	  if(st_manuf_context->tx_packet_struct.byte_index==st_manuf_context->tx_packet_struct.data_to_send_size)
    733          	  {
    734          	    /* in this case move the state machine to the RAMP_DOWN_1 state
    735          	    so that the next time we will start to ramp down.*/
    736          	    st_manuf_context->tx_packet_struct.byte_index=0;
    737          	    st_manuf_context->tx_packet_struct.tx_state=ST_TX_STATE_RAMP_DOWN_1;
    738          	  }
    739          	}
    740          	else
    741          	{
    742          	  /* if we don't need to change byte just decrease the bit pointer to go to the next bit */
    743          	  st_manuf_context->tx_packet_struct.bit_index--;
    744          	}
    745              }
    746              break;
    747          
    748            case ST_TX_STATE_RAMP_DOWN_1:
    749              /* store the 1st part of the TX RAMP DOWN pattern */
    750              priv_ST_MANUF_generateFIFORampsBuffer(FIFO_RAMP_DOWN_1, &rampBuffer[0], &bfSize, &st_manuf_context->ramps_settings);
    751              priv_ST_MANUF_SpiRaw_Ramp(bfSize, rampBuffer, NULL, 1);
    752              /* move the state to store the second part */
    753              st_manuf_context->tx_packet_struct.tx_state=ST_TX_STATE_RAMP_DOWN_2;
    754              break;
    755          
    756            case ST_TX_STATE_RAMP_DOWN_2:
    757              /* store the 2nd part of the TX RAMP DOWN pattern */
    758              priv_ST_MANUF_generateFIFORampsBuffer(FIFO_RAMP_DOWN_2, &rampBuffer[0], &bfSize, &st_manuf_context->ramps_settings);
    759              priv_ST_MANUF_SpiRaw_Ramp(bfSize, rampBuffer, NULL, 1);
    760              /* move the state to store the third part... */
    761              st_manuf_context->tx_packet_struct.tx_state=ST_TX_STATE_RAMP_DOWN_3;
    762              break;
    763          
    764            case ST_TX_STATE_RAMP_DOWN_3:
    765              /* notice that the 3rd part of the ramp is just a sequence of zeroes used as a padding
    766              to wait the fifo_ramp_down_2 is over */
    767              priv_ST_MANUF_SpiRaw_Ramp(66, (uint8_t*)zeroes, NULL, 1);
    768          
    769              /* the next state will be TX_STATE_STOP to shut off the transmitter */
    770              st_manuf_context->tx_packet_struct.tx_state=ST_TX_STATE_STOP;
    771              break;
    772          
    773            case ST_TX_STATE_STOP:
    774          
    775              /* give the ABORT command to stop the transmitter */
    776              ST_RF_API_StopRxTx();
    777              /* give the FLUSH_TX command to flush the TX FIFO*/
    778              CMD_STROBE_FTX();
    779              /* disable the IRQ on the MCU side */
    780              ST_MCU_API_GpioIRQ(SFX_FALSE, SFX_TRUE);
    781              /* reset the SM state */
    782              st_manuf_context->tx_packet_struct.tx_state=ST_TX_STATE_NONE;
    783              /* notify to the MANUF_API_rf_send that we are done setting the s2lp_irq_raised flag */
    784              st_manuf_context->s2lp_irq_raised=1;
    785              break;
    786            }
    787          }
    788          
    789          /* Function used both for BPSK MOD and CONTINUOS BPSK */

   \                                 In section .text, align 2, keep-with-next
    790          static void priv_ST_MANUF_rf_load_first_ramp_up()
    791          {
   \                     priv_ST_MANUF_rf_load_first_ramp_up: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
    792            uint8_t tmp;
    793            /* TX FIFO flush */
    794            CMD_STROBE_FTX();
   \        0x2   0x2072             MOVS     R0,#+114
   \        0x4   0x....'....        BL       priv_ST_MANUF_CmdStrobe
    795          
    796            /* fill the 1st part of the FIFO */
    797            priv_ST_MANUF_SpiRaw_Ramp(18, (uint8_t*)zeroes, NULL,0);
   \        0x8   0x....             LDR      R4,??DataTable11_5
   \        0xA   0x2300             MOVS     R3,#+0
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x0021             MOVS     R1,R4
   \       0x10   0x31E8             ADDS     R1,R1,#+232
   \       0x12   0x2012             MOVS     R0,#+18
   \       0x14   0x....'....        BL       priv_ST_MANUF_SpiRaw_Ramp
    798            priv_ST_MANUF_generateFIFORampsBuffer(FIFO_RAMP_UP_1, &rampBuffer[0], &bfSize, &st_manuf_context->ramps_settings);
   \       0x18   0x0026             MOVS     R6,R4
   \       0x1A   0x3694             ADDS     R6,R6,#+148
   \       0x1C   0x....             LDR      R5,??DataTable11_7
   \       0x1E   0x0023             MOVS     R3,R4
   \       0x20   0x338A             ADDS     R3,R3,#+138
   \       0x22   0x002A             MOVS     R2,R5
   \       0x24   0x0031             MOVS     R1,R6
   \       0x26   0x2004             MOVS     R0,#+4
   \       0x28   0x....'....        BL       priv_ST_MANUF_generateFIFORampsBuffer
    799            priv_ST_MANUF_SpiRaw_Ramp(bfSize, rampBuffer, NULL, 0);
   \       0x2C   0x2300             MOVS     R3,#+0
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x0031             MOVS     R1,R6
   \       0x32   0x7828             LDRB     R0,[R5, #+0]
   \       0x34   0x....'....        BL       priv_ST_MANUF_SpiRaw_Ramp
    800          
    801            /* GPIO interrupt on S2-LP side */
    802            tmp=0x32;
   \       0x38   0x2032             MOVS     R0,#+50
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x7008             STRB     R0,[R1, #+0]
    803            priv_ST_MANUF_WriteRegisters(S2LP_GPIO_IRQ_PIN, 1, &tmp);
   \       0x3E   0x466A             MOV      R2,SP
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x2003             MOVS     R0,#+3
   \       0x44   0x....'....        BL       priv_ST_MANUF_WriteRegisters
    804          
    805            /* S2-LP IRQ on MCU side */
    806            ST_MCU_API_GpioIRQ(SFX_TRUE, SFX_TRUE);
   \       0x48   0x2101             MOVS     R1,#+1
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0x....'....        BL       ST_MCU_API_GpioIRQ
    807          
    808            /* manuf_state to TX */
    809            st_manuf_context->manuf_state=ST_MANUF_STATE_TX;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0x2124             MOVS     R1,#+36
   \       0x54   0x5460             STRB     R0,[R4, R1]
    810          
    811            /* next TX state is the 2nd part of the ramp-up */
    812            st_manuf_context->tx_packet_struct.tx_state=ST_TX_STATE_RAMP_UP_2;
   \       0x56   0x2002             MOVS     R0,#+2
   \       0x58   0x7020             STRB     R0,[R4, #+0]
    813          }
   \       0x5A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    814          
    815          static void priv_ST_MANUF_rf_modulation_dbpsk(uint8_t* stream, uint8_t size)
    816          {
    817            st_manuf_context->tx_packet_struct.continuous_tx_monarch_flag=0; //The transmission will be a packet and not PN9
    818          
    819            /* save the current pointer to data and size */
    820            st_manuf_context->tx_packet_struct.data_to_send=stream;
    821            st_manuf_context->tx_packet_struct.data_to_send_size=size;
    822          
    823            //SET GPIO to receive interrupt and Send first ramp in the FIFO
    824            priv_ST_MANUF_rf_load_first_ramp_up();
    825            /* give the TX command: from now on the device will start to transmit */
    826            ST_RF_API_StartTx();
    827            /* use the s2lp_irq_raised flag to understand when the function should return.
    828            All the FIFO management will be done into the priv_ST_MANUF_Transmission_Tick (generated by the ST_MANUF_S2LP_Exti_CB() fcn)*/
    829            st_manuf_context->s2lp_irq_raised=0;
    830            while(!st_manuf_context->s2lp_irq_raised){
    831              ST_MCU_API_WaitForInterrupt();
    832            }
    833            /* if we are here, we have finished the transmission */
    834            st_manuf_context->s2lp_irq_raised=0;
    835          
    836            /* reset the manuf_state to IDLE */
    837            st_manuf_context->manuf_state=ST_MANUF_STATE_IDLE;
    838          }
    839          
    840          static void priv_ST_MANUF_rx_rf_init(void)
    841          {
    842            uint64_t tgt1,tgt2;
    843            uint32_t f_dig=privGetXtalFrequency();
    844            uint16_t dr_m;
    845            uint8_t mod_e,fdev_e,fdev_m,tmp;
    846            uint8_t regs[3];
    847            /* packet setting registers */
    848            uint8_t pckt_setting[]={0,0,0,0,15};
    849          
    850            if(f_dig>DIG_DOMAIN_XTAL_THRESH) {
    851              f_dig >>= 1;
    852            }
    853          
    854            /* modulation is 2GFSK01 @600bps| DR EXPONENT = 1 */
    855            mod_e=0x20|0x01;
    856            /* dr_num=(2**32)*600 */
    857            dr_m=(uint16_t)((uint64_t)0x25800000000/f_dig-65536);
    858            /* understand if we are getting the nearest integer */
    859            tgt1=(uint64_t)f_dig*((uint64_t)dr_m+65536);
    860            tgt2=(uint64_t)f_dig*((uint64_t)dr_m+1+65536);
    861            dr_m=((uint64_t)0x25800000000-tgt1>tgt2-(uint64_t)0x25800000000)?(dr_m+1):(dr_m);
    862          
    863            fdev_e=0;
    864            /* fdev_num=((2**22)*800) - FDEV=800Hz */
    865            fdev_m=(uint8_t)((uint64_t)3355443200/privGetXtalFrequency());
    866            /* understand if we are getting the nearest integer */
    867            tgt1=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m);
    868            tgt2=(uint64_t)privGetXtalFrequency()*((uint64_t)fdev_m+1);
    869            fdev_m=((uint64_t)3355443200-tgt1>tgt2-(uint64_t)3355443200)?(fdev_m+1):(fdev_m);
    870          
    871            uint8_t if_regs[2];
    872          
    873            if_regs[0] = (uint8_t)(((uint64_t)7372800000/privGetXtalFrequency())-100);
    874            if_regs[1] = (uint8_t)(((uint64_t)7372800000/f_dig)-100);
    875          
    876            priv_ST_MANUF_WriteRegisters(0x09, 2, if_regs);
    877          
    878            /* write DATARATE mantissa and exponent */
    879            regs[0]=(dr_m>>8)&0xFF;
    880            regs[1]=(dr_m)&0xFF;
    881            regs[2]=mod_e;
    882            priv_ST_MANUF_WriteRegisters(0x0E,3,regs);
    883          
    884            /* write FDEV mantissa and exponent */
    885            regs[0]=fdev_e;
    886            regs[1]=fdev_m;
    887            priv_ST_MANUF_WriteRegisters(0x11,2,regs);
    888          
    889            /* channel filter */
    890          
    891          #ifdef MON_REF_DES
    892            tmp=0x18; //3.3 KHz - Since there is LNA, we are able to receive even with a larger filter.
    893          #else
    894          if (f_dig>24500000) /*CHFILTER must be multiplied for Fdig/26e6 to obtain the actual value*/
    895            tmp=0x88; //2.1 KHz
    896          else
    897            tmp=0x68;
    898          #endif
    899          
    900            priv_ST_MANUF_WriteRegisters(0x13,1,&tmp);
    901          
    902            /* settings of the packet (CRC, FEC, WHIT, ...) + packet length to 15*/
    903            priv_ST_MANUF_WriteRegisters(0x2E, 5, pckt_setting);
    904          
    905            /* SYNC LEN */
    906            pckt_setting[0]=0x40;
    907            priv_ST_MANUF_WriteRegisters(0x2B, 1, pckt_setting);
    908          
    909            /* SYNC WORD 16 bits 0xB227 */
    910            pckt_setting[0]=0x27;
    911            pckt_setting[1]=0xB2;
    912            priv_ST_MANUF_WriteRegisters(0x35, 2, pckt_setting);
    913          
    914            /* SYNC WORD LENGTH is 16bits */
    915            pckt_setting[0]=0x40;
    916            pckt_setting[1]=0x00;
    917            priv_ST_MANUF_WriteRegisters(0x39, 2, pckt_setting);
    918          
    919            /* equ ctrl and cs blank */
    920            tmp=0x00;
    921            priv_ST_MANUF_WriteRegisters(0x1f,1,&tmp);
    922          
    923            /* RSSI thr */
    924            tmp=0x07;
    925            priv_ST_MANUF_WriteRegisters(0x18,1,&tmp);
    926          
    927            /* CLK rec fast */
    928            tmp=0x70;
    929            priv_ST_MANUF_WriteRegisters(0x21,1,&tmp);
    930          
    931            /* CLK rec slow */
    932            tmp=0x20;
    933            priv_ST_MANUF_WriteRegisters(0x20,1,&tmp);
    934          
    935            /* AFC */
    936            tmp=0x00;
    937            priv_ST_MANUF_WriteRegisters(0x14,1,&tmp);
    938          
    939            /* SMPS switch to 0x8800 - old */
    940            /* SMPS switch to 0x87FC - new */
    941            tmp=0x88;
    942            //tmp=0x87;
    943            priv_ST_MANUF_WriteRegisters(0x76, 1, &tmp);
    944            tmp=0x00;
    945            //tmp=0xFC;
    946            priv_ST_MANUF_WriteRegisters(0x77, 1, &tmp);
    947          
    948            st_manuf_context->tx_is_ready=0;
    949          }
    950          
    951          #ifdef MONARCH_FEATURE_ENABLED
    952          
    953          static void priv_ST_MANUF_rx_monarch_rf_init(void)
    954          {
    955            PRINTF("priv_ST_MANUF_rx_monarch_rf_init IN \n\r");
    956          
    957            /*It Informs trough ST_RF_API_Get_Continuous_TX_or_MONARCH_Scan_Flag, the mcu api that monarch scan is ongoing*/
    958            st_manuf_context->tx_packet_struct.continuous_tx_monarch_flag=1;
    959          
    960            uint64_t tgt1,tgt2;
    961            uint32_t f_dig=0;
    962            uint16_t dr_m=0;
    963          
    964            f_dig=privGetXtalFrequency();
    965            /*The digital frequency is half of xtal frequancy for high freq xtals cuts */
    966            if(f_dig > DIG_DOMAIN_XTAL_THRESH) f_dig >>= 1;
    967          
    968            /* SET THE IF TO 300 KHz - It is necessary especially for low frequancy xtals (Both IF equal) */
    969            uint8_t if_regs[2];
    970            if_regs[0] = (uint8_t)(((uint64_t)7372800000/privGetXtalFrequency())-100);
    971            if_regs[1] = (uint8_t)(((uint64_t)7372800000/f_dig)-100);
    972            priv_ST_MANUF_WriteRegisters(0x09, 2, if_regs);
    973          
    974            /* DATARATE MANTISSA COMPUTATION FOR EXP=6 */
    975            dr_m=(uint16_t)(((uint64_t)MONARCH_DATARATE*134217728)/f_dig-65536);
    976            /* understand if we are getting the nearest integer */
    977            tgt1=(uint64_t)f_dig*((uint64_t)dr_m+65536);
    978            tgt2=(uint64_t)f_dig*((uint64_t)dr_m+1+65536);
    979            dr_m=((uint64_t)((uint64_t) MONARCH_DATARATE*134217728)-tgt1>tgt2-(uint64_t)((uint64_t) MONARCH_DATARATE*134217728))?(dr_m+1):(dr_m);
    980          
    981            /* WRITE DATARATE + MOD TYPE REGS */
    982            uint8_t regs[3];
    983            regs[0]=(dr_m>>8)&0xFF; //MOD4 DATA_RATE_M[15:8]
    984            regs[1]=(dr_m)&0xFF;    //MOD3 DATA_RATE_M[7:0]
    985            regs[2]=0x56;           //MOD2 MOD TYPE [7:4] + DATA_RATE_E [3:0] = OOK + EXP=6
    986            priv_ST_MANUF_WriteRegisters(0x0E,3,regs);
    987          
    988            // Channel filter
    989            regs[0]=0x84;  //CHFLT MANTISSA [7:4] +EXPONENT [3:0] 20Khz
    990            priv_ST_MANUF_WriteRegisters(0x13,1,regs);
    991          
    992            // OOK decay 0 + RSSI TH
    993            regs[0]=0xE0; // DECAY
    994            regs[1]=0x15; // RSSI TH old 18
    995            priv_ST_MANUF_WriteRegisters(0x17,2, regs);
    996          
    997            // S2LP GPIO3 Configuration
    998          #ifdef MONARCH_GPIO_SAMPLING
    999            regs[0]=0x42; // GPIO3_CONF RX data output, OOK Output
   1000          #else
   1001            /* manuf_state to MONARCH SCAN to mux gpio it handler */
   1002            st_manuf_context->manuf_state=ST_MANUF_STATE_MONARCH_SCAN;
   1003            regs[0]=0x3A; // GPIO3_CONF: TX/RX FIFO ALMOST FULL FLAG
   1004          #endif
   1005            priv_ST_MANUF_WriteRegisters(0x03,1, regs);
   1006          
   1007            //SET FIFO
   1008          #ifndef MONARCH_GPIO_SAMPLING
   1009            //Set Almost full Mux Sel to Select RX fifo
   1010            priv_ST_MANUF_ReadRegisters(0x39, 1, regs);
   1011            regs[0] |= 0x04;
   1012            priv_ST_MANUF_WriteRegisters(0x39,1, regs); //PROTOCOL2 REG --> FIFO_GPIO_OUT_MUX_SEL = 1
   1013          #endif
   1014          
   1015            //DIRECT RX THROUGH GPIO/FIFO BYPASSING PKT HANDLER
   1016          #ifdef MONARCH_GPIO_SAMPLING
   1017            regs[0]=0x20; //THROUGH GPIO
   1018          #else
   1019            regs[0]=0x10; //THROUGH FIFO
   1020          #endif
   1021            priv_ST_MANUF_WriteRegisters(0x2E,1, regs);
   1022            //RX TIMEOUT 0 - TIMERS5
   1023            regs[0]=0x00;
   1024            priv_ST_MANUF_WriteRegisters(0x46,1, regs);
   1025          
   1026            //AGC Conf
   1027            regs[0]=0xF0;
   1028            //AGCCTRL5
   1029            priv_ST_MANUF_WriteRegisters(0x19,1, regs);
   1030          
   1031            //AGC Conf, Philippe configuration
   1032            regs[0]=0x00;
   1033            //AGCCTRL4
   1034            priv_ST_MANUF_WriteRegisters(0x1A,1, regs);
   1035          
   1036            PRINTF("priv_ST_MANUF_rx_monarch_rf_init OUT \n\r");
   1037          }
   1038          
   1039          #endif
   1040          

   \                                 In section .text, align 2
   1041          __weak void ST_RF_API_custom_setting(void)
   1042          {
   1043          }
   \                     ST_RF_API_custom_setting: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1044          
   1045          /*!******************************************************************
   1046          * \fn sfx_u8 RF_API_init(sfx_rf_mode_t rf_mode)
   1047          * \brief Init and configure Radio link in RX/TX
   1048          *
   1049          * [RX Configuration]
   1050          * To receive Sigfox Frame on your device, program the following:
   1051          *  - Preamble  : 0xAAAAAAAAA
   1052          *  - Sync Word : 0xB227
   1053          *  - Packet of the Sigfox frame is 15 bytes length.
   1054          *
   1055          * \param[in] sfx_rf_mode_t rf_mode         Init Radio link in Tx or RX
   1056          * \param[out] none
   1057          *
   1058          * \retval SFX_ERRNONE:              No error
   1059          * \retval RF_ERR_API_INIT:          Init Radio link error
   1060          *******************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1061          sfx_u8 RF_API_init(sfx_rf_mode_t rf_mode)
   1062          {
   \                     RF_API_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
   \        0x4   0x0007             MOVS     R7,R0
   1063            PRINTF("RF_API_init IN (rf_mode=%d)\n\r",rf_mode);
   1064            sfx_u8 tmp;
   1065          
   1066            if(rf_mode==SFX_RF_MODE_TX && st_manuf_context->tx_is_ready)
   \        0x6   0x4CB7             LDR      R4,??RF_API_init_0
   \        0x8   0xD106             BNE      ??RF_API_init_1
   \        0xA   0x202A             MOVS     R0,#+42
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD002             BEQ      ??RF_API_init_1
   1067            {
   1068              st_manuf_context->tx_packet_struct.tx_state=ST_TX_STATE_NONE;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x7020             STRB     R0,[R4, #+0]
   1069              PRINTF("RF_API_init fast OUT\n\r");
   1070              return SFX_ERR_NONE;
   \       0x16   0xE1CC             B        ??RF_API_init_2
   1071            }
   1072          
   1073            ST_MCU_API_Shutdown(1);
   \                     ??RF_API_init_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x....'....        BL       ST_MCU_API_Shutdown
   1074            ST_MCU_API_Shutdown(0);
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x....'....        BL       ST_MCU_API_Shutdown
   1075          
   1076            if(st_manuf_context->tcxo_flag){
   \       0x24   0x7F60             LDRB     R0,[R4, #+29]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD008             BEQ      ??RF_API_init_3
   1077              tmp=0xB0;
   \       0x2A   0x20B0             MOVS     R0,#+176
   \       0x2C   0x4669             MOV      R1,SP
   \       0x2E   0x7648             STRB     R0,[R1, #+25]
   1078              priv_ST_MANUF_WriteRegisters(0x6D,1,&tmp);
   \       0x30   0xAA06             ADD      R2,SP,#+24
   \       0x32   0x1C52             ADDS     R2,R2,#+1
   \       0x34   0x2101             MOVS     R1,#+1
   \       0x36   0x206D             MOVS     R0,#+109
   \       0x38   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1079            }
   1080          
   1081            ST_MCU_API_GpioIRQ(SFX_FALSE, SFX_FALSE);
   \                     ??RF_API_init_3: (+1)
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x....'....        BL       ST_MCU_API_GpioIRQ
   1082          
   1083            if(privGetXtalFrequency()<30000000)
   \       0x44   0x....             LDR      R5,??DataTable12  ;; 0x1c9c380
   \       0x46   0x69A0             LDR      R0,[R4, #+24]
   \       0x48   0x42A8             CMP      R0,R5
   \       0x4A   0xD201             BCS      ??RF_API_init_4
   1084            {
   1085              /* digital divider - set the bit to 1 only if xtal<30MHz so that the divider is disabled + Frequency drift mitigation*/
   1086              tmp=0x3E;
   \       0x4C   0x203E             MOVS     R0,#+62
   \       0x4E   0xE000             B        ??RF_API_init_5
   1087              priv_ST_MANUF_WriteRegisters(0x6C,1,&tmp);
   1088            }
   1089            else
   1090            {
   1091              /* To mitigate freq drift use 0X2E */
   1092              tmp=0x2E;
   \                     ??RF_API_init_4: (+1)
   \       0x50   0x202E             MOVS     R0,#+46
   \                     ??RF_API_init_5: (+1)
   \       0x52   0x4669             MOV      R1,SP
   \       0x54   0x7648             STRB     R0,[R1, #+25]
   1093              priv_ST_MANUF_WriteRegisters(0x6C, 1, &tmp);
   \       0x56   0xAA06             ADD      R2,SP,#+24
   \       0x58   0x1C52             ADDS     R2,R2,#+1
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x206C             MOVS     R0,#+108
   \       0x5E   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1094            }
   1095          
   1096            switch (rf_mode)
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0xD036             BEQ      ??RF_API_init_6
   \       0x66   0x2F02             CMP      R7,#+2
   \       0x68   0xD004             BEQ      ??RF_API_init_7
   \       0x6A   0xD200             BCS      .+4
   \       0x6C   0xE09A             B        ??RF_API_init_8
   \       0x6E   0x2F03             CMP      R7,#+3
   \       0x70   0xD000             BEQ      .+4
   \       0x72   0xE194             B        ??RF_API_init_9
   1097            {
   1098            case SFX_RF_MODE_CS200K_RX:
   1099              /* configure the RF IC into sensing 200KHz bandwidth to be able to read out RSSI level
   1100              RSSI level will outputed during the wait_for_clear_channel api */
   1101            case SFX_RF_MODE_CS300K_RX:
   1102              /* configure the RF IC into sensing 300KHz bandwidth to be able to read out RSSI level
   1103              This is possible to make this carrier sense in 2 * 200Kz if you respect the regulation time for listening
   1104              RSSI level will outputed during the wait_for_clear_channel api */
   1105              {
   1106          	uint8_t tmp,if_regs[2];
   1107          	uint32_t f_dig=privGetXtalFrequency();
   \                     ??RF_API_init_7: (+1)
   \       0x74   0x69A6             LDR      R6,[R4, #+24]
   1108          
   1109          	if(f_dig>DIG_DOMAIN_XTAL_THRESH) {
   \       0x76   0x42AE             CMP      R6,R5
   \       0x78   0xD900             BLS      ??RF_API_init_10
   1110          	  f_dig >>= 1;
   \       0x7A   0x0876             LSRS     R6,R6,#+1
   1111          	}
   1112          	if_regs[0] = (uint8_t)(((uint64_t)7372800000/privGetXtalFrequency())-100);
   \                     ??RF_API_init_10: (+1)
   \       0x7C   0xAD00             ADD      R5,SP,#+0
   \       0x7E   0x1CAD             ADDS     R5,R5,#+2
   \       0x80   0x....             LDR      R0,??DataTable13  ;; 0xb7740000
   \       0x82   0x2101             MOVS     R1,#+1
   \       0x84   0x69A2             LDR      R2,[R4, #+24]
   \       0x86   0x2300             MOVS     R3,#+0
   \       0x88   0x....'....        BL       __aeabi_uldivmod
   \       0x8C   0x3864             SUBS     R0,R0,#+100
   \       0x8E   0x7028             STRB     R0,[R5, #+0]
   1113          	if_regs[1] = (uint8_t)(((uint64_t)7372800000/f_dig)-100);
   \       0x90   0x....             LDR      R0,??DataTable13  ;; 0xb7740000
   \       0x92   0x2101             MOVS     R1,#+1
   \       0x94   0x0032             MOVS     R2,R6
   \       0x96   0x2300             MOVS     R3,#+0
   \       0x98   0x....'....        BL       __aeabi_uldivmod
   \       0x9C   0x3864             SUBS     R0,R0,#+100
   \       0x9E   0x7068             STRB     R0,[R5, #+1]
   1114          	priv_ST_MANUF_WriteRegisters(0x09, 2, if_regs);
   \       0xA0   0xAA00             ADD      R2,SP,#+0
   \       0xA2   0x1C92             ADDS     R2,R2,#+2
   \       0xA4   0x2102             MOVS     R1,#+2
   \       0xA6   0x2009             MOVS     R0,#+9
   \       0xA8   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1115          	/* channel filter */
   1116          	tmp=0x81; /* 200kHz+ filter */
   \       0xAC   0x2081             MOVS     R0,#+129
   \       0xAE   0x4669             MOV      R1,SP
   \       0xB0   0x7008             STRB     R0,[R1, #+0]
   1117          	if(rf_mode==SFX_RF_MODE_CS300K_RX)
   \       0xB2   0x2F03             CMP      R7,#+3
   \       0xB4   0xD101             BNE      ??RF_API_init_11
   1118          	{
   1119          	  tmp=0x51;  /* 300kHz+ filter */
   \       0xB6   0x2051             MOVS     R0,#+81
   \       0xB8   0x7008             STRB     R0,[R1, #+0]
   1120          	}
   1121          	priv_ST_MANUF_WriteRegisters(0x13,1,&tmp);
   \                     ??RF_API_init_11: (+1)
   \       0xBA   0x466A             MOV      R2,SP
   \       0xBC   0x2101             MOVS     R1,#+1
   \       0xBE   0x2013             MOVS     R0,#+19
   \       0xC0   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1122          	tmp=0x20;
   \       0xC4   0x2020             MOVS     R0,#+32
   \       0xC6   0x4669             MOV      R1,SP
   \       0xC8   0x7008             STRB     R0,[R1, #+0]
   1123          	priv_ST_MANUF_WriteRegisters(0x2E,1,&tmp);
   \       0xCA   0x466A             MOV      R2,SP
   \       0xCC   0x2101             MOVS     R1,#+1
   \       0xCE   0x202E             MOVS     R0,#+46
   \       0xD0   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1124          
   1125              }
   1126              /* here the lack of a break is intetional because we should do the case SFX_RF_MODE_TX also */
   1127            case SFX_RF_MODE_TX :
   1128              priv_ST_MANUF_tx_rf_init();
   \                     ??RF_API_init_6: (+1)
   \       0xD4   0x2004             MOVS     R0,#+4
   \       0xD6   0x4669             MOV      R1,SP
   \       0xD8   0x7008             STRB     R0,[R1, #+0]
   \       0xDA   0x466A             MOV      R2,SP
   \       0xDC   0x2101             MOVS     R1,#+1
   \       0xDE   0x2030             MOVS     R0,#+48
   \       0xE0   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \       0xE4   0x2007             MOVS     R0,#+7
   \       0xE6   0x4669             MOV      R1,SP
   \       0xE8   0x7008             STRB     R0,[R1, #+0]
   \       0xEA   0x466A             MOV      R2,SP
   \       0xEC   0x2101             MOVS     R1,#+1
   \       0xEE   0x2062             MOVS     R0,#+98
   \       0xF0   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \       0xF4   0x466A             MOV      R2,SP
   \       0xF6   0x2101             MOVS     R1,#+1
   \       0xF8   0x2063             MOVS     R0,#+99
   \       0xFA   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   \       0xFE   0x4668             MOV      R0,SP
   \      0x100   0x7800             LDRB     R0,[R0, #+0]
   \      0x102   0x21FD             MOVS     R1,#+253
   \      0x104   0x4001             ANDS     R1,R1,R0
   \      0x106   0x4668             MOV      R0,SP
   \      0x108   0x7001             STRB     R1,[R0, #+0]
   \      0x10A   0x466A             MOV      R2,SP
   \      0x10C   0x2101             MOVS     R1,#+1
   \      0x10E   0x2063             MOVS     R0,#+99
   \      0x110   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x114   0x20D7             MOVS     R0,#+215
   \      0x116   0x4669             MOV      R1,SP
   \      0x118   0x7008             STRB     R0,[R1, #+0]
   \      0x11A   0x466A             MOV      R2,SP
   \      0x11C   0x2101             MOVS     R1,#+1
   \      0x11E   0x2065             MOVS     R0,#+101
   \      0x120   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x124   0x2087             MOVS     R0,#+135
   \      0x126   0x4669             MOV      R1,SP
   \      0x128   0x7008             STRB     R0,[R1, #+0]
   \      0x12A   0x466A             MOV      R2,SP
   \      0x12C   0x2101             MOVS     R1,#+1
   \      0x12E   0x2076             MOVS     R0,#+118
   \      0x130   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x134   0x20FC             MOVS     R0,#+252
   \      0x136   0x4669             MOV      R1,SP
   \      0x138   0x7008             STRB     R0,[R1, #+0]
   \      0x13A   0x466A             MOV      R2,SP
   \      0x13C   0x2101             MOVS     R1,#+1
   \      0x13E   0x2077             MOVS     R0,#+119
   \      0x140   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x144   0x20C8             MOVS     R0,#+200
   \      0x146   0x4669             MOV      R1,SP
   \      0x148   0x7008             STRB     R0,[R1, #+0]
   \      0x14A   0x466A             MOV      R2,SP
   \      0x14C   0x2101             MOVS     R1,#+1
   \      0x14E   0x2064             MOVS     R0,#+100
   \      0x150   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x154   0x7F20             LDRB     R0,[R4, #+28]
   \      0x156   0x2800             CMP      R0,#+0
   \      0x158   0xD018             BEQ      ??RF_API_init_12
   \      0x15A   0x7F20             LDRB     R0,[R4, #+28]
   \      0x15C   0x2808             CMP      R0,#+8
   \      0x15E   0xDA15             BGE      ??RF_API_init_12
   \      0x160   0x7F20             LDRB     R0,[R4, #+28]
   \      0x162   0x0100             LSLS     R0,R0,#+4
   \      0x164   0x2102             MOVS     R1,#+2
   \      0x166   0x4301             ORRS     R1,R1,R0
   \      0x168   0x4668             MOV      R0,SP
   \      0x16A   0x7001             STRB     R1,[R0, #+0]
   \      0x16C   0x466A             MOV      R2,SP
   \      0x16E   0x2101             MOVS     R1,#+1
   \      0x170   0x2079             MOVS     R0,#+121
   \      0x172   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x176   0x7F20             LDRB     R0,[R4, #+28]
   \      0x178   0x2805             CMP      R0,#+5
   \      0x17A   0xDB07             BLT      ??RF_API_init_12
   \      0x17C   0x2088             MOVS     R0,#+136
   \      0x17E   0x4669             MOV      R1,SP
   \      0x180   0x7008             STRB     R0,[R1, #+0]
   \      0x182   0x466A             MOV      R2,SP
   \      0x184   0x2101             MOVS     R1,#+1
   \      0x186   0x2064             MOVS     R0,#+100
   \      0x188   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \                     ??RF_API_init_12: (+1)
   \      0x18C   0x2030             MOVS     R0,#+48
   \      0x18E   0x4669             MOV      R1,SP
   \      0x190   0x7008             STRB     R0,[R1, #+0]
   \      0x192   0x466A             MOV      R2,SP
   \      0x194   0x2101             MOVS     R1,#+1
   \      0x196   0x203F             MOVS     R0,#+63
   \      0x198   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x19C   0x2001             MOVS     R0,#+1
   \      0x19E   0x212A             MOVS     R1,#+42
   \      0x1A0   0x5460             STRB     R0,[R4, R1]
   1129              break;
   \      0x1A2   0xE0FC             B        ??RF_API_init_9
   1130            case SFX_RF_MODE_RX :
   1131              priv_ST_MANUF_rx_rf_init();
   \                     ??RF_API_init_8: (+1)
   \      0x1A4   0x69A7             LDR      R7,[R4, #+24]
   \      0x1A6   0xA808             ADD      R0,SP,#+32
   \      0x1A8   0x....             ADR.N    R1,?_2
   \      0x1AA   0xC90C             LDM      R1!,{R2,R3}
   \      0x1AC   0xC00C             STM      R0!,{R2,R3}
   \      0x1AE   0x42AF             CMP      R7,R5
   \      0x1B0   0xD900             BLS      ??RF_API_init_13
   \      0x1B2   0x087F             LSRS     R7,R7,#+1
   \                     ??RF_API_init_13: (+1)
   \      0x1B4   0x2000             MOVS     R0,#+0
   \      0x1B6   0x2196             MOVS     R1,#+150
   \      0x1B8   0x0089             LSLS     R1,R1,#+2        ;; #+600
   \      0x1BA   0x003A             MOVS     R2,R7
   \      0x1BC   0x2300             MOVS     R3,#+0
   \      0x1BE   0x....'....        BL       __aeabi_uldivmod
   \      0x1C2   0xB285             UXTH     R5,R0
   \      0x1C4   0x2100             MOVS     R1,#+0
   \      0x1C6   0x9700             STR      R7,[SP, #+0]
   \      0x1C8   0x9101             STR      R1,[SP, #+4]
   \      0x1CA   0x....             LDR      R2,??DataTable16  ;; 0x10001
   \      0x1CC   0x2300             MOVS     R3,#+0
   \      0x1CE   0x1952             ADDS     R2,R2,R5
   \      0x1D0   0x9800             LDR      R0,[SP, #+0]
   \      0x1D2   0x....'....        BL       __aeabi_lmul
   \      0x1D6   0x2200             MOVS     R2,#+0
   \      0x1D8   0x....             LDR      R3,??DataTable16_1  ;; 0xfffffda8
   \      0x1DA   0x1812             ADDS     R2,R2,R0
   \      0x1DC   0x414B             ADCS     R3,R3,R1
   \      0x1DE   0x9204             STR      R2,[SP, #+16]
   \      0x1E0   0x9305             STR      R3,[SP, #+20]
   \      0x1E2   0x2000             MOVS     R0,#+0
   \      0x1E4   0x2196             MOVS     R1,#+150
   \      0x1E6   0x0089             LSLS     R1,R1,#+2        ;; #+600
   \      0x1E8   0x9002             STR      R0,[SP, #+8]
   \      0x1EA   0x9103             STR      R1,[SP, #+12]
   \      0x1EC   0x2100             MOVS     R1,#+0
   \      0x1EE   0x9700             STR      R7,[SP, #+0]
   \      0x1F0   0x9101             STR      R1,[SP, #+4]
   \      0x1F2   0x2280             MOVS     R2,#+128
   \      0x1F4   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \      0x1F6   0x2300             MOVS     R3,#+0
   \      0x1F8   0x1952             ADDS     R2,R2,R5
   \      0x1FA   0x9800             LDR      R0,[SP, #+0]
   \      0x1FC   0x....'....        BL       __aeabi_lmul
   \      0x200   0x9A02             LDR      R2,[SP, #+8]
   \      0x202   0x9B03             LDR      R3,[SP, #+12]
   \      0x204   0x1A12             SUBS     R2,R2,R0
   \      0x206   0x418B             SBCS     R3,R3,R1
   \      0x208   0x9804             LDR      R0,[SP, #+16]
   \      0x20A   0x9905             LDR      R1,[SP, #+20]
   \      0x20C   0x4299             CMP      R1,R3
   \      0x20E   0xD803             BHI      ??RF_API_init_14
   \      0x210   0xD301             BCC      ??RF_API_init_15
   \      0x212   0x4290             CMP      R0,R2
   \      0x214   0xD200             BCS      ??RF_API_init_14
   \                     ??RF_API_init_15: (+1)
   \      0x216   0x1C6D             ADDS     R5,R5,#+1
   \                     ??RF_API_init_14: (+1)
   \      0x218   0x9504             STR      R5,[SP, #+16]
   \      0x21A   0x20C8             MOVS     R0,#+200
   \      0x21C   0x0600             LSLS     R0,R0,#+24       ;; #-939524096
   \      0x21E   0x69A1             LDR      R1,[R4, #+24]
   \      0x220   0x....'....        BL       __aeabi_uidiv
   \      0x224   0xB2C5             UXTB     R5,R0
   \      0x226   0x69A0             LDR      R0,[R4, #+24]
   \      0x228   0x9005             STR      R0,[SP, #+20]
   \      0x22A   0x69A0             LDR      R0,[R4, #+24]
   \      0x22C   0x2100             MOVS     R1,#+0
   \      0x22E   0x2300             MOVS     R3,#+0
   \      0x230   0x2600             MOVS     R6,#+0
   \      0x232   0x1C6A             ADDS     R2,R5,#+1
   \      0x234   0x....'....        BL       __aeabi_lmul
   \      0x238   0x22E0             MOVS     R2,#+224
   \      0x23A   0x0592             LSLS     R2,R2,#+22       ;; #+939524096
   \      0x23C   0x2300             MOVS     R3,#+0
   \      0x23E   0x43DB             MVNS     R3,R3            ;; #-1
   \      0x240   0x1812             ADDS     R2,R2,R0
   \      0x242   0x414B             ADCS     R3,R3,R1
   \      0x244   0x9202             STR      R2,[SP, #+8]
   \      0x246   0x9303             STR      R3,[SP, #+12]
   \      0x248   0x20C8             MOVS     R0,#+200
   \      0x24A   0x0600             LSLS     R0,R0,#+24       ;; #-939524096
   \      0x24C   0x2100             MOVS     R1,#+0
   \      0x24E   0x9000             STR      R0,[SP, #+0]
   \      0x250   0x9101             STR      R1,[SP, #+4]
   \      0x252   0x9805             LDR      R0,[SP, #+20]
   \      0x254   0x002A             MOVS     R2,R5
   \      0x256   0x2300             MOVS     R3,#+0
   \      0x258   0x....'....        BL       __aeabi_lmul
   \      0x25C   0x9A00             LDR      R2,[SP, #+0]
   \      0x25E   0x2300             MOVS     R3,#+0
   \      0x260   0x1A12             SUBS     R2,R2,R0
   \      0x262   0x418B             SBCS     R3,R3,R1
   \      0x264   0x9802             LDR      R0,[SP, #+8]
   \      0x266   0x9903             LDR      R1,[SP, #+12]
   \      0x268   0x4299             CMP      R1,R3
   \      0x26A   0xD805             BHI      ??RF_API_init_16
   \      0x26C   0xD301             BCC      ??RF_API_init_17
   \      0x26E   0x4290             CMP      R0,R2
   \      0x270   0xD202             BCS      ??RF_API_init_16
   \                     ??RF_API_init_17: (+1)
   \      0x272   0x4668             MOV      R0,SP
   \      0x274   0x1C6D             ADDS     R5,R5,#+1
   \      0x276   0xE000             B        ??RF_API_init_18
   \                     ??RF_API_init_16: (+1)
   \      0x278   0x4668             MOV      R0,SP
   \                     ??RF_API_init_18: (+1)
   \      0x27A   0x7005             STRB     R5,[R0, #+0]
   \      0x27C   0xAD00             ADD      R5,SP,#+0
   \      0x27E   0x1CAD             ADDS     R5,R5,#+2
   \      0x280   0x....             LDR      R0,??DataTable13  ;; 0xb7740000
   \      0x282   0x2101             MOVS     R1,#+1
   \      0x284   0x69A2             LDR      R2,[R4, #+24]
   \      0x286   0x2300             MOVS     R3,#+0
   \      0x288   0x....'....        BL       __aeabi_uldivmod
   \      0x28C   0x3864             SUBS     R0,R0,#+100
   \      0x28E   0x7028             STRB     R0,[R5, #+0]
   \      0x290   0x....             LDR      R0,??DataTable13  ;; 0xb7740000
   \      0x292   0x2101             MOVS     R1,#+1
   \      0x294   0x003A             MOVS     R2,R7
   \      0x296   0x2300             MOVS     R3,#+0
   \      0x298   0x....'....        BL       __aeabi_uldivmod
   \      0x29C   0x3864             SUBS     R0,R0,#+100
   \      0x29E   0x7068             STRB     R0,[R5, #+1]
   \      0x2A0   0xAA00             ADD      R2,SP,#+0
   \      0x2A2   0x1C92             ADDS     R2,R2,#+2
   \      0x2A4   0x2102             MOVS     R1,#+2
   \      0x2A6   0x2009             MOVS     R0,#+9
   \      0x2A8   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x2AC   0xAD07             ADD      R5,SP,#+28
   \      0x2AE   0x9804             LDR      R0,[SP, #+16]
   \      0x2B0   0x0400             LSLS     R0,R0,#+16
   \      0x2B2   0x0E00             LSRS     R0,R0,#+24
   \      0x2B4   0x7028             STRB     R0,[R5, #+0]
   \      0x2B6   0x9804             LDR      R0,[SP, #+16]
   \      0x2B8   0x7068             STRB     R0,[R5, #+1]
   \      0x2BA   0x2021             MOVS     R0,#+33
   \      0x2BC   0x70A8             STRB     R0,[R5, #+2]
   \      0x2BE   0xAA07             ADD      R2,SP,#+28
   \      0x2C0   0x2103             MOVS     R1,#+3
   \      0x2C2   0x200E             MOVS     R0,#+14
   \      0x2C4   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x2C8   0x702E             STRB     R6,[R5, #+0]
   \      0x2CA   0x4668             MOV      R0,SP
   \      0x2CC   0x7800             LDRB     R0,[R0, #+0]
   \      0x2CE   0x7068             STRB     R0,[R5, #+1]
   \      0x2D0   0xAA07             ADD      R2,SP,#+28
   \      0x2D2   0x2102             MOVS     R1,#+2
   \      0x2D4   0x2011             MOVS     R0,#+17
   \      0x2D6   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x2DA   0x....             LDR      R0,??DataTable17  ;; 0x175d721
   \      0x2DC   0x4287             CMP      R7,R0
   \      0x2DE   0xD303             BCC      ??RF_API_init_19
   \      0x2E0   0x2088             MOVS     R0,#+136
   \      0x2E2   0xE002             B        ??RF_API_init_20
   \                     ??RF_API_init_0:
   \      0x2E4   0x....'....        DC32     st_manuf
   \                     ??RF_API_init_19: (+1)
   \      0x2E8   0x2068             MOVS     R0,#+104
   \                     ??RF_API_init_20: (+1)
   \      0x2EA   0x4669             MOV      R1,SP
   \      0x2EC   0x7608             STRB     R0,[R1, #+24]
   \      0x2EE   0xAA06             ADD      R2,SP,#+24
   \      0x2F0   0x2101             MOVS     R1,#+1
   \      0x2F2   0x2013             MOVS     R0,#+19
   \      0x2F4   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x2F8   0xAA08             ADD      R2,SP,#+32
   \      0x2FA   0x2105             MOVS     R1,#+5
   \      0x2FC   0x202E             MOVS     R0,#+46
   \      0x2FE   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x302   0x2740             MOVS     R7,#+64
   \      0x304   0xAD08             ADD      R5,SP,#+32
   \      0x306   0x702F             STRB     R7,[R5, #+0]
   \      0x308   0xAA08             ADD      R2,SP,#+32
   \      0x30A   0x2101             MOVS     R1,#+1
   \      0x30C   0x202B             MOVS     R0,#+43
   \      0x30E   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x312   0x2027             MOVS     R0,#+39
   \      0x314   0x7028             STRB     R0,[R5, #+0]
   \      0x316   0x20B2             MOVS     R0,#+178
   \      0x318   0x7068             STRB     R0,[R5, #+1]
   \      0x31A   0xAA08             ADD      R2,SP,#+32
   \      0x31C   0x2102             MOVS     R1,#+2
   \      0x31E   0x2035             MOVS     R0,#+53
   \      0x320   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x324   0x702F             STRB     R7,[R5, #+0]
   \      0x326   0x706E             STRB     R6,[R5, #+1]
   \      0x328   0xAA08             ADD      R2,SP,#+32
   \      0x32A   0x2102             MOVS     R1,#+2
   \      0x32C   0x2039             MOVS     R0,#+57
   \      0x32E   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x332   0x4668             MOV      R0,SP
   \      0x334   0x7606             STRB     R6,[R0, #+24]
   \      0x336   0xAA06             ADD      R2,SP,#+24
   \      0x338   0x2101             MOVS     R1,#+1
   \      0x33A   0x201F             MOVS     R0,#+31
   \      0x33C   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x340   0x2007             MOVS     R0,#+7
   \      0x342   0x4669             MOV      R1,SP
   \      0x344   0x7608             STRB     R0,[R1, #+24]
   \      0x346   0xAA06             ADD      R2,SP,#+24
   \      0x348   0x2101             MOVS     R1,#+1
   \      0x34A   0x2018             MOVS     R0,#+24
   \      0x34C   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x350   0x2070             MOVS     R0,#+112
   \      0x352   0x4669             MOV      R1,SP
   \      0x354   0x7608             STRB     R0,[R1, #+24]
   \      0x356   0xAA06             ADD      R2,SP,#+24
   \      0x358   0x2101             MOVS     R1,#+1
   \      0x35A   0x2021             MOVS     R0,#+33
   \      0x35C   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x360   0x2020             MOVS     R0,#+32
   \      0x362   0x4669             MOV      R1,SP
   \      0x364   0x7608             STRB     R0,[R1, #+24]
   \      0x366   0xAA06             ADD      R2,SP,#+24
   \      0x368   0x2101             MOVS     R1,#+1
   \      0x36A   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x36E   0x4668             MOV      R0,SP
   \      0x370   0x7606             STRB     R6,[R0, #+24]
   \      0x372   0xAA06             ADD      R2,SP,#+24
   \      0x374   0x2101             MOVS     R1,#+1
   \      0x376   0x2014             MOVS     R0,#+20
   \      0x378   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x37C   0x2088             MOVS     R0,#+136
   \      0x37E   0x4669             MOV      R1,SP
   \      0x380   0x7608             STRB     R0,[R1, #+24]
   \      0x382   0xAA06             ADD      R2,SP,#+24
   \      0x384   0x2101             MOVS     R1,#+1
   \      0x386   0x2076             MOVS     R0,#+118
   \      0x388   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x38C   0x4668             MOV      R0,SP
   \      0x38E   0x7606             STRB     R6,[R0, #+24]
   \      0x390   0xAA06             ADD      R2,SP,#+24
   \      0x392   0x2101             MOVS     R1,#+1
   \      0x394   0x2077             MOVS     R0,#+119
   \      0x396   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x39A   0x202A             MOVS     R0,#+42
   \      0x39C   0x5426             STRB     R6,[R4, R0]
   1132              break;
   1133          #ifdef MONARCH_FEATURE_ENABLED
   1134            case  SFX_RF_MODE_MONARCH:
   1135              priv_ST_MANUF_rx_monarch_rf_init();
   1136              break;
   1137          #endif
   1138            default :
   1139              break;
   1140            }
   1141          
   1142            _s2lpFIFOState = ST_FIFO_STATE_WAITING_UNDERFLOW;
   \                     ??RF_API_init_9: (+1)
   \      0x39E   0x2000             MOVS     R0,#+0
   \      0x3A0   0x....             LDR      R1,??DataTable18
   \      0x3A2   0x7088             STRB     R0,[R1, #+2]
   1143            priv_ST_MANUF_Get_Ramps_Settings(&st_manuf_context->ramps_settings);
   \      0x3A4   0x0020             MOVS     R0,R4
   \      0x3A6   0x308A             ADDS     R0,R0,#+138
   \      0x3A8   0x....'....        BL       priv_ST_MANUF_Get_Ramps_Settings
   1144            ST_RF_API_custom_setting();
   \      0x3AC   0x....'....        BL       ST_RF_API_custom_setting
   1145          
   1146            return SFX_ERR_NONE;
   \      0x3B0   0x2000             MOVS     R0,#+0
   \                     ??RF_API_init_2: (+1)
   \      0x3B2   0xB00B             ADD      SP,SP,#+44
   \      0x3B4   0xBDF0             POP      {R4-R7,PC}       ;; return
   1147          }
   1148          
   1149          /*!******************************************************************
   1150          * \fn sfx_u8 RF_API_stop(void)
   1151          * \brief Close Radio link
   1152          *
   1153          * \param[in] none
   1154          * \param[out] none
   1155          *
   1156          * \retval SFX_ERR_NONE:              No error
   1157          * \retval RF_ERR_API_STOP:           Close Radio link error
   1158          *******************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1159          sfx_u8 RF_API_stop(void)
   1160          {
   \                     RF_API_stop: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1161            PRINTF("RF_API_stop IN\n\r");
   1162          
   1163            /* give an abort command (just for safety) */
   1164            ST_RF_API_StopRxTx();
   \        0x2   0x....'....        BL       ST_RF_API_StopRxTx
   1165          
   1166            /* shut down the radio */
   1167            ST_MCU_API_Shutdown(1);
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x....'....        BL       ST_MCU_API_Shutdown
   1168          
   1169            //To be verified, verify if for every condition the monarch end with RF_API_stop
   1170          #ifndef MONARCH_GPIO_SAMPLING //Only for monarch fifo feature
   1171            if (st_manuf_context->manuf_state==ST_MANUF_STATE_MONARCH_SCAN)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x....             LDR      R1,??DataTable18_1
   \       0x10   0x2224             MOVS     R2,#+36
   \       0x12   0x5C8A             LDRB     R2,[R1, R2]
   \       0x14   0x2A05             CMP      R2,#+5
   \       0x16   0xD101             BNE      ??RF_API_stop_0
   1172              st_manuf_context->manuf_state=ST_MANUF_STATE_IDLE;
   \       0x18   0x2224             MOVS     R2,#+36
   \       0x1A   0x5488             STRB     R0,[R1, R2]
   1173          #endif
   1174          
   1175            st_manuf_context->s2lp_irq_raised=0;
   \                     ??RF_API_stop_0: (+1)
   \       0x1C   0x2220             MOVS     R2,#+32
   \       0x1E   0x5488             STRB     R0,[R1, R2]
   1176          
   1177            st_manuf_context->tx_is_ready=0;
   \       0x20   0x222A             MOVS     R2,#+42
   \       0x22   0x5488             STRB     R0,[R1, R2]
   1178          
   1179            PRINTF("RF_API_stop OUT\n\r");
   1180          
   1181            return SFX_ERR_NONE;
   \       0x24   0xBD02             POP      {R1,PC}          ;; return
   1182          }
   1183          
   1184          /*!******************************************************************
   1185          * \fn sfx_u8 RF_API_send(sfx_u8 *stream, sfx_modulation_type_t type, sfx_u8 size)
   1186          * \brief BPSK Modulation of data stream
   1187          * (from synchro bit field to CRC)
   1188          *
   1189          * NOTE : during this function, the voltage_tx needs to be retrieved and stored in
   1190          *        a variable to be returned into the MCU_API_get_voltage_and_temperature or
   1191          *        MCU_API_get_voltage functions.
   1192          *
   1193          * \param[in] sfx_u8 *stream                Complete stream to modulate
   1194          * \param[in]sfx_modulation_type_t          Type of the modulation ( enum with baudrate and modulation information)
   1195          * \param[in] sfx_u8 size                   Length of stream
   1196          * \param[out] none
   1197          *
   1198          * \retval SFX_ERR_NONE:                    No error
   1199          * \retval RF_ERR_API_SEND:                 Send data stream error
   1200          *******************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1201          sfx_u8 RF_API_send(sfx_u8 *stream, sfx_modulation_type_t type, sfx_u8 size)
   1202          {
   \                     RF_API_send: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x0008             MOVS     R0,R1
   1203            PRINTF("RF_API_send IN\n\r");
   1204          
   1205            PRINTF("FTS: [");
   1206            for(uint8_t i=0;i<size;i++)
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0xE000             B        ??RF_API_send_0
   \                     ??RF_API_send_1: (+1)
   \        0xE   0x1C49             ADDS     R1,R1,#+1
   \                     ??RF_API_send_0: (+1)
   \       0x10   0xB2CA             UXTB     R2,R1
   \       0x12   0x42B2             CMP      R2,R6
   \       0x14   0xD3FB             BCC      ??RF_API_send_1
   1207            {
   1208              PRINTF("%.2X",stream[i]);
   1209            }
   1210            PRINTF("]\n\r");
   1211          
   1212            if(type==SFX_NO_MODULATION || st_manuf_context->manuf_state!=ST_MANUF_STATE_IDLE)
   \       0x16   0x0001             MOVS     R1,R0
   \       0x18   0xD004             BEQ      ??RF_API_send_2
   \       0x1A   0x....             LDR      R5,??DataTable18_1
   \       0x1C   0x2124             MOVS     R1,#+36
   \       0x1E   0x5C69             LDRB     R1,[R5, R1]
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD001             BEQ      ??RF_API_send_3
   1213              return RF_ERR_API_SEND;
   \                     ??RF_API_send_2: (+1)
   \       0x24   0x2031             MOVS     R0,#+49
   \       0x26   0xBDF2             POP      {R1,R4-R7,PC}
   1214          
   1215            /* configure the modem according to the modulation (100bps, 600bps) */
   1216            priv_ST_MANUF_tx_rf_dbpsk_init(type);
   \                     ??RF_API_send_3: (+1)
   \       0x28   0x....'....        BL       priv_ST_MANUF_tx_rf_dbpsk_init
   1217          
   1218            /* start the modulation of the data stream */
   1219            priv_ST_MANUF_rf_modulation_dbpsk(stream, size);
   \       0x2C   0x73AC             STRB     R4,[R5, #+14]
   \       0x2E   0x60AF             STR      R7,[R5, #+8]
   \       0x30   0x806E             STRH     R6,[R5, #+2]
   \       0x32   0x....'....        BL       priv_ST_MANUF_rf_load_first_ramp_up
   \       0x36   0x....'....        BL       ST_RF_API_StartTx
   \       0x3A   0x2020             MOVS     R0,#+32
   \       0x3C   0x542C             STRB     R4,[R5, R0]
   \       0x3E   0xE001             B        ??RF_API_send_4
   \                     ??RF_API_send_5: (+1)
   \       0x40   0x....'....        BL       ST_MCU_API_WaitForInterrupt
   \                     ??RF_API_send_4: (+1)
   \       0x44   0x2020             MOVS     R0,#+32
   \       0x46   0x5C28             LDRB     R0,[R5, R0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD0F9             BEQ      ??RF_API_send_5
   \       0x4C   0x2020             MOVS     R0,#+32
   \       0x4E   0x542C             STRB     R4,[R5, R0]
   \       0x50   0x2024             MOVS     R0,#+36
   \       0x52   0x542C             STRB     R4,[R5, R0]
   1220          
   1221          #ifdef MONARCH_CLI_TESTS
   1222            printf("{{(SigfoxSendBPSK)} API call...{value:");
   1223            for(uint8_t i=0;i<size;i++)
   1224            {
   1225              printf("%.2X",stream[i]);
   1226            }
   1227            printf("}}\n\r");
   1228          #endif
   1229            PRINTF("RF_API_send OUT\n\r");
   1230          
   1231            return SFX_ERR_NONE;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1232          }
   1233          
   1234          /*!******************************************************************
   1235          * \fn sfx_u8 RF_API_start_continuous_transmission (sfx_modulation_type_t type)
   1236          * \brief Generate a signal with modulation type. All the configuration ( Init of the RF and Frequency have already been executed
   1237          *        when this function is called.
   1238          *
   1239          * \param[in] sfx_modulation_type_t         Type of the modulation ( enum with baudrate and modulation information is contained in sigfox_api.h)
   1240          *
   1241          * \retval SFX_ERR_NONE:                                 No error
   1242          * \retval RF_ERR_API_START_CONTINUOUS_TRANSMISSION:     Continuous Transmission Start error
   1243          *******************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1244          sfx_u8 RF_API_start_continuous_transmission(sfx_modulation_type_t type)
   1245          {
   \                     RF_API_start_continuous_transmission: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   1246            PRINTF("RF_API_start_continuous_transmission IN\n\r");
   1247          
   1248            if(st_manuf_context->manuf_state!=ST_MANUF_STATE_IDLE)
   \        0x2   0x....             LDR      R4,??DataTable18_1
   \        0x4   0x2124             MOVS     R1,#+36
   \        0x6   0x5C61             LDRB     R1,[R4, R1]
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD001             BEQ      ??RF_API_start_continuous_transmission_0
   1249              return RF_ERR_API_SEND;
   \        0xC   0x2031             MOVS     R0,#+49
   \        0xE   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??RF_API_start_continuous_transmission_0: (+1)
   \       0x10   0x0006             MOVS     R6,R0
   1250          
   1251            // Make an infinite BPSK 100/600bps modulation on the RF IC at the frequency given by the RF_API_change_frequency()
   1252            // If BPSK modulation configure based on datarate
   1253          
   1254            if (type==SFX_DBPSK_100BPS || type==SFX_DBPSK_600BPS)
   \       0x12   0x2501             MOVS     R5,#+1
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD001             BEQ      ??RF_API_start_continuous_transmission_1
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xD10C             BNE      ??RF_API_start_continuous_transmission_2
   1255            {
   1256              /* S2-LP IRQ on MCU side */
   1257              ST_MCU_API_GpioIRQ(SFX_TRUE, SFX_TRUE);
   \                     ??RF_API_start_continuous_transmission_1: (+1)
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x....'....        BL       ST_MCU_API_GpioIRQ
   1258          
   1259              st_manuf_context->tx_packet_struct.continuous_tx_monarch_flag=1; //The transmission will be a PN9 and no packets
   \       0x24   0x73A5             STRB     R5,[R4, #+14]
   1260              st_manuf_context->tx_packet_struct.current_pn9=PN9_INITIALIZER;
   \       0x26   0x....             LDR      R0,??DataTable18_2  ;; 0x1ff
   \       0x28   0x81A0             STRH     R0,[R4, #+12]
   1261              priv_ST_MANUF_tx_rf_dbpsk_init(type);
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x....'....        BL       priv_ST_MANUF_tx_rf_dbpsk_init
   1262          
   1263              // Set GPIO to receive interrupt and Send first ramp in the FIFO
   1264              priv_ST_MANUF_rf_load_first_ramp_up();
   \       0x30   0x....'....        BL       priv_ST_MANUF_rf_load_first_ramp_up
   1265          
   1266              /* Give the TX command: from now on the device will start to transmit */
   1267              ST_RF_API_StartTx();
   \       0x34   0xE020             B        ??RF_API_start_continuous_transmission_3
   1268            }
   1269          
   1270            // Configure the RF IC into pure carrier CW : no modulation
   1271            // this mode is available on many RF ICs for type approval tests or manufacturing tests.
   1272            // the frequency is chosen in the RF_API_change_frequency by the sigfox lib
   1273            // SPI_DRV_write(CW)
   1274            else if (type==SFX_NO_MODULATION)
   \                     ??RF_API_start_continuous_transmission_2: (+1)
   \       0x36   0x2E00             CMP      R6,#+0
   \       0x38   0xD120             BNE      ??RF_API_start_continuous_transmission_4
   1275            {
   1276              sfx_u8 tmp;
   1277          
   1278              ST_MCU_API_GpioIRQ(SFX_FALSE, SFX_FALSE);
   \       0x3A   0x....'....        BL       ST_MCU_API_GpioIRQ
   1279          
   1280              // MOD register to Save Datarate and pu
   1281              priv_ST_MANUF_ReadRegisters(0x10, 1, &tmp);
   \       0x3E   0x466A             MOV      R2,SP
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x2010             MOVS     R0,#+16
   \       0x44   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   1282              tmp &= (~0xF0);
   1283              tmp |= 0x70;
   \       0x48   0x4668             MOV      R0,SP
   \       0x4A   0x7800             LDRB     R0,[R0, #+0]
   \       0x4C   0x0700             LSLS     R0,R0,#+28
   \       0x4E   0x0F00             LSRS     R0,R0,#+28
   \       0x50   0x2170             MOVS     R1,#+112
   \       0x52   0x4301             ORRS     R1,R1,R0
   \       0x54   0x4668             MOV      R0,SP
   \       0x56   0x7001             STRB     R1,[R0, #+0]
   1284              priv_ST_MANUF_WriteRegisters(0x10, 1, &tmp);
   \       0x58   0x466A             MOV      R2,SP
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x2010             MOVS     R0,#+16
   \       0x5E   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1285          
   1286              // Set Power PA_POWER8
   1287          #ifdef MON_REF_DES
   1288              if (st_manuf_context->pa_flag == 0)
   1289          	tmp=1+st_manuf_context->power_reduction;
   1290              else
   1291          	tmp=1+5+st_manuf_context->power_reduction;
   1292          #else
   1293              tmp=1+st_manuf_context->power_reduction;
   \       0x62   0x8CE0             LDRH     R0,[R4, #+38]
   \       0x64   0x1C40             ADDS     R0,R0,#+1
   \       0x66   0x4669             MOV      R1,SP
   \       0x68   0x7008             STRB     R0,[R1, #+0]
   1294          #endif
   1295          
   1296              priv_ST_MANUF_WriteRegisters(0x5A, 1, &tmp);
   \       0x6A   0x466A             MOV      R2,SP
   \       0x6C   0x2101             MOVS     R1,#+1
   \       0x6E   0x205A             MOVS     R0,#+90
   \       0x70   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1297          
   1298              st_manuf_context->manuf_state=ST_MANUF_STATE_TX;
   \       0x74   0x2024             MOVS     R0,#+36
   \       0x76   0x5425             STRB     R5,[R4, R0]
   1299          
   1300              ST_RF_API_StartTx();
   \                     ??RF_API_start_continuous_transmission_3: (+1)
   \       0x78   0x....'....        BL       ST_RF_API_StartTx
   1301            }
   1302          
   1303            PRINTF("RF_API_start_continuous_transmission OUT\n\r");
   1304          
   1305            return SFX_ERR_NONE;
   \                     ??RF_API_start_continuous_transmission_4: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1306          }
   1307          
   1308          /*!******************************************************************
   1309          * \fn sfx_u8 RF_API_stop_continuous_transmission (void)
   1310          * \brief Stop the current continuous transmisssion
   1311          *
   1312          * \retval SFX_ERR_NONE:                                 No error
   1313          * \retval RF_ERR_API_STOP_CONTINUOUS_TRANSMISSION:      Continuous Transmission Stop error
   1314          *******************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1315          sfx_u8 RF_API_stop_continuous_transmission (void)
   1316          {
   \                     RF_API_stop_continuous_transmission: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1317            PRINTF("RF_API_stop_continuous_transmission IN\n\r");
   1318          
   1319            ST_RF_API_StopRxTx();
   \        0x2   0x....'....        BL       ST_RF_API_StopRxTx
   1320          
   1321            st_manuf_context->manuf_state=ST_MANUF_STATE_IDLE;
   \        0x6   0x....             LDR      R0,??DataTable18_1
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x2224             MOVS     R2,#+36
   \        0xC   0x5481             STRB     R1,[R0, R2]
   1322          
   1323            if (st_manuf_context->tx_packet_struct.continuous_tx_monarch_flag)
   \        0xE   0x7B80             LDRB     R0,[R0, #+14]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD002             BEQ      ??RF_API_stop_continuous_transmission_0
   1324              ST_MCU_API_GpioIRQ(SFX_FALSE, SFX_FALSE);
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x....'....        BL       ST_MCU_API_GpioIRQ
   1325          
   1326            PRINTF("RF_API_stop_continuous_transmission OUT\n\r");
   1327          
   1328            return SFX_ERR_NONE;
   \                     ??RF_API_stop_continuous_transmission_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD02             POP      {R1,PC}          ;; return
   1329          }
   1330          
   1331          /*!******************************************************************
   1332          * \fn sfx_u8 RF_API_change_frequency(sfx_u32 frequency)
   1333          * \brief Change synthesizer carrier frequency
   1334          *
   1335          * \param[in] sfx_u32 frequency             Frequency in Hz to program in the radio chipset
   1336          * \param[out] none
   1337          *
   1338          * \retval SFX_ERR_NONE:                    No error
   1339          * \retval RF_ERR_API_CHANGE_FREQ:          Change frequency error
   1340          *******************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1341          sfx_u8 RF_API_change_frequency(sfx_u32 frequency)
   1342          {
   \                     RF_API_change_frequency: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   1343            PRINTF("RF_API_change_frequency IN %d\n\r",frequency);
   1344          
   1345            uint8_t tmp[4];
   1346            uint32_t synth;
   1347          
   1348            synth=((uint64_t)2097152*frequency/privGetXtalFrequency());
   \        0x4   0x0AC5             LSRS     R5,R0,#+11
   \        0x6   0x0544             LSLS     R4,R0,#+21
   \        0x8   0x....             LDR      R6,??DataTable18_1
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x69B2             LDR      R2,[R6, #+24]
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x....'....        BL       __aeabi_uldivmod
   \       0x16   0x0007             MOVS     R7,R0
   1349            /* understand if we are getting the nearest integer */
   1350            uint64_t tgt1,tgt2;
   1351            tgt1=(uint64_t)privGetXtalFrequency()*((uint64_t)synth);
   \       0x18   0x69B0             LDR      R0,[R6, #+24]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   1352            tgt2=(uint64_t)privGetXtalFrequency()*((uint64_t)synth+1);
   1353            synth=((uint64_t)2097152*frequency-tgt1>tgt2-(uint64_t)2097152*frequency)?(synth+1):(synth);
   \       0x1C   0x69B0             LDR      R0,[R6, #+24]
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0x9101             STR      R1,[SP, #+4]
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x1C7A             ADDS     R2,R7,#+1
   \       0x2A   0x4143             ADCS     R3,R3,R0
   \       0x2C   0x9800             LDR      R0,[SP, #+0]
   \       0x2E   0x....'....        BL       __aeabi_lmul
   \       0x32   0x1B00             SUBS     R0,R0,R4
   \       0x34   0x41A9             SBCS     R1,R1,R5
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0x9101             STR      R1,[SP, #+4]
   \       0x3A   0x9803             LDR      R0,[SP, #+12]
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x003A             MOVS     R2,R7
   \       0x40   0x2300             MOVS     R3,#+0
   \       0x42   0x....'....        BL       __aeabi_lmul
   \       0x46   0x1A24             SUBS     R4,R4,R0
   \       0x48   0x418D             SBCS     R5,R5,R1
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
   \       0x4C   0x9901             LDR      R1,[SP, #+4]
   \       0x4E   0x42A9             CMP      R1,R5
   \       0x50   0xD803             BHI      ??RF_API_change_frequency_0
   \       0x52   0xD301             BCC      ??RF_API_change_frequency_1
   \       0x54   0x42A0             CMP      R0,R4
   \       0x56   0xD200             BCS      ??RF_API_change_frequency_0
   \                     ??RF_API_change_frequency_1: (+1)
   \       0x58   0x1C7F             ADDS     R7,R7,#+1
   1354          
   1355            /* CHARGE PUMP */
   1356            uint32_t vcofreq = frequency*4;
   1357            uint8_t cp_isel,pfd_split;
   1358          
   1359            /* Set the correct charge pump word */
   1360            if(vcofreq>=(uint64_t)3600000000) {
   \                     ??RF_API_change_frequency_0: (+1)
   \       0x5A   0x2440             MOVS     R4,#+64
   \       0x5C   0x....             LDR      R2,??DataTable21  ;; 0x1c9c381
   \       0x5E   0x9B04             LDR      R3,[SP, #+16]
   \       0x60   0x009B             LSLS     R3,R3,#+2
   \       0x62   0x....             LDR      R5,??DataTable21_1  ;; 0xd693a400
   \       0x64   0x42AB             CMP      R3,R5
   \       0x66   0x69B3             LDR      R3,[R6, #+24]
   \       0x68   0xD303             BCC      ??RF_API_change_frequency_2
   1361              if(privGetXtalFrequency()>DIG_DOMAIN_XTAL_THRESH) {
   \       0x6A   0x4293             CMP      R3,R2
   \       0x6C   0xD204             BCS      ??RF_API_change_frequency_3
   1362          	cp_isel = 0x02;
   1363          	pfd_split = 0;
   1364              }
   1365              else {
   1366          	cp_isel = 0x01;
   \       0x6E   0x2420             MOVS     R4,#+32
   1367          	pfd_split = 1;
   \       0x70   0xE004             B        ??RF_API_change_frequency_4
   1368              }
   1369            }
   1370            else {
   1371              if(privGetXtalFrequency()>DIG_DOMAIN_XTAL_THRESH) {
   \                     ??RF_API_change_frequency_2: (+1)
   \       0x72   0x4293             CMP      R3,R2
   \       0x74   0xD302             BCC      ??RF_API_change_frequency_4
   1372          	cp_isel = 0x03;
   \       0x76   0x2460             MOVS     R4,#+96
   1373          	pfd_split = 0;
   \                     ??RF_API_change_frequency_3: (+1)
   \       0x78   0x2600             MOVS     R6,#+0
   \       0x7A   0xE000             B        ??RF_API_change_frequency_5
   1374              }
   1375              else {
   1376          	cp_isel = 0x02;
   1377          	pfd_split = 1;
   \                     ??RF_API_change_frequency_4: (+1)
   \       0x7C   0x2604             MOVS     R6,#+4
   1378              }
   1379            }
   1380          
   1381            priv_ST_MANUF_ReadRegisters(0x65, 1, tmp);
   \                     ??RF_API_change_frequency_5: (+1)
   \       0x7E   0xAA02             ADD      R2,SP,#+8
   \       0x80   0x2101             MOVS     R1,#+1
   \       0x82   0x2065             MOVS     R0,#+101
   \       0x84   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   1382            tmp[0] &= (~0x04);
   1383            tmp[0] |= (pfd_split<<2);
   \       0x88   0xAD02             ADD      R5,SP,#+8
   \       0x8A   0x7828             LDRB     R0,[R5, #+0]
   \       0x8C   0x21FB             MOVS     R1,#+251
   \       0x8E   0x4001             ANDS     R1,R1,R0
   \       0x90   0x430E             ORRS     R6,R6,R1
   \       0x92   0x702E             STRB     R6,[R5, #+0]
   1384            priv_ST_MANUF_WriteRegisters(0x65, 1, tmp);
   \       0x94   0xAA02             ADD      R2,SP,#+8
   \       0x96   0x2101             MOVS     R1,#+1
   \       0x98   0x2065             MOVS     R0,#+101
   \       0x9A   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1385          
   1386            tmp[0] = (((uint8_t)(synth>>24)) & 0x0F) | (cp_isel<<5);
   \       0x9E   0x0138             LSLS     R0,R7,#+4
   \       0xA0   0x0F00             LSRS     R0,R0,#+28
   \       0xA2   0x4304             ORRS     R4,R4,R0
   \       0xA4   0x702C             STRB     R4,[R5, #+0]
   1387            tmp[1] = (uint8_t)(synth>>16);
   \       0xA6   0x0C38             LSRS     R0,R7,#+16
   \       0xA8   0x7068             STRB     R0,[R5, #+1]
   1388            tmp[2] = (uint8_t)(synth>>8);
   \       0xAA   0x0A38             LSRS     R0,R7,#+8
   \       0xAC   0x70A8             STRB     R0,[R5, #+2]
   1389            tmp[3] = (uint8_t)synth;
   \       0xAE   0x70EF             STRB     R7,[R5, #+3]
   1390          
   1391            priv_ST_MANUF_WriteRegisters(0x05, 4, tmp);
   \       0xB0   0xAA02             ADD      R2,SP,#+8
   \       0xB2   0x2104             MOVS     R1,#+4
   \       0xB4   0x2005             MOVS     R0,#+5
   \       0xB6   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1392          
   1393            PRINTF("RF_API_change_frequency OUT (SYNT=0x%x)\n\r",synth);
   1394          
   1395            return SFX_ERR_NONE;
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0xB005             ADD      SP,SP,#+20
   \       0xBE   0xBDF0             POP      {R4-R7,PC}       ;; return
   1396          }
   1397          
   1398          /*!******************************************************************
   1399          * \fn sfx_u8 RF_API_wait_frame(sfx_u8 *frame, sfx_s16 *rssi, sfx_rx_state_enum_t * state)
   1400          * \brief Get all GFSK frames received in Rx buffer, structure of
   1401          * frame is : Synchro bit + Synchro frame + 15 Bytes.<BR> This function must
   1402          * be blocking state since data is received or timer of 25 s has elapsed.
   1403          *
   1404          * - If received buffer, function returns SFX_ERR_MANUF_NONE then the
   1405          *   library will try to decode frame. If the frame is not correct, the
   1406          *   library will recall RF_API_wait_frame .
   1407          *
   1408          * - If 25 seconds timer has elapsed, function returns
   1409          *   SFX_ERR_MANUF_WAIT_FRAME_TIMEOUT then library will stop receive
   1410          *   frame phase.
   1411          *
   1412          * \param[in] none
   1413          * \param[out] sfx_s8 *frame                  Receive buffer
   1414          * \param[out] sfx_s16 *rssi                  Chipset RSSI
   1415          * Warning: This is the 'raw' RSSI value. Do not add 100 as made
   1416          * in Library versions 1.x.x
   1417          * Resolution: 1 LSB = 1 dBm
   1418          *
   1419          * \param[out] sfx_rx_state_enum_t state      Indicate the final state of the reception. Value can be TIMEOUT or PASSED
   1420          *                                            if a frame has been received,  as per defined in sigfox_api.h file.
   1421          *
   1422          * \retval SFX_ERR_NONE:                      No error
   1423          * \retval RF_ERR_API_WAIT_FRAME_TIMEOUT:     Wait frame error
   1424          *******************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1425          sfx_u8 RF_API_wait_frame(sfx_u8 *frame, sfx_s16 *rssi, sfx_rx_state_enum_t * state)
   1426          {
   \                     RF_API_wait_frame: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   1427            sfx_u8 sync_detected=0;
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x700D             STRB     R5,[R1, #+0]
   \        0xA   0xA801             ADD      R0,SP,#+4
   \        0xC   0x6005             STR      R5,[R0, #0]
   1428            sfx_u8 n_bytes, tmp[4]={0,0,0,0};
   1429          
   1430            PRINTF("RF_API_wait_frame IN\n\r");
   1431          
   1432            /* enable the RX DATA READY interrupt */
   1433            tmp[3]=0x01;
   \        0xE   0x2601             MOVS     R6,#+1
   \       0x10   0xAF01             ADD      R7,SP,#+4
   \       0x12   0x70FE             STRB     R6,[R7, #+3]
   1434            /* enable the VALID SYNC interrupt */
   1435            tmp[2]=0x20;
   \       0x14   0x2020             MOVS     R0,#+32
   \       0x16   0x70B8             STRB     R0,[R7, #+2]
   1436            priv_ST_MANUF_WriteRegisters(0x50,4,tmp);
   \       0x18   0xAA01             ADD      R2,SP,#+4
   \       0x1A   0x2104             MOVS     R1,#+4
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1437          
   1438            /* GPIO configuration: IRQ on S2-LP pin */
   1439            tmp[0]=0x02;
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0x7038             STRB     R0,[R7, #+0]
   1440            priv_ST_MANUF_WriteRegisters(S2LP_GPIO_IRQ_PIN, 1, tmp);
   \       0x26   0xAA01             ADD      R2,SP,#+4
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x2003             MOVS     R0,#+3
   \       0x2C   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1441          
   1442            /* enable the GPIO interrupt on the MCU side - configure the MCU to sense the falling edge */
   1443            ST_MCU_API_GpioIRQ(SFX_TRUE, SFX_FALSE);
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0x....'....        BL       ST_MCU_API_GpioIRQ
   1444          
   1445            /* RX FIFO flush */
   1446            CMD_STROBE_FRX();
   \       0x38   0x2071             MOVS     R0,#+113
   \       0x3A   0x....'....        BL       priv_ST_MANUF_CmdStrobe
   1447          
   1448            /* cleanup the IRQ STATUS registers */
   1449            priv_ST_MANUF_ReadRegisters(0xFA,4,tmp);
   \       0x3E   0xAA01             ADD      R2,SP,#+4
   \       0x40   0x2104             MOVS     R1,#+4
   \       0x42   0x20FA             MOVS     R0,#+250
   \       0x44   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   1450          
   1451            /* cleanup the IRQ flag */
   1452            st_manuf_context->s2lp_irq_raised=0;
   \       0x48   0x....             LDR      R4,??DataTable18_1
   \       0x4A   0x2120             MOVS     R1,#+32
   \       0x4C   0x5465             STRB     R5,[R4, R1]
   1453          
   1454            /* set the manuf state to RX */
   1455            st_manuf_context->manuf_state=ST_MANUF_STATE_RX;
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0x2124             MOVS     R1,#+36
   \       0x52   0x5460             STRB     R0,[R4, R1]
   1456          
   1457            /* RX strobe command to the S2-LP */
   1458            ST_RF_API_StartRx();
   \       0x54   0x....'....        BL       ST_RF_API_StartRx
   \       0x58   0xE004             B        ??RF_API_wait_frame_0
   1459          
   1460            while((!st_manuf_context->api_timer_raised) || sync_detected)
   1461            {
   1462              /* hook the wait for interrupt function */
   1463              ST_MCU_API_WaitForInterrupt();
   1464          
   1465              if(st_manuf_context->s2lp_irq_raised)
   1466              {
   1467          	st_manuf_context->s2lp_irq_raised=0;
   1468          
   1469          	/* read the IRQ STATUS register */
   1470          	priv_ST_MANUF_ReadRegisters(0xFA,4,tmp);
   1471          
   1472          	/* check the RX_DATA_READY interrupt */
   1473          	if(tmp[3]&0x01)
   1474          	{
   1475          	  /* -> if we get here we have some data info the RX FIFO */
   1476          
   1477          	  /* read the num of bytes stored into the RX FIFO */
   1478          	  priv_ST_MANUF_ReadRegisters(0x90, 1, &n_bytes);
   1479          
   1480          	  /* read the data stored into the RX FIFO */
   1481          	  priv_ST_MANUF_ReadFifo(n_bytes,frame);
   1482          
   1483          	  /* read the RSSI value captured at the end of the SYNC word detection of the received packet */
   1484          	  priv_ST_MANUF_ReadRegisters(0xA2, 1, &st_manuf_context->last_rssi_reg);
   1485          
   1486          	  (*rssi)=((sfx_s8)st_manuf_context->last_rssi_reg)-146+st_manuf_context->rssi_offset;
   1487          
   1488          	  /* disable the interrupt on the MCU side */
   1489          	  ST_MCU_API_GpioIRQ(SFX_FALSE, SFX_FALSE);
   1490          
   1491          	  /* reset the ST_MANUF state to IDLE */
   1492          	  st_manuf_context->manuf_state=ST_MANUF_STATE_IDLE;
   1493          
   1494          	  /* reception succesful */
   1495          	  (*state) = DL_PASSED;
   1496          
   1497          	  PRINTF("RF_API_wait_frame OUT (ok)\n\r");
   1498          
   1499          	  return SFX_ERR_NONE;
   1500          	}
   1501          
   1502          	/* check the VALID_SYNC interrupt, this is needed to manage the case when
   1503          	the SYNC has been detected near the edge of the RX window */
   1504          	if(tmp[2]&0x20)
   \                     ??RF_API_wait_frame_1: (+1)
   \       0x5A   0x78B8             LDRB     R0,[R7, #+2]
   \       0x5C   0x0680             LSLS     R0,R0,#+26
   \       0x5E   0xD501             BPL      ??RF_API_wait_frame_0
   1505          	{
   1506          	  sync_detected=1;
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0x7006             STRB     R6,[R0, #+0]
   1507          
   1508          	  PRINTF("RF_API_wait_frame -> sync_detected\n\r");
   1509          	}
   \                     ??RF_API_wait_frame_0: (+1)
   \       0x64   0x2021             MOVS     R0,#+33
   \       0x66   0x5C20             LDRB     R0,[R4, R0]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD003             BEQ      ??RF_API_wait_frame_2
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x7800             LDRB     R0,[R0, #+0]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD035             BEQ      ??RF_API_wait_frame_3
   \                     ??RF_API_wait_frame_2: (+1)
   \       0x74   0x....'....        BL       ST_MCU_API_WaitForInterrupt
   \       0x78   0x2020             MOVS     R0,#+32
   \       0x7A   0x5C20             LDRB     R0,[R4, R0]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD0F1             BEQ      ??RF_API_wait_frame_0
   \       0x80   0x2120             MOVS     R1,#+32
   \       0x82   0x5465             STRB     R5,[R4, R1]
   \       0x84   0xAA01             ADD      R2,SP,#+4
   \       0x86   0x2104             MOVS     R1,#+4
   \       0x88   0x20FA             MOVS     R0,#+250
   \       0x8A   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   \       0x8E   0x78F8             LDRB     R0,[R7, #+3]
   \       0x90   0x07C0             LSLS     R0,R0,#+31
   \       0x92   0xD5E2             BPL      ??RF_API_wait_frame_1
   \       0x94   0x9F02             LDR      R7,[SP, #+8]
   \       0x96   0xAA00             ADD      R2,SP,#+0
   \       0x98   0x1C52             ADDS     R2,R2,#+1
   \       0x9A   0x2101             MOVS     R1,#+1
   \       0x9C   0x2090             MOVS     R0,#+144
   \       0x9E   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   \       0xA2   0x003A             MOVS     R2,R7
   \       0xA4   0x4668             MOV      R0,SP
   \       0xA6   0x7841             LDRB     R1,[R0, #+1]
   \       0xA8   0x20FF             MOVS     R0,#+255
   \       0xAA   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   \       0xAE   0x0022             MOVS     R2,R4
   \       0xB0   0x3210             ADDS     R2,R2,#+16
   \       0xB2   0x2101             MOVS     R1,#+1
   \       0xB4   0x20A2             MOVS     R0,#+162
   \       0xB6   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   \       0xBA   0x7C20             LDRB     R0,[R4, #+16]
   \       0xBC   0xB240             SXTB     R0,R0
   \       0xBE   0x2128             MOVS     R1,#+40
   \       0xC0   0x5661             LDRSB    R1,[R4, R1]
   \       0xC2   0x1840             ADDS     R0,R0,R1
   \       0xC4   0x3892             SUBS     R0,R0,#+146
   \       0xC6   0x9903             LDR      R1,[SP, #+12]
   \       0xC8   0x8008             STRH     R0,[R1, #+0]
   \       0xCA   0x2100             MOVS     R1,#+0
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0x....'....        BL       ST_MCU_API_GpioIRQ
   \       0xD2   0x2024             MOVS     R0,#+36
   \       0xD4   0x5425             STRB     R5,[R4, R0]
   \       0xD6   0x9804             LDR      R0,[SP, #+16]
   \       0xD8   0x7006             STRB     R6,[R0, #+0]
   \                     ??RF_API_wait_frame_4: (+1)
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0xB005             ADD      SP,SP,#+20
   \       0xDE   0xBDF0             POP      {R4-R7,PC}       ;; return
   1510              }
   1511            }
   1512          
   1513            /* stop the reception */
   1514            ST_RF_API_StopRxTx();
   \                     ??RF_API_wait_frame_3: (+1)
   \       0xE0   0x....'....        BL       ST_RF_API_StopRxTx
   1515          
   1516            /* disable the interrupt on the MCU side */
   1517            ST_MCU_API_GpioIRQ(SFX_FALSE, SFX_FALSE);
   \       0xE4   0x2100             MOVS     R1,#+0
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0x....'....        BL       ST_MCU_API_GpioIRQ
   1518          
   1519            /* reset the ST_MANUF state to IDLE */
   1520            st_manuf_context->manuf_state=ST_MANUF_STATE_IDLE;
   \       0xEC   0x2124             MOVS     R1,#+36
   \       0xEE   0x5465             STRB     R5,[R4, R1]
   1521          
   1522            (*state) = DL_TIMEOUT;
   \       0xF0   0x9804             LDR      R0,[SP, #+16]
   \       0xF2   0x7005             STRB     R5,[R0, #+0]
   1523          
   1524            PRINTF("RF_API_wait_frame OUT (fail)\n\r");
   1525          
   1526            /* reception failed due to RX timeout */
   1527            return SFX_ERR_NONE;
   \       0xF4   0xE7F1             B        ??RF_API_wait_frame_4
   1528          }
   1529          
   1530          /*!******************************************************************
   1531          * \fn sfx_u8 RF_API_wait_for_clear_channel (sfx_u8 cs_min, sfx_u8 cs_threshold, sfx_rx_state_enum_t * state);
   1532          * \brief This function is used in ARIB standard for the Listen Before Talk
   1533          *        feature. It listens on a specific frequency band initialized through the RF_API_init(), during a sliding window set
   1534          *        in the MCU_API_timer_start_carrier_sense().
   1535          *        If the channel is clear during the minimum carrier sense
   1536          *        value (cs_min), under the limit of the cs_threshold,
   1537          *        the functions returns with SFX_ERR_NONE (transmission
   1538          *        allowed). Otherwise it continues to listen to the channel till the expiration of the
   1539          *        carrier sense maximum window and then updates the state ( with timeout enum ).
   1540          *
   1541          * \param[in] none
   1542          * \param[out] sfx_u8 cs_min                  Minimum Carrier Sense time in ms.
   1543          * \param[out] sfx_s8 cs_threshold            Power threshold limit to declare the channel clear.
   1544          *                                            i.e : cs_threshold value -80dBm in Japan / -65dBm in Korea
   1545          * \param[out] sfx_rx_state_enum_t state      Indicate the final state of the carrier sense. Value can be DL_TIMEOUT or PASSED
   1546          *                                            as per defined in sigfox_api.h file.
   1547          *
   1548          * \retval SFX_ERR_NONE:                      No error
   1549          *******************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1550          sfx_u8 RF_API_wait_for_clear_channel(sfx_u8 cs_min, sfx_s8 cs_threshold, sfx_rx_state_enum_t * state)
   1551          {
   \                     RF_API_wait_for_clear_channel: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x6013             STR      R3,[R2, #0]
   1552            PRINTF("RF_API_wait_for_clear_channel IN (cs_min=%d, cs_thr=%d)\n\r", cs_min, cs_threshold);
   1553          
   1554            uint8_t tmp[4]={0,0,0,0};
   1555            uint32_t f_dig=privGetXtalFrequency();
   \        0x8   0x....             LDR      R5,??DataTable27
   \        0xA   0x69AE             LDR      R6,[R5, #+24]
   1556            if(f_dig>DIG_DOMAIN_XTAL_THRESH) {
   \        0xC   0x....             LDR      R2,??DataTable21  ;; 0x1c9c381
   \        0xE   0x4296             CMP      R6,R2
   \       0x10   0xD300             BCC      ??RF_API_wait_for_clear_channel_0
   1557              f_dig >>= 1;
   \       0x12   0x0876             LSRS     R6,R6,#+1
   \                     ??RF_API_wait_for_clear_channel_0: (+1)
   \       0x14   0x000C             MOVS     R4,R1
   \       0x16   0x0007             MOVS     R7,R0
   1558            }
   1559          
   1560            tmp[2]=0x40; /* RSSI_ABOVE_TH */
   \       0x18   0x2040             MOVS     R0,#+64
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x7088             STRB     R0,[R1, #+2]
   1561            tmp[0]=0x10; /* RX timeout */
   \       0x1E   0x2010             MOVS     R0,#+16
   \       0x20   0x7008             STRB     R0,[R1, #+0]
   1562          
   1563            priv_ST_MANUF_WriteRegisters(0x50,4,tmp);
   \       0x22   0x466A             MOV      R2,SP
   \       0x24   0x2104             MOVS     R1,#+4
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1564          
   1565            tmp[0]=0x02;
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0x7008             STRB     R0,[R1, #+0]
   1566            priv_ST_MANUF_WriteRegisters(S2LP_GPIO_IRQ_PIN, 1, tmp);
   \       0x32   0x466A             MOV      R2,SP
   \       0x34   0x2101             MOVS     R1,#+1
   \       0x36   0x2003             MOVS     R0,#+3
   \       0x38   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1567          
   1568            ST_MCU_API_GpioIRQ(SFX_TRUE, SFX_FALSE);
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x....'....        BL       ST_MCU_API_GpioIRQ
   1569          
   1570            /* RSSI threshold setting */
   1571            tmp[0]=(uint8_t)((sfx_s16)146+(sfx_s16)cs_threshold-st_manuf_context->rssi_offset-st_manuf_context->lbt_thr_offset);
   \       0x44   0x3C6E             SUBS     R4,R4,#+110
   \       0x46   0x2028             MOVS     R0,#+40
   \       0x48   0x5628             LDRSB    R0,[R5, R0]
   \       0x4A   0x1A20             SUBS     R0,R4,R0
   \       0x4C   0x2129             MOVS     R1,#+41
   \       0x4E   0x5669             LDRSB    R1,[R5, R1]
   \       0x50   0x1A40             SUBS     R0,R0,R1
   \       0x52   0x4669             MOV      R1,SP
   \       0x54   0x7008             STRB     R0,[R1, #+0]
   1572          
   1573            /* RSSI thr */
   1574            priv_ST_MANUF_WriteRegisters(0x18,1,tmp);
   \       0x56   0x466A             MOV      R2,SP
   \       0x58   0x2101             MOVS     R1,#+1
   \       0x5A   0x2018             MOVS     R0,#+24
   \       0x5C   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1575          
   1576            /* stop the timer at RSSI above THR */
   1577            tmp[0]=0x80;
   \       0x60   0x2080             MOVS     R0,#+128
   \       0x62   0x4669             MOV      R1,SP
   \       0x64   0x7008             STRB     R0,[R1, #+0]
   1578            priv_ST_MANUF_WriteRegisters(0x39,1,tmp);
   \       0x66   0x466A             MOV      R2,SP
   \       0x68   0x2101             MOVS     R1,#+1
   \       0x6A   0x2039             MOVS     R0,#+57
   \       0x6C   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1579          
   1580            /* set the RX timeout */
   1581            tmp[1]=(uint8_t)((((uint64_t)cs_min*f_dig/1000)/1210+1)/255);
   \       0x70   0x0038             MOVS     R0,R7
   \       0x72   0x2100             MOVS     R1,#+0
   \       0x74   0x0032             MOVS     R2,R6
   \       0x76   0x2300             MOVS     R3,#+0
   \       0x78   0x....'....        BL       __aeabi_lmul
   \       0x7C   0x22FA             MOVS     R2,#+250
   \       0x7E   0x0092             LSLS     R2,R2,#+2        ;; #+1000
   \       0x80   0x2300             MOVS     R3,#+0
   \       0x82   0x....'....        BL       __aeabi_uldivmod
   \       0x86   0x....             LDR      R2,??DataTable35  ;; 0x4ba
   \       0x88   0x2300             MOVS     R3,#+0
   \       0x8A   0x....'....        BL       __aeabi_uldivmod
   \       0x8E   0x0006             MOVS     R6,R0
   \       0x90   0x000F             MOVS     R7,R1
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x1C76             ADDS     R6,R6,#+1
   \       0x96   0x4147             ADCS     R7,R7,R0
   \       0x98   0x0030             MOVS     R0,R6
   \       0x9A   0x0039             MOVS     R1,R7
   \       0x9C   0x22FF             MOVS     R2,#+255
   \       0x9E   0x2300             MOVS     R3,#+0
   \       0xA0   0x....'....        BL       __aeabi_uldivmod
   \       0xA4   0x4669             MOV      R1,SP
   \       0xA6   0x7048             STRB     R0,[R1, #+1]
   1582            if(tmp[1]>1)
   \       0xA8   0x4668             MOV      R0,SP
   \       0xAA   0x7840             LDRB     R0,[R0, #+1]
   \       0xAC   0x2801             CMP      R0,#+1
   \       0xAE   0xDD01             BLE      ??RF_API_wait_for_clear_channel_1
   1583            {
   1584              tmp[1]--;
   \       0xB0   0x1E40             SUBS     R0,R0,#+1
   \       0xB2   0xE000             B        ??RF_API_wait_for_clear_channel_2
   1585            }
   1586            else
   1587            {
   1588              tmp[1]=1;
   \                     ??RF_API_wait_for_clear_channel_1: (+1)
   \       0xB4   0x2001             MOVS     R0,#+1
   \                     ??RF_API_wait_for_clear_channel_2: (+1)
   \       0xB6   0x7048             STRB     R0,[R1, #+1]
   1589            }
   1590          
   1591            tmp[0]=(uint8_t)((((uint64_t)cs_min*f_dig/1000)/1210+1)/(tmp[1]+1));
   \       0xB8   0x0030             MOVS     R0,R6
   \       0xBA   0x0039             MOVS     R1,R7
   \       0xBC   0x466A             MOV      R2,SP
   \       0xBE   0x7852             LDRB     R2,[R2, #+1]
   \       0xC0   0x1C52             ADDS     R2,R2,#+1
   \       0xC2   0x17D3             ASRS     R3,R2,#+31
   \       0xC4   0x....'....        BL       __aeabi_uldivmod
   \       0xC8   0x4669             MOV      R1,SP
   \       0xCA   0x7008             STRB     R0,[R1, #+0]
   1592          
   1593            PRINTF("REGISTER RXTIMERCNT=%d, PRESCALER=%d \n\r",tmp[0],tmp[1]);
   1594            priv_ST_MANUF_WriteRegisters(0x46,2,tmp);
   \       0xCC   0x466A             MOV      R2,SP
   \       0xCE   0x2102             MOVS     R1,#+2
   \       0xD0   0x2046             MOVS     R0,#+70
   \       0xD2   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1595          
   1596            st_manuf_context->manuf_state=ST_MANUF_STATE_WAIT_CLEAR_CH;
   \       0xD6   0x2004             MOVS     R0,#+4
   \       0xD8   0x2124             MOVS     R1,#+36
   \       0xDA   0x5468             STRB     R0,[R5, R1]
   1597          
   1598            (*state) = DL_PASSED;
   \       0xDC   0x2001             MOVS     R0,#+1
   \       0xDE   0x9902             LDR      R1,[SP, #+8]
   \       0xE0   0x7008             STRB     R0,[R1, #+0]
   \       0xE2   0x2400             MOVS     R4,#+0
   1599          
   1600            while(1)
   1601            {
   1602              CMD_STROBE_FRX();
   \                     ??RF_API_wait_for_clear_channel_3: (+1)
   \       0xE4   0x2071             MOVS     R0,#+113
   \       0xE6   0x....'....        BL       priv_ST_MANUF_CmdStrobe
   1603              /* clean the IRQ STATUS registers */
   1604              priv_ST_MANUF_ReadRegisters(0xFA,4,tmp);
   \       0xEA   0x466A             MOV      R2,SP
   \       0xEC   0x2104             MOVS     R1,#+4
   \       0xEE   0x20FA             MOVS     R0,#+250
   \       0xF0   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   1605              st_manuf_context->s2lp_irq_raised=0;
   \       0xF4   0x2120             MOVS     R1,#+32
   \       0xF6   0x546C             STRB     R4,[R5, R1]
   1606          
   1607              /* enter in RX through the RX command */
   1608              ST_RF_API_StartRx();
   \       0xF8   0x....'....        BL       ST_RF_API_StartRx
   \       0xFC   0xE001             B        ??RF_API_wait_for_clear_channel_4
   1609          
   1610              while(!(st_manuf_context->s2lp_irq_raised || st_manuf_context->api_timer_channel_clear_raised))
   1611              {
   1612          	ST_MCU_API_WaitForInterrupt();
   \                     ??RF_API_wait_for_clear_channel_5: (+1)
   \       0xFE   0x....'....        BL       ST_MCU_API_WaitForInterrupt
   1613              }
   \                     ??RF_API_wait_for_clear_channel_4: (+1)
   \      0x102   0x2020             MOVS     R0,#+32
   \      0x104   0x5C28             LDRB     R0,[R5, R0]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD103             BNE      ??RF_API_wait_for_clear_channel_6
   \      0x10A   0x2022             MOVS     R0,#+34
   \      0x10C   0x5C28             LDRB     R0,[R5, R0]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD0F5             BEQ      ??RF_API_wait_for_clear_channel_5
   1614              if(st_manuf_context->s2lp_irq_raised)
   \                     ??RF_API_wait_for_clear_channel_6: (+1)
   \      0x112   0x2020             MOVS     R0,#+32
   \      0x114   0x5C28             LDRB     R0,[R5, R0]
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD010             BEQ      ??RF_API_wait_for_clear_channel_7
   1615              {
   1616          	st_manuf_context->s2lp_irq_raised=0;
   \      0x11A   0x2120             MOVS     R1,#+32
   \      0x11C   0x546C             STRB     R4,[R5, R1]
   1617          
   1618          	/* read the IRQ STATUS registers */
   1619          	priv_ST_MANUF_ReadRegisters(0xFA,4,tmp);
   \      0x11E   0x466A             MOV      R2,SP
   \      0x120   0x2104             MOVS     R1,#+4
   \      0x122   0x20FA             MOVS     R0,#+250
   \      0x124   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   1620          
   1621          	/* check the IRQ_RSSI_ABOVE_TH flag */
   1622          	if(tmp[2]&0x40)
   \      0x128   0x4668             MOV      R0,SP
   \      0x12A   0x7881             LDRB     R1,[R0, #+2]
   \      0x12C   0x0649             LSLS     R1,R1,#+25
   \      0x12E   0xD502             BPL      ??RF_API_wait_for_clear_channel_8
   1623          	{
   1624          	  ST_RF_API_StopRxTx();
   \      0x130   0x....'....        BL       ST_RF_API_StopRxTx
   \      0x134   0xE002             B        ??RF_API_wait_for_clear_channel_7
   1625          	}
   1626          	/* check the IRQ_RX_TIMEOUT flag */
   1627          	else if(tmp[0]&0x10)
   \                     ??RF_API_wait_for_clear_channel_8: (+1)
   \      0x136   0x7800             LDRB     R0,[R0, #+0]
   \      0x138   0x06C0             LSLS     R0,R0,#+27
   \      0x13A   0xD414             BMI      ??RF_API_wait_for_clear_channel_9
   1628          	{
   1629          	  (*state) = DL_PASSED;
   1630          	  break;
   1631          	}
   1632              }
   1633              if(st_manuf_context->api_timer_channel_clear_raised)
   \                     ??RF_API_wait_for_clear_channel_7: (+1)
   \      0x13C   0x2022             MOVS     R0,#+34
   \      0x13E   0x5C28             LDRB     R0,[R5, R0]
   \      0x140   0x2800             CMP      R0,#+0
   \      0x142   0xD0CF             BEQ      ??RF_API_wait_for_clear_channel_3
   1634              {
   1635          	PRINTF("\t\t\t\t\t\t\t TIMEOUTn\r");
   1636          	st_manuf_context->api_timer_channel_clear_raised=0;
   \      0x144   0x2000             MOVS     R0,#+0
   \      0x146   0x2122             MOVS     R1,#+34
   \      0x148   0x5468             STRB     R0,[R5, R1]
   1637          	(*state) = DL_TIMEOUT;
   1638          	break;
   \                     ??RF_API_wait_for_clear_channel_10: (+1)
   \      0x14A   0x9902             LDR      R1,[SP, #+8]
   \      0x14C   0x7008             STRB     R0,[R1, #+0]
   1639              }
   1640            }
   1641          
   1642            if((*state) == DL_PASSED)
   \      0x14E   0x9802             LDR      R0,[SP, #+8]
   \      0x150   0x7800             LDRB     R0,[R0, #+0]
   \      0x152   0x2801             CMP      R0,#+1
   \      0x154   0xD109             BNE      ??RF_API_wait_for_clear_channel_11
   1643            {
   1644              tmp[3]=0x00;tmp[2]=0x00; /* DISABLE all IRQs */
   \      0x156   0x4668             MOV      R0,SP
   1645              tmp[1]=0x00;tmp[0]=0x00;
   \      0x158   0x6004             STR      R4,[R0, #+0]
   1646              priv_ST_MANUF_WriteRegisters(0x50,4,tmp);
   \      0x15A   0x466A             MOV      R2,SP
   \      0x15C   0x2104             MOVS     R1,#+4
   \      0x15E   0x2050             MOVS     R0,#+80
   \      0x160   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   \      0x164   0xE008             B        ??RF_API_wait_for_clear_channel_12
   1647            }
   \                     ??RF_API_wait_for_clear_channel_9: (+1)
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0xE7EF             B        ??RF_API_wait_for_clear_channel_10
   1648            else
   1649            {
   1650              ST_MCU_API_Shutdown(1);
   \                     ??RF_API_wait_for_clear_channel_11: (+1)
   \      0x16A   0x2001             MOVS     R0,#+1
   \      0x16C   0x....'....        BL       ST_MCU_API_Shutdown
   1651              MCU_API_timer_stop_carrier_sense();
   \      0x170   0x....'....        BL       MCU_API_timer_stop_carrier_sense
   1652              st_manuf_context->tx_is_ready=0;
   \      0x174   0x212A             MOVS     R1,#+42
   \      0x176   0x546C             STRB     R4,[R5, R1]
   1653            }
   1654            ST_MCU_API_GpioIRQ(SFX_FALSE, SFX_FALSE);
   \                     ??RF_API_wait_for_clear_channel_12: (+1)
   \      0x178   0x2100             MOVS     R1,#+0
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0x....'....        BL       ST_MCU_API_GpioIRQ
   1655          
   1656            st_manuf_context->manuf_state=ST_MANUF_STATE_IDLE;
   \      0x180   0x2024             MOVS     R0,#+36
   \      0x182   0x542C             STRB     R4,[R5, R0]
   1657          
   1658            PRINTF("RF_API_wait_for_clear_channel OUT (passed=%d)\n\r",(*state));
   1659          
   1660            return SFX_ERR_NONE;
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0xBDFE             POP      {R1-R7,PC}       ;; return
   1661          }
   1662          
   1663          /*!******************************************************************
   1664          * \fn sfx_u8 RF_API_get_version(sfx_u8 **version, sfx_u8 *size)
   1665          * \brief Returns current RF API version
   1666          *
   1667          * \param[out] sfx_u8 **version                 Pointer to Byte array (ASCII format) containing library version
   1668          * \param[out] sfx_u8 *size                     Size of the byte array pointed by *version
   1669          *
   1670          * \retval SFX_ERR_NONE:                No error
   1671          * \retval RF_ERR_API_GET_VERSION:      Get Version error
   1672          *******************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1673          sfx_u8 RF_API_get_version(sfx_u8 **version, sfx_u8 *size)
   1674          {
   1675            (*size) = ST_RF_API_VER_SIZE;
   \                     RF_API_get_version: (+1)
   \        0x0   0x2208             MOVS     R2,#+8
   \        0x2   0x700A             STRB     R2,[R1, #+0]
   1676            (*version) = (sfx_u8*)ST_RF_API_VER;
   \        0x4   0x....             ADR.N    R1,ST_RF_API_VER
   \        0x6   0x6001             STR      R1,[R0, #+0]
   1677          
   1678            return SFX_ERR_NONE;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR               ;; return
   1679          }
   1680          
   1681          /* This is the callback that notifies that the MCU timer called
   1682          *  by the MANUF_API_timer_start started/has expired. */

   \                                 In section .text, align 2, keep-with-next
   1683          void ST_RF_API_Timer_CB(sfx_u8 state)
   1684          {
   1685            st_manuf_context->api_timer_raised=state;
   \                     ST_RF_API_Timer_CB: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36
   \        0x2   0x7008             STRB     R0,[R1, #+0]
   1686          }
   \        0x4   0x4770             BX       LR               ;; return
   1687          
   1688          /* This is the callback that notifies that the MCU timer started
   1689          *  by the MANUF_API_timer_start has expired. */

   \                                 In section .text, align 2, keep-with-next
   1690          void ST_RF_API_Timer_Channel_Clear_CB(void)
   1691          {
   1692            st_manuf_context->api_timer_channel_clear_raised=1;
   \                     ST_RF_API_Timer_Channel_Clear_CB: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x....             LDR      R1,??DataTable36_1
   \        0x4   0x7008             STRB     R0,[R1, #+0]
   1693          }
   \        0x6   0x4770             BX       LR               ;; return
   1694          
   1695          /* This is the callback to be called each time an interrupt from S2-LP occurs */

   \                                 In section .text, align 4, keep-with-next
   1696          void ST_RF_API_S2LP_IRQ_CB(void)
   1697          {
   \                     ST_RF_API_S2LP_IRQ_CB: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1698            /* If we are not transmitting the current implementation manages the actions to do
   1699            *  with a flag (s2lp_irq_raised) that makes the functions waiting can be ticked on */
   1700            if((st_manuf_context->manuf_state!=ST_MANUF_STATE_TX) && (st_manuf_context->manuf_state!=ST_MANUF_STATE_MONARCH_SCAN))
   \        0x2   0x2501             MOVS     R5,#+1
   \        0x4   0x....             LDR      R4,??DataTable27
   \        0x6   0x2024             MOVS     R0,#+36
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD006             BEQ      ??ST_RF_API_S2LP_IRQ_CB_1
   \        0xE   0x2024             MOVS     R0,#+36
   \       0x10   0x5C20             LDRB     R0,[R4, R0]
   \       0x12   0x2805             CMP      R0,#+5
   \       0x14   0xD002             BEQ      ??ST_RF_API_S2LP_IRQ_CB_1
   1701            {
   1702              st_manuf_context->s2lp_irq_raised=1;
   \       0x16   0x2020             MOVS     R0,#+32
   \       0x18   0x5425             STRB     R5,[R4, R0]
   \                     ??ST_RF_API_S2LP_IRQ_CB_2: (+1)
   \       0x1A   0xBDF1             POP      {R0,R4-R7,PC}
   1703            }
   1704          #ifdef  MONARCH_FEATURE_ENABLED
   1705          #ifndef MONARCH_GPIO_SAMPLING
   1706            else if (st_manuf_context->manuf_state==ST_MANUF_STATE_MONARCH_SCAN)
   1707            {
   1708              ST_MONARCH_API_AFTHR_GPIO_CB();
   1709            }
   1710          #endif
   1711          #endif
   1712            else
   1713            {
   1714              /* If we are transmitting, we have to tick the state machine for transmission
   1715              so that the transmission actions (fill the TX FIFO according to the actual state)
   1716              are done in this same context.
   1717              The user can decide to call this function in the interrupt ISR or
   1718              in the ST_MCU_API_WaitForInterrupt() function. */
   1719              if (S2LPGetSpiInUse() == 0){
   \                     ??ST_RF_API_S2LP_IRQ_CB_1: (+1)
   \       0x1C   0x....'....        BL       S2LPGetSpiInUse
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD1FA             BNE      ??ST_RF_API_S2LP_IRQ_CB_2
   1720          	priv_ST_MANUF_Transmission_Tick();
   \       0x24   0x....             LDR      R1,??DataTable36_2
   \       0x26   0x708D             STRB     R5,[R1, #+2]
   \       0x28   0x88E0             LDRH     R0,[R4, #+6]
   \       0x2A   0x0023             MOVS     R3,R4
   \       0x2C   0x338A             ADDS     R3,R3,#+138
   \       0x2E   0x2707             MOVS     R7,#+7
   \       0x30   0x2608             MOVS     R6,#+8
   \       0x32   0x7821             LDRB     R1,[R4, #+0]
   \       0x34   0x1E89             SUBS     R1,R1,#+2
   \       0x36   0x2906             CMP      R1,#+6
   \       0x38   0xD813             BHI      ??ST_RF_API_S2LP_IRQ_CB_3
   \       0x3A   0xA201             ADR      R2,??ST_RF_API_S2LP_IRQ_CB_0
   \       0x3C   0x5C52             LDRB     R2,[R2, R1]
   \       0x3E   0x4497             ADD      PC,PC,R2
   \                     ??ST_RF_API_S2LP_IRQ_CB_0:
   \       0x40   0xC2 0x70          DC8      0xC2,0x70,0x9E,0x52

   \              0x9E 0x52
   \       0x44   0x34 0x22          DC8      0x34,0x22,0x6,0x0

   \              0x06 0x00
   \                     ??ST_RF_API_S2LP_IRQ_CB_4: (+1)
   \       0x48   0x....'....        BL       ST_RF_API_StopRxTx
   \       0x4C   0x2072             MOVS     R0,#+114
   \       0x4E   0x....'....        BL       priv_ST_MANUF_CmdStrobe
   \       0x52   0x2101             MOVS     R1,#+1
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x....'....        BL       ST_MCU_API_GpioIRQ
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x7020             STRB     R0,[R4, #+0]
   \       0x5E   0x2020             MOVS     R0,#+32
   \       0x60   0x5425             STRB     R5,[R4, R0]
   \                     ??ST_RF_API_S2LP_IRQ_CB_3: (+1)
   \       0x62   0xE068             B        ??ST_RF_API_S2LP_IRQ_CB_5
   \                     ??ST_RF_API_S2LP_IRQ_CB_6: (+1)
   \       0x64   0x2301             MOVS     R3,#+1
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0x31E8             ADDS     R1,R1,#+232
   \       0x6C   0x2042             MOVS     R0,#+66
   \       0x6E   0x....'....        BL       priv_ST_MANUF_SpiRaw_Ramp
   \       0x72   0x7026             STRB     R6,[R4, #+0]
   \       0x74   0xE05F             B        ??ST_RF_API_S2LP_IRQ_CB_5
   \                     ??ST_RF_API_S2LP_IRQ_CB_7: (+1)
   \       0x76   0x....             LDR      R5,??DataTable36_3
   \       0x78   0x....             LDR      R2,??DataTable36_2
   \       0x7A   0x0029             MOVS     R1,R5
   \       0x7C   0x2003             MOVS     R0,#+3
   \       0x7E   0x....'....        BL       priv_ST_MANUF_generateFIFORampsBuffer
   \       0x82   0x2301             MOVS     R3,#+1
   \       0x84   0x2200             MOVS     R2,#+0
   \       0x86   0x0029             MOVS     R1,R5
   \       0x88   0x....             LDR      R0,??DataTable36_2
   \       0x8A   0x7800             LDRB     R0,[R0, #+0]
   \       0x8C   0x....'....        BL       priv_ST_MANUF_SpiRaw_Ramp
   \       0x90   0x7027             STRB     R7,[R4, #+0]
   \       0x92   0xE050             B        ??ST_RF_API_S2LP_IRQ_CB_5
   \                     ??ST_RF_API_S2LP_IRQ_CB_8: (+1)
   \       0x94   0x....             LDR      R5,??DataTable36_3
   \       0x96   0x....             LDR      R2,??DataTable36_2
   \       0x98   0x0029             MOVS     R1,R5
   \       0x9A   0x2002             MOVS     R0,#+2
   \       0x9C   0x....'....        BL       priv_ST_MANUF_generateFIFORampsBuffer
   \       0xA0   0x2301             MOVS     R3,#+1
   \       0xA2   0x2200             MOVS     R2,#+0
   \       0xA4   0x0029             MOVS     R1,R5
   \       0xA6   0x....             LDR      R0,??DataTable36_2
   \       0xA8   0x7800             LDRB     R0,[R0, #+0]
   \       0xAA   0x....'....        BL       priv_ST_MANUF_SpiRaw_Ramp
   \       0xAE   0x2006             MOVS     R0,#+6
   \       0xB0   0xE040             B        ??ST_RF_API_S2LP_IRQ_CB_9
   \                     ??ST_RF_API_S2LP_IRQ_CB_10: (+1)
   \       0xB2   0x68A1             LDR      R1,[R4, #+8]
   \       0xB4   0x88A2             LDRH     R2,[R4, #+4]
   \       0xB6   0x5C89             LDRB     R1,[R1, R2]
   \       0xB8   0x40C1             LSRS     R1,R1,R0
   \       0xBA   0x400D             ANDS     R5,R5,R1
   \       0xBC   0x0028             MOVS     R0,R5
   \       0xBE   0x....'....        BL       priv_ST_MANUF_tx_rf_dbpsk_single_bit
   \       0xC2   0x88E0             LDRH     R0,[R4, #+6]
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD11A             BNE      ??ST_RF_API_S2LP_IRQ_CB_11
   \       0xC8   0x80E7             STRH     R7,[R4, #+6]
   \       0xCA   0x88A0             LDRH     R0,[R4, #+4]
   \       0xCC   0x1C40             ADDS     R0,R0,#+1
   \       0xCE   0x80A0             STRH     R0,[R4, #+4]
   \       0xD0   0x8861             LDRH     R1,[R4, #+2]
   \       0xD2   0xB280             UXTH     R0,R0
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xD12E             BNE      ??ST_RF_API_S2LP_IRQ_CB_5
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0x80A0             STRH     R0,[R4, #+4]
   \       0xDC   0x2005             MOVS     R0,#+5
   \       0xDE   0xE029             B        ??ST_RF_API_S2LP_IRQ_CB_9
   \                     ??ST_RF_API_S2LP_IRQ_CB_12: (+1)
   \       0xE0   0x89A1             LDRH     R1,[R4, #+12]
   \       0xE2   0x40C1             LSRS     R1,R1,R0
   \       0xE4   0x400D             ANDS     R5,R5,R1
   \       0xE6   0x0028             MOVS     R0,R5
   \       0xE8   0x....'....        BL       priv_ST_MANUF_tx_rf_dbpsk_single_bit
   \       0xEC   0x88E0             LDRH     R0,[R4, #+6]
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD105             BNE      ??ST_RF_API_S2LP_IRQ_CB_11
   \       0xF2   0x80E6             STRH     R6,[R4, #+6]
   \       0xF4   0x89A0             LDRH     R0,[R4, #+12]
   \       0xF6   0x....'....        BL       pn9_next_byte
   \       0xFA   0x81A0             STRH     R0,[R4, #+12]
   \       0xFC   0xE01B             B        ??ST_RF_API_S2LP_IRQ_CB_5
   \                     ??ST_RF_API_S2LP_IRQ_CB_11: (+1)
   \       0xFE   0x1E40             SUBS     R0,R0,#+1
   \      0x100   0x80E0             STRH     R0,[R4, #+6]
   \      0x102   0xE018             B        ??ST_RF_API_S2LP_IRQ_CB_5
   \                     ??ST_RF_API_S2LP_IRQ_CB_13: (+1)
   \      0x104   0x....             LDR      R2,??DataTable36_2
   \      0x106   0x0021             MOVS     R1,R4
   \      0x108   0x3194             ADDS     R1,R1,#+148
   \      0x10A   0x2005             MOVS     R0,#+5
   \      0x10C   0x....'....        BL       priv_ST_MANUF_generateFIFORampsBuffer
   \      0x110   0x2301             MOVS     R3,#+1
   \      0x112   0x2200             MOVS     R2,#+0
   \      0x114   0x0021             MOVS     R1,R4
   \      0x116   0x3194             ADDS     R1,R1,#+148
   \      0x118   0x....             LDR      R0,??DataTable36_2
   \      0x11A   0x7800             LDRB     R0,[R0, #+0]
   \      0x11C   0x....'....        BL       priv_ST_MANUF_SpiRaw_Ramp
   \      0x120   0x7BA0             LDRB     R0,[R4, #+14]
   \      0x122   0x2801             CMP      R0,#+1
   \      0x124   0xD102             BNE      ??ST_RF_API_S2LP_IRQ_CB_14
   \      0x126   0x80E6             STRH     R6,[R4, #+6]
   \      0x128   0x2004             MOVS     R0,#+4
   \      0x12A   0xE003             B        ??ST_RF_API_S2LP_IRQ_CB_9
   \                     ??ST_RF_API_S2LP_IRQ_CB_14: (+1)
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0x80A0             STRH     R0,[R4, #+4]
   \      0x130   0x80E7             STRH     R7,[R4, #+6]
   \      0x132   0x2003             MOVS     R0,#+3
   \                     ??ST_RF_API_S2LP_IRQ_CB_9: (+1)
   \      0x134   0x7020             STRB     R0,[R4, #+0]
   1721          	_s2lpFIFOState = ST_FIFO_STATE_WAITING_UNDERFLOW;
   \                     ??ST_RF_API_S2LP_IRQ_CB_5: (+1)
   \      0x136   0x2000             MOVS     R0,#+0
   \      0x138   0x....             LDR      R1,??DataTable36_2
   \      0x13A   0x7088             STRB     R0,[R1, #+2]
   1722              }
   1723            }
   1724          }
   \                     ??ST_RF_API_S2LP_IRQ_CB_15: (+1)
   \      0x13C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1725          
   1726          /* RSSI offset as param */

   \                                 In section .text, align 2, keep-with-next
   1727          sfx_u8 ST_RF_API_set_rssi_offset(int8_t rssi_off)
   1728          {
   1729            st_manuf_context->rssi_offset=rssi_off;
   \                     ST_RF_API_set_rssi_offset: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36_4
   \        0x2   0x7008             STRB     R0,[R1, #+0]
   1730          
   1731            return SFX_ERR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
   1732          }
   1733          

   \                                 In section .text, align 2, keep-with-next
   1734          sfx_u8 ST_RF_API_get_rssi_offset(int8_t *rssi_off)
   1735          {
   1736            (*rssi_off)=st_manuf_context->rssi_offset;
   \                     ST_RF_API_get_rssi_offset: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36_4
   \        0x2   0x....             B.N      ?Subroutine0
   1737          
   1738            return SFX_ERR_NONE;
   1739          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x7809             LDRB     R1,[R1, #+0]
   \        0x2   0x7001             STRB     R1,[R0, #+0]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
   1740          
   1741          /* XTAL FREQ as param */

   \                                 In section .text, align 2, keep-with-next
   1742          sfx_u8 ST_RF_API_set_xtal_freq(sfx_u32 xtal)
   1743          {
   1744            st_manuf_context->priv_xtal_freq = xtal;
   \                     ST_RF_API_set_xtal_freq: (+1)
   \        0x0   0x....             LDR      R1,??DataTable27
   \        0x2   0x6188             STR      R0,[R1, #+24]
   1745          
   1746            return SFX_ERR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
   1747          }
   1748          

   \                                 In section .text, align 2, keep-with-next
   1749          sfx_u8 ST_RF_API_get_xtal_freq(sfx_u32 *xtal)
   1750          {
   1751            (*xtal)=st_manuf_context->priv_xtal_freq;
   \                     ST_RF_API_get_xtal_freq: (+1)
   \        0x0   0x....             LDR      R1,??DataTable27
   \        0x2   0x6989             LDR      R1,[R1, #+24]
   \        0x4   0x6001             STR      R1,[R0, #+0]
   1752          
   1753            return SFX_ERR_NONE;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x4770             BX       LR               ;; return
   1754          }
   1755          
   1756          /* LBT offset as param */

   \                                 In section .text, align 2, keep-with-next
   1757          sfx_u8 ST_RF_API_set_lbt_thr_offset(sfx_s8 lbt_thr_off)
   1758          {
   1759            st_manuf_context->lbt_thr_offset=lbt_thr_off;
   \                     ST_RF_API_set_lbt_thr_offset: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36_5
   \        0x2   0x7008             STRB     R0,[R1, #+0]
   1760          
   1761            return SFX_ERR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
   1762          }
   1763          

   \                                 In section .text, align 2, keep-with-next
   1764          sfx_u8 ST_RF_API_get_lbt_thr_offset(sfx_s8 *lbt_thr_off)
   1765          {
   1766            (*lbt_thr_off)=st_manuf_context->lbt_thr_offset;
   \                     ST_RF_API_get_lbt_thr_offset: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36_5
   \        0x2                      REQUIRE ?Subroutine0
   \        0x2                      ;; // Fall through to label ?Subroutine0
   1767          
   1768            return SFX_ERR_NONE;
   1769          }
   1770          

   \                                 In section .text, align 2, keep-with-next
   1771          sfx_u8 ST_RF_API_reduce_output_power(int16_t reduction)
   1772          {
   1773          //  if((int16_t)st_manuf_context->bpsk_ramps->fifo_ramp_fast[3]+reduction<st_manuf_context->ramps_settings->max_power)
   1774          //  {}//return ST_MANUF_POWER_ERROR;
   1775          
   1776            st_manuf_context->power_reduction=reduction;
   \                     ST_RF_API_reduce_output_power: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36_6
   \        0x2   0x84C8             STRH     R0,[R1, #+38]
   1777          
   1778            return SFX_ERR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
   1779          }
   1780          

   \                                 In section .text, align 2, keep-with-next
   1781          sfx_u8 ST_RF_API_set_tcxo(sfx_u8 tcxo)
   1782          {
   1783            st_manuf_context->tcxo_flag=tcxo;
   \                     ST_RF_API_set_tcxo: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36_6
   \        0x2   0x7748             STRB     R0,[R1, #+29]
   1784          
   1785            return SFX_ERR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
   1786          }
   1787          

   \                                 In section .text, align 2, keep-with-next
   1788          sfx_u8 ST_RF_API_set_pa(sfx_u8 pa)
   1789          {
   1790            st_manuf_context->pa_flag=pa;
   \                     ST_RF_API_set_pa: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36_6
   \        0x2   0x7788             STRB     R0,[R1, #+30]
   1791          
   1792            return SFX_ERR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
   1793          }
   1794          

   \                                 In section .text, align 2, keep-with-next
   1795          sfx_u8 ST_RF_API_get_ramp_duration(void)
   1796          {
   1797            return st_manuf_context->ramps_settings.ramp_start_duration;
   \                     ST_RF_API_get_ramp_duration: (+1)
   \        0x0   0x....             LDR      R0,??DataTable36_7
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   1798          }
   1799          

   \                                 In section .text, align 2, keep-with-next
   1800          sfx_u8 ST_RF_API_smps(uint8_t mode)
   1801          {
   1802            st_manuf_context->smps_mode=mode;
   \                     ST_RF_API_smps: (+1)
   \        0x0   0x....             LDR      R1,??DataTable36_6
   \        0x2   0x7708             STRB     R0,[R1, #+28]
   1803          
   1804            return SFX_ERR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
   1805          }
   1806          

   \                                 In section .text, align 2, keep-with-next
   1807          sfx_u8 ST_RF_API_Get_Continuous_TX_or_MONARCH_Scan_Flag(void)
   1808          {
   1809            return (sfx_u8) st_manuf_context->tx_packet_struct.continuous_tx_monarch_flag;
   \                     ST_RF_API_Get_Continuous_TX_or_MONARCH_Scan_Flag: (+1)
   \        0x0   0x....             LDR      R0,??DataTable36_6
   \        0x2   0x7B80             LDRB     R0,[R0, #+14]
   \        0x4   0x4770             BX       LR               ;; return
   1810          }
   1811          

   \                                 In section .text, align 2, keep-with-next
   1812          sfx_u8 ST_RF_API_StartTx(void)
   1813          {
   \                     ST_RF_API_StartTx: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1814            /*Configure External FE module*/
   1815            if (st_manuf_context->pa_flag == 0)
   \        0x2   0x....             LDR      R0,??DataTable36_6
   \        0x4   0x7F80             LDRB     R0,[R0, #+30]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD101             BNE      ??ST_RF_API_StartTx_0
   1816              FEM_Operation(FEM_TX_BYPASS);
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B        ??ST_RF_API_StartTx_1
   1817            else
   1818              FEM_Operation(FEM_TX);
   \                     ??ST_RF_API_StartTx_0: (+1)
   \        0xE   0x2002             MOVS     R0,#+2
   \                     ??ST_RF_API_StartTx_1: (+1)
   \       0x10   0x....'....        BL       FEM_Operation
   1819          
   1820            /*Put S2LP in TX*/
   1821            CMD_STROBE_TX();
   \       0x14   0x2060             MOVS     R0,#+96
   \       0x16   0x....             B.N      ?Subroutine1
   1822            return SFX_ERR_NONE;
   1823          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....'....        BL       priv_ST_MANUF_CmdStrobe
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD02             POP      {R1,PC}          ;; return
   1824          

   \                                 In section .text, align 2, keep-with-next
   1825          sfx_u8 ST_RF_API_StartRx(void)
   1826          {
   \                     ST_RF_API_StartRx: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1827            /*Configure External FE module in RX*/
   1828            FEM_Operation(FEM_RX);
   \        0x2   0x2003             MOVS     R0,#+3
   \        0x4   0x....'....        BL       FEM_Operation
   1829            /*Put S2LP in RX*/
   1830            CMD_STROBE_RX();
   \        0x8   0x2061             MOVS     R0,#+97
   \        0xA                      REQUIRE ?Subroutine1
   \        0xA                      ;; // Fall through to label ?Subroutine1
   1831            return SFX_ERR_NONE;
   1832          }
   1833          

   \                                 In section .text, align 2, keep-with-next
   1834          sfx_u8 ST_RF_API_StopRxTx(void)
   1835          {
   \                     ST_RF_API_StopRxTx: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1836            /*Put S2LP in READY*/
   1837            CMD_STROBE_SABORT();
   \        0x2   0x2067             MOVS     R0,#+103
   \        0x4   0x....'....        BL       priv_ST_MANUF_CmdStrobe
   1838          
   1839            /*Configure External FE module in RX*/
   1840            FEM_Operation(FEM_SHUTDOWN);
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x....'....        BL       FEM_Operation
   1841          
   1842            return SFX_ERR_NONE;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
   1843          }
   1844          

   \                                 In section .text, align 2, keep-with-next
   1845          sfx_s16 ST_RF_API_GetRSSI(void)
   1846          {
   \                     ST_RF_API_GetRSSI: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1847            sfx_u8  last_rssi;
   1848            /* Read the RSSI value captured at the end of the SYNC word detection of the received packet */
   1849            priv_ST_MANUF_ReadRegisters(0xA2, 1, &last_rssi); //RSSI_REG
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x20A2             MOVS     R0,#+162
   \        0x8   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   1850            return (sfx_s16) (last_rssi-146+st_manuf_context->rssi_offset-6);
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0x....             LDR      R1,??DataTable36_6
   \       0x12   0x2228             MOVS     R2,#+40
   \       0x14   0x5689             LDRSB    R1,[R1, R2]
   \       0x16   0x1840             ADDS     R0,R0,R1
   \       0x18   0x3898             SUBS     R0,R0,#+152
   \       0x1A   0xB200             SXTH     R0,R0
   \       0x1C   0xBD02             POP      {R1,PC}          ;; return
   1851          }
   1852          
   1853          /* Retrieve FIFO data */

   \                                 In section .text, align 2, keep-with-next
   1854          void ST_RF_API_ReadFifo(sfx_u8 n_bytes, sfx_u8* buffer, sfx_u8 flush )
   1855          {
   \                     ST_RF_API_ReadFifo: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0014             MOVS     R4,R2
   1856            /* Read the num of bytes stored into the RX FIFO */
   1857            priv_ST_MANUF_ReadFifo(n_bytes, buffer);
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0x0001             MOVS     R1,R0
   \        0x8   0x20FF             MOVS     R0,#+255
   \        0xA   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   1858          
   1859            if (flush)
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD002             BEQ      ??ST_RF_API_ReadFifo_0
   1860              CMD_STROBE_FRX();
   \       0x12   0x2071             MOVS     R0,#+113
   \       0x14   0x....'....        BL       priv_ST_MANUF_CmdStrobe
   1861          }
   \                     ??ST_RF_API_ReadFifo_0: (+1)
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
   1862          
   1863          /* Retrieve FIFO data */

   \                                 In section .text, align 2, keep-with-next
   1864          sfx_u8 ST_RF_API_ReadFifoBytes()
   1865          {
   \                     ST_RF_API_ReadFifoBytes: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1866            /* Read the num of bytes stored into the RX FIFO */
   1867            sfx_u8 occuped_slot;
   1868            priv_ST_MANUF_ReadRegisters(0x90, 1, &occuped_slot);
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2090             MOVS     R0,#+144
   \        0x8   0x....'....        BL       priv_ST_MANUF_ReadRegisters
   1869          
   1870            return occuped_slot;
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
   1871          }
   1872          

   \                                 In section .text, align 2, keep-with-next
   1873          void ST_RF_API_SetFifoLength(sfx_u8 n_bytes)
   1874          {
   \                     ST_RF_API_SetFifoLength: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1875            // Set the almost full threshold (It starts form the top of the fifo)
   1876            sfx_u8 reg=128-n_bytes;
   \        0x2   0x2180             MOVS     R1,#+128
   \        0x4   0x1A08             SUBS     R0,R1,R0
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x7008             STRB     R0,[R1, #+0]
   1877          
   1878            priv_ST_MANUF_WriteRegisters(0x3C,1, &reg); //FIFO_CONFIG3
   \        0xA   0x466A             MOV      R2,SP
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x203C             MOVS     R0,#+60
   \       0x10   0x....'....        BL       priv_ST_MANUF_WriteRegisters
   1879          
   1880            CMD_STROBE_FRX(); /*Flush fifo after threshold setting*/
   \       0x14   0x2071             MOVS     R0,#+113
   \       0x16   0x....'....        BL       priv_ST_MANUF_CmdStrobe
   1881          }
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
   1882          
   1883          /* Monarch weak functions */
   1884          

   \                                 In section .text, align 2
   1885          __weak sfx_u8 MONARCH_API_malloc(sfx_u16 size, sfx_u8 **returned_pointer) { return MONARCH_ERR_API_MALLOC; }
   \                     MONARCH_API_malloc: (+1)
   \        0x0   0x2080             MOVS     R0,#+128
   \        0x2   0x4770             BX       LR               ;; return
   1886          

   \                                 In section .text, align 2
   1887          __weak sfx_u8 MONARCH_API_free(sfx_u8 *ptr) { return MONARCH_ERR_API_FREE; }
   \                     MONARCH_API_free: (+1)
   \        0x0   0x2081             MOVS     R0,#+129
   \        0x2   0x4770             BX       LR               ;; return
   1888          

   \                                 In section .text, align 2
   1889          __weak sfx_u8 MONARCH_API_timer_start (sfx_u16 timer_value, sfx_timer_unit_enum_t unit, sfx_error_t(* timeout_callback_handler)(void)) { return MONARCH_ERR_API_TIMER_START; }
   \                     MONARCH_API_timer_start: (+1)
   \        0x0   0x2082             MOVS     R0,#+130
   \        0x2   0x4770             BX       LR               ;; return
   1890          

   \                                 In section .text, align 2
   1891          __weak sfx_u8 MONARCH_API_timer_stop (void) { return SFX_ERR_API_GET_VERSION; }
   \                     MONARCH_API_timer_stop: (+1)
   \        0x0   0x205C             MOVS     R0,#+92
   \        0x2   0x4770             BX       LR               ;; return
   1892          

   \                                 In section .text, align 2
   1893          __weak sfx_u8 MONARCH_API_configure_search_pattern ( sfx_monarch_pattern_search_t list_freq_pattern[],
   1894          								    sfx_u8 size,
   1895          								    sfx_monarch_listening_mode_t mode,
   1896          								    sfx_error_t(* monarch_pattern_freq_result_callback_handler)(sfx_u32 freq, sfx_pattern_enum_t pattern, sfx_s16 rssi)){ return MONARCH_ERR_API_CONFIGURE_SEARCH_PATTERN; }
   \                     MONARCH_API_configure_search_pattern: (+1)
   \        0x0   0x2084             MOVS     R0,#+132
   \        0x2   0x4770             BX       LR               ;; return
   1897          

   \                                 In section .text, align 2
   1898          __weak sfx_u8 MONARCH_API_stop_search_pattern(void) { return MONARCH_ERR_API_STOP_SEARCH_PATTERN; }
   \                     MONARCH_API_stop_search_pattern: (+1)
   \        0x0   0x2085             MOVS     R0,#+133
   \        0x2   0x4770             BX       LR               ;; return
   1899          

   \                                 In section .text, align 2
   1900          __weak sfx_u8 MONARCH_API_get_version(sfx_u8 **version, sfx_u8 *size) { return MONARCH_ERR_API_TIMER_STOP; }
   \                     MONARCH_API_get_version: (+1)
   \        0x0   0x2083             MOVS     R0,#+131
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     st_manuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     st_manuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x01C9'C381        DC32     0x1c9c381

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0001'0001        DC32     0x10001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0xFFFF'FE0C        DC32     0xfffffe0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x0175'D721        DC32     0x175d721

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x0000'02EE        DC32     0x2ee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0xFFFF'FD12        DC32     0xfffffd12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0xFFFF'FE89        DC32     0xfffffe89

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x02E4'0D20        DC32     0x2e40d20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x....'....        DC32     st_manuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     st_manuf+0x8A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x....'....        DC32     bfSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x01C9'C380        DC32     0x1c9c380

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 15

   \              0x00 0x00    

   \              0x0F
   \        0x5                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xB774'0000        DC32     0xb7740000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x0001'0001        DC32     0x10001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0xFFFF'FDA8        DC32     0xfffffda8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x0175'D721        DC32     0x175d721

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     bfSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x....'....        DC32     st_manuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x0000'01FF        DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x01C9'C381        DC32     0x1c9c381

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0xD693'A400        DC32     0xd693a400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     st_manuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \        0x0   0x0000'04BA        DC32     0x4ba

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \        0x0   0x....'....        DC32     st_manuf+0x21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \        0x0   0x....'....        DC32     st_manuf+0x22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_2:
   \        0x0   0x....'....        DC32     bfSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_3:
   \        0x0   0x....'....        DC32     st_manuf+0x94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_4:
   \        0x0   0x....'....        DC32     st_manuf+0x28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_5:
   \        0x0   0x....'....        DC32     st_manuf+0x29

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_6:
   \        0x0   0x....'....        DC32     st_manuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_7:
   \        0x0   0x....'....        DC32     st_manuf+0x8C

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x01 0x01          DC8 1, 1, 2, 2, 3, 4, 6, 8, 11, 14, 19, 23, 27, 31, 44, 220

   \              0x02 0x02    

   \              0x03 0x04    

   \              0x06 0x08    

   \              0x0B 0x0E    

   \              0x13 0x17    

   \              0x1B 0x1F    

   \              0x2C 0xDC

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x08 0x08          DC8 8, 8, 9, 9, 10, 10, 11, 11, 13, 13, 15, 16, 17, 18, 20, 22, 24, 26

   \              0x09 0x09    

   \              0x0A 0x0A    

   \              0x0B 0x0B    

   \              0x0D 0x0D    

   \              0x0F 0x10    

   \              0x11 0x12    

   \              0x14 0x16    

   \              0x18 0x1A
   \       0x12   0x1F 0x23          DC8 31, 35, 40, 45, 51, 60, 67, 70, 80

   \              0x28 0x2D    

   \              0x33 0x3C    

   \              0x43 0x46    

   \              0x50
   \       0x1B                      DS8 1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MONARCH_API_configure_search_pattern
       0   MONARCH_API_free
       0   MONARCH_API_get_version
       0   MONARCH_API_malloc
       0   MONARCH_API_stop_search_pattern
       0   MONARCH_API_timer_start
       0   MONARCH_API_timer_stop
      40   RF_API_change_frequency
        40   -> priv_ST_MANUF_ReadRegisters
        40   -> priv_ST_MANUF_WriteRegisters
        40 __aeabi_lmul
        40 __aeabi_uldivmod
       0   RF_API_get_version
      64   RF_API_init
        64   -> ST_MCU_API_GpioIRQ
        64   -> ST_MCU_API_Shutdown
        64   -> ST_RF_API_custom_setting
        64   -> priv_ST_MANUF_Get_Ramps_Settings
        64   -> priv_ST_MANUF_ReadRegisters
        64   -> priv_ST_MANUF_WriteRegisters
        64 __aeabi_lmul
        64 __aeabi_uidiv
        64 __aeabi_uldivmod
      24   RF_API_send
        24   -> ST_MCU_API_WaitForInterrupt
        24   -> ST_RF_API_StartTx
        24   -> priv_ST_MANUF_rf_load_first_ramp_up
        24   -> priv_ST_MANUF_tx_rf_dbpsk_init
      24   RF_API_start_continuous_transmission
        24   -> ST_MCU_API_GpioIRQ
        24   -> ST_RF_API_StartTx
        24   -> priv_ST_MANUF_ReadRegisters
        24   -> priv_ST_MANUF_WriteRegisters
        24   -> priv_ST_MANUF_rf_load_first_ramp_up
        24   -> priv_ST_MANUF_tx_rf_dbpsk_init
       8   RF_API_stop
         8   -> ST_MCU_API_Shutdown
         8   -> ST_RF_API_StopRxTx
       8   RF_API_stop_continuous_transmission
         8   -> ST_MCU_API_GpioIRQ
         8   -> ST_RF_API_StopRxTx
      32   RF_API_wait_for_clear_channel
        32   -> MCU_API_timer_stop_carrier_sense
        32   -> ST_MCU_API_GpioIRQ
        32   -> ST_MCU_API_Shutdown
        32   -> ST_MCU_API_WaitForInterrupt
        32   -> ST_RF_API_StartRx
        32   -> ST_RF_API_StopRxTx
        32   -> priv_ST_MANUF_CmdStrobe
        32   -> priv_ST_MANUF_ReadRegisters
        32   -> priv_ST_MANUF_WriteRegisters
        32 __aeabi_lmul
        32 __aeabi_uldivmod
      40   RF_API_wait_frame
        40   -> ST_MCU_API_GpioIRQ
        40   -> ST_MCU_API_WaitForInterrupt
        40   -> ST_RF_API_StartRx
        40   -> ST_RF_API_StopRxTx
        40   -> priv_ST_MANUF_CmdStrobe
        40   -> priv_ST_MANUF_ReadRegisters
        40   -> priv_ST_MANUF_WriteRegisters
       0   ST_RF_API_GetFIFOState
       8   ST_RF_API_GetRSSI
         8   -> priv_ST_MANUF_ReadRegisters
       0   ST_RF_API_Get_Continuous_TX_or_MONARCH_Scan_Flag
       8   ST_RF_API_ReadFifo
         8   -> priv_ST_MANUF_CmdStrobe
         8   -> priv_ST_MANUF_ReadRegisters
       8   ST_RF_API_ReadFifoBytes
         8   -> priv_ST_MANUF_ReadRegisters
      24   ST_RF_API_S2LP_IRQ_CB
        24   -> S2LPGetSpiInUse
        24   -> ST_MCU_API_GpioIRQ
        24   -> ST_RF_API_StopRxTx
        24   -> pn9_next_byte
        24   -> priv_ST_MANUF_CmdStrobe
        24   -> priv_ST_MANUF_SpiRaw_Ramp
        24   -> priv_ST_MANUF_generateFIFORampsBuffer
        24   -> priv_ST_MANUF_tx_rf_dbpsk_single_bit
       8   ST_RF_API_SetFifoLength
         8   -> priv_ST_MANUF_CmdStrobe
         8   -> priv_ST_MANUF_WriteRegisters
       8   ST_RF_API_StartRx
         8   -> FEM_Operation
         8   -> priv_ST_MANUF_CmdStrobe
       8   ST_RF_API_StartTx
         8   -> FEM_Operation
         8   -> priv_ST_MANUF_CmdStrobe
       8   ST_RF_API_StopRxTx
         8   -> FEM_Operation
         8   -> priv_ST_MANUF_CmdStrobe
       0   ST_RF_API_Timer_CB
       0   ST_RF_API_Timer_Channel_Clear_CB
       0   ST_RF_API_custom_setting
       0   ST_RF_API_get_lbt_thr_offset
       0   ST_RF_API_get_ramp_duration
       0   ST_RF_API_get_rssi_offset
       0   ST_RF_API_get_xtal_freq
       0   ST_RF_API_reduce_output_power
       0   ST_RF_API_set_lbt_thr_offset
       0   ST_RF_API_set_pa
       0   ST_RF_API_set_rssi_offset
       0   ST_RF_API_set_tcxo
       0   ST_RF_API_set_xtal_freq
       0   ST_RF_API_smps
       0   pn9_next
      16   pn9_next_byte
        16   -> pn9_next
       0   privGetXtalFrequency
       8   priv_ST_MANUF_CmdStrobe
         8   -> ST_MCU_API_SpiRaw
       8   priv_ST_MANUF_Get_Ramps_Settings
         8   -> S2LPManagementGetRangeExtender
     280   priv_ST_MANUF_ReadRegisters
       280   -> ST_MCU_API_SpiRaw
       280   -> __aeabi_memset
     120   priv_ST_MANUF_SpiRaw_Ramp
       120   -> ST_MCU_API_SpiRaw
      40   priv_ST_MANUF_WriteRegisters
        40   -> ST_MCU_API_SpiRaw
     160   priv_ST_MANUF_generateFIFORampsBuffer
       160   -> __aeabi_memclr4
       160   -> __aeabi_memcpy
       160   -> __aeabi_memcpy4
      24   priv_ST_MANUF_rf_load_first_ramp_up
        24   -> ST_MCU_API_GpioIRQ
        24   -> priv_ST_MANUF_CmdStrobe
        24   -> priv_ST_MANUF_SpiRaw_Ramp
        24   -> priv_ST_MANUF_WriteRegisters
        24   -> priv_ST_MANUF_generateFIFORampsBuffer
      56   priv_ST_MANUF_tx_rf_dbpsk_init
        56   -> privGetXtalFrequency
        56   -> priv_ST_MANUF_Get_Ramps_Settings
        56   -> priv_ST_MANUF_WriteRegisters
        56 __aeabi_lmul
        56 __aeabi_uldivmod
      24   priv_ST_MANUF_tx_rf_dbpsk_single_bit
        24   -> priv_ST_MANUF_SpiRaw_Ramp
        24   -> priv_ST_MANUF_generateFIFORampsBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable27
       4  ??DataTable35
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_2
       4  ??DataTable36_3
       4  ??DataTable36_4
       4  ??DataTable36_5
       4  ??DataTable36_6
       4  ??DataTable36_7
       4  ??DataTable4
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       8  ?Subroutine0
       8  ?Subroutine1
      16  ?_0
      28  ?_1
       8  ?_2
       4  MONARCH_API_configure_search_pattern
       4  MONARCH_API_free
       4  MONARCH_API_get_version
       4  MONARCH_API_malloc
       4  MONARCH_API_stop_search_pattern
       4  MONARCH_API_timer_start
       4  MONARCH_API_timer_stop
     192  RF_API_change_frequency
      12  RF_API_get_version
     950  RF_API_init
      88  RF_API_send
     128  RF_API_start_continuous_transmission
      38  RF_API_stop
      30  RF_API_stop_continuous_transmission
     392  RF_API_wait_for_clear_channel
     246  RF_API_wait_frame
       6  ST_RF_API_GetFIFOState
      30  ST_RF_API_GetRSSI
       6  ST_RF_API_Get_Continuous_TX_or_MONARCH_Scan_Flag
      26  ST_RF_API_ReadFifo
      18  ST_RF_API_ReadFifoBytes
     318  ST_RF_API_S2LP_IRQ_CB
      28  ST_RF_API_SetFifoLength
      10  ST_RF_API_StartRx
      24  ST_RF_API_StartTx
      18  ST_RF_API_StopRxTx
       6  ST_RF_API_Timer_CB
       8  ST_RF_API_Timer_Channel_Clear_CB
       8  ST_RF_API_VER
       2  ST_RF_API_custom_setting
       2  ST_RF_API_get_lbt_thr_offset
       6  ST_RF_API_get_ramp_duration
       4  ST_RF_API_get_rssi_offset
      10  ST_RF_API_get_xtal_freq
       8  ST_RF_API_reduce_output_power
       8  ST_RF_API_set_lbt_thr_offset
       8  ST_RF_API_set_pa
       8  ST_RF_API_set_rssi_offset
       8  ST_RF_API_set_tcxo
       8  ST_RF_API_set_xtal_freq
       8  ST_RF_API_smps
       3  bfSize
          bSwap
          _s2lpFIFOState
      24  pn9_next
      22  pn9_next_byte
       6  privGetXtalFrequency
      22  priv_ST_MANUF_CmdStrobe
      82  priv_ST_MANUF_Get_Ramps_Settings
      66  priv_ST_MANUF_ReadRegisters
     102  priv_ST_MANUF_SpiRaw_Ramp
      46  priv_ST_MANUF_WriteRegisters
     960  priv_ST_MANUF_generateFIFORampsBuffer
      92  priv_ST_MANUF_rf_load_first_ramp_up
     904  priv_ST_MANUF_tx_rf_dbpsk_init
      74  priv_ST_MANUF_tx_rf_dbpsk_single_bit
     304  st_manuf
          rampBuffer
          zeroes

 
     3 bytes in section .bss
   304 bytes in section .data
    44 bytes in section .rodata
 5'246 bytes in section .text
 
 5'216 bytes of CODE  memory (+ 30 bytes shared)
    44 bytes of CONST memory
   307 bytes of DATA  memory

Errors: none
Warnings: none
