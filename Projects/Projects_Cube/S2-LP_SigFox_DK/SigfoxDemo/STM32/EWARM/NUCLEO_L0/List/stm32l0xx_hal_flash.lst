###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  12:25:24
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_flash.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW70C2.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_flash.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal_flash.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal_flash.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @brief   FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the internal FLASH memory:
      8            *           + Program operations functions
      9            *           + Memory Control functions 
     10            *           + Peripheral State functions
     11            *         
     12            @verbatim
     13            ==============================================================================
     14                                  ##### FLASH peripheral features #####
     15            ==============================================================================
     16            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     17                 to the Flash memory. It implements the erase and program Flash memory operations 
     18                 and the read and write protection mechanisms.
     19          
     20            [..] The Flash memory interface accelerates code execution with a system of instruction
     21                prefetch. 
     22          
     23            [..] The FLASH main features are:
     24                (+) Flash memory read operations
     25                (+) Flash memory program/erase operations
     26                (+) Read / write protections
     27                (+) Prefetch on I-Code
     28                (+) Option Bytes programming
     29          
     30          
     31                               ##### How to use this driver #####
     32            ==============================================================================
     33            [..]                             
     34                This driver provides functions and macros to configure and program the FLASH 
     35                memory of all STM32L0xx devices.
     36              
     37                (#) FLASH Memory I/O Programming functions: this group includes all needed
     38                    functions to erase and program the main memory:
     39                  (++) Lock and Unlock the FLASH interface
     40                  (++) Erase function: Erase page
     41                  (++) Program functions: Fast Word and Half Page(should be 
     42                  executed from internal SRAM).
     43            
     44                (#) DATA EEPROM Programming functions: this group includes all 
     45                    needed functions to erase and program the DATA EEPROM memory:
     46                  (++) Lock and Unlock the DATA EEPROM interface.
     47                  (++) Erase function: Erase Byte, erase HalfWord, erase Word, erase 
     48                       Double Word (should be executed from internal SRAM).
     49                  (++) Program functions: Fast Program Byte, Fast Program Half-Word, 
     50                       FastProgramWord, Program Byte, Program Half-Word, 
     51                       Program Word and Program Double-Word (should be executed 
     52                       from internal SRAM).
     53          
     54                (#) FLASH Option Bytes Programming functions: this group includes all needed
     55                    functions to manage the Option Bytes:
     56                  (++) Lock and Unlock the Option Bytes
     57                  (++) Set/Reset the write protection
     58                  (++) Set the Read protection Level
     59                  (++) Program the user Option Bytes
     60                  (++) Launch the Option Bytes loader
     61                  (++) Set/Get the Read protection Level.
     62                  (++) Set/Get the BOR level.
     63                  (++) Get the Write protection.
     64                  (++) Get the user option bytes.
     65              
     66                (#) Interrupts and flags management functions : this group 
     67                    includes all needed functions to:
     68                  (++) Handle FLASH interrupts
     69                  (++) Wait for last FLASH operation according to its status
     70                  (++) Get error flag status
     71          
     72              (#) FLASH Interface configuration functions: this group includes 
     73                the management of following features:
     74                (++) Enable/Disable the RUN PowerDown mode.
     75                (++) Enable/Disable the SLEEP PowerDown mode.  
     76            
     77              (#) FLASH Peripheral State methods: this group includes 
     78                the management of following features:
     79                (++) Wait for the FLASH operation
     80                (++)  Get the specific FLASH error flag
     81              
     82            [..] In addition to these function, this driver includes a set of macros allowing
     83                 to handle the following operations:
     84                
     85                (+) Set/Get the latency
     86                (+) Enable/Disable the prefetch buffer
     87                (+) Enable/Disable the preread buffer
     88                (+) Enable/Disable the Flash power-down
     89                (+) Enable/Disable the FLASH interrupts
     90                (+) Monitor the FLASH flags status
     91                    
     92                           ##### Programming operation functions #####
     93            ===============================================================================  
     94               [..]
     95               This subsection provides a set of functions allowing to manage the FLASH 
     96               program operations.
     97            
     98              [..] The FLASH Memory Programming functions, includes the following functions:
     99               (+) HAL_FLASH_Unlock(void);
    100               (+) HAL_FLASH_Lock(void);
    101               (+) HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    102               (+) HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    103              
    104               [..] Any operation of erase or program should follow these steps:
    105               (#) Call the HAL_FLASH_Unlock() function to enable the flash control register and 
    106                   program memory access.
    107               (#) Call the desired function to erase page or program data.
    108               (#) Call the HAL_FLASH_Lock() to disable the flash program memory access 
    109                  (recommended to protect the FLASH memory against possible unwanted operation).
    110            
    111                         ##### Option Bytes Programming functions ##### 
    112             ==============================================================================  
    113            
    114               [..] The FLASH_Option Bytes Programming_functions, includes the following functions:
    115               (+) HAL_FLASH_OB_Unlock(void);
    116               (+) HAL_FLASH_OB_Lock(void);
    117               (+) HAL_FLASH_OB_Launch(void);
    118               (+) HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
    119               (+) HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
    120              
    121               [..] Any operation of erase or program should follow these steps:
    122               (#) Call the HAL_FLASH_OB_Unlock() function to enable the Flash option control 
    123                   register access.
    124               (#) Call the following functions to program the desired option bytes.
    125                   (++) HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);      
    126               (#) Once all needed option bytes to be programmed are correctly written, call the
    127                   HAL_FLASH_OB_Launch(void) function to launch the Option Bytes programming process.
    128               (#) Call the HAL_FLASH_OB_Lock() to disable the Flash option control register access (recommended
    129                   to protect the option Bytes against possible unwanted operations).
    130            
    131              [..] Proprietary code Read Out Protection (PcROP):    
    132              (#) The PcROP sector is selected by using the same option bytes as the Write
    133                  protection. As a result, these 2 options are exclusive each other.
    134              (#) To activate PCROP mode for Flash sectors(s), you need to follow the sequence below:
    135                  (++) Use this function HAL_FLASHEx_AdvOBProgram with PCROPState = OB_PCROP_STATE_ENABLE.
    136          
    137            @endverbatim
    138            ******************************************************************************
    139            * @attention
    140            *
    141            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics. 
    142            * All rights reserved.</center></h2>
    143            *
    144            * This software component is licensed by ST under BSD 3-Clause license,
    145            * the "License"; You may not use this file except in compliance with the 
    146            * License. You may obtain a copy of the License at:
    147            *                        opensource.org/licenses/BSD-3-Clause
    148            *
    149            ******************************************************************************  
    150            */
    151          
    152          /* Includes ------------------------------------------------------------------*/
    153          #include "stm32l0xx_hal.h"
    154          
    155          /** @addtogroup STM32L0xx_HAL_Driver
    156            * @{
    157            */
    158          
    159          #ifdef HAL_FLASH_MODULE_ENABLED
    160          
    161          /** @defgroup FLASH FLASH
    162            * @brief FLASH HAL module driver
    163            * @{
    164            */
    165          
    166          /* Private typedef -----------------------------------------------------------*/
    167          /* Private define ------------------------------------------------------------*/
    168          /** @defgroup FLASH_Private_Constants FLASH Private Constants
    169            * @{
    170            */
    171          /**
    172            * @}
    173            */
    174          
    175          /* Private macro ---------------------------- ---------------------------------*/
    176          /** @defgroup FLASH_Private_Macros FLASH Private Macros
    177            * @{
    178            */
    179           
    180          /**
    181            * @}
    182            */
    183          
    184          /* Private variables ---------------------------------------------------------*/
    185          /** @defgroup FLASH_Private_Variables FLASH Private Variables
    186            * @{
    187            */
    188          /* Variables used for Erase pages under interruption*/

   \                                 In section .bss, align 4
    189          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \        0x0                      DS8 24
    190          /**
    191            * @}
    192            */
    193          
    194          /* Private function prototypes -----------------------------------------------*/
    195          /** @defgroup FLASH_Private_Functions FLASH Private Functions
    196            * @{
    197            */
    198          static  void   FLASH_SetErrorCode(void);
    199          extern void    FLASH_PageErase(uint32_t PageAddress);
    200          /**
    201            * @}
    202            */
    203          
    204          /* Exported functions ---------------------------------------------------------*/
    205          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    206            * @{
    207            */
    208            
    209          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    210            *  @brief   Programming operation functions 
    211            *
    212          @verbatim   
    213          @endverbatim
    214            * @{
    215            */
    216          
    217          /**
    218            * @brief  Program word at a specified address
    219            * @note   To correctly run this function, the HAL_FLASH_Unlock() function
    220            *         must be called before.
    221            *         Call the HAL_FLASH_Lock() to disable the flash memory access
    222            *         (recommended to protect the FLASH memory against possible unwanted operation).
    223            *
    224            * @param  TypeProgram   Indicate the way to program at a specified address.
    225            *                       This parameter can be a value of @ref FLASH_Type_Program
    226            * @param  Address       Specifie the address to be programmed.
    227            * @param  Data          Specifie the data to be programmed
    228            * 
    229            * @retval HAL_StatusTypeDef HAL Status
    230            */

   \                                 In section .text, align 2, keep-with-next
    231          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    232          {
   \                     HAL_FLASH_Program: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0017             MOVS     R7,R2
    233            HAL_StatusTypeDef status = HAL_ERROR;
    234            
    235            /* Process Locked */
    236            __HAL_LOCK(&pFlash);
   \        0x4   0x....             LDR      R4,??DataTable9
   \        0x6   0x7C20             LDRB     R0,[R4, #+16]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_FLASH_Program_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_FLASH_Program_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x7420             STRB     R0,[R4, #+16]
    237          
    238            /* Check the parameters */
    239            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    240            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    241          
    242            /* Wait for last operation to be completed */
    243            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \       0x14   0x....             LDR      R5,??DataTable9_1  ;; 0xc350
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x....'....        BL       FLASH_WaitForLastOperation
    244            
    245            if(status == HAL_OK)
   \       0x1C   0x2600             MOVS     R6,#+0
   \       0x1E   0x0001             MOVS     R1,R0
   \       0x20   0xD105             BNE      ??HAL_FLASH_Program_1
   \       0x22   0x9800             LDR      R0,[SP, #+0]
    246            {
    247              /* Clean the error context */
    248              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \       0x24   0x6166             STR      R6,[R4, #+20]
    249          
    250              /*Program word (32-bit) at a specified address.*/
    251              *(__IO uint32_t *)Address = Data;
   \       0x26   0x6007             STR      R7,[R0, #+0]
    252          
    253              /* Wait for last operation to be completed */
    254              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0x....'....        BL       FLASH_WaitForLastOperation
    255            }
    256          
    257            /* Process Unlocked */
    258            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_1: (+1)
   \       0x2E   0x7426             STRB     R6,[R4, #+16]
    259          
    260            return status;
   \       0x30   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    261          }
    262          
    263          /**
    264            * @brief   Program word at a specified address  with interrupt enabled.
    265            *
    266            * @param  TypeProgram  Indicate the way to program at a specified address.
    267            *                      This parameter can be a value of @ref FLASH_Type_Program
    268            * @param  Address      Specifie the address to be programmed.
    269            * @param  Data         Specifie the data to be programmed
    270            * 
    271            * @retval HAL_StatusTypeDef HAL Status
    272            */

   \                                 In section .text, align 2, keep-with-next
    273          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    274          {
   \                     HAL_FLASH_Program_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    275            HAL_StatusTypeDef status = HAL_OK;
    276            
    277            /* Process Locked */
    278            __HAL_LOCK(&pFlash);
   \        0x2   0x....             LDR      R3,??DataTable9
   \        0x4   0x7C1C             LDRB     R4,[R3, #+16]
   \        0x6   0x2C01             CMP      R4,#+1
   \        0x8   0xD101             BNE      ??HAL_FLASH_Program_IT_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_FLASH_Program_IT_0: (+1)
   \        0xE   0x2401             MOVS     R4,#+1
   \       0x10   0x741C             STRB     R4,[R3, #+16]
    279          
    280            /* Check the parameters */
    281            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    282            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    283          
    284            /* Enable End of FLASH Operation and Error source interrupts */
    285            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \       0x12   0x....             LDR      R4,??DataTable9_2  ;; 0x40022004
   \       0x14   0x6825             LDR      R5,[R4, #+0]
   \       0x16   0x26C0             MOVS     R6,#+192
   \       0x18   0x02B6             LSLS     R6,R6,#+10       ;; #+196608
   \       0x1A   0x432E             ORRS     R6,R6,R5
   \       0x1C   0x6026             STR      R6,[R4, #+0]
    286            
    287            pFlash.Address = Address;
   \       0x1E   0x6099             STR      R1,[R3, #+8]
    288            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \       0x20   0x2402             MOVS     R4,#+2
   \       0x22   0x701C             STRB     R4,[R3, #+0]
    289            /* Clean the error context */
    290            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \       0x24   0x2400             MOVS     R4,#+0
   \       0x26   0x615C             STR      R4,[R3, #+20]
    291          
    292            if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \       0x28   0x2802             CMP      R0,#+2
   \       0x2A   0xD100             BNE      ??HAL_FLASH_Program_IT_1
    293            {
    294              /* Program word (32-bit) at a specified address. */
    295              *(__IO uint32_t *)Address = Data;
   \       0x2C   0x600A             STR      R2,[R1, #+0]
    296            }
    297            return status;
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
    298          }
    299          
    300          /**
    301            * @brief This function handles FLASH interrupt request.
    302            * @retval None
    303            */

   \                                 In section .text, align 2, keep-with-next
    304          void HAL_FLASH_IRQHandler(void)
    305          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    306            uint32_t addresstmp = 0;
    307            
    308            /* Check FLASH operation error flags */
    309          
    310            /* WARNING : On the first cut of STM32L031xx and STM32L041xx devices,
    311             *           (RefID = 0x1000) the FLASH_FLAG_OPTVERR bit was not behaving
    312             *           as expected. If the user run an application using the first
    313             *           cut of the STM32L031xx device or the first cut of the STM32L041xx
    314             *           device, the check on the FLASH_FLAG_OPTVERR bit should be ignored.
    315             *
    316             *           Note :The revId of the device can be retrieved via the HAL_GetREVID()
    317             *           function.
    318             *
    319             */
    320          
    321            if( __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)     || 
    322                __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR)     || 
    323                __HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)     || 
    324                __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)    || 
    325                __HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR)      || 
    326                __HAL_FLASH_GET_FLAG(FLASH_FLAG_FWWERR)     || 
    327                __HAL_FLASH_GET_FLAG(FLASH_FLAG_NOTZEROERR) )
   \        0x2   0x....             LDR      R4,??DataTable9_2  ;; 0x40022004
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x43ED             MVNS     R5,R5            ;; #-1
   \        0x8   0x....             LDR      R6,??DataTable9
   \        0xA   0x2700             MOVS     R7,#+0
   \        0xC   0x6960             LDR      R0,[R4, #+20]
   \        0xE   0x05C0             LSLS     R0,R0,#+23
   \       0x10   0xD411             BMI      ??HAL_FLASH_IRQHandler_0
   \       0x12   0x6960             LDR      R0,[R4, #+20]
   \       0x14   0x0580             LSLS     R0,R0,#+22
   \       0x16   0xD40E             BMI      ??HAL_FLASH_IRQHandler_0
   \       0x18   0x6960             LDR      R0,[R4, #+20]
   \       0x1A   0x0540             LSLS     R0,R0,#+21
   \       0x1C   0xD40B             BMI      ??HAL_FLASH_IRQHandler_0
   \       0x1E   0x6960             LDR      R0,[R4, #+20]
   \       0x20   0x0500             LSLS     R0,R0,#+20
   \       0x22   0xD408             BMI      ??HAL_FLASH_IRQHandler_0
   \       0x24   0x6960             LDR      R0,[R4, #+20]
   \       0x26   0x0480             LSLS     R0,R0,#+18
   \       0x28   0xD405             BMI      ??HAL_FLASH_IRQHandler_0
   \       0x2A   0x6960             LDR      R0,[R4, #+20]
   \       0x2C   0x0380             LSLS     R0,R0,#+14
   \       0x2E   0xD402             BMI      ??HAL_FLASH_IRQHandler_0
   \       0x30   0x6960             LDR      R0,[R4, #+20]
   \       0x32   0x03C0             LSLS     R0,R0,#+15
   \       0x34   0xD50E             BPL      ??HAL_FLASH_IRQHandler_1
    328            {
    329              if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \       0x36   0x7830             LDRB     R0,[R6, #+0]
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD103             BNE      ??HAL_FLASH_IRQHandler_2
    330              {
    331                /* Return the faulty sector */
    332                addresstmp = pFlash.Page;
   \       0x3C   0x68F0             LDR      R0,[R6, #+12]
   \       0x3E   0x9000             STR      R0,[SP, #+0]
    333                pFlash.Page = 0xFFFFFFFFU;
   \       0x40   0x60F5             STR      R5,[R6, #+12]
   \       0x42   0xE001             B        ??HAL_FLASH_IRQHandler_3
    334              }
    335              else
    336              {
    337                /* Return the faulty address */
    338                addresstmp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \       0x44   0x68B0             LDR      R0,[R6, #+8]
   \       0x46   0x9000             STR      R0,[SP, #+0]
    339              }
    340              /* Save the Error code */
    341              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \       0x48   0x....'....        BL       FLASH_SetErrorCode
    342              
    343              /* FLASH error interrupt user callback */
    344              HAL_FLASH_OperationErrorCallback(addresstmp);
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0x....'....        BL       HAL_FLASH_OperationErrorCallback
    345          
    346              /* Stop the procedure ongoing */
    347              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0x52   0x7037             STRB     R7,[R6, #+0]
    348            }
    349          
    350            /* Check FLASH End of Operation flag  */
    351            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \       0x54   0x2002             MOVS     R0,#+2
   \       0x56   0x6961             LDR      R1,[R4, #+20]
   \       0x58   0x4001             ANDS     R1,R1,R0
   \       0x5A   0xD028             BEQ      ??HAL_FLASH_IRQHandler_4
    352            {
    353              /* Clear FLASH End of Operation pending bit */
    354              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \       0x5C   0x6160             STR      R0,[R4, #+20]
    355              
    356              /* Process can continue only if no error detected */
    357              if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
   \       0x5E   0x7830             LDRB     R0,[R6, #+0]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD024             BEQ      ??HAL_FLASH_IRQHandler_4
    358              {
    359                if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \       0x64   0x7830             LDRB     R0,[R6, #+0]
   \       0x66   0x2801             CMP      R0,#+1
   \       0x68   0xD118             BNE      ??HAL_FLASH_IRQHandler_5
    360                {
    361                  /* Nb of pages to erased can be decreased */
    362                  pFlash.NbPagesToErase--;
   \       0x6A   0x6870             LDR      R0,[R6, #+4]
   \       0x6C   0x1E40             SUBS     R0,R0,#+1
   \       0x6E   0x6070             STR      R0,[R6, #+4]
    363          
    364                  /* Check if there are still pages to erase */
    365                  if(pFlash.NbPagesToErase != 0U)
   \       0x70   0x6870             LDR      R0,[R6, #+4]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD00C             BEQ      ??HAL_FLASH_IRQHandler_6
    366                  {
    367                    addresstmp = pFlash.Page;
   \       0x76   0x68F0             LDR      R0,[R6, #+12]
    368                    /*Indicate user which sector has been erased */
    369                    HAL_FLASH_EndOfOperationCallback(addresstmp);
   \       0x78   0x....'....        BL       HAL_FLASH_EndOfOperationCallback
    370          
    371                    /*Increment sector number*/
    372                    addresstmp = pFlash.Page + FLASH_PAGE_SIZE;
   \       0x7C   0x68F0             LDR      R0,[R6, #+12]
   \       0x7E   0x3080             ADDS     R0,R0,#+128
    373                    pFlash.Page = addresstmp;
   \       0x80   0x60F0             STR      R0,[R6, #+12]
    374          
    375                    /* If the erase operation is completed, disable the ERASE Bit */
    376                    CLEAR_BIT(FLASH->PECR, FLASH_PECR_ERASE);
   \       0x82   0x6821             LDR      R1,[R4, #+0]
   \       0x84   0x....             LDR      R2,??DataTable10  ;; 0xfffffdff
   \       0x86   0x400A             ANDS     R2,R2,R1
   \       0x88   0x6022             STR      R2,[R4, #+0]
    377          
    378                    FLASH_PageErase(addresstmp);
   \       0x8A   0x....'....        BL       FLASH_PageErase
   \       0x8E   0xE00E             B        ??HAL_FLASH_IRQHandler_4
    379                  }
    380                  else
    381                  {
    382                    /* No more pages to Erase, user callback can be called. */
    383                    /* Reset Sector and stop Erase pages procedure */
    384                    pFlash.Page = addresstmp = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \       0x90   0x60F5             STR      R5,[R6, #+12]
    385                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0x92   0x7037             STRB     R7,[R6, #+0]
    386                    /* FLASH EOP interrupt user callback */
    387                    HAL_FLASH_EndOfOperationCallback(addresstmp);
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0x....'....        BL       HAL_FLASH_EndOfOperationCallback
   \       0x9A   0xE008             B        ??HAL_FLASH_IRQHandler_4
    388                  }
    389                }
    390                else
    391                {
    392                    /* If the program operation is completed, disable the PROG Bit */
    393                    CLEAR_BIT(FLASH->PECR, FLASH_PECR_PROG);
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x2108             MOVS     R1,#+8
   \       0xA0   0x4388             BICS     R0,R0,R1
   \       0xA2   0x6020             STR      R0,[R4, #+0]
    394          
    395                    /* Program ended. Return the selected address */
    396                    /* FLASH EOP interrupt user callback */
    397                    HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \       0xA4   0x68B0             LDR      R0,[R6, #+8]
   \       0xA6   0x....'....        BL       HAL_FLASH_EndOfOperationCallback
    398                  
    399                    /* Reset Address and stop Program procedure */
    400                    pFlash.Address = 0xFFFFFFFFU;
   \       0xAA   0x60B5             STR      R5,[R6, #+8]
    401                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0xAC   0x7037             STRB     R7,[R6, #+0]
    402                }
    403              }
    404            }
    405            
    406          
    407            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \       0xAE   0x7830             LDRB     R0,[R6, #+0]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD108             BNE      ??HAL_FLASH_IRQHandler_7
    408            {
    409              /* Operation is completed, disable the PROG and ERASE */
    410              CLEAR_BIT(FLASH->PECR, (FLASH_PECR_ERASE | FLASH_PECR_PROG));
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x....             LDR      R1,??DataTable10_1  ;; 0xfffffdf7
   \       0xB8   0x4001             ANDS     R1,R1,R0
   \       0xBA   0x6021             STR      R1,[R4, #+0]
    411          
    412              /* Disable End of FLASH Operation and Error source interrupts */
    413              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x....             LDR      R1,??DataTable10_2  ;; 0xfffcffff
   \       0xC0   0x4001             ANDS     R1,R1,R0
   \       0xC2   0x6021             STR      R1,[R4, #+0]
    414          
    415              /* Process Unlocked */
    416              __HAL_UNLOCK(&pFlash);
   \       0xC4   0x7437             STRB     R7,[R6, #+16]
    417            }
    418          }
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \       0xC6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    419          
    420          /**
    421            * @brief  FLASH end of operation interrupt callback
    422            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    423            *                 - Pages Erase: Address of the page which has been erased 
    424            *                    (if 0xFFFFFFFF, it means that all the selected pages have been erased)
    425            *                 - Program: Address which was selected for data program
    426            * @retval none
    427            */

   \                                 In section .text, align 2
    428          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    429          {
    430            /* Prevent unused argument(s) compilation warning */
    431            UNUSED(ReturnValue);
    432          
    433            /* NOTE : This function Should not be modified, when the callback is needed,
    434                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    435             */ 
    436          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    437          
    438          /**
    439            * @brief  FLASH operation error interrupt callback
    440            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    441            *                 - Pages Erase: Address of the page which returned an error
    442            *                 - Program: Address which was selected for data program
    443            * @retval none
    444            */

   \                                 In section .text, align 2
    445          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    446          {
    447            /* Prevent unused argument(s) compilation warning */
    448            UNUSED(ReturnValue);
    449          
    450            /* NOTE : This function Should not be modified, when the callback is needed,
    451                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    452             */ 
    453          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    454          
    455          /**
    456            * @}
    457            */
    458          
    459          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    460           *  @brief   management functions 
    461           *
    462          @verbatim   
    463           ===============================================================================
    464                                ##### Peripheral Control functions #####
    465           ===============================================================================  
    466              [..]
    467              This subsection provides a set of functions allowing to control the FLASH 
    468              memory operations.
    469          
    470          @endverbatim
    471            * @{
    472            */
    473          
    474          /**
    475            * @brief  Unlock the FLASH control register access
    476            * @retval HAL Status
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    479          {
    480            uint32_t primask_bit;
    481          
    482            /* Unlocking FLASH_PECR register access*/
    483            if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PELOCK))
   \                     HAL_FLASH_Unlock: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x....             LDR      R0,??DataTable9_2  ;; 0x40022004
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0x400A             ANDS     R2,R2,R1
   \        0x8   0xD00B             BEQ      ??HAL_FLASH_Unlock_0
    484            {
    485              /* Disable interrupts to avoid any interruption during unlock sequence */
    486              primask_bit = __get_PRIMASK();
   \        0xA   0xF3EF 0x8210      MRS      R2,PRIMASK
    487              __disable_irq();
   \        0xE   0xB672             CPSID    I
    488          
    489              WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY1);
   \       0x10   0x....             LDR      R3,??DataTable10_3  ;; 0x89abcdef
   \       0x12   0x6083             STR      R3,[R0, #+8]
    490              WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY2);
   \       0x14   0x....             LDR      R3,??DataTable10_4  ;; 0x2030405
   \       0x16   0x6083             STR      R3,[R0, #+8]
    491          
    492              /* Re-enable the interrupts: restore previous priority mask */
    493              __set_PRIMASK(primask_bit);
   \       0x18   0xF382 0x8810      MSR      PRIMASK,R2
    494          
    495              if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PELOCK))
   \       0x1C   0x6802             LDR      R2,[R0, #+0]
   \       0x1E   0x4011             ANDS     R1,R1,R2
   \       0x20   0xD10F             BNE      ??HAL_FLASH_Unlock_1
    496              {
    497                return HAL_ERROR;
    498              }
    499            }
    500          
    501            if (HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PRGLOCK))
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \       0x22   0x2202             MOVS     R2,#+2
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0x4011             ANDS     R1,R1,R2
   \       0x28   0xD00D             BEQ      ??HAL_FLASH_Unlock_2
    502            {
    503              /* Disable interrupts to avoid any interruption during unlock sequence */
    504              primask_bit = __get_PRIMASK();
   \       0x2A   0xF3EF 0x8110      MRS      R1,PRIMASK
    505              __disable_irq();
   \       0x2E   0xB672             CPSID    I
    506          
    507              /* Unlocking the program memory access */
    508              WRITE_REG(FLASH->PRGKEYR, FLASH_PRGKEY1);
   \       0x30   0x....             LDR      R3,??DataTable10_5  ;; 0x8c9daebf
   \       0x32   0x60C3             STR      R3,[R0, #+12]
    509              WRITE_REG(FLASH->PRGKEYR, FLASH_PRGKEY2);  
   \       0x34   0x....             LDR      R3,??DataTable10_6  ;; 0x13141516
   \       0x36   0x60C3             STR      R3,[R0, #+12]
    510          
    511              /* Re-enable the interrupts: restore previous priority mask */
    512              __set_PRIMASK(primask_bit);
   \       0x38   0xF381 0x8810      MSR      PRIMASK,R1
    513          
    514              if (HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PRGLOCK))
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0x4002             ANDS     R2,R2,R0
   \       0x40   0xD001             BEQ      ??HAL_FLASH_Unlock_2
    515              {
    516                return HAL_ERROR;
   \                     ??HAL_FLASH_Unlock_1: (+1)
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0x4770             BX       LR
    517              }
    518            }
    519          
    520            return HAL_OK; 
   \                     ??HAL_FLASH_Unlock_2: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x4770             BX       LR               ;; return
    521          }
    522          
    523          /**
    524            * @brief  Locks the FLASH control register access
    525            * @retval HAL Status
    526            */

   \                                 In section .text, align 2, keep-with-next
    527          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    528          {
    529            /* Set the PRGLOCK Bit to lock the FLASH Registers access */
    530            SET_BIT(FLASH->PECR, FLASH_PECR_PRGLOCK);
   \                     HAL_FLASH_Lock: (+1)
   \        0x0   0x....             LDR      R0,??DataTable9_2  ;; 0x40022004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    531            
    532            /* Set the PELOCK Bit to lock the PECR Register access */
    533            SET_BIT(FLASH->PECR, FLASH_PECR_PELOCK);
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0x....             B.N      ?Subroutine0
    534          
    535            return HAL_OK;  
    536          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x430A             ORRS     R2,R2,R1
   \        0x2   0x6002             STR      R2,[R0, #+0]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
    537          
    538          /**
    539            * @brief  Unlock the FLASH Option Control Registers access.
    540            * @retval HAL Status
    541            */

   \                                 In section .text, align 2, keep-with-next
    542          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    543          {
    544            uint32_t primask_bit;
    545          
    546            if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_OPTLOCK))
   \                     HAL_FLASH_OB_Unlock: (+1)
   \        0x0   0x....             LDR      R0,??DataTable9_2  ;; 0x40022004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0749             LSLS     R1,R1,#+29
   \        0x6   0xD511             BPL      ??HAL_FLASH_OB_Unlock_0
    547            {
    548              /* Disable interrupts to avoid any interruption during unlock sequence */
    549              primask_bit = __get_PRIMASK();
   \        0x8   0xF3EF 0x8110      MRS      R1,PRIMASK
    550              __disable_irq();
   \        0xC   0xB672             CPSID    I
    551          
    552              /* Unlocking FLASH_PECR register access*/
    553              if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PELOCK))
   \        0xE   0x6802             LDR      R2,[R0, #+0]
   \       0x10   0x07D2             LSLS     R2,R2,#+31
   \       0x12   0xD503             BPL      ??HAL_FLASH_OB_Unlock_1
    554              {  
    555                /* Unlocking FLASH_PECR register access*/
    556                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY1);
   \       0x14   0x....             LDR      R2,??DataTable10_3  ;; 0x89abcdef
   \       0x16   0x6082             STR      R2,[R0, #+8]
    557                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY2);
   \       0x18   0x....             LDR      R2,??DataTable10_4  ;; 0x2030405
   \       0x1A   0x6082             STR      R2,[R0, #+8]
    558              }
    559          
    560              /* Unlocking the option bytes block access */
    561              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
   \                     ??HAL_FLASH_OB_Unlock_1: (+1)
   \       0x1C   0x....             LDR      R2,??DataTable10_7  ;; 0xfbead9c8
   \       0x1E   0x6102             STR      R2,[R0, #+16]
    562              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
   \       0x20   0x....             LDR      R2,??DataTable10_8  ;; 0x24252627
   \       0x22   0x6102             STR      R2,[R0, #+16]
    563          
    564              /* Re-enable the interrupts: restore previous priority mask */
    565              __set_PRIMASK(primask_bit);
   \       0x24   0xF381 0x8810      MSR      PRIMASK,R1
    566            }
    567            else
    568            {
    569              return HAL_ERROR;
    570            }  
    571            
    572            return HAL_OK;  
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x4770             BX       LR
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x4770             BX       LR               ;; return
    573          }
    574          
    575          /**
    576            * @brief  Lock the FLASH Option Control Registers access.
    577            * @retval HAL Status 
    578            */

   \                                 In section .text, align 2, keep-with-next
    579          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    580          {
    581            /* Set the OPTLOCK Bit to lock the option bytes block access */
    582            SET_BIT(FLASH->PECR, FLASH_PECR_OPTLOCK);
   \                     HAL_FLASH_OB_Lock: (+1)
   \        0x0   0x....             LDR      R0,??DataTable9_2  ;; 0x40022004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2204             MOVS     R2,#+4
   \        0x6                      REQUIRE ?Subroutine0
   \        0x6                      ;; // Fall through to label ?Subroutine0
    583            
    584            return HAL_OK;  
    585          }
    586            
    587          /**
    588            * @brief  Launch the option byte loading.
    589            * @note   This function will reset automatically the MCU.
    590            * @retval HAL Status
    591            */

   \                                 In section .text, align 2, keep-with-next
    592          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    593          {
   \                     HAL_FLASH_OB_Launch: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    594            /* Set the OBL_Launch bit to launch the option byte loading */
    595            SET_BIT(FLASH->PECR, FLASH_PECR_OBL_LAUNCH);
   \        0x2   0x....             LDR      R0,??DataTable9_2  ;; 0x40022004
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x2280             MOVS     R2,#+128
   \        0x8   0x02D2             LSLS     R2,R2,#+11       ;; #+262144
   \        0xA   0x430A             ORRS     R2,R2,R1
   \        0xC   0x6002             STR      R2,[R0, #+0]
    596            
    597            /* Wait for last operation to be completed */
    598            return(FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE));
   \        0xE   0x....             LDR      R0,??DataTable9_1  ;; 0xc350
   \       0x10   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x14   0xBD02             POP      {R1,PC}          ;; return
    599          }
    600          
    601          /**
    602            * @}
    603            */  
    604          
    605          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral errors functions 
    606           *  @brief    Peripheral errors functions 
    607           *
    608          @verbatim   
    609           ===============================================================================
    610                                ##### Peripheral Errors functions #####
    611           ===============================================================================  
    612              [..]
    613              This subsection permit to get in run-time errors of  the FLASH peripheral.
    614          
    615          @endverbatim
    616            * @{
    617            */
    618          
    619          /**
    620            * @brief  Get the specific FLASH error flag.
    621            * @retval FLASH_ErrorCode The returned value can be:
    622            *            @ref FLASH_Error_Codes
    623            */

   \                                 In section .text, align 2, keep-with-next
    624          uint32_t HAL_FLASH_GetError(void)
    625          {
    626             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \        0x0   0x....             LDR      R0,??DataTable10_9
   \        0x2   0x6940             LDR      R0,[R0, #+20]
   \        0x4   0x4770             BX       LR               ;; return
    627          }
    628          
    629          /**
    630            * @}
    631            */
    632          
    633          /**
    634            * @}
    635            */
    636          
    637          /** @addtogroup FLASH_Private_Functions
    638           * @{
    639           */
    640          
    641          /**
    642            * @brief  Wait for a FLASH operation to complete.
    643            * @param  Timeout  maximum flash operation timeout
    644            * @retval HAL Status
    645            */

   \                                 In section .text, align 2, keep-with-next
    646          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    647          {
   \                     FLASH_WaitForLastOperation: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
    648            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    649               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    650               flag will be set */
    651               
    652            uint32_t tickstart = HAL_GetTick();
   \        0x4   0x....'....        BL       HAL_GetTick
   \        0x8   0x0006             MOVS     R6,R0
   \        0xA   0x....             LDR      R4,??DataTable10_10  ;; 0x40022018
    653               
    654            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x07C0             LSLS     R0,R0,#+31
   \       0x10   0xD50C             BPL      ??FLASH_WaitForLastOperation_1
    655            { 
    656              if (Timeout != HAL_MAX_DELAY)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x16   0x4285             CMP      R5,R0
   \       0x18   0xD0F8             BEQ      ??FLASH_WaitForLastOperation_0
    657              {
    658                if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD004             BEQ      ??FLASH_WaitForLastOperation_2
   \       0x1E   0x....'....        BL       HAL_GetTick
   \       0x22   0x1B80             SUBS     R0,R0,R6
   \       0x24   0x4285             CMP      R5,R0
   \       0x26   0xD2F1             BCS      ??FLASH_WaitForLastOperation_0
    659                {
    660                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \       0x28   0x2003             MOVS     R0,#+3
   \       0x2A   0xBD70             POP      {R4-R6,PC}
    661                }
    662              }
    663            }
    664            
    665            /* Check FLASH End of Operation flag  */
    666            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x4001             ANDS     R1,R1,R0
   \       0x32   0xD000             BEQ      ??FLASH_WaitForLastOperation_3
    667            {
    668              /* Clear FLASH End of Operation pending bit */
    669              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \       0x34   0x6020             STR      R0,[R4, #+0]
    670            }
    671            
    672            if( __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)     || 
    673                __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR)     || 
    674                __HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)     || 
    675                __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)    || 
    676                __HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR)      || 
    677                __HAL_FLASH_GET_FLAG(FLASH_FLAG_FWWERR)     || 
    678                __HAL_FLASH_GET_FLAG(FLASH_FLAG_NOTZEROERR) )
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x05C0             LSLS     R0,R0,#+23
   \       0x3A   0xD411             BMI      ??FLASH_WaitForLastOperation_4
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x0580             LSLS     R0,R0,#+22
   \       0x40   0xD40E             BMI      ??FLASH_WaitForLastOperation_4
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x0540             LSLS     R0,R0,#+21
   \       0x46   0xD40B             BMI      ??FLASH_WaitForLastOperation_4
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x0500             LSLS     R0,R0,#+20
   \       0x4C   0xD408             BMI      ??FLASH_WaitForLastOperation_4
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x0480             LSLS     R0,R0,#+18
   \       0x52   0xD405             BMI      ??FLASH_WaitForLastOperation_4
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x0380             LSLS     R0,R0,#+14
   \       0x58   0xD402             BMI      ??FLASH_WaitForLastOperation_4
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x03C0             LSLS     R0,R0,#+15
   \       0x5E   0xD503             BPL      ??FLASH_WaitForLastOperation_5
    679            {
    680              /*Save the error code*/
    681          
    682              /* WARNING : On the first cut of STM32L031xx and STM32L041xx devices,
    683               *           (RefID = 0x1000) the FLASH_FLAG_OPTVERR bit was not behaving
    684               *           as expected. If the user run an application using the first
    685               *           cut of the STM32L031xx device or the first cut of the STM32L041xx
    686               *           device, this error should be ignored. The revId of the device
    687               *           can be retrieved via the HAL_GetREVID() function.
    688               *
    689               */
    690              FLASH_SetErrorCode();
   \                     ??FLASH_WaitForLastOperation_4: (+1)
   \       0x60   0x....'....        BL       FLASH_SetErrorCode
    691              return HAL_ERROR;
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xBD70             POP      {R4-R6,PC}
    692            }
    693          
    694            /* There is no error flag set */
    695            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_5: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBD70             POP      {R4-R6,PC}       ;; return
    696          }
    697          
    698          
    699          /**
    700            * @brief  Set the specific FLASH error flag.
    701            * @retval None
    702            */

   \                                 In section .text, align 2, keep-with-next
    703          static void FLASH_SetErrorCode(void)
    704          {
   \                     FLASH_SetErrorCode: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    705            uint32_t flags = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    706            
    707            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
   \        0x4   0x....             LDR      R0,??DataTable10_9
   \        0x6   0x2380             MOVS     R3,#+128
   \        0x8   0x005B             LSLS     R3,R3,#+1        ;; #+256
   \        0xA   0x....             LDR      R1,??DataTable10_10  ;; 0x40022018
   \        0xC   0x680C             LDR      R4,[R1, #+0]
   \        0xE   0x401C             ANDS     R4,R4,R3
   \       0x10   0xD004             BEQ      ??FLASH_SetErrorCode_0
    708            {
    709              pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \       0x12   0x6942             LDR      R2,[R0, #+20]
   \       0x14   0x2402             MOVS     R4,#+2
   \       0x16   0x4314             ORRS     R4,R4,R2
   \       0x18   0x6144             STR      R4,[R0, #+20]
    710              flags |= FLASH_FLAG_WRPERR;
   \       0x1A   0x001A             MOVS     R2,R3
    711            }
    712            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))
   \                     ??FLASH_SetErrorCode_0: (+1)
   \       0x1C   0x0D4B             LSRS     R3,R1,#+21
   \       0x1E   0x680C             LDR      R4,[R1, #+0]
   \       0x20   0x401C             ANDS     R4,R4,R3
   \       0x22   0xD006             BEQ      ??FLASH_SetErrorCode_1
    713            {
    714              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \       0x24   0x6944             LDR      R4,[R0, #+20]
   \       0x26   0x2501             MOVS     R5,#+1
   \       0x28   0x4325             ORRS     R5,R5,R4
   \       0x2A   0x6145             STR      R5,[R0, #+20]
    715              flags |= FLASH_FLAG_PGAERR;
   \       0x2C   0x0014             MOVS     R4,R2
   \       0x2E   0x001A             MOVS     R2,R3
   \       0x30   0x4322             ORRS     R2,R2,R4
    716            }
    717            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR))
   \                     ??FLASH_SetErrorCode_1: (+1)
   \       0x32   0x0D0B             LSRS     R3,R1,#+20
   \       0x34   0x680C             LDR      R4,[R1, #+0]
   \       0x36   0x401C             ANDS     R4,R4,R3
   \       0x38   0xD006             BEQ      ??FLASH_SetErrorCode_2
    718            { 
    719              pFlash.ErrorCode |= HAL_FLASH_ERROR_SIZE;
   \       0x3A   0x6944             LDR      R4,[R0, #+20]
   \       0x3C   0x2508             MOVS     R5,#+8
   \       0x3E   0x4325             ORRS     R5,R5,R4
   \       0x40   0x6145             STR      R5,[R0, #+20]
    720              flags |= FLASH_FLAG_SIZERR;
   \       0x42   0x0014             MOVS     R4,R2
   \       0x44   0x001A             MOVS     R2,R3
   \       0x46   0x4322             ORRS     R2,R2,R4
    721            }
    722            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
   \                     ??FLASH_SetErrorCode_2: (+1)
   \       0x48   0x0CCB             LSRS     R3,R1,#+19
   \       0x4A   0x680C             LDR      R4,[R1, #+0]
   \       0x4C   0x401C             ANDS     R4,R4,R3
   \       0x4E   0xD006             BEQ      ??FLASH_SetErrorCode_3
    723            {
    724              /* WARNING : On the first cut of STM32L031xx and STM32L041xx devices,
    725               *           (RefID = 0x1000) the FLASH_FLAG_OPTVERR bit was not behaving
    726               *           as expected. If the user run an application using the first
    727               *           cut of the STM32L031xx device or the first cut of the STM32L041xx
    728               *           device, this error should be ignored. The revId of the device
    729               *           can be retrieved via the HAL_GetREVID() function.
    730               *
    731               */
    732              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
   \       0x50   0x6944             LDR      R4,[R0, #+20]
   \       0x52   0x2504             MOVS     R5,#+4
   \       0x54   0x4325             ORRS     R5,R5,R4
   \       0x56   0x6145             STR      R5,[R0, #+20]
    733              flags |= FLASH_FLAG_OPTVERR;
   \       0x58   0x0014             MOVS     R4,R2
   \       0x5A   0x001A             MOVS     R2,R3
   \       0x5C   0x4322             ORRS     R2,R2,R4
    734            }
    735          
    736            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))
   \                     ??FLASH_SetErrorCode_3: (+1)
   \       0x5E   0x009B             LSLS     R3,R3,#+2
   \       0x60   0x680C             LDR      R4,[R1, #+0]
   \       0x62   0x401C             ANDS     R4,R4,R3
   \       0x64   0xD006             BEQ      ??FLASH_SetErrorCode_4
    737            {
    738              pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
   \       0x66   0x6944             LDR      R4,[R0, #+20]
   \       0x68   0x2510             MOVS     R5,#+16
   \       0x6A   0x4325             ORRS     R5,R5,R4
   \       0x6C   0x6145             STR      R5,[R0, #+20]
    739              flags |= FLASH_FLAG_RDERR;
   \       0x6E   0x0014             MOVS     R4,R2
   \       0x70   0x001A             MOVS     R2,R3
   \       0x72   0x4322             ORRS     R2,R2,R4
    740            }
    741            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_FWWERR))
   \                     ??FLASH_SetErrorCode_4: (+1)
   \       0x74   0x680B             LDR      R3,[R1, #+0]
   \       0x76   0x039B             LSLS     R3,R3,#+14
   \       0x78   0xD506             BPL      ??FLASH_SetErrorCode_5
    742            { 
    743              pFlash.ErrorCode |= HAL_FLASH_ERROR_FWWERR;
   \       0x7A   0x2320             MOVS     R3,#+32
   \       0x7C   0x6944             LDR      R4,[R0, #+20]
   \       0x7E   0x431C             ORRS     R4,R4,R3
   \       0x80   0x6144             STR      R4,[R0, #+20]
    744              flags |= HAL_FLASH_ERROR_FWWERR;
   \       0x82   0x0014             MOVS     R4,R2
   \       0x84   0x2220             MOVS     R2,#+32
   \       0x86   0x4322             ORRS     R2,R2,R4
    745            }
    746            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_NOTZEROERR))
   \                     ??FLASH_SetErrorCode_5: (+1)
   \       0x88   0x2380             MOVS     R3,#+128
   \       0x8A   0x025B             LSLS     R3,R3,#+9        ;; #+65536
   \       0x8C   0x680C             LDR      R4,[R1, #+0]
   \       0x8E   0x401C             ANDS     R4,R4,R3
   \       0x90   0xD006             BEQ      ??FLASH_SetErrorCode_6
    747            { 
    748              pFlash.ErrorCode |= HAL_FLASH_ERROR_NOTZERO;
   \       0x92   0x6944             LDR      R4,[R0, #+20]
   \       0x94   0x2540             MOVS     R5,#+64
   \       0x96   0x4325             ORRS     R5,R5,R4
   \       0x98   0x6145             STR      R5,[R0, #+20]
    749              flags |= FLASH_FLAG_NOTZEROERR;
   \       0x9A   0x0010             MOVS     R0,R2
   \       0x9C   0x001A             MOVS     R2,R3
   \       0x9E   0x4302             ORRS     R2,R2,R0
    750            }
    751          
    752            /* Clear FLASH error pending bits */
    753            __HAL_FLASH_CLEAR_FLAG(flags);
   \                     ??FLASH_SetErrorCode_6: (+1)
   \       0xA0   0x600A             STR      R2,[R1, #+0]
    754          }  
   \       0xA2   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x0000'C350        DC32     0xc350

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x4002'2004        DC32     0x40022004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0xFFFF'FDF7        DC32     0xfffffdf7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0xFFFC'FFFF        DC32     0xfffcffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x89AB'CDEF        DC32     0x89abcdef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x0203'0405        DC32     0x2030405

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0x8C9D'AEBF        DC32     0x8c9daebf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0x1314'1516        DC32     0x13141516

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0xFBEA'D9C8        DC32     0xfbead9c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \        0x0   0x2425'2627        DC32     0x24252627

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \        0x0   0x....'....        DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \        0x0   0x4002'2018        DC32     0x40022018
    755          /**
    756            * @}
    757            */
    758          
    759          /**
    760            * @}
    761            */
    762          
    763          #endif /* HAL_FLASH_MODULE_ENABLED */
    764          
    765          /**
    766            * @}
    767            */
    768          
    769          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      24   HAL_FLASH_IRQHandler
        24   -> FLASH_PageErase
        24   -> FLASH_SetErrorCode
        24   -> HAL_FLASH_EndOfOperationCallback
        24   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       8   HAL_FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      24   HAL_FLASH_Program
        24   -> FLASH_WaitForLastOperation
      16   HAL_FLASH_Program_IT
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       8  ?Subroutine0
     164  FLASH_SetErrorCode
     108  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     200  HAL_FLASH_IRQHandler
      16  HAL_FLASH_Lock
      22  HAL_FLASH_OB_Launch
       6  HAL_FLASH_OB_Lock
      48  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
      50  HAL_FLASH_Program
      50  HAL_FLASH_Program_IT
      74  HAL_FLASH_Unlock
      24  pFlash

 
  24 bytes in section .bss
 812 bytes in section .text
 
 808 bytes of CODE memory (+ 4 bytes shared)
  24 bytes of DATA memory

Errors: none
Warnings: none
