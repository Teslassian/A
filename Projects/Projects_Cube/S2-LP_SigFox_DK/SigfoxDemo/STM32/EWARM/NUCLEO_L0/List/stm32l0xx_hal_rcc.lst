###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  13:02:29
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rcc.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW63E6.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rcc.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal_rcc.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal_rcc.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @brief   RCC HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Reset and Clock Control (RCC) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + Peripheral Control functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                                ##### RCC specific features #####
     14            ==============================================================================
     15              [..]
     16                After reset the device is running from multispeed internal oscillator clock
     17                (MSI 2.097MHz) with Flash 0 wait state and Flash prefetch buffer is disabled,
     18                and all peripherals are off except internal SRAM, Flash and JTAG.
     19                (+) There is no prescaler on High speed (AHB) and Low speed (APB) buses;
     20                    all peripherals mapped on these buses are running at MSI speed.
     21                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     22                (+) All GPIOs are in input floating state, except the JTAG pins which
     23                    are assigned to be used for debug purpose.
     24              [..] Once the device started from reset, the user application has to:
     25                (+) Configure the clock source to be used to drive the System clock
     26                    (if the application needs higher frequency/performance)
     27                (+) Configure the System clock frequency and Flash settings
     28                (+) Configure the AHB and APB buses prescalers
     29                (+) Enable the clock for the peripheral(s) to be used
     30                (+) Configure the clock source(s) for peripherals whose clocks are not
     31                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)
     32                    (*) SDIO only for STM32L0xxxD devices
     33          
     34                                ##### RCC Limitations #####
     35            ==============================================================================
     36              [..]
     37                A delay between an RCC peripheral clock enable and the effective peripheral
     38                enabling should be taken into account in order to manage the peripheral read/write
     39                from/to registers.
     40                (+) This delay depends on the peripheral mapping.
     41                  (++) AHB & APB peripherals, 1 dummy read is necessary
     42          
     43              [..]
     44                Workarounds:
     45                (#) For AHB & APB peripherals, a dummy read to the peripheral register has been
     46                    inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
     47          
     48            @endverbatim
     49            ******************************************************************************
     50            * @attention
     51            *
     52            * <h2><center>&copy; Copyright(c) 2016 STMicroelectronics.
     53            * All rights reserved.</center></h2>
     54            *
     55            * This software component is licensed by ST under BSD 3-Clause license,
     56            * the "License"; You may not use this file except in compliance with the
     57            * License. You may obtain a copy of the License at:
     58            *                        opensource.org/licenses/BSD-3-Clause
     59            *
     60            ******************************************************************************
     61          */
     62          
     63          /* Includes ------------------------------------------------------------------*/
     64          #include "stm32l0xx_hal.h"
     65          
     66          /** @addtogroup STM32L0xx_HAL_Driver
     67            * @{
     68            */
     69          
     70          /** @defgroup RCC RCC
     71          * @brief RCC HAL module driver
     72            * @{
     73            */
     74          
     75          #ifdef HAL_RCC_MODULE_ENABLED
     76          
     77          /* Private typedef -----------------------------------------------------------*/
     78          /* Private define ------------------------------------------------------------*/
     79          /* Private macro -------------------------------------------------------------*/
     80          /** @defgroup RCC_Private_Macros RCC Private Macros
     81            * @{
     82            */
     83          
     84          #define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()
     85          #define MCO1_GPIO_PORT        GPIOA
     86          #define MCO1_PIN              GPIO_PIN_8
     87          
     88          #define MCO2_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()
     89          #define MCO2_GPIO_PORT        GPIOA
     90          #define MCO2_PIN              GPIO_PIN_9
     91          
     92          #if  defined(STM32L031xx) || defined(STM32L041xx) || defined(STM32L073xx) || defined(STM32L083xx) \
     93            || defined(STM32L072xx) || defined(STM32L082xx) || defined(STM32L071xx) || defined(STM32L081xx)
     94          #define MCO3_CLK_ENABLE()     __HAL_RCC_GPIOB_CLK_ENABLE()
     95          #define MCO3_GPIO_PORT        GPIOB
     96          #define MCO3_PIN              GPIO_PIN_13
     97          #endif
     98          
     99          /**
    100            * @}
    101            */
    102          
    103          /* Private variables ---------------------------------------------------------*/
    104          /* Private function prototypes -----------------------------------------------*/
    105          /* Exported functions ---------------------------------------------------------*/
    106          
    107          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    108            * @{
    109            */
    110          
    111          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions
    112            *  @brief    Initialization and Configuration functions
    113            *
    114            @verbatim
    115            ===============================================================================
    116                     ##### Initialization and de-initialization functions #####
    117            ===============================================================================
    118              [..]
    119                This section provides functions allowing to configure the internal/external oscillators
    120                (MSI, HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB, APB1
    121                and APB2).
    122          
    123              [..] Internal/external clock and PLL configuration
    124                (#) MSI (Multispeed internal), Seven frequency ranges are available: 65.536 kHz,
    125                    131.072 kHz, 262.144 kHz, 524.288 kHz, 1.048 MHz, 2.097 MHz (default value) and 4.194 MHz.
    126          
    127                (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    128                    the PLL as System clock source.
    129                (#) LSI (low-speed internal), ~37 KHz low consumption RC used as IWDG and/or RTC
    130                    clock source.
    131          
    132                (#) HSE (high-speed external), 1 to 24 MHz crystal oscillator used directly or
    133                    through the PLL as System clock source. Can be used also as RTC clock source.
    134          
    135                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.
    136          
    137                (#) PLL (clocked by HSI or HSE), featuring different output clocks:
    138                  (++) The first output is used to generate the high speed system clock (up to 32 MHz)
    139                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz)
    140          
    141                (#) CSS (Clock security system), once enable using the macro __HAL_RCC_CSS_ENABLE()
    142                    and if a HSE clock failure occurs(HSE used directly or through PLL as System
    143                    clock source), the System clocks automatically switched to MSI and an interrupt
    144                    is generated if enabled. The interrupt is linked to the Cortex-M0+ NMI
    145                    (Non-Maskable Interrupt) exception vector.
    146          
    147                (#) MCO1/MCO2/MCO3 (microcontroller clock output), used to output SYSCLK, HSI, LSI, MSI, LSE,
    148                    HSE, HSI48 or PLL clock (through a configurable prescaler) on PA8/PA9/PB13 pins.
    149          
    150              [..] System, AHB and APB buses clocks configuration
    151                (#) Several clock sources can be used to drive the System clock (SYSCLK): MSI, HSI,
    152                    HSE and PLL.
    153                    The AHB clock (HCLK) is derived from System clock through configurable
    154                    prescaler and used to clock the CPU, memory and peripherals mapped
    155                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived
    156                    from AHB clock through configurable prescalers and used to clock
    157                    the peripherals mapped on these buses. You can use
    158                    "@ref HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.
    159          
    160                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    161                    (+@) RTC: RTC clock can be derived either from the LSI, LSE or HSE clock
    162                        divided by 2 to 16. You have to use @ref __HAL_RCC_RTC_CONFIG() and @ref __HAL_RCC_RTC_ENABLE()
    163                        macros to configure this clock.
    164                    (+@) LCD: LCD clock can be derived either from the LSI, LSE or HSE clock
    165                        divided by 2 to 16. You have to use @ref __HAL_RCC_LCD_CONFIG()
    166                        macros to configure this clock.
    167                    (+@) USB FS and RNG: USB FS require a frequency equal to 48 MHz to work correctly.
    168                         This clock is derived of the main PLL through PLL Multiplier or HSI48 RC oscillator.
    169          
    170                    (+@) IWDG clock which is always the LSI clock.
    171          
    172                (#) The maximum frequency of the SYSCLK and HCLK is 32 MHz, PCLK2 32 MHz
    173                    and PCLK1 32 MHz. Depending on the device voltage range, the maximum
    174                    frequency should be adapted accordingly.
    175            @endverbatim
    176            * @{
    177            */
    178          
    179          /*
    180            Additional consideration on the HCLK based on Latency settings:
    181            +----------------------------------------------------------------------+
    182            | Latency       |                HCLK clock frequency (MHz)            |
    183            |               |------------------------------------------------------|
    184            |               | voltage range 1  | voltage range 2 | voltage range 3 |
    185            |               |      1.8 V       |     1.5 V       |      1.2 V      |
    186            |---------------|------------------|-----------------|-----------------|
    187            |0WS(1CPU cycle)| 0 < HCLK <= 16   | 0 < HCLK <= 8   | 0 < HCLK <= 4.2 |
    188            |---------------|------------------|-----------------|-----------------|
    189            |1WS(2CPU cycle)| 16 < HCLK <= 32  | 8 < HCLK <= 16  |                 |
    190            +----------------------------------------------------------------------+
    191          
    192            The following table gives the different clock source frequencies depending on the product
    193            voltage range:
    194            +------------------------------------------------------------------------------------------+
    195            | Product voltage |                    Clock frequency                                     |
    196            |                 |------------------|-----------------------------|-----------------------|
    197            |      range      |   MSI   |   HSI  |              HSE            |          PLL          |
    198            |-----------------|---------|--------|-----------------------------|-----------------------|
    199            | Range 1 (1.8 V) | 4.2 MHz | 16 MHz | HSE 32 MHz (external clock) |         32 MHz        |
    200            |                 |         |        |      or 24 MHz (crystal)    | (PLLVCO max = 96 MHz) |
    201            |-----------------|---------|--------|-----------------------------|-----------------------|
    202            | Range 2 (1.5 V) | 4.2 MHz | 16 MHz |         16 MHz              |         16 MHz        |
    203            |                 |         |        |                             | (PLLVCO max = 48 MHz) |
    204            |-----------------|---------|--------|-----------------------------|-----------------------|
    205            | Range 3 (1.2 V) | 4.2 MHz |   NA   |         8 MHz               |           4 MHz       |
    206            |                 |         |        |                             | (PLLVCO max = 24 MHz) |
    207            +------------------------------------------------------------------------------------------+
    208            */
    209          
    210          /**
    211            * @brief  Resets the RCC clock configuration to the default reset state.
    212            * @note   The default reset state of the clock configuration is given below:
    213            *            - MSI ON and used as system clock source
    214            *            - HSI, HSE and PLL  OFF
    215            *            - AHB, APB1 and APB2 prescaler set to 1.
    216            *            - CSS and MCO1/MCO2/MCO3 OFF
    217            *            - All interrupts disabled
    218            * @note   This function does not modify the configuration of the
    219            *            - Peripheral clocks
    220            *            - LSI, LSE and RTC clocks
    221            *            - HSI48 clock
    222            * @retval None
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          HAL_StatusTypeDef HAL_RCC_DeInit(void)
    225          {
   \                     HAL_RCC_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    226            __IO uint32_t tmpreg;
    227            uint32_t tickstart;
    228            uint32_t vl_mask;
    229            HAL_StatusTypeDef status;
    230          
    231            /* Set MSIClockRange, HSITRIM and MSITRIM bits to the reset values */
    232            MODIFY_REG(RCC->ICSCR, (RCC_ICSCR_MSITRIM | RCC_ICSCR_HSITRIM | RCC_ICSCR_MSIRANGE), \
    233                      ((RCC_MSICALIBRATION_DEFAULT << RCC_ICSCR_MSITRIM_Pos) | (RCC_HSICALIBRATION_DEFAULT << RCC_ICSCR_HSITRIM_Pos) | RCC_ICSCR_MSIRANGE_5));
   \        0x2   0x....             LDR      R4,??DataTable0  ;; 0x40021000
   \        0x4   0x6860             LDR      R0,[R4, #+4]
   \        0x6   0x....             LDR      R1,??DataTable0_1  ;; 0xff00ff
   \        0x8   0x4001             ANDS     R1,R1,R0
   \        0xA   0x20B0             MOVS     R0,#+176
   \        0xC   0x0200             LSLS     R0,R0,#+8        ;; #+45056
   \        0xE   0x4308             ORRS     R0,R0,R1
   \       0x10   0x6060             STR      R0,[R4, #+4]
    234          
    235            /* Set MSION bit */
    236            SET_BIT(RCC->CR, RCC_CR_MSION);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x0DA1             LSRS     R1,R4,#+22
   \       0x16   0x4301             ORRS     R1,R1,R0
   \       0x18   0x6021             STR      R1,[R4, #+0]
    237          
    238            /* Get Start Tick*/
    239            tickstart = HAL_GetTick();
   \       0x1A   0x....'....        BL       HAL_GetTick
   \       0x1E   0x0005             MOVS     R5,R0
    240          
    241            /* Wait till MSI is ready */
    242            while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
   \                     ??HAL_RCC_DeInit_0: (+1)
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x0580             LSLS     R0,R0,#+22
   \       0x24   0xD406             BMI      ??HAL_RCC_DeInit_1
    243            {
    244              if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
   \       0x26   0x....'....        BL       HAL_GetTick
   \       0x2A   0x1B40             SUBS     R0,R0,R5
   \       0x2C   0x2803             CMP      R0,#+3
   \       0x2E   0xD3F7             BCC      ??HAL_RCC_DeInit_0
    245              {
    246                return HAL_TIMEOUT;
    247              }
    248            }
    249          
    250            /* Switch SYSCLK to MSI*/
    251            CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
    252          
    253            /* Wait till MSI as SYSCLK status is ready */
    254            while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
    255            {
    256              if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
    257              {
    258                return HAL_TIMEOUT;
    259              }
    260            }
    261          
    262            /* Update the SystemCoreClock global variable for MSI as system clock source */
    263            SystemCoreClock = MSI_VALUE;
    264          
    265            /* Configure the source of time base considering new system clock settings  */
    266            status = HAL_InitTick(TICK_INT_PRIORITY);
    267            if(status != HAL_OK)
    268            {
    269              return status;
    270            }
    271          
    272            /* Reset HSE, HSI, CSS, PLL */
    273          #if defined(RCC_CR_CSSHSEON) && defined(RCC_CR_HSIOUTEN)
    274            CLEAR_BIT(RCC->CR, RCC_CR_HSION| RCC_CR_HSIKERON| RCC_CR_HSIDIVEN | RCC_CR_HSIOUTEN | \
    275                               RCC_CR_HSEON | RCC_CR_CSSHSEON | RCC_CR_PLLON);
    276          #elif !defined(RCC_CR_CSSHSEON) && defined(RCC_CR_HSIOUTEN)
    277            CLEAR_BIT(RCC->CR, RCC_CR_HSION| RCC_CR_HSIKERON| RCC_CR_HSIDIVEN | RCC_CR_HSIOUTEN | \
    278                               RCC_CR_HSEON | RCC_CR_PLLON);
    279          #elif defined(RCC_CR_CSSHSEON) && !defined(RCC_CR_HSIOUTEN)
    280            CLEAR_BIT(RCC->CR, RCC_CR_HSION| RCC_CR_HSIKERON| RCC_CR_HSIDIVEN | \
    281                               RCC_CR_HSEON | RCC_CR_CSSHSEON | RCC_CR_PLLON);
    282          #endif
    283          
    284            /* Delay after an RCC peripheral clock */ \
    285            tmpreg = READ_BIT(RCC->CR, RCC_CR_HSEON);      \
    286            UNUSED(tmpreg);
    287          
    288            /* Reset HSEBYP bit */
    289            CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
    290          
    291            /* Get Start Tick*/
    292            tickstart = HAL_GetTick();
    293          
    294            /* Wait till PLL is not ready */
    295            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
    296            {
    297              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
    298              {
    299                return HAL_TIMEOUT;
   \                     ??HAL_RCC_DeInit_2: (+1)
   \       0x30   0x2003             MOVS     R0,#+3
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}
    300              }
   \                     ??HAL_RCC_DeInit_1: (+1)
   \       0x34   0x68E0             LDR      R0,[R4, #+12]
   \       0x36   0x2103             MOVS     R1,#+3
   \       0x38   0x4388             BICS     R0,R0,R1
   \       0x3A   0x60E0             STR      R0,[R4, #+12]
   \                     ??HAL_RCC_DeInit_3: (+1)
   \       0x3C   0x68E0             LDR      R0,[R4, #+12]
   \       0x3E   0x210C             MOVS     R1,#+12
   \       0x40   0x4001             ANDS     R1,R1,R0
   \       0x42   0xD006             BEQ      ??HAL_RCC_DeInit_4
   \       0x44   0x....'....        BL       HAL_GetTick
   \       0x48   0x1B40             SUBS     R0,R0,R5
   \       0x4A   0x....             LDR      R1,??DataTable0_2  ;; 0x1389
   \       0x4C   0x4288             CMP      R0,R1
   \       0x4E   0xD3F5             BCC      ??HAL_RCC_DeInit_3
   \       0x50   0xE7EE             B        ??HAL_RCC_DeInit_2
   \                     ??HAL_RCC_DeInit_4: (+1)
   \       0x52   0x....             LDR      R0,??DataTable0_3  ;; 0x1e8480
   \       0x54   0x....             LDR      R1,??DataTable0_4
   \       0x56   0x6008             STR      R0,[R1, #+0]
   \       0x58   0x2003             MOVS     R0,#+3
   \       0x5A   0x....'....        BL       HAL_InitTick
   \       0x5E   0x0001             MOVS     R1,R0
   \       0x60   0xD124             BNE      ??HAL_RCC_DeInit_5
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x....             LDR      R1,??DataTable0_5  ;; 0xfef6fff4
   \       0x66   0x4001             ANDS     R1,R1,R0
   \       0x68   0x6021             STR      R1,[R4, #+0]
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x2180             MOVS     R1,#+128
   \       0x6E   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \       0x70   0x4008             ANDS     R0,R0,R1
   \       0x72   0x9000             STR      R0,[SP, #+0]
   \       0x74   0x9800             LDR      R0,[SP, #+0]
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x....             LDR      R1,??DataTable0_6  ;; 0xfffbffff
   \       0x7A   0x4001             ANDS     R1,R1,R0
   \       0x7C   0x6021             STR      R1,[R4, #+0]
   \       0x7E   0x....'....        BL       HAL_GetTick
   \       0x82   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_DeInit_6: (+1)
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x0180             LSLS     R0,R0,#+6
   \       0x88   0xD505             BPL      ??HAL_RCC_DeInit_7
   \       0x8A   0x....'....        BL       HAL_GetTick
   \       0x8E   0x1B40             SUBS     R0,R0,R5
   \       0x90   0x2803             CMP      R0,#+3
   \       0x92   0xD3F7             BCC      ??HAL_RCC_DeInit_6
   \       0x94   0xE7CC             B        ??HAL_RCC_DeInit_2
    301            }
    302          
    303            /* Reset CFGR register */
    304            CLEAR_REG(RCC->CFGR);
   \                     ??HAL_RCC_DeInit_7: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x60E0             STR      R0,[R4, #+12]
    305          
    306            /* Disable all interrupts */
    307            CLEAR_REG(RCC->CIER);
   \       0x9A   0x6120             STR      R0,[R4, #+16]
    308          
    309            /* Clear all flags */
    310            vl_mask = RCC_CICR_LSIRDYC | RCC_CICR_LSERDYC | RCC_CICR_HSIRDYC | RCC_CICR_HSERDYC | RCC_CICR_PLLRDYC | RCC_CICR_MSIRDYC | RCC_CICR_CSSLSEC;
    311          #if defined(RCC_HSI48_SUPPORT)
    312            vl_mask |= RCC_CICR_HSI48RDYC;
    313          #endif
    314          #if defined(RCC_HSECSS_SUPPORT)
    315            vl_mask |= RCC_CICR_CSSHSEC;
    316          #endif
    317            WRITE_REG(RCC->CICR, vl_mask);
   \       0x9C   0x....             LDR      R0,??DataTable0_7  ;; 0x1ff
   \       0x9E   0x61A0             STR      R0,[R4, #+24]
    318          
    319            /* Clear all reset flags */
    320            SET_BIT(RCC->CSR, RCC_CSR_RMVF);
   \       0xA0   0x6D20             LDR      R0,[R4, #+80]
   \       0xA2   0x2180             MOVS     R1,#+128
   \       0xA4   0x0409             LSLS     R1,R1,#+16       ;; #+8388608
   \       0xA6   0x4301             ORRS     R1,R1,R0
   \       0xA8   0x6521             STR      R1,[R4, #+80]
    321          
    322            return HAL_OK;
   \       0xAA   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_DeInit_5: (+1)
   \       0xAC   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    323          }
    324          
    325          /**
    326            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    327            *         RCC_OscInitTypeDef.
    328            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
    329            *         contains the configuration information for the RCC Oscillators.
    330            * @note   The PLL is not disabled when used as system clock.
    331            * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
    332            *         supported by this macro. User should request a transition to LSE Off
    333            *         first and then LSE On or LSE Bypass.
    334            * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
    335            *         supported by this macro. User should request a transition to HSE Off
    336            *         first and then HSE On or HSE Bypass.
    337            * @retval HAL status
    338            */

   \                                 In section .text, align 4, keep-with-next
    339          HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    340          {
   \                     HAL_RCC_OscConfig: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
    341            uint32_t tickstart;
    342            uint32_t hsi_state;
    343            HAL_StatusTypeDef status;
    344            uint32_t sysclk_source, pll_config;
    345          
    346            /* Check the parameters */
    347            if(RCC_OscInitStruct == NULL)
   \        0x4   0xD057             BEQ      ??HAL_RCC_OscConfig_4
    348            {
    349              return HAL_ERROR;
    350            }
    351          
    352            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    353          
    354            sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
   \        0x6   0x4CB6             LDR      R4,??HAL_RCC_OscConfig_0  ;; 0x40021000
   \        0x8   0x68E0             LDR      R0,[R4, #+12]
   \        0xA   0x210C             MOVS     R1,#+12
   \        0xC   0x4001             ANDS     R1,R1,R0
   \        0xE   0x9100             STR      R1,[SP, #+0]
    355            pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
   \       0x10   0x68E0             LDR      R0,[R4, #+12]
   \       0x12   0x2180             MOVS     R1,#+128
   \       0x14   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \       0x16   0x4008             ANDS     R0,R0,R1
   \       0x18   0x9001             STR      R0,[SP, #+4]
    356          
    357            /*------------------------------- HSE Configuration ------------------------*/
    358            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \       0x1A   0x7830             LDRB     R0,[R6, #+0]
   \       0x1C   0x07C0             LSLS     R0,R0,#+31
   \       0x1E   0xD50E             BPL      ??HAL_RCC_OscConfig_5
    359            {
    360              /* Check the parameters */
    361              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    362          
    363              /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    364              if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
    365                 || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
   \       0x20   0x004F             LSLS     R7,R1,#+1
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0x2808             CMP      R0,#+8
   \       0x26   0xD004             BEQ      ??HAL_RCC_OscConfig_6
   \       0x28   0x280C             CMP      R0,#+12
   \       0x2A   0xD167             BNE      ??HAL_RCC_OscConfig_7
   \       0x2C   0x9801             LDR      R0,[SP, #+4]
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD164             BNE      ??HAL_RCC_OscConfig_7
    366              {
    367                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x4007             ANDS     R7,R7,R0
   \       0x36   0xD002             BEQ      ??HAL_RCC_OscConfig_5
   \       0x38   0x6870             LDR      R0,[R6, #+4]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD03B             BEQ      ??HAL_RCC_OscConfig_4
    368                {
    369                  return HAL_ERROR;
    370                }
    371              }
    372              else
    373              {
    374                /* Set the new HSE configuration ---------------------------------------*/
    375                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    376          
    377                /* Check the HSE State */
    378                if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
    379                {
    380                  /* Get Start Tick */
    381                  tickstart = HAL_GetTick();
    382          
    383                  /* Wait till HSE is ready */
    384                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    385                  {
    386                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    387                    {
    388                      return HAL_TIMEOUT;
    389                    }
    390                  }
    391                }
    392                else
    393                {
    394                  /* Get Start Tick */
    395                  tickstart = HAL_GetTick();
    396          
    397                  /* Wait till HSE is disabled */
    398                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    399                  {
    400                     if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    401                    {
    402                      return HAL_TIMEOUT;
    403                    }
    404                  }
    405                }
    406              }
    407            }
    408            /*----------------------------- HSI Configuration --------------------------*/
    409            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \       0x3E   0x7830             LDRB     R0,[R6, #+0]
   \       0x40   0x0780             LSLS     R0,R0,#+30
   \       0x42   0xD52A             BPL      ??HAL_RCC_OscConfig_8
    410            {
    411              /* Check the parameters */
    412              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    413              assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    414          
    415              hsi_state = RCC_OscInitStruct->HSIState;
   \       0x44   0x68F0             LDR      R0,[R6, #+12]
    416          
    417          #if defined(RCC_CR_HSIOUTEN)
    418              if((hsi_state & RCC_HSI_OUTEN) != 0U)
    419              {
    420                /* HSI Output enable for timer requested */
    421                SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
    422          
    423                hsi_state &= ~RCC_CR_HSIOUTEN;
    424              }
    425          #endif
    426          
    427              /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    428              if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
    429                 || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
   \       0x46   0x4FBA             LDR      R7,??HAL_RCC_OscConfig_1  ;; 0xffffe0ff
   \       0x48   0x2109             MOVS     R1,#+9
   \       0x4A   0x43C9             MVNS     R1,R1            ;; #-10
   \       0x4C   0x9A00             LDR      R2,[SP, #+0]
   \       0x4E   0x2A04             CMP      R2,#+4
   \       0x50   0xD005             BEQ      ??HAL_RCC_OscConfig_9
   \       0x52   0x2A0C             CMP      R2,#+12
   \       0x54   0xD101             BNE      ??HAL_RCC_OscConfig_10
   \       0x56   0x9A01             LDR      R2,[SP, #+4]
   \       0x58   0x2A00             CMP      R2,#+0
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \       0x5A   0xD000             BEQ      .+4
   \       0x5C   0xE089             B        ??HAL_RCC_OscConfig_11
    430              {
    431                /* When HSI is used as system clock it will not disabled */
    432                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \       0x5E   0x6822             LDR      R2,[R4, #+0]
   \       0x60   0x0752             LSLS     R2,R2,#+29
   \       0x62   0xD501             BPL      ??HAL_RCC_OscConfig_12
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD026             BEQ      ??HAL_RCC_OscConfig_4
    433                {
    434                  return HAL_ERROR;
    435                }
    436                /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
    437                else
    438                {
    439                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    440                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \       0x68   0x6862             LDR      R2,[R4, #+4]
   \       0x6A   0x4017             ANDS     R7,R7,R2
   \       0x6C   0x6932             LDR      R2,[R6, #+16]
   \       0x6E   0x0212             LSLS     R2,R2,#+8
   \       0x70   0x433A             ORRS     R2,R2,R7
   \       0x72   0x6062             STR      R2,[R4, #+4]
    441          
    442                  /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
    443                  __HAL_RCC_HSI_CONFIG(hsi_state);
   \       0x74   0x6822             LDR      R2,[R4, #+0]
   \       0x76   0x4011             ANDS     R1,R1,R2
   \       0x78   0x4308             ORRS     R0,R0,R1
   \       0x7A   0x6020             STR      R0,[R4, #+0]
    444                }
    445          
    446                /* Update the SystemCoreClock global variable */
    447                SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
   \       0x7C   0x....'....        BL       HAL_RCC_GetSysClockFreq
   \       0x80   0x49AC             LDR      R1,??HAL_RCC_OscConfig_1+0x4
   \       0x82   0x68E2             LDR      R2,[R4, #+12]
   \       0x84   0x0612             LSLS     R2,R2,#+24
   \       0x86   0x0F12             LSRS     R2,R2,#+28
   \       0x88   0x5C89             LDRB     R1,[R1, R2]
   \       0x8A   0x40C8             LSRS     R0,R0,R1
   \       0x8C   0x49BD             LDR      R1,??HAL_RCC_OscConfig_2
   \       0x8E   0x6008             STR      R0,[R1, #+0]
    448          
    449                /* Configure the source of time base considering new system clocks settings*/
    450                status = HAL_InitTick (TICK_INT_PRIORITY);
   \       0x90   0x2003             MOVS     R0,#+3
   \       0x92   0x....'....        BL       HAL_InitTick
    451                if(status != HAL_OK)
   \       0x96   0x0001             MOVS     R1,R0
   \       0x98   0xD12F             BNE      ??HAL_RCC_OscConfig_13
    452                {
    453                  return status;
    454                }
    455              }
    456              else
    457              {
    458                /* Check the HSI State */
    459                if(hsi_state != RCC_HSI_OFF)
    460                {
    461                  /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
    462                  __HAL_RCC_HSI_CONFIG(hsi_state);
    463          
    464                  /* Get Start Tick */
    465                  tickstart = HAL_GetTick();
    466          
    467                  /* Wait till HSI is ready */
    468                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    469                  {
    470                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    471                    {
    472                      return HAL_TIMEOUT;
    473                    }
    474                  }
    475          
    476                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    477                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    478                }
    479                else
    480                {
    481                  /* Disable the Internal High Speed oscillator (HSI). */
    482                  __HAL_RCC_HSI_DISABLE();
    483          
    484                  /* Get Start Tick */
    485                  tickstart = HAL_GetTick();
    486          
    487                  /* Wait till HSI is disabled */
    488                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    489                  {
    490                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    491                    {
    492                      return HAL_TIMEOUT;
    493                    }
    494                  }
    495                }
    496              }
    497            }
    498            /*----------------------------- MSI Configuration --------------------------*/
    499            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \       0x9A   0x7830             LDRB     R0,[R6, #+0]
   \       0x9C   0x06C0             LSLS     R0,R0,#+27
   \       0x9E   0xD400             BMI      .+4
   \       0xA0   0xE0B3             B        ??HAL_RCC_OscConfig_14
    500            {
    501              /* When the MSI is used as system clock it will not be disabled */
    502              if((sysclk_source == RCC_CFGR_SWS_MSI) )
   \       0xA2   0x4FB9             LDR      R7,??HAL_RCC_OscConfig_2+0x4  ;; 0xffff1fff
   \       0xA4   0x9800             LDR      R0,[SP, #+0]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD000             BEQ      .+4
   \       0xAA   0xE08F             B        ??HAL_RCC_OscConfig_15
    503              {
    504                if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x0580             LSLS     R0,R0,#+22
   \       0xB0   0xD503             BPL      ??HAL_RCC_OscConfig_16
   \       0xB2   0x69F0             LDR      R0,[R6, #+28]
   \       0xB4   0x2800             CMP      R0,#+0
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \       0xB6   0xD100             BNE      .+4
   \       0xB8   0xE1D7             B        ??HAL_RCC_OscConfig_17
    505                {
    506                  return HAL_ERROR;
    507                }
    508                /* Otherwise, just the calibration and MSI range change are allowed */
    509                else
    510                {
    511                  /* Check MSICalibrationValue and MSIClockRange input parameters */
    512                  assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    513                  assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
    514          
    515                  /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    516                  __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \       0xBA   0x6860             LDR      R0,[R4, #+4]
   \       0xBC   0x4007             ANDS     R7,R7,R0
   \       0xBE   0x6A70             LDR      R0,[R6, #+36]
   \       0xC0   0x4338             ORRS     R0,R0,R7
   \       0xC2   0x6060             STR      R0,[R4, #+4]
    517                  /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    518                  __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
   \       0xC4   0x6860             LDR      R0,[R4, #+4]
   \       0xC6   0x0200             LSLS     R0,R0,#+8
   \       0xC8   0x0A00             LSRS     R0,R0,#+8
   \       0xCA   0x6A31             LDR      R1,[R6, #+32]
   \       0xCC   0x0609             LSLS     R1,R1,#+24
   \       0xCE   0x4301             ORRS     R1,R1,R0
   \       0xD0   0x6061             STR      R1,[R4, #+4]
    519          
    520          
    521                  /* Update the SystemCoreClock global variable */
    522                  SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
    523                                     >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0x6A71             LDR      R1,[R6, #+36]
   \       0xD6   0x0B49             LSRS     R1,R1,#+13
   \       0xD8   0x1C49             ADDS     R1,R1,#+1
   \       0xDA   0x4088             LSLS     R0,R0,R1
   \       0xDC   0x03C0             LSLS     R0,R0,#+15
   \       0xDE   0x4995             LDR      R1,??HAL_RCC_OscConfig_1+0x4
   \       0xE0   0x68E2             LDR      R2,[R4, #+12]
   \       0xE2   0x0612             LSLS     R2,R2,#+24
   \       0xE4   0x0F12             LSRS     R2,R2,#+28
   \       0xE6   0x5C89             LDRB     R1,[R1, R2]
   \       0xE8   0x40C8             LSRS     R0,R0,R1
   \       0xEA   0x49A6             LDR      R1,??HAL_RCC_OscConfig_2
   \       0xEC   0x6008             STR      R0,[R1, #+0]
    524          
    525                  /* Configure the source of time base considering new system clocks settings*/
    526                  status = HAL_InitTick (TICK_INT_PRIORITY);
   \       0xEE   0x2003             MOVS     R0,#+3
   \       0xF0   0x....'....        BL       HAL_InitTick
    527                  if(status != HAL_OK)
   \       0xF4   0x0001             MOVS     R1,R0
   \       0xF6   0xD100             BNE      .+4
   \       0xF8   0xE087             B        ??HAL_RCC_OscConfig_14
    528                  {
    529                    return status;
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \       0xFA   0xBDFE             POP      {R1-R7,PC}
    530                  }
    531                }
    532              }
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \       0xFC   0x6870             LDR      R0,[R6, #+4]
   \       0xFE   0x4288             CMP      R0,R1
   \      0x100   0xD101             BNE      ??HAL_RCC_OscConfig_18
   \      0x102   0x6820             LDR      R0,[R4, #+0]
   \      0x104   0xE009             B.N      ??HAL_RCC_OscConfig_19
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \      0x106   0x21A0             MOVS     R1,#+160
   \      0x108   0x02C9             LSLS     R1,R1,#+11       ;; #+327680
   \      0x10A   0x4288             CMP      R0,R1
   \      0x10C   0x6820             LDR      R0,[R4, #+0]
   \      0x10E   0xD106             BNE      ??HAL_RCC_OscConfig_20
   \      0x110   0x0079             LSLS     R1,R7,#+1
   \      0x112   0x4301             ORRS     R1,R1,R0
   \      0x114   0x6021             STR      R1,[R4, #+0]
   \      0x116   0x6820             LDR      R0,[R4, #+0]
   \      0x118   0x0879             LSRS     R1,R7,#+1
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \      0x11A   0x4301             ORRS     R1,R1,R0
   \      0x11C   0xE00A             B        ??HAL_RCC_OscConfig_21
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \      0x11E   0x49B2             LDR      R1,??HAL_RCC_OscConfig_3  ;; 0xfffeffff
   \      0x120   0x4001             ANDS     R1,R1,R0
   \      0x122   0x6021             STR      R1,[R4, #+0]
   \      0x124   0x6820             LDR      R0,[R4, #+0]
   \      0x126   0x0879             LSRS     R1,R7,#+1
   \      0x128   0x4008             ANDS     R0,R0,R1
   \      0x12A   0x9002             STR      R0,[SP, #+8]
   \      0x12C   0x9802             LDR      R0,[SP, #+8]
   \      0x12E   0x6820             LDR      R0,[R4, #+0]
   \      0x130   0x49AE             LDR      R1,??HAL_RCC_OscConfig_3+0x4  ;; 0xfffbffff
   \      0x132   0x4001             ANDS     R1,R1,R0
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \      0x134   0x6021             STR      R1,[R4, #+0]
   \      0x136   0x6870             LDR      R0,[R6, #+4]
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD00D             BEQ      ??HAL_RCC_OscConfig_22
   \      0x13C   0x....'....        BL       HAL_GetTick
   \      0x140   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \      0x142   0x6820             LDR      R0,[R4, #+0]
   \      0x144   0x4038             ANDS     R0,R0,R7
   \      0x146   0xD000             BEQ      .+4
   \      0x148   0xE779             B        ??HAL_RCC_OscConfig_5
   \      0x14A   0x....'....        BL       HAL_GetTick
   \      0x14E   0x1B40             SUBS     R0,R0,R5
   \      0x150   0x2865             CMP      R0,#+101
   \      0x152   0xD3F6             BCC      ??HAL_RCC_OscConfig_23
    533              else
    534              {
    535                /* Check MSI State */
    536                assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    537          
    538                /* Check the MSI State */
    539                if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
    540                {
    541                  /* Enable the Multi Speed oscillator (MSI). */
    542                  __HAL_RCC_MSI_ENABLE();
    543          
    544                  /* Get Start Tick */
    545                  tickstart = HAL_GetTick();
    546          
    547                  /* Wait till MSI is ready */
    548                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
    549                  {
    550                    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
    551                    {
    552                      return HAL_TIMEOUT;
    553                    }
    554                  }
    555                  /* Check MSICalibrationValue and MSIClockRange input parameters */
    556                  assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    557                  assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
    558          
    559                  /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    560                  __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
    561                   /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    562                  __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
    563                }
    564                else
    565                {
    566                  /* Disable the Multi Speed oscillator (MSI). */
    567                  __HAL_RCC_MSI_DISABLE();
    568          
    569                  /* Get Start Tick */
    570                  tickstart = HAL_GetTick();
    571          
    572                  /* Wait till MSI is ready */
    573                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
    574                  {
    575                    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
    576                    {
    577                      return HAL_TIMEOUT;
    578                    }
    579                  }
    580                }
    581              }
    582            }
    583            /*------------------------------ LSI Configuration -------------------------*/
    584            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
    585            {
    586              /* Check the parameters */
    587              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    588          
    589              /* Check the LSI State */
    590              if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
    591              {
    592                /* Enable the Internal Low Speed oscillator (LSI). */
    593                __HAL_RCC_LSI_ENABLE();
    594          
    595                /* Get Start Tick */
    596                tickstart = HAL_GetTick();
    597          
    598                /* Wait till LSI is ready */
    599                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    600                {
    601                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    602                  {
    603                    return HAL_TIMEOUT;
    604                  }
    605                }
    606              }
    607              else
    608              {
    609                /* Disable the Internal Low Speed oscillator (LSI). */
    610                __HAL_RCC_LSI_DISABLE();
    611          
    612                /* Get Start Tick */
    613                tickstart = HAL_GetTick();
    614          
    615                /* Wait till LSI is disabled */
    616                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    617                {
    618                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    619                  {
    620                    return HAL_TIMEOUT;
    621                  }
    622                }
    623              }
    624            }
    625            /*------------------------------ LSE Configuration -------------------------*/
    626            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
    627            {
    628              FlagStatus       pwrclkchanged = RESET;
    629          
    630              /* Check the parameters */
    631              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    632          
    633              /* Update LSE configuration in Backup Domain control register    */
    634              /* Requires to enable write access to Backup Domain of necessary */
    635              if(__HAL_RCC_PWR_IS_CLK_DISABLED())
    636              {
    637                __HAL_RCC_PWR_CLK_ENABLE();
    638                pwrclkchanged = SET;
    639              }
    640          
    641              if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
    642              {
    643                /* Enable write access to Backup domain */
    644                SET_BIT(PWR->CR, PWR_CR_DBP);
    645          
    646                /* Wait for Backup domain Write protection disable */
    647                tickstart = HAL_GetTick();
    648          
    649                while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
    650                {
    651                  if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
    652                  {
    653                    return HAL_TIMEOUT;
    654                  }
    655                }
    656              }
    657          
    658              /* Set the new LSE configuration -----------------------------------------*/
    659              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    660              /* Check the LSE State */
    661              if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    662              {
    663                /* Get Start Tick */
    664                tickstart = HAL_GetTick();
    665          
    666                /* Wait till LSE is ready */
    667                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    668                {
    669                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    670                  {
    671                    return HAL_TIMEOUT;
    672                  }
    673                }
    674              }
    675              else
    676              {
    677                /* Get Start Tick */
    678                tickstart = HAL_GetTick();
    679          
    680                /* Wait till LSE is disabled */
    681                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    682                {
    683                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    684                  {
    685                    return HAL_TIMEOUT;
    686                  }
    687                }
    688              }
    689          
    690              /* Require to disable power clock if necessary */
    691              if(pwrclkchanged == SET)
    692              {
    693                __HAL_RCC_PWR_CLK_DISABLE();
    694              }
    695            }
    696          
    697          #if defined(RCC_HSI48_SUPPORT)
    698            /*----------------------------- HSI48 Configuration --------------------------*/
    699            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
    700            {
    701              /* Check the parameters */
    702              assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    703          
    704                /* Check the HSI48 State */
    705                if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
    706                {
    707                  /* Enable the Internal High Speed oscillator (HSI48). */
    708                  __HAL_RCC_HSI48_ENABLE();
    709          
    710                  /* Get Start Tick */
    711                  tickstart = HAL_GetTick();
    712          
    713                  /* Wait till HSI48 is ready */
    714                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    715                  {
    716                    if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
    717                    {
    718                      return HAL_TIMEOUT;
    719                    }
    720                  }
    721                }
    722                else
    723                {
    724                  /* Disable the Internal High Speed oscillator (HSI48). */
    725                  __HAL_RCC_HSI48_DISABLE();
    726          
    727                  /* Get Start Tick */
    728                  tickstart = HAL_GetTick();
    729          
    730                  /* Wait till HSI48 is ready */
    731                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    732                  {
    733                    if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
    734                    {
    735                      return HAL_TIMEOUT;
    736                    }
    737                  }
    738                }
    739            }
    740          #endif /* RCC_HSI48_SUPPORT */
    741          
    742            /*-------------------------------- PLL Configuration -----------------------*/
    743            /* Check the parameters */
    744            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    745            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
    746            {
    747              /* Check if the PLL is used as system clock or not */
    748              if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
    749              {
    750                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
    751                {
    752                  /* Check the parameters */
    753                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    754                  assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
    755                  assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
    756          
    757                  /* Disable the main PLL. */
    758                  __HAL_RCC_PLL_DISABLE();
    759          
    760                  /* Get Start Tick */
    761                  tickstart = HAL_GetTick();
    762          
    763                  /* Wait till PLL is disabled */
    764                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
    765                  {
    766                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    767                    {
    768                      return HAL_TIMEOUT;
    769                    }
    770                  }
    771          
    772                  /* Configure the main PLL clock source, multiplication and division factors. */
    773                  __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    774                                       RCC_OscInitStruct->PLL.PLLMUL,
    775                                       RCC_OscInitStruct->PLL.PLLDIV);
    776                  /* Enable the main PLL. */
    777                  __HAL_RCC_PLL_ENABLE();
    778          
    779                  /* Get Start Tick */
    780                  tickstart = HAL_GetTick();
    781          
    782                  /* Wait till PLL is ready */
    783                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
    784                  {
    785                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    786                    {
    787                      return HAL_TIMEOUT;
    788                    }
    789                  }
    790                }
    791                else
    792                {
    793                  /* Disable the main PLL. */
    794                  __HAL_RCC_PLL_DISABLE();
    795          
    796                  /* Get Start Tick */
    797                  tickstart = HAL_GetTick();
    798          
    799                  /* Wait till PLL is disabled */
    800                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
    801                  {
    802                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    803                    {
    804                      return HAL_TIMEOUT;
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \      0x154   0x2003             MOVS     R0,#+3
   \      0x156   0xBDFE             POP      {R1-R7,PC}
    805                    }
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \      0x158   0x....'....        BL       HAL_GetTick
   \      0x15C   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \      0x15E   0x6820             LDR      R0,[R4, #+0]
   \      0x160   0x4038             ANDS     R0,R0,R7
   \      0x162   0xD100             BNE      .+4
   \      0x164   0xE76B             B        ??HAL_RCC_OscConfig_5
   \      0x166   0x....'....        BL       HAL_GetTick
   \      0x16A   0x1B40             SUBS     R0,R0,R5
   \      0x16C   0x2865             CMP      R0,#+101
   \      0x16E   0xD3F6             BCC      ??HAL_RCC_OscConfig_25
   \      0x170   0xE7F0             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \      0x172   0x2204             MOVS     R2,#+4
   \      0x174   0x9201             STR      R2,[SP, #+4]
   \      0x176   0x2800             CMP      R0,#+0
   \      0x178   0xD017             BEQ      ??HAL_RCC_OscConfig_26
   \      0x17A   0x6822             LDR      R2,[R4, #+0]
   \      0x17C   0x4011             ANDS     R1,R1,R2
   \      0x17E   0x4308             ORRS     R0,R0,R1
   \      0x180   0x6020             STR      R0,[R4, #+0]
   \      0x182   0x....'....        BL       HAL_GetTick
   \      0x186   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \      0x188   0x6820             LDR      R0,[R4, #+0]
   \      0x18A   0x9901             LDR      R1,[SP, #+4]
   \      0x18C   0x4001             ANDS     R1,R1,R0
   \      0x18E   0xD105             BNE      ??HAL_RCC_OscConfig_28
   \      0x190   0x....'....        BL       HAL_GetTick
   \      0x194   0x1B40             SUBS     R0,R0,R5
   \      0x196   0x2803             CMP      R0,#+3
   \      0x198   0xD3F6             BCC      ??HAL_RCC_OscConfig_27
   \      0x19A   0xE7DB             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \      0x19C   0x6860             LDR      R0,[R4, #+4]
   \      0x19E   0x4007             ANDS     R7,R7,R0
   \      0x1A0   0x6930             LDR      R0,[R6, #+16]
   \      0x1A2   0x0200             LSLS     R0,R0,#+8
   \      0x1A4   0x4338             ORRS     R0,R0,R7
   \      0x1A6   0x6060             STR      R0,[R4, #+4]
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \      0x1A8   0xE777             B        ??HAL_RCC_OscConfig_8
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \      0x1AA   0x6820             LDR      R0,[R4, #+0]
   \      0x1AC   0x2101             MOVS     R1,#+1
   \      0x1AE   0x4388             BICS     R0,R0,R1
   \      0x1B0   0x6020             STR      R0,[R4, #+0]
   \      0x1B2   0x....'....        BL       HAL_GetTick
   \      0x1B6   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \      0x1B8   0x6820             LDR      R0,[R4, #+0]
   \      0x1BA   0x9901             LDR      R1,[SP, #+4]
   \      0x1BC   0x4001             ANDS     R1,R1,R0
   \      0x1BE   0xD0F3             BEQ      ??HAL_RCC_OscConfig_29
   \      0x1C0   0x....'....        BL       HAL_GetTick
   \      0x1C4   0x1B40             SUBS     R0,R0,R5
   \      0x1C6   0x2803             CMP      R0,#+3
   \      0x1C8   0xD3F6             BCC      ??HAL_RCC_OscConfig_30
   \      0x1CA   0xE7C3             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \      0x1CC   0x69F0             LDR      R0,[R6, #+28]
   \      0x1CE   0x2800             CMP      R0,#+0
   \      0x1D0   0x6820             LDR      R0,[R4, #+0]
   \      0x1D2   0xD031             BEQ      ??HAL_RCC_OscConfig_31
   \      0x1D4   0x0DA1             LSRS     R1,R4,#+22
   \      0x1D6   0x4301             ORRS     R1,R1,R0
   \      0x1D8   0x6021             STR      R1,[R4, #+0]
   \      0x1DA   0x....'....        BL       HAL_GetTick
   \      0x1DE   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \      0x1E0   0x6820             LDR      R0,[R4, #+0]
   \      0x1E2   0x0580             LSLS     R0,R0,#+22
   \      0x1E4   0xD405             BMI      ??HAL_RCC_OscConfig_33
   \      0x1E6   0x....'....        BL       HAL_GetTick
   \      0x1EA   0x1B40             SUBS     R0,R0,R5
   \      0x1EC   0x2803             CMP      R0,#+3
   \      0x1EE   0xD3F7             BCC      ??HAL_RCC_OscConfig_32
   \      0x1F0   0xE7B0             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \      0x1F2   0x6860             LDR      R0,[R4, #+4]
   \      0x1F4   0x4007             ANDS     R7,R7,R0
   \      0x1F6   0x6A70             LDR      R0,[R6, #+36]
   \      0x1F8   0x4338             ORRS     R0,R0,R7
   \      0x1FA   0x6060             STR      R0,[R4, #+4]
   \      0x1FC   0x6860             LDR      R0,[R4, #+4]
   \      0x1FE   0x0200             LSLS     R0,R0,#+8
   \      0x200   0x0A00             LSRS     R0,R0,#+8
   \      0x202   0x6A31             LDR      R1,[R6, #+32]
   \      0x204   0x0609             LSLS     R1,R1,#+24
   \      0x206   0x4301             ORRS     R1,R1,R0
   \      0x208   0x6061             STR      R1,[R4, #+4]
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \      0x20A   0x7830             LDRB     R0,[R6, #+0]
   \      0x20C   0x0700             LSLS     R0,R0,#+28
   \      0x20E   0xD531             BPL      ??HAL_RCC_OscConfig_34
   \      0x210   0x2702             MOVS     R7,#+2
   \      0x212   0x6970             LDR      R0,[R6, #+20]
   \      0x214   0x2800             CMP      R0,#+0
   \      0x216   0x6D20             LDR      R0,[R4, #+80]
   \      0x218   0xD01D             BEQ      ??HAL_RCC_OscConfig_35
   \      0x21A   0x2101             MOVS     R1,#+1
   \      0x21C   0x4301             ORRS     R1,R1,R0
   \      0x21E   0x6521             STR      R1,[R4, #+80]
   \      0x220   0x....'....        BL       HAL_GetTick
   \      0x224   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \      0x226   0x6D20             LDR      R0,[R4, #+80]
   \      0x228   0x4038             ANDS     R0,R0,R7
   \      0x22A   0xD123             BNE      ??HAL_RCC_OscConfig_34
   \      0x22C   0x....'....        BL       HAL_GetTick
   \      0x230   0x1B40             SUBS     R0,R0,R5
   \      0x232   0x2803             CMP      R0,#+3
   \      0x234   0xD3F7             BCC      ??HAL_RCC_OscConfig_36
   \      0x236   0xE78D             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \      0x238   0x....             LDR      R1,??DataTable1  ;; 0xfffffeff
   \      0x23A   0x4001             ANDS     R1,R1,R0
   \      0x23C   0x6021             STR      R1,[R4, #+0]
   \      0x23E   0x....'....        BL       HAL_GetTick
   \      0x242   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \      0x244   0x6820             LDR      R0,[R4, #+0]
   \      0x246   0x0580             LSLS     R0,R0,#+22
   \      0x248   0xD5DF             BPL      ??HAL_RCC_OscConfig_14
   \      0x24A   0x....'....        BL       HAL_GetTick
   \      0x24E   0x1B40             SUBS     R0,R0,R5
   \      0x250   0x2803             CMP      R0,#+3
   \      0x252   0xD3F7             BCC      ??HAL_RCC_OscConfig_37
   \      0x254   0xE77E             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \      0x256   0x2101             MOVS     R1,#+1
   \      0x258   0x4388             BICS     R0,R0,R1
   \      0x25A   0x6520             STR      R0,[R4, #+80]
   \      0x25C   0x....'....        BL       HAL_GetTick
   \      0x260   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \      0x262   0x6D20             LDR      R0,[R4, #+80]
   \      0x264   0x4038             ANDS     R0,R0,R7
   \      0x266   0xD005             BEQ      ??HAL_RCC_OscConfig_34
   \      0x268   0x....'....        BL       HAL_GetTick
   \      0x26C   0x1B40             SUBS     R0,R0,R5
   \      0x26E   0x2803             CMP      R0,#+3
   \      0x270   0xD3F7             BCC      ??HAL_RCC_OscConfig_38
   \      0x272   0xE76F             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \      0x274   0x7830             LDRB     R0,[R6, #+0]
   \      0x276   0x0740             LSLS     R0,R0,#+29
   \      0x278   0xD565             BPL      ??HAL_RCC_OscConfig_39
   \      0x27A   0x2000             MOVS     R0,#+0
   \      0x27C   0x9001             STR      R0,[SP, #+4]
   \      0x27E   0x2080             MOVS     R0,#+128
   \      0x280   0x0540             LSLS     R0,R0,#+21       ;; #+268435456
   \      0x282   0x6BA1             LDR      R1,[R4, #+56]
   \      0x284   0x4001             ANDS     R1,R1,R0
   \      0x286   0xD104             BNE      ??HAL_RCC_OscConfig_40
   \      0x288   0x6BA1             LDR      R1,[R4, #+56]
   \      0x28A   0x4308             ORRS     R0,R0,R1
   \      0x28C   0x63A0             STR      R0,[R4, #+56]
   \      0x28E   0x2001             MOVS     R0,#+1
   \      0x290   0x9001             STR      R0,[SP, #+4]
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \      0x292   0x....             LDR      R7,??DataTable1_1  ;; 0x40007000
   \      0x294   0x6838             LDR      R0,[R7, #+0]
   \      0x296   0x05C0             LSLS     R0,R0,#+23
   \      0x298   0xD40F             BMI      ??HAL_RCC_OscConfig_41
   \      0x29A   0x6838             LDR      R0,[R7, #+0]
   \      0x29C   0x0DA1             LSRS     R1,R4,#+22
   \      0x29E   0x4301             ORRS     R1,R1,R0
   \      0x2A0   0x6039             STR      R1,[R7, #+0]
   \      0x2A2   0x....'....        BL       HAL_GetTick
   \      0x2A6   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_42: (+1)
   \      0x2A8   0x6838             LDR      R0,[R7, #+0]
   \      0x2AA   0x05C0             LSLS     R0,R0,#+23
   \      0x2AC   0xD405             BMI      ??HAL_RCC_OscConfig_41
   \      0x2AE   0x....'....        BL       HAL_GetTick
   \      0x2B2   0x1B40             SUBS     R0,R0,R5
   \      0x2B4   0x2865             CMP      R0,#+101
   \      0x2B6   0xD3F7             BCC      ??HAL_RCC_OscConfig_42
   \      0x2B8   0xE74C             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \      0x2BA   0x68B2             LDR      R2,[R6, #+8]
   \      0x2BC   0x0DA1             LSRS     R1,R4,#+22
   \      0x2BE   0x428A             CMP      R2,R1
   \      0x2C0   0xD00A             BEQ      ??HAL_RCC_OscConfig_43
   \      0x2C2   0x....             LDR      R0,??DataTable1_2  ;; 0xfffffbff
   \      0x2C4   0x2A00             CMP      R2,#+0
   \      0x2C6   0xD00D             BEQ      ??HAL_RCC_OscConfig_44
   \      0x2C8   0x23A0             MOVS     R3,#+160
   \      0x2CA   0x00DB             LSLS     R3,R3,#+3        ;; #+1280
   \      0x2CC   0x429A             CMP      R2,R3
   \      0x2CE   0xD109             BNE      ??HAL_RCC_OscConfig_44
   \      0x2D0   0x6D20             LDR      R0,[R4, #+80]
   \      0x2D2   0x008A             LSLS     R2,R1,#+2
   \      0x2D4   0x4302             ORRS     R2,R2,R0
   \      0x2D6   0x6522             STR      R2,[R4, #+80]
   \                     ??HAL_RCC_OscConfig_43: (+1)
   \      0x2D8   0x6D20             LDR      R0,[R4, #+80]
   \      0x2DA   0x4301             ORRS     R1,R1,R0
   \      0x2DC   0x6521             STR      R1,[R4, #+80]
   \      0x2DE   0xE008             B        ??HAL_RCC_OscConfig_45
   \                     ??HAL_RCC_OscConfig_0:
   \      0x2E0   0x4002'1000        DC32     0x40021000
   \                     ??HAL_RCC_OscConfig_44: (+1)
   \      0x2E4   0x6D21             LDR      R1,[R4, #+80]
   \      0x2E6   0x....             LDR      R2,??DataTable1  ;; 0xfffffeff
   \      0x2E8   0x400A             ANDS     R2,R2,R1
   \      0x2EA   0x6522             STR      R2,[R4, #+80]
   \      0x2EC   0x6D21             LDR      R1,[R4, #+80]
   \      0x2EE   0x4008             ANDS     R0,R0,R1
   \      0x2F0   0x6520             STR      R0,[R4, #+80]
   \                     ??HAL_RCC_OscConfig_45: (+1)
   \      0x2F2   0x0D67             LSRS     R7,R4,#+21
   \      0x2F4   0x68B0             LDR      R0,[R6, #+8]
   \      0x2F6   0x2800             CMP      R0,#+0
   \      0x2F8   0xD00C             BEQ      ??HAL_RCC_OscConfig_46
   \      0x2FA   0x....'....        BL       HAL_GetTick
   \      0x2FE   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_47: (+1)
   \      0x300   0x6D20             LDR      R0,[R4, #+80]
   \      0x302   0x4038             ANDS     R0,R0,R7
   \      0x304   0xD118             BNE      ??HAL_RCC_OscConfig_48
   \      0x306   0x....'....        BL       HAL_GetTick
   \      0x30A   0x1B40             SUBS     R0,R0,R5
   \      0x30C   0x....             LDR      R1,??DataTable1_3  ;; 0x1389
   \      0x30E   0x4288             CMP      R0,R1
   \      0x310   0xD3F6             BCC      ??HAL_RCC_OscConfig_47
   \      0x312   0xE71F             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_46: (+1)
   \      0x314   0x....'....        BL       HAL_GetTick
   \      0x318   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_49: (+1)
   \      0x31A   0x6D20             LDR      R0,[R4, #+80]
   \      0x31C   0x4038             ANDS     R0,R0,R7
   \      0x31E   0xD00B             BEQ      ??HAL_RCC_OscConfig_48
   \      0x320   0x....'....        BL       HAL_GetTick
   \      0x324   0x1B40             SUBS     R0,R0,R5
   \      0x326   0x....             LDR      R1,??DataTable1_3  ;; 0x1389
   \      0x328   0x4288             CMP      R0,R1
   \      0x32A   0xD3F6             BCC      ??HAL_RCC_OscConfig_49
   \      0x32C   0xE712             B        ??HAL_RCC_OscConfig_24
   \      0x32E   0xBF00             Nop
   \                     ??HAL_RCC_OscConfig_1:
   \      0x330   0xFFFF'E0FF        DC32     0xffffe0ff
   \      0x334   0x....'....        DC32     AHBPrescTable
   \                     ??HAL_RCC_OscConfig_48: (+1)
   \      0x338   0x9801             LDR      R0,[SP, #+4]
   \      0x33A   0x2800             CMP      R0,#+0
   \      0x33C   0xD003             BEQ      ??HAL_RCC_OscConfig_39
   \      0x33E   0x6BA0             LDR      R0,[R4, #+56]
   \      0x340   0x....             LDR      R1,??DataTable2  ;; 0xefffffff
   \      0x342   0x4001             ANDS     R1,R1,R0
   \      0x344   0x63A1             STR      R1,[R4, #+56]
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \      0x346   0x7830             LDRB     R0,[R6, #+0]
   \      0x348   0x0680             LSLS     R0,R0,#+26
   \      0x34A   0xD533             BPL      ??HAL_RCC_OscConfig_50
   \      0x34C   0x....             LDR      R0,??DataTable2_1  ;; 0x40010020
   \      0x34E   0x2702             MOVS     R7,#+2
   \      0x350   0x69B1             LDR      R1,[R6, #+24]
   \      0x352   0x2900             CMP      R1,#+0
   \      0x354   0xD01A             BEQ      ??HAL_RCC_OscConfig_51
   \      0x356   0x2101             MOVS     R1,#+1
   \      0x358   0x68A2             LDR      R2,[R4, #+8]
   \      0x35A   0x430A             ORRS     R2,R2,R1
   \      0x35C   0x60A2             STR      R2,[R4, #+8]
   \      0x35E   0x6B62             LDR      R2,[R4, #+52]
   \      0x360   0x4311             ORRS     R1,R1,R2
   \      0x362   0x6361             STR      R1,[R4, #+52]
   \      0x364   0x6801             LDR      R1,[R0, #+0]
   \      0x366   0x0C42             LSRS     R2,R0,#+17
   \      0x368   0x430A             ORRS     R2,R2,R1
   \      0x36A   0x6002             STR      R2,[R0, #+0]
   \      0x36C   0x....'....        BL       HAL_GetTick
   \      0x370   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_52: (+1)
   \      0x372   0x68A0             LDR      R0,[R4, #+8]
   \      0x374   0x4038             ANDS     R0,R0,R7
   \      0x376   0xD11D             BNE      ??HAL_RCC_OscConfig_50
   \      0x378   0x....'....        BL       HAL_GetTick
   \      0x37C   0x1B40             SUBS     R0,R0,R5
   \      0x37E   0x2803             CMP      R0,#+3
   \      0x380   0xD3F7             BCC      ??HAL_RCC_OscConfig_52
   \      0x382   0xE6E7             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_2:
   \      0x384   0x....'....        DC32     SystemCoreClock
   \      0x388   0xFFFF'1FFF        DC32     0xffff1fff
   \                     ??HAL_RCC_OscConfig_51: (+1)
   \      0x38C   0x68A1             LDR      R1,[R4, #+8]
   \      0x38E   0x2201             MOVS     R2,#+1
   \      0x390   0x4391             BICS     R1,R1,R2
   \      0x392   0x60A1             STR      R1,[R4, #+8]
   \      0x394   0x6801             LDR      R1,[R0, #+0]
   \      0x396   0x....             LDR      R2,??DataTable4  ;; 0xffffdfff
   \      0x398   0x400A             ANDS     R2,R2,R1
   \      0x39A   0x6002             STR      R2,[R0, #+0]
   \      0x39C   0x....'....        BL       HAL_GetTick
   \      0x3A0   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_53: (+1)
   \      0x3A2   0x68A0             LDR      R0,[R4, #+8]
   \      0x3A4   0x4038             ANDS     R0,R0,R7
   \      0x3A6   0xD005             BEQ      ??HAL_RCC_OscConfig_50
   \      0x3A8   0x....'....        BL       HAL_GetTick
   \      0x3AC   0x1B40             SUBS     R0,R0,R5
   \      0x3AE   0x2803             CMP      R0,#+3
   \      0x3B0   0xD3F7             BCC      ??HAL_RCC_OscConfig_53
   \      0x3B2   0xE6CF             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_50: (+1)
   \      0x3B4   0x6AB0             LDR      R0,[R6, #+40]
   \      0x3B6   0x2800             CMP      R0,#+0
   \      0x3B8   0xD059             BEQ      ??HAL_RCC_OscConfig_54
   \      0x3BA   0x9900             LDR      R1,[SP, #+0]
   \      0x3BC   0x290C             CMP      R1,#+12
   \      0x3BE   0xD03F             BEQ      ??HAL_RCC_OscConfig_55
   \      0x3C0   0x2580             MOVS     R5,#+128
   \      0x3C2   0x04AD             LSLS     R5,R5,#+18       ;; #+33554432
   \      0x3C4   0x....             LDR      R1,??DataTable4_1  ;; 0xfeffffff
   \      0x3C6   0x2802             CMP      R0,#+2
   \      0x3C8   0x6820             LDR      R0,[R4, #+0]
   \      0x3CA   0xD12B             BNE      ??HAL_RCC_OscConfig_56
   \      0x3CC   0x4001             ANDS     R1,R1,R0
   \      0x3CE   0x6021             STR      R1,[R4, #+0]
   \      0x3D0   0x....'....        BL       HAL_GetTick
   \      0x3D4   0x0007             MOVS     R7,R0
   \                     ??HAL_RCC_OscConfig_57: (+1)
   \      0x3D6   0x6820             LDR      R0,[R4, #+0]
   \      0x3D8   0x4028             ANDS     R0,R0,R5
   \      0x3DA   0xD009             BEQ      ??HAL_RCC_OscConfig_58
   \      0x3DC   0x....'....        BL       HAL_GetTick
   \      0x3E0   0x1BC0             SUBS     R0,R0,R7
   \      0x3E2   0x2803             CMP      R0,#+3
   \      0x3E4   0xD3F7             BCC      ??HAL_RCC_OscConfig_57
   \      0x3E6   0xE6B5             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_3:
   \      0x3E8   0xFFFE'FFFF        DC32     0xfffeffff
   \      0x3EC   0xFFFB'FFFF        DC32     0xfffbffff
   \                     ??HAL_RCC_OscConfig_58: (+1)
   \      0x3F0   0x68E0             LDR      R0,[R4, #+12]
   \      0x3F2   0x....             LDR      R1,??DataTable7  ;; 0xff02ffff
   \      0x3F4   0x4001             ANDS     R1,R1,R0
   \      0x3F6   0x6AF0             LDR      R0,[R6, #+44]
   \      0x3F8   0x4308             ORRS     R0,R0,R1
   \      0x3FA   0x6B31             LDR      R1,[R6, #+48]
   \      0x3FC   0x4301             ORRS     R1,R1,R0
   \      0x3FE   0x6B70             LDR      R0,[R6, #+52]
   \      0x400   0x4308             ORRS     R0,R0,R1
   \      0x402   0x60E0             STR      R0,[R4, #+12]
   \      0x404   0x6820             LDR      R0,[R4, #+0]
   \      0x406   0x0869             LSRS     R1,R5,#+1
   \      0x408   0x4301             ORRS     R1,R1,R0
   \      0x40A   0x6021             STR      R1,[R4, #+0]
   \      0x40C   0x....'....        BL       HAL_GetTick
   \      0x410   0x0006             MOVS     R6,R0
   \                     ??HAL_RCC_OscConfig_59: (+1)
   \      0x412   0x6820             LDR      R0,[R4, #+0]
   \      0x414   0x4028             ANDS     R0,R0,R5
   \      0x416   0xD12A             BNE      ??HAL_RCC_OscConfig_54
   \      0x418   0x....'....        BL       HAL_GetTick
   \      0x41C   0x1B80             SUBS     R0,R0,R6
   \      0x41E   0x2803             CMP      R0,#+3
   \      0x420   0xD3F7             BCC      ??HAL_RCC_OscConfig_59
   \      0x422   0xE697             B        ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_56: (+1)
   \      0x424   0x4001             ANDS     R1,R1,R0
   \      0x426   0x6021             STR      R1,[R4, #+0]
   \      0x428   0x....'....        BL       HAL_GetTick
   \      0x42C   0x0006             MOVS     R6,R0
   \                     ??HAL_RCC_OscConfig_60: (+1)
   \      0x42E   0x6820             LDR      R0,[R4, #+0]
   \      0x430   0x4028             ANDS     R0,R0,R5
   \      0x432   0xD01C             BEQ      ??HAL_RCC_OscConfig_54
   \      0x434   0x....'....        BL       HAL_GetTick
   \      0x438   0x1B80             SUBS     R0,R0,R6
   \      0x43A   0x2803             CMP      R0,#+3
   \      0x43C   0xD3F7             BCC      ??HAL_RCC_OscConfig_60
   \      0x43E   0xE689             B        ??HAL_RCC_OscConfig_24
    806                  }
    807                }
    808              }
    809              else
    810              {
    811                /* Check if there is a request to disable the PLL used as System clock source */
    812                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
   \                     ??HAL_RCC_OscConfig_55: (+1)
   \      0x440   0x2801             CMP      R0,#+1
   \      0x442   0xD012             BEQ      ??HAL_RCC_OscConfig_17
    813                {
    814                  return HAL_ERROR;
    815                }
    816                else
    817                {
    818                  /* Do not return HAL_ERROR if request repeats the current configuration */
    819                  pll_config = RCC->CFGR;
   \      0x444   0x68E0             LDR      R0,[R4, #+12]
    820                  if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    821                     (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
    822                     (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
   \      0x446   0x2180             MOVS     R1,#+128
   \      0x448   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \      0x44A   0x4001             ANDS     R1,R1,R0
   \      0x44C   0x6AF2             LDR      R2,[R6, #+44]
   \      0x44E   0x4291             CMP      R1,R2
   \      0x450   0xD10B             BNE      ??HAL_RCC_OscConfig_17
   \      0x452   0x21F0             MOVS     R1,#+240
   \      0x454   0x0389             LSLS     R1,R1,#+14       ;; #+3932160
   \      0x456   0x4001             ANDS     R1,R1,R0
   \      0x458   0x6B32             LDR      R2,[R6, #+48]
   \      0x45A   0x4291             CMP      R1,R2
   \      0x45C   0xD105             BNE      ??HAL_RCC_OscConfig_17
   \      0x45E   0x21C0             MOVS     R1,#+192
   \      0x460   0x0409             LSLS     R1,R1,#+16       ;; #+12582912
   \      0x462   0x4001             ANDS     R1,R1,R0
   \      0x464   0x6B70             LDR      R0,[R6, #+52]
   \      0x466   0x4281             CMP      R1,R0
   \      0x468   0xD001             BEQ      ??HAL_RCC_OscConfig_54
    823                  {
    824                    return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \      0x46A   0x2001             MOVS     R0,#+1
   \      0x46C   0xBDFE             POP      {R1-R7,PC}
    825                  }
    826                }
    827              }
    828            }
    829          
    830            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_54: (+1)
   \      0x46E   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_61: (+1)
   \      0x470   0xBDFE             POP      {R1-R7,PC}       ;; return
    831          }
    832          
    833          /**
    834            * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified
    835            *         parameters in the RCC_ClkInitStruct.
    836            * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
    837            *         contains the configuration information for the RCC peripheral.
    838            * @param  FLatency FLASH Latency
    839            *          The value of this parameter depend on device used within the same series
    840            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
    841            *         and updated by @ref HAL_RCC_GetHCLKFreq() function called within this function
    842            *
    843            * @note   The MSI is used (enabled by hardware) as system clock source after
    844            *         start-up from Reset, wake-up from STOP and STANDBY mode, or in case
    845            *         of failure of the HSE used directly or indirectly as system clock
    846            *         (if the Clock Security System CSS is enabled).
    847            *
    848            * @note   A switch from one clock source to another occurs only if the target
    849            *         clock source is ready (clock stable after start-up delay or PLL locked).
    850            *         If a clock source which is not yet ready is selected, the switch will
    851            *         occur when the clock source will be ready.
    852            *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
    853            *         currently used as system clock source.
    854            * @note   Depending on the device voltage range, the software has to set correctly
    855            *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
    856            *         (for more details refer to section above "Initialization/de-initialization functions")
    857            * @retval HAL status
    858            */

   \                                 In section .text, align 2, keep-with-next
    859          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    860          {
   \                     HAL_RCC_ClockConfig: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    861            uint32_t tickstart;
    862            HAL_StatusTypeDef status;
    863          
    864            /* Check the parameters */
    865            if(RCC_ClkInitStruct == NULL)
   \        0x4   0xD032             BEQ      ??HAL_RCC_ClockConfig_0
   \        0x6   0x9100             STR      R1,[SP, #+0]
    866            {
    867              return HAL_ERROR;
    868            }
    869          
    870            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    871            assert_param(IS_FLASH_LATENCY(FLatency));
    872          
    873            /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    874            must be correctly programmed according to the frequency of the CPU clock
    875            (HCLK) and the supply voltage of the device. */
    876          
    877            /* Increasing the number of wait states because of higher CPU frequency */
    878            if(FLatency > __HAL_FLASH_GET_LATENCY())
   \        0x8   0x....             LDR      R0,??DataTable8  ;; 0x40022000
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x07C1             LSLS     R1,R0,#+31
   \        0xE   0x0FC9             LSRS     R1,R1,#+31
   \       0x10   0x9800             LDR      R0,[SP, #+0]
   \       0x12   0x4281             CMP      R1,R0
   \       0x14   0xD20C             BCS      ??HAL_RCC_ClockConfig_1
    879            {
    880              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    881              __HAL_FLASH_SET_LATENCY(FLatency);
   \       0x16   0x....             LDR      R0,??DataTable8  ;; 0x40022000
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x2201             MOVS     R2,#+1
   \       0x1C   0x4391             BICS     R1,R1,R2
   \       0x1E   0x9A00             LDR      R2,[SP, #+0]
   \       0x20   0x430A             ORRS     R2,R2,R1
   \       0x22   0x6002             STR      R2,[R0, #+0]
    882          
    883              /* Check that the new number of wait states is taken into account to access the Flash
    884              memory by reading the FLASH_ACR register */
    885              if(__HAL_FLASH_GET_LATENCY() != FLatency)
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x07C1             LSLS     R1,R0,#+31
   \       0x28   0x0FC9             LSRS     R1,R1,#+31
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD16F             BNE      ??HAL_RCC_ClockConfig_2
    886              {
    887                return HAL_ERROR;
    888              }
    889            }
    890          
    891            /*-------------------------- HCLK Configuration --------------------------*/
    892            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \       0x30   0x....             LDR      R5,??DataTable8_1  ;; 0x40021000
   \       0x32   0x7820             LDRB     R0,[R4, #+0]
   \       0x34   0x0780             LSLS     R0,R0,#+30
   \       0x36   0xD505             BPL      ??HAL_RCC_ClockConfig_3
    893            {
    894              assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    895              MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \       0x38   0x68E8             LDR      R0,[R5, #+12]
   \       0x3A   0x21F0             MOVS     R1,#+240
   \       0x3C   0x4388             BICS     R0,R0,R1
   \       0x3E   0x68A1             LDR      R1,[R4, #+8]
   \       0x40   0x4301             ORRS     R1,R1,R0
   \       0x42   0x60E9             STR      R1,[R5, #+12]
    896            }
    897          
    898            /*------------------------- SYSCLK Configuration ---------------------------*/
    899            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \       0x44   0x2701             MOVS     R7,#+1
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x4038             ANDS     R0,R0,R7
   \       0x4A   0xD051             BEQ      ??HAL_RCC_ClockConfig_4
    900            {
    901              assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    902          
    903              /* HSE is selected as System Clock Source */
    904              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \       0x4C   0x6860             LDR      R0,[R4, #+4]
   \       0x4E   0x2802             CMP      R0,#+2
   \       0x50   0xD102             BNE      ??HAL_RCC_ClockConfig_5
    905              {
    906                /* Check the HSE ready flag */
    907                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
   \       0x52   0x6829             LDR      R1,[R5, #+0]
   \       0x54   0x0389             LSLS     R1,R1,#+14
   \       0x56   0xE008             B.N      ??HAL_RCC_ClockConfig_6
    908                {
    909                  return HAL_ERROR;
    910                }
    911              }
    912              /* PLL is selected as System Clock Source */
    913              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \       0x58   0x2803             CMP      R0,#+3
   \       0x5A   0xD102             BNE      ??HAL_RCC_ClockConfig_7
    914              {
    915                /* Check the PLL ready flag */
    916                if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
   \       0x5C   0x6829             LDR      R1,[R5, #+0]
   \       0x5E   0x0189             LSLS     R1,R1,#+6
   \       0x60   0xE003             B.N      ??HAL_RCC_ClockConfig_6
    917                {
    918                  return HAL_ERROR;
    919                }
    920              }
    921              /* HSI is selected as System Clock Source */
    922              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0x6829             LDR      R1,[R5, #+0]
   \       0x66   0xD102             BNE      ??HAL_RCC_ClockConfig_8
    923              {
    924                /* Check the HSI ready flag */
    925                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
   \       0x68   0x0749             LSLS     R1,R1,#+29
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \       0x6A   0xD402             BMI      ??HAL_RCC_ClockConfig_9
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \       0x6C   0xE050             B        ??HAL_RCC_ClockConfig_2
    926                {
    927                  return HAL_ERROR;
    928                }
    929              }
    930              /* MSI is selected as System Clock Source */
    931              else
    932              {
    933                /* Check the MSI ready flag */
    934                if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \       0x6E   0x0589             LSLS     R1,R1,#+22
   \       0x70   0xD54E             BPL      ??HAL_RCC_ClockConfig_2
    935                {
    936                  return HAL_ERROR;
    937                }
    938              }
    939              __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \       0x72   0x68E9             LDR      R1,[R5, #+12]
   \       0x74   0x2203             MOVS     R2,#+3
   \       0x76   0x4391             BICS     R1,R1,R2
   \       0x78   0x4308             ORRS     R0,R0,R1
   \       0x7A   0x60E8             STR      R0,[R5, #+12]
    940          
    941              /* Get Start Tick */
    942              tickstart = HAL_GetTick();
   \       0x7C   0x....'....        BL       HAL_GetTick
   \       0x80   0x0006             MOVS     R6,R0
    943          
    944              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \       0x82   0x6860             LDR      R0,[R4, #+4]
   \       0x84   0x2802             CMP      R0,#+2
   \       0x86   0xD10C             BNE      ??HAL_RCC_ClockConfig_10
    945              {
    946                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \       0x88   0x68E8             LDR      R0,[R5, #+12]
   \       0x8A   0x210C             MOVS     R1,#+12
   \       0x8C   0x4001             ANDS     R1,R1,R0
   \       0x8E   0x2908             CMP      R1,#+8
   \       0x90   0xD02E             BEQ      ??HAL_RCC_ClockConfig_4
    947                {
    948                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \       0x92   0x....'....        BL       HAL_GetTick
   \       0x96   0x1B80             SUBS     R0,R0,R6
   \       0x98   0x....             LDR      R1,??DataTable9  ;; 0x1389
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xD3F4             BCC      ??HAL_RCC_ClockConfig_11
    949                  {
    950                    return HAL_TIMEOUT;
    951                  }
    952                }
    953              }
    954              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    955              {
    956                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
    957                {
    958                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    959                  {
    960                    return HAL_TIMEOUT;
    961                  }
    962                }
    963              }
    964              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
    965              {
    966                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
    967                {
    968                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    969                  {
    970                    return HAL_TIMEOUT;
    971                  }
    972                }
    973              }
    974              else
    975              {
    976                while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
    977                {
    978                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    979                  {
    980                    return HAL_TIMEOUT;
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \       0x9E   0x2003             MOVS     R0,#+3
   \       0xA0   0xBDF2             POP      {R1,R4-R7,PC}
    981                  }
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \       0xA2   0x2803             CMP      R0,#+3
   \       0xA4   0xD10B             BNE      ??HAL_RCC_ClockConfig_13
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \       0xA6   0x68E8             LDR      R0,[R5, #+12]
   \       0xA8   0x210C             MOVS     R1,#+12
   \       0xAA   0x4001             ANDS     R1,R1,R0
   \       0xAC   0x290C             CMP      R1,#+12
   \       0xAE   0xD01F             BEQ      ??HAL_RCC_ClockConfig_4
   \       0xB0   0x....'....        BL       HAL_GetTick
   \       0xB4   0x1B80             SUBS     R0,R0,R6
   \       0xB6   0x....             LDR      R1,??DataTable9  ;; 0x1389
   \       0xB8   0x4288             CMP      R0,R1
   \       0xBA   0xD3F4             BCC      ??HAL_RCC_ClockConfig_14
   \       0xBC   0xE7EF             B        ??HAL_RCC_ClockConfig_12
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \       0xBE   0x2801             CMP      R0,#+1
   \       0xC0   0xD10B             BNE      ??HAL_RCC_ClockConfig_15
   \                     ??HAL_RCC_ClockConfig_16: (+1)
   \       0xC2   0x68E8             LDR      R0,[R5, #+12]
   \       0xC4   0x210C             MOVS     R1,#+12
   \       0xC6   0x4001             ANDS     R1,R1,R0
   \       0xC8   0x2904             CMP      R1,#+4
   \       0xCA   0xD011             BEQ      ??HAL_RCC_ClockConfig_4
   \       0xCC   0x....'....        BL       HAL_GetTick
   \       0xD0   0x1B80             SUBS     R0,R0,R6
   \       0xD2   0x....             LDR      R1,??DataTable9  ;; 0x1389
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xD3F4             BCC      ??HAL_RCC_ClockConfig_16
   \       0xD8   0xE7E1             B        ??HAL_RCC_ClockConfig_12
   \                     ??HAL_RCC_ClockConfig_15: (+1)
   \       0xDA   0x68E8             LDR      R0,[R5, #+12]
   \       0xDC   0x210C             MOVS     R1,#+12
   \       0xDE   0x4001             ANDS     R1,R1,R0
   \       0xE0   0xD006             BEQ      ??HAL_RCC_ClockConfig_4
   \       0xE2   0x....'....        BL       HAL_GetTick
   \       0xE6   0x1B80             SUBS     R0,R0,R6
   \       0xE8   0x....             LDR      R1,??DataTable9  ;; 0x1389
   \       0xEA   0x4288             CMP      R0,R1
   \       0xEC   0xD3F5             BCC      ??HAL_RCC_ClockConfig_15
   \       0xEE   0xE7D6             B        ??HAL_RCC_ClockConfig_12
    982                }
    983              }
    984            }
    985            /* Decreasing the number of wait states because of lower CPU frequency */
    986            if(FLatency < __HAL_FLASH_GET_LATENCY())
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \       0xF0   0x....             LDR      R0,??DataTable8  ;; 0x40022000
   \       0xF2   0x9900             LDR      R1,[SP, #+0]
   \       0xF4   0x6802             LDR      R2,[R0, #+0]
   \       0xF6   0x403A             ANDS     R2,R2,R7
   \       0xF8   0x4291             CMP      R1,R2
   \       0xFA   0xD20B             BCS      ??HAL_RCC_ClockConfig_17
    987            {
    988              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    989              __HAL_FLASH_SET_LATENCY(FLatency);
   \       0xFC   0x6801             LDR      R1,[R0, #+0]
   \       0xFE   0x43B9             BICS     R1,R1,R7
   \      0x100   0x9A00             LDR      R2,[SP, #+0]
   \      0x102   0x430A             ORRS     R2,R2,R1
   \      0x104   0x6002             STR      R2,[R0, #+0]
    990          
    991              /* Check that the new number of wait states is taken into account to access the Flash
    992              memory by reading the FLASH_ACR register */
    993              if(__HAL_FLASH_GET_LATENCY() != FLatency)
   \      0x106   0x6800             LDR      R0,[R0, #+0]
   \      0x108   0x4007             ANDS     R7,R7,R0
   \      0x10A   0x9800             LDR      R0,[SP, #+0]
   \      0x10C   0x4287             CMP      R7,R0
   \      0x10E   0xD001             BEQ      ??HAL_RCC_ClockConfig_17
    994              {
    995                return HAL_ERROR;
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \      0x110   0x2001             MOVS     R0,#+1
   \      0x112   0xBDF2             POP      {R1,R4-R7,PC}
    996              }
    997            }
    998          
    999            /*-------------------------- PCLK1 Configuration ---------------------------*/
   1000            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_17: (+1)
   \      0x114   0x7820             LDRB     R0,[R4, #+0]
   \      0x116   0x0740             LSLS     R0,R0,#+29
   \      0x118   0xD505             BPL      ??HAL_RCC_ClockConfig_18
   1001            {
   1002              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
   1003              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
   \      0x11A   0x68E8             LDR      R0,[R5, #+12]
   \      0x11C   0x....             LDR      R1,??DataTable11  ;; 0xfffff8ff
   \      0x11E   0x4001             ANDS     R1,R1,R0
   \      0x120   0x68E0             LDR      R0,[R4, #+12]
   \      0x122   0x4308             ORRS     R0,R0,R1
   \      0x124   0x60E8             STR      R0,[R5, #+12]
   1004            }
   1005          
   1006            /*-------------------------- PCLK2 Configuration ---------------------------*/
   1007            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_18: (+1)
   \      0x126   0x7820             LDRB     R0,[R4, #+0]
   \      0x128   0x0700             LSLS     R0,R0,#+28
   \      0x12A   0xD506             BPL      ??HAL_RCC_ClockConfig_19
   1008            {
   1009              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
   1010              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
   \      0x12C   0x68E8             LDR      R0,[R5, #+12]
   \      0x12E   0x....             LDR      R1,??DataTable11_1  ;; 0xffffc7ff
   \      0x130   0x4001             ANDS     R1,R1,R0
   \      0x132   0x6920             LDR      R0,[R4, #+16]
   \      0x134   0x00C0             LSLS     R0,R0,#+3
   \      0x136   0x4308             ORRS     R0,R0,R1
   \      0x138   0x60E8             STR      R0,[R5, #+12]
   1011            }
   1012          
   1013            /* Update the SystemCoreClock global variable */
   1014            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
   \                     ??HAL_RCC_ClockConfig_19: (+1)
   \      0x13A   0x....'....        BL       HAL_RCC_GetSysClockFreq
   \      0x13E   0x....             LDR      R1,??DataTable11_2
   \      0x140   0x68EA             LDR      R2,[R5, #+12]
   \      0x142   0x0612             LSLS     R2,R2,#+24
   \      0x144   0x0F12             LSRS     R2,R2,#+28
   \      0x146   0x5C89             LDRB     R1,[R1, R2]
   \      0x148   0x40C8             LSRS     R0,R0,R1
   \      0x14A   0x....             LDR      R1,??DataTable11_3
   \      0x14C   0x6008             STR      R0,[R1, #+0]
   1015          
   1016            /* Configure the source of time base considering new system clocks settings*/
   1017            status = HAL_InitTick(TICK_INT_PRIORITY);
   \      0x14E   0x2003             MOVS     R0,#+3
   \      0x150   0x....'....        BL       HAL_InitTick
   1018            if(status != HAL_OK)
   \      0x154   0x0001             MOVS     R1,R0
   \      0x156   0xD100             BNE      ??HAL_RCC_ClockConfig_20
   1019            {
   1020              return status;
   1021            }
   1022          
   1023            return HAL_OK;
   \      0x158   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_ClockConfig_20: (+1)
   \      0x15A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1024          }
   1025          
   1026          /**
   1027            * @}
   1028            */
   1029          
   1030          /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions
   1031            *  @brief   RCC clocks control functions
   1032            *
   1033            @verbatim
   1034            ===============================================================================
   1035                            ##### Peripheral Control functions #####
   1036            ===============================================================================
   1037              [..]
   1038              This subsection provides a set of functions allowing to control the RCC Clocks
   1039              frequencies.
   1040          
   1041            @endverbatim
   1042            * @{
   1043            */
   1044          
   1045          /**
   1046            * @brief  Selects the clock source to output on MCO pin.
   1047            * @note   MCO pin should be configured in alternate function mode.
   1048            * @param  RCC_MCOx specifies the output direction for the clock source.
   1049            *          This parameter can be one of the following values:
   1050            *            @arg @ref RCC_MCO1 Clock source to output on MCO1 pin(PA8).
   1051            *            @arg @ref RCC_MCO2 Clock source to output on MCO2 pin(PA9).
   1052            @if STM32L031xx
   1053            *            @arg @ref RCC_MCO3 Clock source to output on MCO3 pin(PB13)
   1054            @elseif STM32L041xx
   1055            *            @arg @ref RCC_MCO3 Clock source to output on MCO3 pin(PB13)
   1056            @elseif STM32L073xx
   1057            *            @arg @ref RCC_MCO3 Clock source to output on MCO3 pin(PB13)
   1058            @elseif STM32L083xx
   1059            *            @arg @ref RCC_MCO3 Clock source to output on MCO3 pin(PB13)
   1060            @elseif STM32L072xx
   1061            *            @arg @ref RCC_MCO3 Clock source to output on MCO3 pin(PB13)
   1062            @elseif STM32L082xx
   1063            *            @arg @ref RCC_MCO3 Clock source to output on MCO3 pin(PB13)
   1064            @elseif STM32L071xx
   1065            *            @arg @ref RCC_MCO3 Clock source to output on MCO3 pin(PB13)
   1066            @elseif STM32L081xx
   1067            *            @arg @ref RCC_MCO3 Clock source to output on MCO3 pin(PB13)
   1068            @endif
   1069            * @param  RCC_MCOSource specifies the clock source to output.
   1070            *          This parameter can be one of the following values:
   1071            *            @arg @ref RCC_MCO1SOURCE_NOCLOCK     No clock selected as MCO clock
   1072            *            @arg @ref RCC_MCO1SOURCE_SYSCLK      System clock selected as MCO clock
   1073            *            @arg @ref RCC_MCO1SOURCE_HSI         HSI selected as MCO clock
   1074            *            @arg @ref RCC_MCO1SOURCE_HSE         HSE selected as MCO clock
   1075            *            @arg @ref RCC_MCO1SOURCE_MSI         MSI oscillator clock selected as MCO clock
   1076            *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLL clock selected as MCO clock
   1077            *            @arg @ref RCC_MCO1SOURCE_LSI         LSI clock selected as MCO clock
   1078            *            @arg @ref RCC_MCO1SOURCE_LSE         LSE clock selected as MCO clock
   1079            @if STM32L052xx
   1080            *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 clock selected as MCO clock
   1081            @elseif STM32L053xx
   1082            *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 clock selected as MCO clock
   1083            @elseif STM32L062xx
   1084            *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 clock selected as MCO clock
   1085            @elseif STM32L063xx
   1086            *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 clock selected as MCO clock
   1087            @elseif STM32L072xx
   1088            *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 clock selected as MCO clock
   1089            @elseif STM32L073xx
   1090            *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 clock selected as MCO clock
   1091            @elseif STM32L082xx
   1092            *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 clock selected as MCO clock
   1093            @elseif STM32L083xx
   1094            *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 clock selected as MCO clock
   1095            @endif
   1096            * @param  RCC_MCODiv specifies the MCO DIV.
   1097            *          This parameter can be one of the following values:
   1098            *            @arg @ref RCC_MCODIV_1 no division applied to MCO clock
   1099            *            @arg @ref RCC_MCODIV_2  division by 2 applied to MCO clock
   1100            *            @arg @ref RCC_MCODIV_4  division by 4 applied to MCO clock
   1101            *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
   1102            *            @arg @ref RCC_MCODIV_16 division by 16 applied to MCO clock
   1103            * @retval None
   1104            */

   \                                 In section .text, align 2, keep-with-next
   1105          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
   1106          {
   \                     HAL_RCC_MCOConfig: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x2214             MOVS     R2,#+20
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0xA801             ADD      R0,SP,#+4
   \       0x10   0x....'....        BL       memset
   1107            GPIO_InitTypeDef gpio = {0};
   1108          
   1109            /* Check the parameters */
   1110            assert_param(IS_RCC_MCO(RCC_MCOx));
   1111            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
   1112            assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
   1113          
   1114            /* Configure the MCO1 pin in alternate function mode */
   1115            gpio.Mode      = GPIO_MODE_AF_PP;
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0x9002             STR      R0,[SP, #+8]
   1116            gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
   \       0x18   0x9004             STR      R0,[SP, #+16]
   1117            gpio.Pull      = GPIO_NOPULL;
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x9103             STR      R1,[SP, #+12]
   1118            if(RCC_MCOx == RCC_MCO1)
   \       0x1E   0x....             LDR      R5,??DataTable11_4  ;; 0x4002100c
   \       0x20   0x20A0             MOVS     R0,#+160
   \       0x22   0x05C0             LSLS     R0,R0,#+23       ;; #+1342177280
   \       0x24   0x2201             MOVS     R2,#+1
   \       0x26   0x2F00             CMP      R7,#+0
   \       0x28   0xD101             BNE      ??HAL_RCC_MCOConfig_0
   1119            {
   1120              gpio.Pin       = MCO1_PIN;
   \       0x2A   0x0213             LSLS     R3,R2,#+8
   \       0x2C   0xE000             B        ??HAL_RCC_MCOConfig_1
   1121              gpio.Alternate = GPIO_AF0_MCO;
   1122          
   1123              /* MCO1 Clock Enable */
   1124              MCO1_CLK_ENABLE();
   1125              HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
   1126            }
   1127          #if  defined(STM32L031xx) || defined(STM32L041xx) || defined(STM32L073xx) || defined(STM32L083xx) \
   1128            || defined(STM32L072xx) || defined(STM32L082xx) || defined(STM32L071xx) || defined(STM32L081xx)
   1129            else if (RCC_MCOx == RCC_MCO3)
   1130            {
   1131              gpio.Pin       = MCO3_PIN;
   1132              gpio.Alternate = GPIO_AF2_MCO;
   1133          
   1134              /* MCO3 Clock Enable */
   1135              MCO3_CLK_ENABLE();
   1136              HAL_GPIO_Init(MCO3_GPIO_PORT, &gpio);
   1137            }
   1138          #endif
   1139            else
   1140            {
   1141              gpio.Pin       = MCO2_PIN;
   \                     ??HAL_RCC_MCOConfig_0: (+1)
   \       0x2E   0x0253             LSLS     R3,R2,#+9
   \                     ??HAL_RCC_MCOConfig_1: (+1)
   \       0x30   0x9301             STR      R3,[SP, #+4]
   1142              gpio.Alternate = GPIO_AF0_MCO;
   \       0x32   0x9105             STR      R1,[SP, #+20]
   1143          
   1144              /* MCO2 Clock Enable */
   1145              MCO2_CLK_ENABLE();
   \       0x34   0x6A29             LDR      R1,[R5, #+32]
   \       0x36   0x4311             ORRS     R1,R1,R2
   \       0x38   0x6229             STR      R1,[R5, #+32]
   \       0x3A   0x6A29             LDR      R1,[R5, #+32]
   \       0x3C   0x400A             ANDS     R2,R2,R1
   \       0x3E   0x9200             STR      R2,[SP, #+0]
   \       0x40   0x9900             LDR      R1,[SP, #+0]
   1146              HAL_GPIO_Init(MCO2_GPIO_PORT, &gpio);
   \       0x42   0xA901             ADD      R1,SP,#+4
   \       0x44   0x....'....        BL       HAL_GPIO_Init
   1147            }
   1148          
   1149            /* Configure the MCO clock source */
   1150            __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x....             LDR      R1,??DataTable11_5  ;; 0x80ffffff
   \       0x4C   0x4001             ANDS     R1,R1,R0
   \       0x4E   0x430E             ORRS     R6,R6,R1
   \       0x50   0x4334             ORRS     R4,R4,R6
   \       0x52   0x602C             STR      R4,[R5, #+0]
   1151          }
   \       0x54   0xB007             ADD      SP,SP,#+28
   \       0x56   0xBDF0             POP      {R4-R7,PC}       ;; return
   1152          
   1153          #if defined(RCC_HSECSS_SUPPORT)
   1154          /**
   1155            * @brief  Enables the Clock Security System.
   1156            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
   1157            *         is automatically disabled and an interrupt is generated to inform the
   1158            *         software about the failure (Clock Security System Interrupt, CSSI),
   1159            *         allowing the MCU to perform rescue operations. The CSSI is linked to
   1160            *         the Cortex-M0+ NMI (Non-Maskable Interrupt) exception vector.
   1161            * @retval None
   1162            */

   \                                 In section .text, align 2, keep-with-next
   1163          void HAL_RCC_EnableCSS(void)
   1164          {
   1165            SET_BIT(RCC->CR, RCC_CR_CSSON) ;
   \                     HAL_RCC_EnableCSS: (+1)
   \        0x0   0x....             LDR      R0,??DataTable8_1  ;; 0x40021000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x0312             LSLS     R2,R2,#+12       ;; #+524288
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x6002             STR      R2,[R0, #+0]
   1166          }
   \        0xC   0x4770             BX       LR               ;; return
   1167          
   1168          #endif /* RCC_HSECSS_SUPPORT */
   1169          /**
   1170            * @brief  Returns the SYSCLK frequency
   1171            * @note   The system frequency computed by this function is not the real
   1172            *         frequency in the chip. It is calculated based on the predefined
   1173            *         constant and the selected clock source:
   1174            * @note     If SYSCLK source is MSI, function returns a value based on MSI
   1175            *             Value as defined by the MSI range.
   1176            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
   1177            * @note     If SYSCLK source is HSE, function returns a value based on HSE_VALUE(**)
   1178            * @note     If SYSCLK source is PLL, function returns a value based on HSE_VALUE(**)
   1179            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.
   1180            * @note     (*) HSI_VALUE is a constant defined in stm32l0xx_hal_conf.h file (default value
   1181            *               16 MHz) but the real value may vary depending on the variations
   1182            *               in voltage and temperature.
   1183            * @note     (**) HSE_VALUE is a constant defined in stm32l0xx_hal_conf.h file (default value
   1184            *                8 MHz), user has to ensure that HSE_VALUE is same as the real
   1185            *                frequency of the crystal used. Otherwise, this function may
   1186            *                have wrong result.
   1187            *
   1188            * @note   The result of this function could be not correct when using fractional
   1189            *         value for HSE crystal.
   1190            *
   1191            * @note   This function can be used by the user application to compute the
   1192            *         baud-rate for the communication peripherals or configure other parameters.
   1193            *
   1194            * @note   Each time SYSCLK changes, this function must be called to update the
   1195            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
   1196            *
   1197            * @retval SYSCLK frequency
   1198            */

   \                                 In section .text, align 2, keep-with-next
   1199          uint32_t HAL_RCC_GetSysClockFreq(void)
   1200          {
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   1201            uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
   1202            uint32_t sysclockfreq;
   1203          
   1204            tmpreg = RCC->CFGR;
   \        0x2   0x....             LDR      R5,??DataTable8_1  ;; 0x40021000
   \        0x4   0x68E9             LDR      R1,[R5, #+12]
   1205          
   1206            /* Get SYSCLK source -------------------------------------------------------*/
   1207            switch (tmpreg & RCC_CFGR_SWS)
   \        0x6   0x....             LDR      R2,??DataTable11_6  ;; 0xf42400
   \        0x8   0x0893             LSRS     R3,R2,#+2
   \        0xA   0x2610             MOVS     R6,#+16
   \        0xC   0x0854             LSRS     R4,R2,#+1
   \        0xE   0x200C             MOVS     R0,#+12
   \       0x10   0x4008             ANDS     R0,R0,R1
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD004             BEQ      ??HAL_RCC_GetSysClockFreq_0
   \       0x16   0x2808             CMP      R0,#+8
   \       0x18   0xD009             BEQ      ??HAL_RCC_GetSysClockFreq_1
   \       0x1A   0x280C             CMP      R0,#+12
   \       0x1C   0xD009             BEQ      ??HAL_RCC_GetSysClockFreq_2
   \       0x1E   0xE01D             B        ??HAL_RCC_GetSysClockFreq_3
   1208            {
   1209              case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
   1210              {
   1211                if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
   \                     ??HAL_RCC_GetSysClockFreq_0: (+1)
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x4006             ANDS     R6,R6,R0
   \       0x24   0xD001             BEQ      ??HAL_RCC_GetSysClockFreq_4
   1212                {
   1213                  sysclockfreq =  (HSI_VALUE >> 2);
   \       0x26   0x0018             MOVS     R0,R3
   \       0x28   0xBDF0             POP      {R4-R7,PC}
   1214                }
   1215                else
   1216                {
   1217                  sysclockfreq =  HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \       0x2A   0x0010             MOVS     R0,R2
   \       0x2C   0xBDF0             POP      {R4-R7,PC}
   1218                }
   1219                break;
   1220              }
   1221              case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
   1222              {
   1223                sysclockfreq = HSE_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   1224                break;
   \       0x30   0xBDF0             POP      {R4-R7,PC}
   1225              }
   1226              case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
   1227              {
   1228                pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \       0x32   0x....             LDR      R0,??DataTable11_7
   \       0x34   0x028F             LSLS     R7,R1,#+10
   \       0x36   0x0F3F             LSRS     R7,R7,#+28
   \       0x38   0x5DC0             LDRB     R0,[R0, R7]
   1229                plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
   \       0x3A   0x0209             LSLS     R1,R1,#+8
   \       0x3C   0x0F89             LSRS     R1,R1,#+30
   \       0x3E   0x1C49             ADDS     R1,R1,#+1
   1230                if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
   \       0x40   0x68EF             LDR      R7,[R5, #+12]
   \       0x42   0x03FF             LSLS     R7,R7,#+15
   \       0x44   0xD501             BPL      ??HAL_RCC_GetSysClockFreq_5
   1231                {
   1232                  /* HSE used as PLL clock source */
   1233                  pllvco = (HSE_VALUE * pllm) / plld;
   \       0x46   0x4360             MULS     R0,R4,R0
   \       0x48   0xE005             B.N      ??HAL_RCC_GetSysClockFreq_6
   1234                }
   1235                else
   1236                {
   1237                  if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \       0x4A   0x682C             LDR      R4,[R5, #+0]
   \       0x4C   0x4026             ANDS     R6,R6,R4
   \       0x4E   0xD001             BEQ      ??HAL_RCC_GetSysClockFreq_7
   1238                  {
   1239                    pllvco = ((HSI_VALUE >> 2) * pllm) / plld;
   \       0x50   0x4358             MULS     R0,R3,R0
   \       0x52   0xE000             B.N      ??HAL_RCC_GetSysClockFreq_6
   1240                  }
   1241                  else
   1242                  {
   1243                   pllvco = (HSI_VALUE * pllm) / plld;
   \                     ??HAL_RCC_GetSysClockFreq_7: (+1)
   \       0x54   0x4350             MULS     R0,R2,R0
   \                     ??HAL_RCC_GetSysClockFreq_6: (+1)
   \       0x56   0x....'....        BL       __aeabi_uidiv
   1244                  }
   1245                }
   1246                sysclockfreq = pllvco;
   1247                break;
   \       0x5A   0xBDF0             POP      {R4-R7,PC}
   1248              }
   1249              case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
   1250              default: /* MSI used as system clock */
   1251              {
   1252                msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \       0x5C   0x6868             LDR      R0,[R5, #+4]
   1253                sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
   \       0x5E   0x2101             MOVS     R1,#+1
   \       0x60   0x0400             LSLS     R0,R0,#+16
   \       0x62   0x0F40             LSRS     R0,R0,#+29
   \       0x64   0x1C40             ADDS     R0,R0,#+1
   \       0x66   0x4081             LSLS     R1,R1,R0
   \       0x68   0x03C8             LSLS     R0,R1,#+15
   1254                break;
   1255              }
   1256            }
   1257            return sysclockfreq;
   \       0x6A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1258          }
   1259          
   1260          /**
   1261            * @brief  Returns the HCLK frequency
   1262            * @note   Each time HCLK changes, this function must be called to update the
   1263            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1264            *
   1265            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
   1266            *         and updated within this function
   1267            * @retval HCLK frequency
   1268            */

   \                                 In section .text, align 2, keep-with-next
   1269          uint32_t HAL_RCC_GetHCLKFreq(void)
   1270          {
   1271            return SystemCoreClock;
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \        0x0   0x....             LDR      R0,??DataTable11_3
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   1272          }
   1273          
   1274          /**
   1275            * @brief  Returns the PCLK1 frequency
   1276            * @note   Each time PCLK1 changes, this function must be called to update the
   1277            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1278            * @retval PCLK1 frequency
   1279            */

   \                                 In section .text, align 2, keep-with-next
   1280          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1281          {
   1282            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1283            return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \        0x0   0x....             LDR      R0,??DataTable11_3
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....             LDR      R1,??DataTable11_8
   \        0x6   0x....             LDR      R2,??DataTable11_4  ;; 0x4002100c
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x0552             LSLS     R2,R2,#+21
   \        0xC   0x....             B.N      ?Subroutine0
   1284          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x0F52             LSRS     R2,R2,#+29
   \        0x2   0x5C89             LDRB     R1,[R1, R2]
   \        0x4   0x40C8             LSRS     R0,R0,R1
   \        0x6   0x4770             BX       LR               ;; return
   1285          
   1286          /**
   1287            * @brief  Returns the PCLK2 frequency
   1288            * @note   Each time PCLK2 changes, this function must be called to update the
   1289            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1290            * @retval PCLK2 frequency
   1291            */

   \                                 In section .text, align 2, keep-with-next
   1292          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1293          {
   1294            /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
   1295            return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \        0x0   0x....             LDR      R0,??DataTable11_3
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....             LDR      R1,??DataTable11_8
   \        0x6   0x....             LDR      R2,??DataTable11_4  ;; 0x4002100c
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x0492             LSLS     R2,R2,#+18
   \        0xC                      REQUIRE ?Subroutine0
   \        0xC                      ;; // Fall through to label ?Subroutine0
   1296          }
   1297          
   1298          /**
   1299            * @brief  Configures the RCC_OscInitStruct according to the internal
   1300            * RCC configuration registers.
   1301            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
   1302            * will be configured.
   1303            * @retval None
   1304            */

   \                                 In section .text, align 2, keep-with-next
   1305          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
   1306          {
   \                     HAL_RCC_GetOscConfig: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   1307            /* Check the parameters */
   1308            assert_param(RCC_OscInitStruct != (void *)NULL);
   1309          
   1310            /* Set all possible values for the Oscillator type parameter ---------------*/
   1311            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
   1312                            | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_MSI;
   1313          #if defined(RCC_HSI48_SUPPORT)
   1314            RCC_OscInitStruct->OscillatorType |= RCC_OSCILLATORTYPE_HSI48;
   \        0x2   0x213F             MOVS     R1,#+63
   \        0x4   0x6001             STR      R1,[R0, #+0]
   1315          #endif /* RCC_HSI48_SUPPORT */
   1316          
   1317          
   1318            /* Get the HSE configuration -----------------------------------------------*/
   1319            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   \        0x6   0x2180             MOVS     R1,#+128
   \        0x8   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x....             LDR      R3,??DataTable11_9  ;; 0x40021000
   \        0xE   0x681C             LDR      R4,[R3, #+0]
   \       0x10   0x0364             LSLS     R4,R4,#+13
   \       0x12   0xD502             BPL      ??HAL_RCC_GetOscConfig_0
   1320            {
   1321              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   \       0x14   0x24A0             MOVS     R4,#+160
   \       0x16   0x02E4             LSLS     R4,R4,#+11       ;; #+327680
   \       0x18   0xE003             B        ??HAL_RCC_GetOscConfig_1
   1322            }
   1323            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   \                     ??HAL_RCC_GetOscConfig_0: (+1)
   \       0x1A   0x681C             LDR      R4,[R3, #+0]
   \       0x1C   0x400C             ANDS     R4,R4,R1
   \       0x1E   0xD000             BEQ      ??HAL_RCC_GetOscConfig_1
   1324            {
   1325              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   \       0x20   0x000C             MOVS     R4,R1
   1326            }
   1327            else
   1328            {
   1329              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \       0x22   0x6044             STR      R4,[R0, #+4]
   1330            }
   1331          
   1332            /* Get the HSI configuration -----------------------------------------------*/
   1333            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   \       0x24   0x2401             MOVS     R4,#+1
   \       0x26   0x681D             LDR      R5,[R3, #+0]
   \       0x28   0x4025             ANDS     R5,R5,R4
   \       0x2A   0xD000             BEQ      ??HAL_RCC_GetOscConfig_2
   \       0x2C   0x2501             MOVS     R5,#+1
   \                     ??HAL_RCC_GetOscConfig_2: (+1)
   \       0x2E   0x60C5             STR      R5,[R0, #+12]
   1334            {
   1335              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   1336            }
   1337            else
   1338            {
   1339              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   1340            }
   1341          
   1342            RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> 8);
   \       0x30   0x685D             LDR      R5,[R3, #+4]
   \       0x32   0x04ED             LSLS     R5,R5,#+19
   \       0x34   0x0EED             LSRS     R5,R5,#+27
   \       0x36   0x6105             STR      R5,[R0, #+16]
   1343          
   1344            /* Get the MSI configuration -----------------------------------------------*/
   1345            if((RCC->CR &RCC_CR_MSION) == RCC_CR_MSION)
   \       0x38   0x0A0D             LSRS     R5,R1,#+8
   \       0x3A   0x681E             LDR      R6,[R3, #+0]
   \       0x3C   0x402E             ANDS     R6,R6,R5
   \       0x3E   0xD000             BEQ      ??HAL_RCC_GetOscConfig_3
   \       0x40   0x2601             MOVS     R6,#+1
   \                     ??HAL_RCC_GetOscConfig_3: (+1)
   \       0x42   0x61C6             STR      R6,[R0, #+28]
   1346            {
   1347              RCC_OscInitStruct->MSIState = RCC_MSI_ON;
   1348            }
   1349            else
   1350            {
   1351              RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
   1352            }
   1353          
   1354            RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_Pos);
   \       0x44   0x685E             LDR      R6,[R3, #+4]
   \       0x46   0x0E36             LSRS     R6,R6,#+24
   \       0x48   0x6206             STR      R6,[R0, #+32]
   1355            RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSIRANGE));
   \       0x4A   0x685E             LDR      R6,[R3, #+4]
   \       0x4C   0x27E0             MOVS     R7,#+224
   \       0x4E   0x023F             LSLS     R7,R7,#+8        ;; #+57344
   \       0x50   0x4037             ANDS     R7,R7,R6
   \       0x52   0x6247             STR      R7,[R0, #+36]
   1356          
   1357            /* Get the LSE configuration -----------------------------------------------*/
   1358            if((RCC->CSR &RCC_CSR_LSEBYP) == RCC_CSR_LSEBYP)
   \       0x54   0x6D1E             LDR      R6,[R3, #+80]
   \       0x56   0x0576             LSLS     R6,R6,#+21
   \       0x58   0xD502             BPL      ??HAL_RCC_GetOscConfig_4
   1359            {
   1360              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   \       0x5A   0x22A0             MOVS     R2,#+160
   \       0x5C   0x00D2             LSLS     R2,R2,#+3        ;; #+1280
   \       0x5E   0xE003             B        ??HAL_RCC_GetOscConfig_5
   1361            }
   1362            else if((RCC->CSR &RCC_CSR_LSEON) == RCC_CSR_LSEON)
   \                     ??HAL_RCC_GetOscConfig_4: (+1)
   \       0x60   0x6D1E             LDR      R6,[R3, #+80]
   \       0x62   0x402E             ANDS     R6,R6,R5
   \       0x64   0xD000             BEQ      ??HAL_RCC_GetOscConfig_5
   1363            {
   1364              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   \       0x66   0x002A             MOVS     R2,R5
   1365            }
   1366            else
   1367            {
   1368              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_5: (+1)
   \       0x68   0x6082             STR      R2,[R0, #+8]
   1369            }
   1370          
   1371            /* Get the LSI configuration -----------------------------------------------*/
   1372            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   \       0x6A   0x6D1A             LDR      R2,[R3, #+80]
   \       0x6C   0x4022             ANDS     R2,R2,R4
   \       0x6E   0xD000             BEQ      ??HAL_RCC_GetOscConfig_6
   \       0x70   0x2201             MOVS     R2,#+1
   \                     ??HAL_RCC_GetOscConfig_6: (+1)
   \       0x72   0x6142             STR      R2,[R0, #+20]
   1373            {
   1374              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   1375            }
   1376            else
   1377            {
   1378              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   1379            }
   1380          
   1381          #if defined(RCC_HSI48_SUPPORT)
   1382            /* Get the HSI48 configuration if any-----------------------------------------*/
   1383            RCC_OscInitStruct->HSI48State = __HAL_RCC_GET_HSI48_STATE();
   \       0x74   0x689A             LDR      R2,[R3, #+8]
   \       0x76   0x4022             ANDS     R2,R2,R4
   \       0x78   0x6182             STR      R2,[R0, #+24]
   1384          #endif /* RCC_HSI48_SUPPORT */
   1385          
   1386            /* Get the PLL configuration -----------------------------------------------*/
   1387            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   \       0x7A   0x681A             LDR      R2,[R3, #+0]
   \       0x7C   0x01D2             LSLS     R2,R2,#+7
   \       0x7E   0xD500             BPL      ??HAL_RCC_GetOscConfig_7
   1388            {
   1389              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \       0x80   0x2402             MOVS     R4,#+2
   1390            }
   1391            else
   1392            {
   1393              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_7: (+1)
   \       0x82   0x6284             STR      R4,[R0, #+40]
   1394            }
   1395            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
   \       0x84   0x68DA             LDR      R2,[R3, #+12]
   \       0x86   0x4011             ANDS     R1,R1,R2
   \       0x88   0x62C1             STR      R1,[R0, #+44]
   1396            RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMUL);
   \       0x8A   0x68D9             LDR      R1,[R3, #+12]
   \       0x8C   0x22F0             MOVS     R2,#+240
   \       0x8E   0x0392             LSLS     R2,R2,#+14       ;; #+3932160
   \       0x90   0x400A             ANDS     R2,R2,R1
   \       0x92   0x6302             STR      R2,[R0, #+48]
   1397            RCC_OscInitStruct->PLL.PLLDIV = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLDIV);
   \       0x94   0x68D9             LDR      R1,[R3, #+12]
   \       0x96   0x22C0             MOVS     R2,#+192
   \       0x98   0x0412             LSLS     R2,R2,#+16       ;; #+12582912
   \       0x9A   0x400A             ANDS     R2,R2,R1
   \       0x9C   0x6342             STR      R2,[R0, #+52]
   1398          }
   \       0x9E   0xBDF0             POP      {R4-R7,PC}       ;; return
   1399          
   1400          /**
   1401            * @brief  Get the RCC_ClkInitStruct according to the internal
   1402            * RCC configuration registers.
   1403            * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that
   1404            * contains the current clock configuration.
   1405            * @param  pFLatency Pointer on the Flash Latency.
   1406            * @retval None
   1407            */

   \                                 In section .text, align 2, keep-with-next
   1408          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1409          {
   \                     HAL_RCC_GetClockConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1410            /* Check the parameters */
   1411            assert_param(RCC_ClkInitStruct != (void *)NULL);
   1412            assert_param(pFLatency != (void *)NULL);
   1413          
   1414            /* Set all possible values for the Clock type parameter --------------------*/
   1415            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
   \        0x2   0x220F             MOVS     R2,#+15
   \        0x4   0x6002             STR      R2,[R0, #+0]
   1416          
   1417            /* Get the SYSCLK configuration --------------------------------------------*/
   1418            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   \        0x6   0x....             LDR      R2,??DataTable11_4  ;; 0x4002100c
   \        0x8   0x6813             LDR      R3,[R2, #+0]
   \        0xA   0x079B             LSLS     R3,R3,#+30
   \        0xC   0x0F9B             LSRS     R3,R3,#+30
   \        0xE   0x6043             STR      R3,[R0, #+4]
   1419          
   1420            /* Get the HCLK configuration ----------------------------------------------*/
   1421            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
   \       0x10   0x6813             LDR      R3,[R2, #+0]
   \       0x12   0x24F0             MOVS     R4,#+240
   \       0x14   0x401C             ANDS     R4,R4,R3
   \       0x16   0x6084             STR      R4,[R0, #+8]
   1422          
   1423            /* Get the APB1 configuration ----------------------------------------------*/
   1424            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
   \       0x18   0x23E0             MOVS     R3,#+224
   \       0x1A   0x00DB             LSLS     R3,R3,#+3        ;; #+1792
   \       0x1C   0x6814             LDR      R4,[R2, #+0]
   \       0x1E   0x401C             ANDS     R4,R4,R3
   \       0x20   0x60C4             STR      R4,[R0, #+12]
   1425          
   1426            /* Get the APB2 configuration ----------------------------------------------*/
   1427            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
   \       0x22   0x6812             LDR      R2,[R2, #+0]
   \       0x24   0x08D2             LSRS     R2,R2,#+3
   \       0x26   0x4013             ANDS     R3,R3,R2
   \       0x28   0x6103             STR      R3,[R0, #+16]
   1428          
   1429            /* Get the Flash Wait State (Latency) configuration ------------------------*/
   1430            *pFLatency = __HAL_FLASH_GET_LATENCY();
   \       0x2A   0x....             LDR      R0,??DataTable11_10  ;; 0x40022000
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \       0x2E   0x07C2             LSLS     R2,R0,#+31
   \       0x30   0x0FD2             LSRS     R2,R2,#+31
   \       0x32   0x600A             STR      R2,[R1, #+0]
   1431          }
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
   1432          
   1433          #if defined(RCC_HSECSS_SUPPORT)
   1434          /**
   1435            * @brief This function handles the RCC CSS interrupt request.
   1436            * @note This API should be called under the NMI_Handler().
   1437            * @retval None
   1438            */

   \                                 In section .text, align 2, keep-with-next
   1439          void HAL_RCC_NMI_IRQHandler(void)
   1440          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1441            /* Check RCC CSSF flag  */
   1442            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   \        0x2   0x2480             MOVS     R4,#+128
   \        0x4   0x0064             LSLS     R4,R4,#+1        ;; #+256
   \        0x6   0x....             LDR      R5,??DataTable11_11  ;; 0x40021014
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x4020             ANDS     R0,R0,R4
   \        0xC   0xD002             BEQ      ??HAL_RCC_NMI_IRQHandler_0
   1443            {
   1444              /* RCC Clock Security System interrupt user callback */
   1445              HAL_RCC_CSSCallback();
   \        0xE   0x....'....        BL       HAL_RCC_CSSCallback
   1446          
   1447              /* Clear RCC CSS pending bit */
   1448              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   \       0x12   0x606C             STR      R4,[R5, #+4]
   1449            }
   1450          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \       0x14   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1451          
   1452          /**
   1453            * @brief  RCC Clock Security System interrupt callback
   1454            * @retval none
   1455            */

   \                                 In section .text, align 2
   1456          __weak void HAL_RCC_CSSCallback(void)
   1457          {
   1458            /* NOTE : This function Should not be modified, when the callback is needed,
   1459              the HAL_RCC_CSSCallback could be implemented in the user file
   1460              */
   1461          }
   \                     HAL_RCC_CSSCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \        0x0   0x00FF'00FF        DC32     0xff00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \        0x0   0x0000'1389        DC32     0x1389

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \        0x0   0xFEF6'FFF4        DC32     0xfef6fff4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \        0x0   0xFFFB'FFFF        DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \        0x0   0x0000'01FF        DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x4000'7000        DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x0000'1389        DC32     0x1389

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xEFFF'FFFF        DC32     0xefffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x4001'0020        DC32     0x40010020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0xFFFF'DFFF        DC32     0xffffdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0xFEFF'FFFF        DC32     0xfeffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xFF02'FFFF        DC32     0xff02ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x0000'1389        DC32     0x1389

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xFFFF'F8FF        DC32     0xfffff8ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0xFFFF'C7FF        DC32     0xffffc7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x4002'100C        DC32     0x4002100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x80FF'FFFF        DC32     0x80ffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x00F4'2400        DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x....'....        DC32     PLLMulTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0x....'....        DC32     APBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \        0x0   0x4002'1014        DC32     0x40021014
   1462          
   1463          #endif /* RCC_HSECSS_SUPPORT */
   1464          /**
   1465            * @}
   1466            */
   1467          
   1468          /**
   1469            * @}
   1470            */
   1471          
   1472          /* Private function prototypes -----------------------------------------------*/
   1473          /** @addtogroup RCC_Private_Functions
   1474            * @{
   1475            */
   1476          
   1477          /**
   1478            * @}
   1479            */
   1480          
   1481          #endif /* HAL_RCC_MODULE_ENABLED */
   1482          /**
   1483            * @}
   1484            */
   1485          
   1486          /**
   1487            * @}
   1488            */
   1489          
   1490          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      24   HAL_RCC_ClockConfig
        24   -> HAL_GetTick
        24   -> HAL_InitTick
        24   -> HAL_RCC_GetSysClockFreq
      16   HAL_RCC_DeInit
        16   -> HAL_GetTick
        16   -> HAL_InitTick
       0   HAL_RCC_EnableCSS
       8   HAL_RCC_GetClockConfig
       0   HAL_RCC_GetHCLKFreq
      20   HAL_RCC_GetOscConfig
       0   HAL_RCC_GetPCLK1Freq
       0   HAL_RCC_GetPCLK2Freq
      20   HAL_RCC_GetSysClockFreq
        20 __aeabi_uidiv
      48   HAL_RCC_MCOConfig
        48   -> HAL_GPIO_Init
        48   -> memset
      16   HAL_RCC_NMI_IRQHandler
        16   -> HAL_RCC_CSSCallback
      32   HAL_RCC_OscConfig
        32   -> HAL_GetTick
        32   -> HAL_InitTick
        32   -> HAL_RCC_GetSysClockFreq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable1
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       8  ?Subroutine0
       2  HAL_RCC_CSSCallback
     348  HAL_RCC_ClockConfig
     174  HAL_RCC_DeInit
      14  HAL_RCC_EnableCSS
      54  HAL_RCC_GetClockConfig
       6  HAL_RCC_GetHCLKFreq
     160  HAL_RCC_GetOscConfig
      14  HAL_RCC_GetPCLK1Freq
      12  HAL_RCC_GetPCLK2Freq
     108  HAL_RCC_GetSysClockFreq
      88  HAL_RCC_MCOConfig
      22  HAL_RCC_NMI_IRQHandler
   1'138  HAL_RCC_OscConfig

 
 2'276 bytes in section .text
 
 2'274 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none
