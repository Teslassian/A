###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  11:53:10
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\nvm_api.c
#    Command line                 =
#        -f C:\Users\dvone\AppData\Local\Temp\EWEB3D.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\nvm_api.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                       =  C
#    List file                    =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\nvm_api.lst
#    Object file                  =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\nvm_api.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\ST_API\src\nvm_api.c
      1          #include <stdio.h>
      2          #include <stdlib.h>
      3          #include <string.h>
      4          #include "nvm_api.h"
      5          #include "SDK_UTILS_Flash.h"
      6          #include "SDK_EVAL_Config.h"
      7          

   \                                 In section .bss, align 4
      8          static volatile NVM_TYPE _nvmType = NVM_TYPE_EEPROM;
   \                     _nvmType:
   \        0x0                      DS8 1
   \        0x1                      DS8 1
   \        0x2                      DS8 2
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 4
      9          static volatile uint8_t  _msgSq = 0x00;
     10          static volatile uint32_t _blockPointer;
     11          static volatile uint32_t _sfxDataAddress;
     12          static volatile uint32_t _boardDataAddress;
     13          
     14          #ifdef USE_FLASH
     15          #define	_nvmReadOperation(addr, nbytes, buff) FlashRead(addr, nbytes, buff)
     16          #define	_nvmWriteOperation(addr, nbytes, buff, mode) FlashWrite(addr, nbytes, buff, mode)
     17          #else
     18          #include "S2LP_AUX_EEPROM.h"
     19          
     20          #define	_nvmReadOperation(addr, nbytes, buff) EepromRead(addr, nbytes, buff)
     21          #define	_nvmWriteOperation(addr, nbytes, buff, mode) EepromWrite(addr, nbytes, buff)
     22          #endif
     23          

   \                                 In section .text, align 2, keep-with-next
     24          static NVM_RW_RESULTS _setBlockState(uint32_t addr, uint64_t state)
     25          {
   \                     _setBlockState: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
     26            NVM_RW_RESULTS tRet = NVM_RW_OK;
     27            uint64_t wrState;
     28          
     29            if(state == NVM_BLOCK_INVALID)
   \        0x2   0x2B00             CMP      R3,#+0
   \        0x4   0xD106             BNE      ??_setBlockState_0
   \        0x6   0x2AFE             CMP      R2,#+254
   \        0x8   0xD104             BNE      ??_setBlockState_0
     30            {
     31              wrState = NVM_BLOCK_INVALID_2;
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0xC10C             STM      R1!,{R2,R3}
     32              tRet = NVM_Write(addr, BLOCK_HEADER_SIZE/2, (uint8_t*)&wrState, NVM_WRITE_MODE_WRITEOVER);
   \        0xE   0x466A             MOV      R2,SP
   \       0x10   0x2104             MOVS     R1,#+4
   \       0x12   0xE00A             B.N      ??_setBlockState_1
     33            }
     34            else if(state == NVM_BLOCK_VALID)
   \                     ??_setBlockState_0: (+1)
   \       0x14   0x2BFC             CMP      R3,#+252
   \       0x16   0xD10B             BNE      ??_setBlockState_2
   \       0x18   0x2AFE             CMP      R2,#+254
   \       0x1A   0xD109             BNE      ??_setBlockState_2
     35            {
     36              wrState = NVM_BLOCK_VALID_2;
   \       0x1C   0x22FC             MOVS     R2,#+252
   \       0x1E   0x2300             MOVS     R3,#+0
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0xC10C             STM      R1!,{R2,R3}
     37              tRet = NVM_Write(addr+BLOCK_HEADER_SIZE/2, BLOCK_HEADER_SIZE/2, (uint8_t*)&wrState, NVM_WRITE_MODE_WRITEOVER);
   \       0x24   0x466A             MOV      R2,SP
   \       0x26   0x2104             MOVS     R1,#+4
   \       0x28   0x1D00             ADDS     R0,R0,#+4
   \                     ??_setBlockState_1: (+1)
   \       0x2A   0x....'....        BL       NVM_Write
   \       0x2E   0xBD0E             POP      {R1-R3,PC}
     38            }
     39            else
     40              tRet = NVM_WRITE_HEADER_ERROR;
   \                     ??_setBlockState_2: (+1)
   \       0x30   0x2005             MOVS     R0,#+5
     41          
     42            return tRet;
   \       0x32   0xBD0E             POP      {R1-R3,PC}       ;; return
     43          }
     44          

   \                                 In section .text, align 2, keep-with-next
     45          static NVM_RW_RESULTS _writeRecordInternal(uint32_t addr, uint8_t* nvmRecord, uint32_t recordSize)
     46          {
   \                     _writeRecordInternal: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0014             MOVS     R4,R2
     47            NVM_RW_RESULTS tRet = NVM_RW_OK;
     48          
     49            tRet = _setBlockState(addr, NVM_BLOCK_INVALID);
   \        0x8   0x22FE             MOVS     R2,#+254
   \        0xA   0x2300             MOVS     R3,#+0
   \        0xC   0x....'....        BL       _setBlockState
     50          
     51            if(tRet == NVM_RW_OK)
   \       0x10   0x0001             MOVS     R1,R0
   \       0x12   0xD106             BNE      ??_writeRecordInternal_0
   \       0x14   0x002A             MOVS     R2,R5
     52              tRet = NVM_Write(addr+BLOCK_HEADER_SIZE, recordSize, (uint8_t *)nvmRecord, NVM_WRITE_MODE_WRITEOVER);
   \       0x16   0x2300             MOVS     R3,#+0
   \       0x18   0xB2E1             UXTB     R1,R4
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x3008             ADDS     R0,R0,#+8
   \       0x1E   0x....'....        BL       NVM_Write
     53          
     54            if(tRet == NVM_RW_OK)
   \                     ??_writeRecordInternal_0: (+1)
   \       0x22   0x0001             MOVS     R1,R0
   \       0x24   0xD104             BNE      ??_writeRecordInternal_1
     55              tRet = _setBlockState(addr, NVM_BLOCK_VALID);
   \       0x26   0x22FE             MOVS     R2,#+254
   \       0x28   0x23FC             MOVS     R3,#+252
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x....'....        BL       _setBlockState
     56          
     57            return tRet;
   \                     ??_writeRecordInternal_1: (+1)
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
     58          }
     59          

   \                                 In section .text, align 2, keep-with-next
     60          void SetNVMInitial(NVM_ConfigType *config)
     61          {
   \                     SetNVMInitial: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
     62            _nvmType = config->nvmType;
   \        0x2   0x....             LDR      R4,??DataTable7
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x7021             STRB     R1,[R4, #+0]
     63            _sfxDataAddress = config->sfxDataAddress;
   \        0x8   0x6881             LDR      R1,[R0, #+8]
   \        0xA   0x60A1             STR      R1,[R4, #+8]
     64            _boardDataAddress = config->boardDataAddress;
   \        0xC   0x6841             LDR      R1,[R0, #+4]
   \        0xE   0x60E1             STR      R1,[R4, #+12]
     65            _msgSq = config->messageSequenceNumber;
   \       0x10   0x7B00             LDRB     R0,[R0, #+12]
   \       0x12   0x7060             STRB     R0,[R4, #+1]
     66          
     67            /* Initialize FLASH user data for first boot */
     68            if(_nvmType == NVM_TYPE_FLASH)
   \       0x14   0x7820             LDRB     R0,[R4, #+0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD111             BNE      ??SetNVMInitial_0
     69            {
     70              uint8_t cleanBuf[BLOCK_BODY_SIZE];
     71          
     72              if (NVM_ReadRecord(cleanBuf, BLOCK_BODY_SIZE) == NVM_NO_RECORDS)
   \       0x1A   0x2108             MOVS     R1,#+8
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x....'....        BL       NVM_ReadRecord
   \       0x22   0x2806             CMP      R0,#+6
   \       0x24   0xD10B             BNE      ??SetNVMInitial_0
     73              {
     74          	memset(cleanBuf, FLASH_ERASE_VALUE, BLOCK_BODY_SIZE);
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0xC006             STM      R0!,{R1,R2}
     75          	FlashErase(_sfxDataAddress, 1);
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0x68A0             LDR      R0,[R4, #+8]
   \       0x32   0x....'....        BL       FlashErase
     76          	NVM_WriteRecord(&cleanBuf[0], BLOCK_BODY_SIZE);
   \       0x36   0x2108             MOVS     R1,#+8
   \       0x38   0x4668             MOV      R0,SP
   \       0x3A   0x....'....        BL       NVM_WriteRecord
     77              }
     78            }
     79          }
   \                     ??SetNVMInitial_0: (+1)
   \       0x3E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     80          

   \                                 In section .text, align 2, keep-with-next
     81          NVM_TYPE GetNVMType()
     82          {
     83            return _nvmType;
   \                     GetNVMType: (+1)
   \        0x0   0x....             LDR      R0,??DataTable7
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
     84          }
     85          

   \                                 In section .text, align 2, keep-with-next
     86          uint32_t GetNVMBoardDataAddress()
     87          {
     88            return _boardDataAddress;
   \                     GetNVMBoardDataAddress: (+1)
   \        0x0   0x....             LDR      R0,??DataTable7
   \        0x2   0x68C0             LDR      R0,[R0, #+12]
   \        0x4   0x4770             BX       LR               ;; return
     89          }
     90          

   \                                 In section .text, align 2, keep-with-next
     91          uint32_t GetNVMSigfoxDataAddress()
     92          {
     93            return _sfxDataAddress;
   \                     GetNVMSigfoxDataAddress: (+1)
   \        0x0   0x....             LDR      R0,??DataTable7
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0x4770             BX       LR               ;; return
     94          }
     95          

   \                                 In section .text, align 2, keep-with-next
     96          NVM_RW_RESULTS NVM_Read(uint32_t nAddress, uint8_t cNbBytes, uint8_t* pcBuffer)
     97          {
   \                     NVM_Read: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     98            NVM_RW_RESULTS tRet = NVM_RW_OK;
   \        0x2   0x2400             MOVS     R4,#+0
     99            FLS_RW_StatusTypeDef flRet = FLS_RW_OK;
    100          
    101            flRet = (FLS_RW_StatusTypeDef)_nvmReadOperation(nAddress, cNbBytes, pcBuffer);
    102          
    103            if(flRet != FLS_RW_OK)
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x....'....        BL       EepromRead
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD000             BEQ      ??NVM_Read_0
    104              tRet = NVM_READ_ERROR;
   \        0xE   0x2402             MOVS     R4,#+2
    105          
    106            return tRet;
   \                     ??NVM_Read_0: (+1)
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xBD10             POP      {R4,PC}          ;; return
    107          }
    108          

   \                                 In section .text, align 2, keep-with-next
    109          NVM_RW_RESULTS NVM_Write(uint32_t nAddress, uint8_t cNbBytes, uint8_t* pcBuffer, NVM_WRITE_MODE writeMode)
    110          {
   \                     NVM_Write: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    111            NVM_RW_RESULTS tRet = NVM_RW_OK;
   \        0x2   0x2400             MOVS     R4,#+0
    112            FLS_RW_StatusTypeDef flRet = FLS_RW_OK;
    113          
    114            flRet = (FLS_RW_StatusTypeDef)_nvmWriteOperation(nAddress, cNbBytes, pcBuffer, writeMode);
    115          
    116            if(flRet != FLS_RW_OK)
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x....'....        BL       EepromWrite
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD000             BEQ      ??NVM_Write_0
    117              tRet = NVM_WRITE_ERROR;
   \        0xE   0x2401             MOVS     R4,#+1
    118          
    119            return tRet;
   \                     ??NVM_Write_0: (+1)
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xBD10             POP      {R4,PC}          ;; return
    120          }
    121          

   \                                 In section .text, align 2, keep-with-next
    122          NVM_RW_RESULTS NVM_ReadRecord(uint8_t* nvmRecord, uint32_t recordSize)
    123          {
   \                     NVM_ReadRecord: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x000F             MOVS     R7,R1
    124            NVM_RW_RESULTS tRet = NVM_RW_OK;
   \        0x6   0x2600             MOVS     R6,#+0
    125          
    126            uint64_t currentBlockState;
    127            currentBlockState = NVM_BLOCK_INVALID;
   \        0x8   0x20FE             MOVS     R0,#+254
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x466A             MOV      R2,SP
   \        0xE   0xC203             STM      R2!,{R0,R1}
    128          
    129            _blockPointer = _sfxDataAddress;
   \       0x10   0x....             LDR      R4,??DataTable7
   \       0x12   0x68A0             LDR      R0,[R4, #+8]
   \       0x14   0x6060             STR      R0,[R4, #+4]
    130          
    131            if (_nvmType == NVM_TYPE_FLASH)
   \       0x16   0x7820             LDRB     R0,[R4, #+0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0x....             LDR      R5,??DataTable7_1
   \       0x1C   0xD137             BNE      ??NVM_ReadRecord_0
    132            {
    133              while(currentBlockState != NVM_BLOCK_EMPTY)
    134              {
    135          	if(NVM_Read(_blockPointer, BLOCK_HEADER_SIZE, (uint8_t*)&currentBlockState) == NVM_RW_OK)
   \                     ??NVM_ReadRecord_1: (+1)
   \       0x1E   0x466A             MOV      R2,SP
   \       0x20   0x2108             MOVS     R1,#+8
   \       0x22   0x6860             LDR      R0,[R4, #+4]
   \       0x24   0x....'....        BL       NVM_Read
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD12E             BNE      ??NVM_ReadRecord_2
    136          	{
    137          	  if(_blockPointer + (BLOCK_BODY_SIZE+BLOCK_HEADER_SIZE) == (uint32_t)FLASH_USER_END_ADDR)
   \       0x2C   0x6860             LDR      R0,[R4, #+4]
   \       0x2E   0x3010             ADDS     R0,R0,#+16
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0x3180             ADDS     R1,R1,#+128
   \       0x34   0x4288             CMP      R0,R1
   \       0x36   0xD019             BEQ      ??NVM_ReadRecord_3
    138          	    break;
    139          	  else
    140          	    _blockPointer += BLOCK_BODY_SIZE+BLOCK_HEADER_SIZE;
   \       0x38   0x6860             LDR      R0,[R4, #+4]
   \       0x3A   0x3010             ADDS     R0,R0,#+16
   \       0x3C   0x6060             STR      R0,[R4, #+4]
    141          	}
    142          	else
    143          	{
    144          	  tRet = NVM_READ_RECORD_ERROR;
    145          	  break;
    146          	}
    147              }
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0xC803             LDM      R0,{R0,R1}
   \       0x42   0x2900             CMP      R1,#+0
   \       0x44   0xD1EB             BNE      ??NVM_ReadRecord_1
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD1E9             BNE      ??NVM_ReadRecord_1
   \       0x4A   0xE001             B        ??NVM_ReadRecord_4
    148          
    149              if(tRet == NVM_RW_OK)
    150              {
    151          	while(currentBlockState != NVM_BLOCK_VALID && tRet == NVM_RW_OK)
   \                     ??NVM_ReadRecord_5: (+1)
   \       0x4C   0x0030             MOVS     R0,R6
   \       0x4E   0xD113             BNE      ??NVM_ReadRecord_6
    152          	{
    153          	  _blockPointer -= (BLOCK_BODY_SIZE+BLOCK_HEADER_SIZE);
   \                     ??NVM_ReadRecord_4: (+1)
   \       0x50   0x6860             LDR      R0,[R4, #+4]
   \       0x52   0x3810             SUBS     R0,R0,#+16
   \       0x54   0x6060             STR      R0,[R4, #+4]
    154          
    155          	  if(_blockPointer < (uint32_t)FLASH_USER_START_ADDR)
   \       0x56   0x6860             LDR      R0,[R4, #+4]
   \       0x58   0x42A8             CMP      R0,R5
   \       0x5A   0xD201             BCS      ??NVM_ReadRecord_7
    156          	  {
    157          	    tRet = NVM_NO_RECORDS;
   \       0x5C   0x2606             MOVS     R6,#+6
    158          	    break;
   \       0x5E   0xE01C             B        ??NVM_ReadRecord_8
    159          	  }
    160          
    161          	  tRet = NVM_Read(_blockPointer, BLOCK_HEADER_SIZE, (uint8_t*)&currentBlockState);
   \                     ??NVM_ReadRecord_7: (+1)
   \       0x60   0x466A             MOV      R2,SP
   \       0x62   0x2108             MOVS     R1,#+8
   \       0x64   0x6860             LDR      R0,[R4, #+4]
   \       0x66   0x....'....        BL       NVM_Read
   \       0x6A   0x0006             MOVS     R6,R0
    162          	}
   \                     ??NVM_ReadRecord_3: (+1)
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0xC803             LDM      R0,{R0,R1}
   \       0x70   0x29FC             CMP      R1,#+252
   \       0x72   0xD1EB             BNE      ??NVM_ReadRecord_5
   \       0x74   0x28FE             CMP      R0,#+254
   \       0x76   0xD1E9             BNE      ??NVM_ReadRecord_5
    163          
    164          	if(tRet == NVM_RW_OK)
   \                     ??NVM_ReadRecord_6: (+1)
   \       0x78   0x0030             MOVS     R0,R6
   \       0x7A   0xD104             BNE      ??NVM_ReadRecord_9
    165          	  tRet = NVM_Read(_blockPointer+BLOCK_HEADER_SIZE, recordSize, (uint8_t *)nvmRecord);
   \       0x7C   0x9A02             LDR      R2,[SP, #+8]
   \       0x7E   0xB2F9             UXTB     R1,R7
   \       0x80   0x6860             LDR      R0,[R4, #+4]
   \       0x82   0x3008             ADDS     R0,R0,#+8
   \       0x84   0xE006             B        ??NVM_ReadRecord_10
    166          	else if (tRet != NVM_NO_RECORDS)
   \                     ??NVM_ReadRecord_9: (+1)
   \       0x86   0x2E06             CMP      R6,#+6
   \       0x88   0xD007             BEQ      ??NVM_ReadRecord_8
    167          	  tRet = NVM_READ_RECORD_ERROR;
   \                     ??NVM_ReadRecord_2: (+1)
   \       0x8A   0x2604             MOVS     R6,#+4
   \       0x8C   0xE005             B        ??NVM_ReadRecord_8
    168              }
    169            }
    170            else
    171              tRet = NVM_Read(_blockPointer, recordSize, (uint8_t *)nvmRecord);
   \                     ??NVM_ReadRecord_0: (+1)
   \       0x8E   0x9A02             LDR      R2,[SP, #+8]
   \       0x90   0xB2F9             UXTB     R1,R7
   \       0x92   0x6860             LDR      R0,[R4, #+4]
   \                     ??NVM_ReadRecord_10: (+1)
   \       0x94   0x....'....        BL       NVM_Read
   \       0x98   0x0006             MOVS     R6,R0
    172          
    173            return tRet;
   \                     ??NVM_ReadRecord_8: (+1)
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0xBDFE             POP      {R1-R7,PC}       ;; return
    174          }
    175          

   \                                 In section .text, align 2, keep-with-next
    176          NVM_RW_RESULTS NVM_WriteRecord(uint8_t* nvmRecord, uint32_t recordSize)
    177          {
   \                     NVM_WriteRecord: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0002             MOVS     R2,R0
   \        0x4   0x000D             MOVS     R5,R1
    178            NVM_RW_RESULTS tRet = NVM_RW_OK;
    179            uint64_t currentBlockState;
    180            currentBlockState = NVM_BLOCK_INVALID;
   \        0x6   0x20FE             MOVS     R0,#+254
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x466B             MOV      R3,SP
   \        0xC   0xC303             STM      R3!,{R0,R1}
    181          
    182            _blockPointer = _sfxDataAddress;
   \        0xE   0x....             LDR      R4,??DataTable7
   \       0x10   0x68A0             LDR      R0,[R4, #+8]
   \       0x12   0x6060             STR      R0,[R4, #+4]
    183          
    184            if (_nvmType == NVM_TYPE_FLASH)
   \       0x14   0x7820             LDRB     R0,[R4, #+0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD005             BEQ      ??NVM_WriteRecord_0
    185            {
    186              while(currentBlockState != NVM_BLOCK_EMPTY)
    187              {
    188          	if(_blockPointer != (uint32_t)FLASH_USER_END_ADDR)
    189          	{
    190          	  if(NVM_Read(_blockPointer, BLOCK_HEADER_SIZE, (uint8_t *)&currentBlockState) == NVM_RW_OK)
    191          	  {
    192          	    if(currentBlockState == NVM_BLOCK_EMPTY)
    193          	    {
    194          		tRet = _writeRecordInternal(_blockPointer, nvmRecord, recordSize);
    195          		break;
    196          	    }
    197          	    else
    198          		_blockPointer += (BLOCK_BODY_SIZE+BLOCK_HEADER_SIZE);
    199          	  }
    200          	  else
    201          	  {
    202          	    tRet = NVM_READ_RECORD_ERROR;
    203          	    break;
    204          	  }
    205          	}
    206          	else
    207          	{
    208          	  _blockPointer = (uint32_t)FLASH_USER_START_ADDR;
    209          	  FlashErase(_blockPointer, 1);
    210          	  tRet = _writeRecordInternal(_blockPointer, nvmRecord, recordSize);
    211          
    212          	  break;
    213          	}
    214              }
    215            }
    216            else
    217              tRet = NVM_Write(_blockPointer, recordSize, nvmRecord, NVM_WRITE_MODE_WRITEOVER);
   \       0x1A   0x2300             MOVS     R3,#+0
   \       0x1C   0xB2E9             UXTB     R1,R5
   \       0x1E   0x6860             LDR      R0,[R4, #+4]
   \       0x20   0x....'....        BL       NVM_Write
    218          
    219          
    220            return tRet;
   \       0x24   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??NVM_WriteRecord_0: (+1)
   \       0x26   0x0016             MOVS     R6,R2
   \       0x28   0xE002             B        ??NVM_WriteRecord_1
   \                     ??NVM_WriteRecord_2: (+1)
   \       0x2A   0x6860             LDR      R0,[R4, #+4]
   \       0x2C   0x3010             ADDS     R0,R0,#+16
   \       0x2E   0x6060             STR      R0,[R4, #+4]
   \                     ??NVM_WriteRecord_1: (+1)
   \       0x30   0x....             LDR      R0,??DataTable7_1
   \       0x32   0x6861             LDR      R1,[R4, #+4]
   \       0x34   0x0002             MOVS     R2,R0
   \       0x36   0x3280             ADDS     R2,R2,#+128
   \       0x38   0x4291             CMP      R1,R2
   \       0x3A   0xD014             BEQ      ??NVM_WriteRecord_3
   \       0x3C   0x466A             MOV      R2,SP
   \       0x3E   0x2108             MOVS     R1,#+8
   \       0x40   0x6860             LDR      R0,[R4, #+4]
   \       0x42   0x....'....        BL       NVM_Read
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD10B             BNE      ??NVM_WriteRecord_4
   \       0x4A   0x4668             MOV      R0,SP
   \       0x4C   0xC803             LDM      R0,{R0,R1}
   \       0x4E   0x2900             CMP      R1,#+0
   \       0x50   0xD1EB             BNE      ??NVM_WriteRecord_2
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD1E9             BNE      ??NVM_WriteRecord_2
   \                     ??NVM_WriteRecord_5: (+1)
   \       0x56   0x002A             MOVS     R2,R5
   \       0x58   0x0031             MOVS     R1,R6
   \       0x5A   0x6860             LDR      R0,[R4, #+4]
   \       0x5C   0x....'....        BL       _writeRecordInternal
   \       0x60   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??NVM_WriteRecord_4: (+1)
   \       0x62   0x2004             MOVS     R0,#+4
   \       0x64   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??NVM_WriteRecord_3: (+1)
   \       0x66   0x6060             STR      R0,[R4, #+4]
   \       0x68   0x2101             MOVS     R1,#+1
   \       0x6A   0x6860             LDR      R0,[R4, #+4]
   \       0x6C   0x....'....        BL       FlashErase
   \       0x70   0xE7F1             B.N      ??NVM_WriteRecord_5
    221          }
    222          

   \                                 In section .text, align 2, keep-with-next
    223          NVM_RW_RESULTS NVM_UpdateOffset(NVM_UPDATE_OFFSET updateWhat, int32_t data)
    224          {
   \                     NVM_UpdateOffset: (+1)
   \        0x0   0xB532             PUSH     {R1,R4,R5,LR}
   \        0x2   0xB090             SUB      SP,SP,#+64
   \        0x4   0x0004             MOVS     R4,R0
    225            uint8_t originalData[64];
    226            NVM_RW_RESULTS ret = NVM_RW_OK;
   \        0x6   0x2000             MOVS     R0,#+0
    227            /* avoid to corrupt eeprom content, this command works only with flash*/
    228            if (_nvmType == NVM_TYPE_FLASH)
   \        0x8   0x....             LDR      R5,??DataTable7
   \        0xA   0x7829             LDRB     R1,[R5, #+0]
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0xD120             BNE      ??NVM_UpdateOffset_0
    229            {
    230              ret = NVM_Read(_boardDataAddress, 64, &originalData[0]);
   \       0x10   0x466A             MOV      R2,SP
   \       0x12   0x2140             MOVS     R1,#+64
   \       0x14   0x68E8             LDR      R0,[R5, #+12]
   \       0x16   0x....'....        BL       NVM_Read
    231          
    232              if(ret == NVM_RW_OK)
   \       0x1A   0x0001             MOVS     R1,R0
   \       0x1C   0xD119             BNE      ??NVM_UpdateOffset_0
    233              {
    234          	if(updateWhat == NVM_FREQ_OFFSET)
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x0021             MOVS     R1,R4
   \       0x22   0xD10A             BNE      ??NVM_UpdateOffset_1
    235          	  memcpy(&originalData[48], &data, sizeof(int32_t));
   \       0x24   0xA910             ADD      R1,SP,#+64
   \       0x26   0x3030             ADDS     R0,R0,#+48
   \       0x28   0x680A             LDR      R2,[R1, #0]
   \       0x2A   0x6002             STR      R2,[R0, #0]
    236          	else if(updateWhat == NVM_RSSI_OFFSET)
    237          	  originalData[52] = data;
    238          	else if(updateWhat == NVM_LBT_OFFSET)
    239          	  originalData[56] = data;
    240          	else
    241          	  ret = NVM_WRITE_ERROR;
    242              }
    243          
    244              if(ret == NVM_RW_OK)
    245          	return NVM_Write(_boardDataAddress, 64, &originalData[0], NVM_WRITE_MODE_ERASE);
   \                     ??NVM_UpdateOffset_2: (+1)
   \       0x2C   0x2301             MOVS     R3,#+1
   \       0x2E   0x466A             MOV      R2,SP
   \       0x30   0x2140             MOVS     R1,#+64
   \       0x32   0x68E8             LDR      R0,[R5, #+12]
   \       0x34   0x....'....        BL       NVM_Write
   \       0x38   0xE00B             B        ??NVM_UpdateOffset_0
   \                     ??NVM_UpdateOffset_1: (+1)
   \       0x3A   0x2C01             CMP      R4,#+1
   \       0x3C   0xD103             BNE      ??NVM_UpdateOffset_3
   \       0x3E   0x9910             LDR      R1,[SP, #+64]
   \       0x40   0x2234             MOVS     R2,#+52
   \                     ??NVM_UpdateOffset_4: (+1)
   \       0x42   0x5481             STRB     R1,[R0, R2]
   \       0x44   0xE7F2             B        ??NVM_UpdateOffset_2
   \                     ??NVM_UpdateOffset_3: (+1)
   \       0x46   0x2C02             CMP      R4,#+2
   \       0x48   0xD102             BNE      ??NVM_UpdateOffset_5
   \       0x4A   0x9910             LDR      R1,[SP, #+64]
   \       0x4C   0x2238             MOVS     R2,#+56
   \       0x4E   0xE7F8             B.N      ??NVM_UpdateOffset_4
   \                     ??NVM_UpdateOffset_5: (+1)
   \       0x50   0x2001             MOVS     R0,#+1
    246            }
    247          
    248            return ret;
   \                     ??NVM_UpdateOffset_0: (+1)
   \       0x52   0xB011             ADD      SP,SP,#+68
   \       0x54   0xBD30             POP      {R4,R5,PC}       ;; return
    249          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     _nvmType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     nvm_data
    250          
    251          
    252          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GetNVMBoardDataAddress
       0   GetNVMSigfoxDataAddress
       0   GetNVMType
       8   NVM_Read
         8   -> EepromRead
      32   NVM_ReadRecord
        32   -> NVM_Read
      80   NVM_UpdateOffset
        80   -> NVM_Read
        80   -> NVM_Write
       8   NVM_Write
         8   -> EepromWrite
      24   NVM_WriteRecord
        24   -> FlashErase
        24   -> NVM_Read
        24   -> NVM_Write
        24   -> _writeRecordInternal
      16   SetNVMInitial
        16   -> FlashErase
        16   -> NVM_ReadRecord
        16   -> NVM_WriteRecord
      16   _setBlockState
        16   -> NVM_Write
      16   _writeRecordInternal
        16   -> NVM_Write
        16   -> _setBlockState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       6  GetNVMBoardDataAddress
       6  GetNVMSigfoxDataAddress
       6  GetNVMType
      20  NVM_Read
     158  NVM_ReadRecord
      86  NVM_UpdateOffset
      20  NVM_Write
     114  NVM_WriteRecord
      64  SetNVMInitial
      16  _nvmType
          _msgSq
          _blockPointer
          _sfxDataAddress
          _boardDataAddress
      52  _setBlockState
      50  _writeRecordInternal

 
  16 bytes in section .bss
 590 bytes in section .text
 
 590 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
