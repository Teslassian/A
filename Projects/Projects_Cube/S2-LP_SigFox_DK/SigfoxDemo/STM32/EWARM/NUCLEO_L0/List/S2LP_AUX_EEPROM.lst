###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  12:25:14
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\S2LP_Middleware\STM32\src\S2LP_AUX_EEPROM.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW4ADB.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\S2LP_Middleware\STM32\src\S2LP_AUX_EEPROM.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\S2LP_AUX_EEPROM.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\S2LP_AUX_EEPROM.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\S2LP_Middleware\STM32\src\S2LP_AUX_EEPROM.c
      1          /**
      2          * @file    S2LP_EVAL_EEPROM_DMA.c
      3          * @author  LowPower RF BU - AMG
      4          * @version 1.0.0
      5          * @date    March, 2020
      6          * @brief   S2LP EVAL EEPROM management
      7          * @details
      8          *
      9          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15          *
     16          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19          *
     20          * <h2><center>&copy; COPYRIGHT 2020 STMicroelectronics</center></h2>
     21          */
     22          
     23          /* Includes -----------------------------------------------------------------*/
     24          #include "S2LP_Middleware_Config.h"
     25          #include "S2LP_AUX_EEPROM.h"
     26          
     27          /** @addtogroup S2LP_MIDDLEWARE_STM32                     S2LP Middleware - STM32
     28          * @{
     29          */
     30          
     31          /** @defgroup S2LP_AUX_EEPROM						S2LP AUX EEPROM
     32            * @brief  S2-LP EEPROM handling module.
     33            * This module exports all the main operations to deal with EEPROM.
     34            * @details See the file <i>@ref S2LP_AUX_EEPROM.h</i> for more details.
     35            * @{
     36          */
     37          
     38          
     39          /**
     40          * @brief  SPI buffers used for DMA application
     41          */
     42          
     43          static volatile uint8_t spi_buffer_rx[128];

   \                                 In section .bss, align 4
     44          static SPI_HandleTypeDef EepromSpiHandle;
   \                     EepromSpiHandle:
   \        0x0                      DS8 88
   \       0x58                      DS8 8
   \       0x60                      DS8 4
   \       0x64                      DS8 4
   \       0x68                      DS8 4
   \       0x6C                      DS8 4
   \       0x70                      DS8 4
     45          
     46          #if EEPROM_PRESENT == EEPROM_YES

   \                                 In section .bss, align 1
     47            static uint8_t s_eeprom  = 0;
   \                     s_eeprom:
   \        0x0                      DS8 1
     48          #endif
     49          
     50          /* To Store the state of the main CS reg */
     51          static uint32_t MainCs_ModerGpioReg;
     52          static uint32_t MainCs_OtyperGpioReg;
     53          static uint32_t MainCs_OspeedrGpioReg;
     54          static uint32_t MainCs_PupdrGpioReg;
     55          static uint32_t MainCs_OdrGpioReg;
     56          static uint32_t MainCs_AfrGpioReg[2];
     57          
     58          

   \                                 In section .text, align 2, keep-with-next
     59          void EepromSPICSLow()
     60          {
   \                     EepromSPICSLow: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     61            if (SdkEvalGetDaughterBoardType()==X_NUCLEO_SERIES)
   \        0x2   0x....'....        BL       SdkEvalGetDaughterBoardType
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD103             BNE      ??EepromSPICSLow_0
     62              HAL_GPIO_WritePin(EEPROM_SPI_XNUCLEO_CS_PORT, EEPROM_SPI_XNUCLEO_CS_PIN, GPIO_PIN_RESET);
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2110             MOVS     R1,#+16
   \        0xE   0x....             LDR      R0,??DataTable13  ;; 0x50000400
   \       0x10   0xE004             B        ??EepromSPICSLow_1
     63            else
     64              HAL_GPIO_WritePin(EEPROM_SPI_CS_PORT, EEPROM_SPI_CS_PIN, GPIO_PIN_RESET);
   \                     ??EepromSPICSLow_0: (+1)
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x2180             MOVS     R1,#+128
   \       0x16   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x18   0x20A0             MOVS     R0,#+160
   \       0x1A   0x05C0             LSLS     R0,R0,#+23       ;; #+1342177280
   \                     ??EepromSPICSLow_1: (+1)
   \       0x1C   0x....'....        BL       HAL_GPIO_WritePin
     65          }
   \       0x20   0xBD01             POP      {R0,PC}          ;; return
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void EepromSPICSHigh()
     68          {
   \                     EepromSPICSHigh: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     69            if (SdkEvalGetDaughterBoardType()==X_NUCLEO_SERIES)
   \        0x2   0x....'....        BL       SdkEvalGetDaughterBoardType
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD103             BNE      ??EepromSPICSHigh_0
     70              HAL_GPIO_WritePin(EEPROM_SPI_XNUCLEO_CS_PORT, EEPROM_SPI_XNUCLEO_CS_PIN, GPIO_PIN_SET);
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x2110             MOVS     R1,#+16
   \        0xE   0x....             LDR      R0,??DataTable13  ;; 0x50000400
   \       0x10   0xE003             B        ??EepromSPICSHigh_1
     71            else
     72              HAL_GPIO_WritePin(EEPROM_SPI_CS_PORT, EEPROM_SPI_CS_PIN, GPIO_PIN_SET);
   \                     ??EepromSPICSHigh_0: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x0251             LSLS     R1,R2,#+9
   \       0x16   0x20A0             MOVS     R0,#+160
   \       0x18   0x05C0             LSLS     R0,R0,#+23       ;; #+1342177280
   \                     ??EepromSPICSHigh_1: (+1)
   \       0x1A   0x....'....        BL       HAL_GPIO_WritePin
     73          }
   \       0x1E   0xBD01             POP      {R0,PC}          ;; return
     74          

   \                                 In section .text, align 2, keep-with-next
     75          void EepromSpiInitialization(void)
     76          {
   \                     EepromSpiInitialization: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
     77            /*----------------------- GPIO Mode Configuration --------------------*/
     78            GPIO_InitTypeDef GPIO_InitStructure;
     79          
     80            /* Enable SPI periph and SCLK, MOSI, MISO and CS GPIO clocks */
     81            EEPROM_SPI_PERIPH_RCC();
   \        0x4   0x....             LDR      R0,??DataTable13_1  ;; 0x4002102c
   \        0x6   0x6881             LDR      R1,[R0, #+8]
   \        0x8   0x0C82             LSRS     R2,R0,#+18
   \        0xA   0x430A             ORRS     R2,R2,R1
   \        0xC   0x6082             STR      R2,[R0, #+8]
     82          
     83            EEPROM_SPI_MOSI_RCC();
   \        0xE   0x2601             MOVS     R6,#+1
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x4331             ORRS     R1,R1,R6
   \       0x14   0x6001             STR      R1,[R0, #+0]
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x4031             ANDS     R1,R1,R6
   \       0x1A   0x9105             STR      R1,[SP, #+20]
   \       0x1C   0x9905             LDR      R1,[SP, #+20]
     84            EEPROM_SPI_MISO_RCC();
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x4331             ORRS     R1,R1,R6
   \       0x22   0x6001             STR      R1,[R0, #+0]
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0x4031             ANDS     R1,R1,R6
   \       0x28   0x9105             STR      R1,[SP, #+20]
   \       0x2A   0x9905             LDR      R1,[SP, #+20]
     85            EEPROM_SPI_CLK_RCC();
   \       0x2C   0x2102             MOVS     R1,#+2
   \       0x2E   0x6802             LDR      R2,[R0, #+0]
   \       0x30   0x430A             ORRS     R2,R2,R1
   \       0x32   0x6002             STR      R2,[R0, #+0]
   \       0x34   0x6802             LDR      R2,[R0, #+0]
   \       0x36   0x400A             ANDS     R2,R2,R1
   \       0x38   0x9205             STR      R2,[SP, #+20]
   \       0x3A   0x9A05             LDR      R2,[SP, #+20]
     86            EEPROM_SPI_CS_RCC();
   \       0x3C   0x6802             LDR      R2,[R0, #+0]
   \       0x3E   0x4332             ORRS     R2,R2,R6
   \       0x40   0x6002             STR      R2,[R0, #+0]
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0x4030             ANDS     R0,R0,R6
   \       0x46   0x9005             STR      R0,[SP, #+20]
   \       0x48   0x9805             LDR      R0,[SP, #+20]
     87          
     88            /* Configure the AF for MOSI, MISO and SCLK GPIO pins*/
     89            GPIO_InitStructure.Pin       = EEPROM_SPI_CLK_PIN;
   \       0x4A   0x2008             MOVS     R0,#+8
   \       0x4C   0x9000             STR      R0,[SP, #+0]
     90            GPIO_InitStructure.Mode      = GPIO_MODE_AF_PP;
   \       0x4E   0x9101             STR      R1,[SP, #+4]
     91            GPIO_InitStructure.Pull      = GPIO_PULLUP;
   \       0x50   0x9602             STR      R6,[SP, #+8]
     92            GPIO_InitStructure.Speed     = GPIO_SPEED_HIGH;
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0x9003             STR      R0,[SP, #+12]
     93            GPIO_InitStructure.Alternate = EEPROM_SPI_CLK_AF;
   \       0x56   0x2400             MOVS     R4,#+0
   \       0x58   0x9404             STR      R4,[SP, #+16]
     94            HAL_GPIO_Init(EEPROM_SPI_CLK_PORT, &GPIO_InitStructure);
   \       0x5A   0x4669             MOV      R1,SP
   \       0x5C   0x....             LDR      R0,??DataTable13  ;; 0x50000400
   \       0x5E   0x....'....        BL       HAL_GPIO_Init
     95          
     96            GPIO_InitStructure.Pin = EEPROM_SPI_MISO_PIN;
   \       0x62   0x2040             MOVS     R0,#+64
   \       0x64   0x9000             STR      R0,[SP, #+0]
     97            GPIO_InitStructure.Alternate = EEPROM_SPI_MISO_AF;
   \       0x66   0x9404             STR      R4,[SP, #+16]
     98            HAL_GPIO_Init(EEPROM_SPI_MISO_PORT, &GPIO_InitStructure);
   \       0x68   0x27A0             MOVS     R7,#+160
   \       0x6A   0x05FF             LSLS     R7,R7,#+23       ;; #+1342177280
   \       0x6C   0x4669             MOV      R1,SP
   \       0x6E   0x0038             MOVS     R0,R7
   \       0x70   0x....'....        BL       HAL_GPIO_Init
     99          
    100            GPIO_InitStructure.Pin = EEPROM_SPI_MOSI_PIN;
   \       0x74   0x2080             MOVS     R0,#+128
   \       0x76   0x9000             STR      R0,[SP, #+0]
    101            GPIO_InitStructure.Alternate = EEPROM_SPI_MOSI_AF;
   \       0x78   0x9404             STR      R4,[SP, #+16]
    102            HAL_GPIO_Init(EEPROM_SPI_MOSI_PORT, &GPIO_InitStructure);
   \       0x7A   0x4669             MOV      R1,SP
   \       0x7C   0x0038             MOVS     R0,R7
   \       0x7E   0x....'....        BL       HAL_GPIO_Init
    103          
    104          
    105            /*- Freeze the previous status of Main CS (Maybe it is used by the user) -*/
    106          
    107            GPIO_TypeDef *MainCsEepromPort;
    108            MainCsEepromPort = EEPROM_SPI_CS_PORT;
    109          
    110            /* Store IO Direction in Input Floting Mode */
    111            MainCs_ModerGpioReg = MainCsEepromPort->MODER;
   \       0x82   0x....             LDR      R5,??DataTable13_2
   \       0x84   0x6838             LDR      R0,[R7, #+0]
   \       0x86   0x6628             STR      R0,[R5, #+96]
    112          
    113            /* Store the previous Alternate Function in current IO */
    114            MainCs_AfrGpioReg[0] = MainCsEepromPort->AFR[0] ;
   \       0x88   0x6A38             LDR      R0,[R7, #+32]
   \       0x8A   0x65A8             STR      R0,[R5, #+88]
    115            MainCs_AfrGpioReg[1] = MainCsEepromPort->AFR[1] ;
   \       0x8C   0x6A78             LDR      R0,[R7, #+36]
   \       0x8E   0x65E8             STR      R0,[R5, #+92]
    116          
    117            /* Store the previous value for IO Speed */
    118            MainCs_OspeedrGpioReg = MainCsEepromPort->OSPEEDR;
   \       0x90   0x68B8             LDR      R0,[R7, #+8]
   \       0x92   0x66A8             STR      R0,[R5, #+104]
    119          
    120            /* Store the previous value IO Output Type */
    121            MainCs_OtyperGpioReg = MainCsEepromPort->OTYPER ;
   \       0x94   0x6878             LDR      R0,[R7, #+4]
   \       0x96   0x6668             STR      R0,[R5, #+100]
    122          
    123            /* Store the previous Output Value  */
    124            MainCs_OdrGpioReg = MainCsEepromPort->ODR ;
   \       0x98   0x6978             LDR      R0,[R7, #+20]
   \       0x9A   0x6728             STR      R0,[R5, #+112]
    125          
    126            /* Store the previous Pull-up oand Pull-down value */
    127            MainCs_PupdrGpioReg = MainCsEepromPort->PUPDR;
   \       0x9C   0x68F8             LDR      R0,[R7, #+12]
   \       0x9E   0x66E8             STR      R0,[R5, #+108]
    128            /*--------------------------- GPIO Mode Configuration --------------------*/
    129          
    130            //Chip Select (CS) GPIO Conf
    131            GPIO_InitStructure.Pin = EEPROM_SPI_CS_PIN;
   \       0xA0   0x0270             LSLS     R0,R6,#+9
   \       0xA2   0x9000             STR      R0,[SP, #+0]
    132            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
   \       0xA4   0x9601             STR      R6,[SP, #+4]
    133            HAL_GPIO_Init(EEPROM_SPI_CS_PORT, &GPIO_InitStructure);
   \       0xA6   0x4669             MOV      R1,SP
   \       0xA8   0x0038             MOVS     R0,R7
   \       0xAA   0x....'....        BL       HAL_GPIO_Init
    134          
    135          
    136            /* Configure SPI peripheral */
    137            if(HAL_SPI_GetState(&EepromSpiHandle) == HAL_SPI_STATE_RESET)
   \       0xAE   0x0028             MOVS     R0,R5
   \       0xB0   0x....'....        BL       HAL_SPI_GetState
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD11C             BNE      ??EepromSpiInitialization_0
    138            {
    139              /* Set the SPI parameters */
    140              EepromSpiHandle.Instance               = EEPROM_SPI_PERIPH_NB;
   \       0xB8   0x....             LDR      R0,??DataTable13_3  ;; 0x40013000
   \       0xBA   0x6028             STR      R0,[R5, #+0]
    141              EepromSpiHandle.Init.Mode              = SPI_MODE_MASTER;
   \       0xBC   0x2082             MOVS     R0,#+130
   \       0xBE   0x0040             LSLS     R0,R0,#+1        ;; #+260
   \       0xC0   0x6068             STR      R0,[R5, #+4]
    142              EepromSpiHandle.Init.BaudRatePrescaler = S2LPGetSPIPrescaler();
   \       0xC2   0x....'....        BL       S2LPGetSPIPrescaler
   \       0xC6   0x61E8             STR      R0,[R5, #+28]
    143          
    144              EepromSpiHandle.Init.Direction         = SPI_DIRECTION_2LINES;
   \       0xC8   0x60AC             STR      R4,[R5, #+8]
    145              EepromSpiHandle.Init.CLKPhase          = SPI_PHASE_1EDGE;
   \       0xCA   0x616C             STR      R4,[R5, #+20]
    146              EepromSpiHandle.Init.CLKPolarity       = SPI_POLARITY_LOW;
   \       0xCC   0x612C             STR      R4,[R5, #+16]
    147              EepromSpiHandle.Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLED;
   \       0xCE   0x62AC             STR      R4,[R5, #+40]
    148              EepromSpiHandle.Init.CRCPolynomial     = 7;
   \       0xD0   0x2007             MOVS     R0,#+7
   \       0xD2   0x62E8             STR      R0,[R5, #+44]
    149              EepromSpiHandle.Init.DataSize          = SPI_DATASIZE_8BIT;
   \       0xD4   0x60EC             STR      R4,[R5, #+12]
    150              EepromSpiHandle.Init.FirstBit          = SPI_FIRSTBIT_MSB;
   \       0xD6   0x622C             STR      R4,[R5, #+32]
    151              EepromSpiHandle.Init.NSS               = SPI_NSS_SOFT;
   \       0xD8   0x0270             LSLS     R0,R6,#+9
   \       0xDA   0x61A8             STR      R0,[R5, #+24]
    152              EepromSpiHandle.Init.TIMode            = SPI_TIMODE_DISABLED;
   \       0xDC   0x626C             STR      R4,[R5, #+36]
    153          
    154              if(HAL_SPI_Init(&EepromSpiHandle) != HAL_OK) {
   \       0xDE   0x0028             MOVS     R0,R5
   \       0xE0   0x....'....        BL       HAL_SPI_Init
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD106             BNE      ??EepromSpiInitialization_1
    155                return;
    156              }
    157              __HAL_SPI_ENABLE(&EepromSpiHandle);
   \       0xE8   0x6828             LDR      R0,[R5, #+0]
   \       0xEA   0x6801             LDR      R1,[R0, #+0]
   \       0xEC   0x2240             MOVS     R2,#+64
   \       0xEE   0x430A             ORRS     R2,R2,R1
   \       0xF0   0x6002             STR      R2,[R0, #+0]
    158            }
    159          
    160            EepromSPICSHigh();
   \                     ??EepromSpiInitialization_0: (+1)
   \       0xF2   0x....'....        BL       EepromSPICSHigh
    161          }
   \                     ??EepromSpiInitialization_1: (+1)
   \       0xF6   0xB007             ADD      SP,SP,#+28
   \       0xF8   0xBDF0             POP      {R4-R7,PC}       ;; return
    162          

   \                                 In section .text, align 2, keep-with-next
    163          void EepromCsPinInitialization(void)
    164          {
   \                     EepromCsPinInitialization: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    165            SdkEvalSetDaughterBoardType(FKI_SERIES);
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x....'....        BL       SdkEvalSetDaughterBoardType
    166          
    167            GPIO_InitTypeDef GPIO_InitStructure;
    168            /* Configure SPI pin: CS */
    169            GPIO_InitStructure.Pin = EEPROM_SPI_CS_PIN;
   \        0xA   0x2080             MOVS     R0,#+128
   \        0xC   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \        0xE   0x9001             STR      R0,[SP, #+4]
    170            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
   \       0x10   0x2401             MOVS     R4,#+1
   \       0x12   0x9402             STR      R4,[SP, #+8]
    171            GPIO_InitStructure.Pull = GPIO_PULLUP;
   \       0x14   0x9403             STR      R4,[SP, #+12]
    172            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
   \       0x16   0x2003             MOVS     R0,#+3
   \       0x18   0x9004             STR      R0,[SP, #+16]
    173            HAL_GPIO_Init(EEPROM_SPI_CS_PORT, &GPIO_InitStructure);
   \       0x1A   0xA901             ADD      R1,SP,#+4
   \       0x1C   0x20A0             MOVS     R0,#+160
   \       0x1E   0x05C0             LSLS     R0,R0,#+23       ;; #+1342177280
   \       0x20   0x....'....        BL       HAL_GPIO_Init
    174          
    175            /* Enable CS GPIO clock */
    176            EEPROM_SPI_CS_RCC();
   \       0x24   0x....             LDR      R0,??DataTable13_1  ;; 0x4002102c
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x4321             ORRS     R1,R1,R4
   \       0x2A   0x6001             STR      R1,[R0, #+0]
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \       0x2E   0x4004             ANDS     R4,R4,R0
   \       0x30   0x9400             STR      R4,[SP, #+0]
   \       0x32   0x9800             LDR      R0,[SP, #+0]
    177          
    178            /* Put the SPI chip select high to end the transaction */
    179            EepromSPICSHigh();
   \       0x34   0x....'....        BL       EepromSPICSHigh
    180          }
   \       0x38   0xB006             ADD      SP,SP,#+24
   \       0x3A   0xBD10             POP      {R4,PC}          ;; return
    181          

   \                                 In section .text, align 2, keep-with-next
    182          void EepromCsXnucleoPinInitialization(void)
    183          {
   \                     EepromCsXnucleoPinInitialization: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    184            /*--------------- To Restore the previous statut of CS ----------------*/
    185            GPIO_TypeDef *MainCsEepromPort;
    186            MainCsEepromPort = EEPROM_SPI_CS_PORT;
    187          
    188            /* Store IO Direction in Input Floting Mode */
    189            MainCsEepromPort->MODER = MainCs_ModerGpioReg;
   \        0x4   0x20A0             MOVS     R0,#+160
   \        0x6   0x05C0             LSLS     R0,R0,#+23       ;; #+1342177280
   \        0x8   0x....             LDR      R1,??DataTable13_2
   \        0xA   0x6E0A             LDR      R2,[R1, #+96]
   \        0xC   0x6002             STR      R2,[R0, #+0]
    190          
    191            /* Store the previous Alternate Function in current IO */
    192            MainCsEepromPort->AFR[0] = MainCs_AfrGpioReg[0];
   \        0xE   0x6D8A             LDR      R2,[R1, #+88]
   \       0x10   0x6202             STR      R2,[R0, #+32]
    193            MainCsEepromPort->AFR[1]=  MainCs_AfrGpioReg[1];
   \       0x12   0x6DCA             LDR      R2,[R1, #+92]
   \       0x14   0x6242             STR      R2,[R0, #+36]
    194          
    195            /* Store the previous value for IO Speed */
    196            MainCsEepromPort->OSPEEDR = MainCs_OspeedrGpioReg;
   \       0x16   0x6E8A             LDR      R2,[R1, #+104]
   \       0x18   0x6082             STR      R2,[R0, #+8]
    197          
    198            /* Store the previous value IO Output Type */
    199            MainCsEepromPort->OTYPER = MainCs_OtyperGpioReg;
   \       0x1A   0x6E4A             LDR      R2,[R1, #+100]
   \       0x1C   0x6042             STR      R2,[R0, #+4]
    200          
    201            /* Store the previous Output Value  */
    202            MainCsEepromPort->ODR = MainCs_OdrGpioReg;
   \       0x1E   0x6F0A             LDR      R2,[R1, #+112]
   \       0x20   0x6142             STR      R2,[R0, #+20]
    203          
    204            /* Store the previous Pull-up oand Pull-down value */
    205            MainCsEepromPort->PUPDR = MainCs_PupdrGpioReg;
   \       0x22   0x6EC9             LDR      R1,[R1, #+108]
   \       0x24   0x60C1             STR      R1,[R0, #+12]
    206          
    207            /* It affects EepromSPICSHigh/Low functions */
    208            SdkEvalSetDaughterBoardType(X_NUCLEO_SERIES);
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x....'....        BL       SdkEvalSetDaughterBoardType
    209          
    210            GPIO_InitTypeDef GPIO_InitStructure;
    211          
    212            /* Configure SPI pin: CS */
    213            GPIO_InitStructure.Pin = EEPROM_SPI_XNUCLEO_CS_PIN;
   \       0x2C   0x2010             MOVS     R0,#+16
   \       0x2E   0x9001             STR      R0,[SP, #+4]
    214            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x9002             STR      R0,[SP, #+8]
    215            GPIO_InitStructure.Pull = GPIO_PULLUP;
   \       0x34   0x9003             STR      R0,[SP, #+12]
    216            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
   \       0x36   0x2003             MOVS     R0,#+3
   \       0x38   0x9004             STR      R0,[SP, #+16]
    217            HAL_GPIO_Init(EEPROM_SPI_XNUCLEO_CS_PORT, &GPIO_InitStructure);
   \       0x3A   0xA901             ADD      R1,SP,#+4
   \       0x3C   0x....             LDR      R0,??DataTable13  ;; 0x50000400
   \       0x3E   0x....'....        BL       HAL_GPIO_Init
    218          
    219            EEPROM_SPI_XNUCLEO_CS_RCC();
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0x....             LDR      R1,??DataTable13_1  ;; 0x4002102c
   \       0x46   0x680A             LDR      R2,[R1, #+0]
   \       0x48   0x4302             ORRS     R2,R2,R0
   \       0x4A   0x600A             STR      R2,[R1, #+0]
   \       0x4C   0x6809             LDR      R1,[R1, #+0]
   \       0x4E   0x4008             ANDS     R0,R0,R1
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x9800             LDR      R0,[SP, #+0]
    220          
    221            //Put the SPI chip select high to end the transaction
    222            EepromSPICSHigh();
   \       0x54   0x....'....        BL       EepromSPICSHigh
    223          }
   \       0x58   0xB007             ADD      SP,SP,#+28
   \       0x5A   0xBD00             POP      {PC}             ;; return
    224          

   \                                 In section .text, align 2, keep-with-next
    225          uint8_t EepromRead(uint16_t nAddress, uint8_t cNbBytes, uint8_t* pcBuffer)
    226          {
   \                     EepromRead: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB0C2             SUB      SP,SP,#+264
   \        0x4   0x0003             MOVS     R3,R0
    227            uint8_t cmd[3];
    228            uint8_t dummy[255];
    229            cmd[0] = EEPROM_CMD_READ;
   \        0x6   0xAC01             ADD      R4,SP,#+4
   \        0x8   0x2003             MOVS     R0,#+3
   \        0xA   0x7020             STRB     R0,[R4, #+0]
    230          
    231            for(uint8_t k=0; k<2; k++) {
   \        0xC   0x2500             MOVS     R5,#+0
    232              cmd[k+1] = (uint8_t)(nAddress>>((1-k)*8));
   \                     ??EepromRead_0: (+1)
   \        0xE   0x0018             MOVS     R0,R3
   \       0x10   0x2601             MOVS     R6,#+1
   \       0x12   0x1B76             SUBS     R6,R6,R5
   \       0x14   0x00F6             LSLS     R6,R6,#+3
   \       0x16   0x40F0             LSRS     R0,R0,R6
   \       0x18   0x1966             ADDS     R6,R4,R5
   \       0x1A   0x7070             STRB     R0,[R6, #+1]
    233            }
   \       0x1C   0x1C6D             ADDS     R5,R5,#+1
   \       0x1E   0x2D01             CMP      R5,#+1
   \       0x20   0xDDF5             BLE      ??EepromRead_0
   \       0x22   0x0016             MOVS     R6,R2
   \       0x24   0x000F             MOVS     R7,R1
    234          
    235            /* Wait the end of a previous write operation */
    236            EepromWaitEndWriteOperation();
   \       0x26   0x....'....        BL       EepromWaitEndWriteOperation
    237          
    238            /* Put the SPI chip select low to start the transaction */
    239            EepromSPICSLow();
   \       0x2A   0x....'....        BL       EepromSPICSLow
    240          
    241            /* Write the header bytes and read the status bytes */
    242            HAL_SPI_TransmitReceive(&EepromSpiHandle, cmd, dummy, 3, 1000);
   \       0x2E   0x....             LDR      R5,??DataTable13_2
   \       0x30   0x24FA             MOVS     R4,#+250
   \       0x32   0x00A4             LSLS     R4,R4,#+2        ;; #+1000
   \       0x34   0x9400             STR      R4,[SP, #+0]
   \       0x36   0x2303             MOVS     R3,#+3
   \       0x38   0xAA02             ADD      R2,SP,#+8
   \       0x3A   0xA901             ADD      R1,SP,#+4
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x....'....        BL       HAL_SPI_TransmitReceive
    243          
    244            /* Read the registers according to the number of bytes */
    245            HAL_SPI_TransmitReceive(&EepromSpiHandle, dummy, pcBuffer, cNbBytes, 1000);
   \       0x42   0x9400             STR      R4,[SP, #+0]
   \       0x44   0x003B             MOVS     R3,R7
   \       0x46   0x0032             MOVS     R2,R6
   \       0x48   0xA902             ADD      R1,SP,#+8
   \       0x4A   0x....             B.N      ?Subroutine0
    246          
    247            /* Put the SPI chip select high to end the transaction */
    248            EepromSPICSHigh();
    249          
    250            return 0;
    251          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x0028             MOVS     R0,R5
   \        0x2   0x....'....        BL       HAL_SPI_TransmitReceive
   \        0x6   0x....'....        BL       EepromSPICSHigh
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xB043             ADD      SP,SP,#+268
   \        0xE   0xBDF0             POP      {R4-R7,PC}       ;; return
    252          

   \                                 In section .text, align 2, keep-with-next
    253          void EepromWaitEndWriteOperation(void)
    254          {
   \                     EepromWaitEndWriteOperation: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    255            uint8_t cmd = EEPROM_CMD_RDSR;
   \        0x2   0x2005             MOVS     R0,#+5
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x7188             STRB     R0,[R1, #+6]
    256            uint8_t dummy = 0xFF;
   \        0x8   0x20FF             MOVS     R0,#+255
   \        0xA   0x7148             STRB     R0,[R1, #+5]
    257            uint8_t status;
    258          
    259            /* Put the SPI chip select low to start the transaction */
    260            EepromSPICSLow();
   \        0xC   0x....'....        BL       EepromSPICSLow
    261          
    262            /* Send command */
    263            HAL_SPI_TransmitReceive(&EepromSpiHandle, &cmd, &status, 1, 1000);
   \       0x10   0x....             LDR      R5,??DataTable13_2
   \       0x12   0x24FA             MOVS     R4,#+250
   \       0x14   0x00A4             LSLS     R4,R4,#+2        ;; #+1000
   \       0x16   0x9400             STR      R4,[SP, #+0]
   \       0x18   0x2301             MOVS     R3,#+1
   \       0x1A   0xAA01             ADD      R2,SP,#+4
   \       0x1C   0xA901             ADD      R1,SP,#+4
   \       0x1E   0x1C89             ADDS     R1,R1,#+2
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x....'....        BL       HAL_SPI_TransmitReceive
    264          
    265            /* Polling on status register */
    266            do{
    267              HAL_SPI_TransmitReceive(&EepromSpiHandle, &dummy, &status, 1, 1000);
   \                     ??EepromWaitEndWriteOperation_0: (+1)
   \       0x26   0x9400             STR      R4,[SP, #+0]
   \       0x28   0x2301             MOVS     R3,#+1
   \       0x2A   0xAA01             ADD      R2,SP,#+4
   \       0x2C   0xA901             ADD      R1,SP,#+4
   \       0x2E   0x1C49             ADDS     R1,R1,#+1
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x....'....        BL       HAL_SPI_TransmitReceive
    268            }while(status&EEPROM_STATUS_WIP);
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x7900             LDRB     R0,[R0, #+4]
   \       0x3A   0x07C0             LSLS     R0,R0,#+31
   \       0x3C   0xD4F3             BMI      ??EepromWaitEndWriteOperation_0
    269          
    270            /* Put the SPI chip select high to end the transaction */
    271            EepromSPICSHigh();
   \       0x3E   0x....'....        BL       EepromSPICSHigh
    272          
    273          }
   \       0x42   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    274          

   \                                 In section .text, align 2, keep-with-next
    275          void EepromWriteEnable(void)
    276          {
   \                     EepromWriteEnable: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    277            uint8_t cmd = EEPROM_CMD_WREN;
   \        0x2   0x2006             MOVS     R0,#+6
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x7148             STRB     R0,[R1, #+5]
    278            uint8_t status;
    279          
    280            /* Put the SPI chip select low to start the transaction */
    281            EepromSPICSLow();
   \        0x8   0x....'....        BL       EepromSPICSLow
    282            /* Send command */
    283            HAL_SPI_TransmitReceive(&EepromSpiHandle, &cmd, &status, 1, 1000);
   \        0xC   0x20FA             MOVS     R0,#+250
   \        0xE   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \       0x10   0x9000             STR      R0,[SP, #+0]
   \       0x12   0x2301             MOVS     R3,#+1
   \       0x14   0xAA01             ADD      R2,SP,#+4
   \       0x16   0xA901             ADD      R1,SP,#+4
   \       0x18   0x1C49             ADDS     R1,R1,#+1
   \       0x1A   0x....             LDR      R0,??DataTable13_2
   \       0x1C   0x....'....        BL       HAL_SPI_TransmitReceive
    284          
    285            /* Put the SPI chip select high to end the transaction */
    286            EepromSPICSHigh();
   \       0x20   0x....'....        BL       EepromSPICSHigh
    287          }
   \       0x24   0xBD07             POP      {R0-R2,PC}       ;; return
    288          

   \                                 In section .text, align 2, keep-with-next
    289          uint8_t EepromWrite(uint16_t nAddress, uint8_t cNbBytes, uint8_t* pcBuffer)
    290          {
   \                     EepromWrite: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB0C2             SUB      SP,SP,#+264
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
    291            uint8_t cmd = EEPROM_CMD_WRITE, tmp[255];
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0x4669             MOV      R1,SP
   \        0xE   0x7188             STRB     R0,[R1, #+6]
    292            uint8_t address[2];
    293          
    294            /* Wait the end of a previous write operation */
    295            EepromWaitEndWriteOperation();
   \       0x10   0x....'....        BL       EepromWaitEndWriteOperation
    296          
    297            /* SET the WREN flag */
    298            EepromWriteEnable();
   \       0x14   0x....'....        BL       EepromWriteEnable
    299          
    300            for(uint8_t k=0; k<2; k++) {
   \       0x18   0x2100             MOVS     R1,#+0
    301              address[k] = (uint8_t)(nAddress>>((1-k)*8));
   \                     ??EepromWrite_0: (+1)
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x2201             MOVS     R2,#+1
   \       0x1E   0x1A52             SUBS     R2,R2,R1
   \       0x20   0x00D2             LSLS     R2,R2,#+3
   \       0x22   0x40D0             LSRS     R0,R0,R2
   \       0x24   0xAA01             ADD      R2,SP,#+4
   \       0x26   0x5450             STRB     R0,[R2, R1]
    302            }
   \       0x28   0x1C49             ADDS     R1,R1,#+1
   \       0x2A   0x2901             CMP      R1,#+1
   \       0x2C   0xDDF5             BLE      ??EepromWrite_0
    303            //EepromWaitEndWriteOperation();
    304          
    305            /* Put the SPI chip select low to start the transaction */
    306            EepromSPICSLow();
   \       0x2E   0x....'....        BL       EepromSPICSLow
    307          
    308            /* Write the header bytes and read the SPIRIT status bytes */
    309            HAL_SPI_TransmitReceive(&EepromSpiHandle, &cmd, tmp, 1, 1000);
   \       0x32   0x....             LDR      R5,??DataTable13_2
   \       0x34   0x24FA             MOVS     R4,#+250
   \       0x36   0x00A4             LSLS     R4,R4,#+2        ;; #+1000
   \       0x38   0x9400             STR      R4,[SP, #+0]
   \       0x3A   0x2301             MOVS     R3,#+1
   \       0x3C   0xAA02             ADD      R2,SP,#+8
   \       0x3E   0xA901             ADD      R1,SP,#+4
   \       0x40   0x1C89             ADDS     R1,R1,#+2
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0x....'....        BL       HAL_SPI_TransmitReceive
    310          
    311            HAL_SPI_TransmitReceive(&EepromSpiHandle, address, tmp, 2, 1000);
   \       0x48   0x9400             STR      R4,[SP, #+0]
   \       0x4A   0x2302             MOVS     R3,#+2
   \       0x4C   0xAA02             ADD      R2,SP,#+8
   \       0x4E   0xA901             ADD      R1,SP,#+4
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0x....'....        BL       HAL_SPI_TransmitReceive
    312          
    313            HAL_SPI_TransmitReceive(&EepromSpiHandle, pcBuffer, tmp, cNbBytes, 1000);
   \       0x56   0x9400             STR      R4,[SP, #+0]
   \       0x58   0x0033             MOVS     R3,R6
   \       0x5A   0xAA02             ADD      R2,SP,#+8
   \       0x5C   0x0039             MOVS     R1,R7
   \       0x5E                      REQUIRE ?Subroutine0
   \       0x5E                      ;; // Fall through to label ?Subroutine0
    314          
    315            /* Put the SPI chip select high to end the transaction */
    316            EepromSPICSHigh();
    317          
    318            return 0;
    319          }
    320          

   \                                 In section .text, align 4, keep-with-next
    321          uint8_t EepromStatus(void)
    322          {
   \                     EepromStatus: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    323            uint8_t status[2];
    324            uint8_t cmd[] = {EEPROM_CMD_RDSR, 0xFF};
   \        0x2   0xA801             ADD      R0,SP,#+4
   \        0x4   0x1C80             ADDS     R0,R0,#+2
   \        0x6   0xBF00             Nop
   \        0x8   0x....             ADR.N    R1,?_0
   \        0xA   0x....             B.N      ?Subroutine1
    325          
    326            /* Put the SPI chip select low to start the transaction */
    327            EepromSPICSLow();
    328          
    329            /* Send command */
    330            HAL_SPI_TransmitReceive(&EepromSpiHandle, cmd, status, 2, 1000);
    331          
    332            /* Put the SPI chip select high to end the transaction */
    333            EepromSPICSHigh();
    334          
    335            return status[1];
    336          
    337          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x880A             LDRH     R2,[R1, #0]
   \        0x2   0x8002             STRH     R2,[R0, #0]
   \        0x4   0x....'....        BL       EepromSPICSLow
   \        0x8   0x20FA             MOVS     R0,#+250
   \        0xA   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \        0xC   0x9000             STR      R0,[SP, #+0]
   \        0xE   0x2302             MOVS     R3,#+2
   \       0x10   0xAA01             ADD      R2,SP,#+4
   \       0x12   0xA901             ADD      R1,SP,#+4
   \       0x14   0x1C89             ADDS     R1,R1,#+2
   \       0x16   0x....             LDR      R0,??DataTable13_2
   \       0x18   0x....'....        BL       HAL_SPI_TransmitReceive
   \       0x1C   0x....'....        BL       EepromSPICSHigh
   \       0x20   0xA801             ADD      R0,SP,#+4
   \       0x22   0x7840             LDRB     R0,[R0, #+1]
   \       0x24   0xBD0E             POP      {R1-R3,PC}       ;; return
    338          

   \                                 In section .text, align 4, keep-with-next
    339          uint8_t EepromSetSrwd(void)
    340          {
   \                     EepromSetSrwd: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    341            uint8_t status[2];
    342            uint8_t cmd[] = {EEPROM_CMD_WRSR, EEPROM_STATUS_SRWD};
   \        0x2   0xA801             ADD      R0,SP,#+4
   \        0x4   0x1C80             ADDS     R0,R0,#+2
   \        0x6   0xBF00             Nop
   \        0x8   0x....             ADR.N    R1,?_1
   \        0xA                      REQUIRE ?Subroutine1
   \        0xA                      ;; // Fall through to label ?Subroutine1
    343          
    344            /* Put the SPI chip select low to start the transaction */
    345            EepromSPICSLow();
    346          
    347            /* Send command */
    348            HAL_SPI_TransmitReceive(&EepromSpiHandle, cmd, status, 2, 1000);
    349          
    350            /* Put the SPI chip select high to end the transaction */
    351            EepromSPICSHigh();
    352          
    353          
    354            return status[1];
    355          }
    356          

   \                                 In section .text, align 2, keep-with-next
    357          uint8_t S2LPEvalGetHasEeprom(void)
    358          {
    359          #if EEPROM_PRESENT == EEPROM_YES
    360            return s_eeprom;
   \                     S2LPEvalGetHasEeprom: (+1)
   \        0x0   0x....             LDR      R0,??DataTable13_4
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    361          #else
    362            return 0;
    363          #endif
    364          }
    365          

   \                                 In section .text, align 2, keep-with-next
    366          void S2LPEvalSetHasEeprom(uint8_t eeprom)
    367          {
    368          #if EEPROM_PRESENT == EEPROM_YES
    369            s_eeprom = eeprom;
   \                     S2LPEvalSetHasEeprom: (+1)
   \        0x0   0x....             LDR      R1,??DataTable13_4
   \        0x2   0x7008             STRB     R0,[R1, #+0]
    370          #else
    371            s_eeprom = 0;
    372          #endif
    373          }
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x5000'0400        DC32     0x50000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x4002'102C        DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     EepromSpiHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x4001'3000        DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x....'....        DC32     s_eeprom

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x05 0xFF          DC8 5, 255

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x01 0x80          DC8 1, 128
    374          
    375          
    376          /**
    377          * @}
    378          */
    379          
    380          /**
    381          * @}
    382          */
    383          
    384          /******************* (C) COPYRIGHT 2020 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   EepromCsPinInitialization
        32   -> EepromSPICSHigh
        32   -> HAL_GPIO_Init
        32   -> SdkEvalSetDaughterBoardType
      32   EepromCsXnucleoPinInitialization
        32   -> EepromSPICSHigh
        32   -> HAL_GPIO_Init
        32   -> SdkEvalSetDaughterBoardType
     288   EepromRead
       288   -> EepromSPICSHigh
       288   -> EepromSPICSLow
       288   -> EepromWaitEndWriteOperation
       288   -> HAL_SPI_TransmitReceive
       8   EepromSPICSHigh
         8   -> HAL_GPIO_WritePin
         8   -> SdkEvalGetDaughterBoardType
       8   EepromSPICSLow
         8   -> HAL_GPIO_WritePin
         8   -> SdkEvalGetDaughterBoardType
      16   EepromSetSrwd
        16   -> EepromSPICSHigh
        16   -> EepromSPICSLow
        16   -> HAL_SPI_TransmitReceive
      48   EepromSpiInitialization
        48   -> EepromSPICSHigh
        48   -> HAL_GPIO_Init
        48   -> HAL_SPI_GetState
        48   -> HAL_SPI_Init
        48   -> S2LPGetSPIPrescaler
      16   EepromStatus
        16   -> EepromSPICSHigh
        16   -> EepromSPICSLow
        16   -> HAL_SPI_TransmitReceive
      24   EepromWaitEndWriteOperation
        24   -> EepromSPICSHigh
        24   -> EepromSPICSLow
        24   -> HAL_SPI_TransmitReceive
     288   EepromWrite
       288   -> EepromSPICSHigh
       288   -> EepromSPICSLow
       288   -> EepromWaitEndWriteOperation
       288   -> EepromWriteEnable
       288   -> HAL_SPI_TransmitReceive
      16   EepromWriteEnable
        16   -> EepromSPICSHigh
        16   -> EepromSPICSLow
        16   -> HAL_SPI_TransmitReceive
       0   S2LPEvalGetHasEeprom
       0   S2LPEvalSetHasEeprom


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
      16  ?Subroutine0
      38  ?Subroutine1
       2  ?_0
       2  ?_1
      60  EepromCsPinInitialization
      92  EepromCsXnucleoPinInitialization
      76  EepromRead
      32  EepromSPICSHigh
      34  EepromSPICSLow
      10  EepromSetSrwd
     116  EepromSpiHandle
          MainCs_AfrGpioReg
          MainCs_ModerGpioReg
          MainCs_OtyperGpioReg
          MainCs_OspeedrGpioReg
          MainCs_PupdrGpioReg
          MainCs_OdrGpioReg
     250  EepromSpiInitialization
      12  EepromStatus
      68  EepromWaitEndWriteOperation
      94  EepromWrite
      38  EepromWriteEnable
       6  S2LPEvalGetHasEeprom
       6  S2LPEvalSetHasEeprom
       1  s_eeprom

 
 117 bytes in section .bss
 856 bytes in section .text
 
 856 bytes of CODE memory
 117 bytes of DATA memory

Errors: none
Warnings: none
