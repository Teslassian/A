###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  12:25:22
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW6882.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal.c
      4            * @author  MCD Application Team
      5            * @brief   HAL module driver.
      6            *          This is the common part of the HAL initialization
      7            *
      8            @verbatim
      9            ==============================================================================
     10                               ##### How to use this driver #####
     11            ==============================================================================
     12              [..]
     13              The common HAL driver contains a set of generic and common APIs that can be
     14              used by the PPP peripheral drivers and the user to start using the HAL.
     15              [..]
     16              The HAL contains two APIs categories:
     17                   (+) Common HAL APIs
     18                   (+) Services HAL APIs
     19          
     20            @endverbatim
     21            ******************************************************************************
     22            * @attention
     23            *
     24            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     25            * All rights reserved.</center></h2>
     26            *
     27            * This software component is licensed by ST under BSD 3-Clause license,
     28            * the "License"; You may not use this file except in compliance with the
     29            * License. You may obtain a copy of the License at:
     30            *                        opensource.org/licenses/BSD-3-Clause
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "stm32l0xx_hal.h"
     37          
     38          /** @addtogroup STM32L0xx_HAL_Driver
     39            * @{
     40            */
     41          
     42          #ifdef HAL_MODULE_ENABLED
     43          
     44          /** @addtogroup HAL
     45            * @brief HAL module driver.
     46            * @{
     47            */
     48          
     49          /** @addtogroup HAL_Exported_Constants
     50            * @{
     51            */
     52          
     53          /** @defgroup HAL_Version HAL Version
     54            * @{
     55            */
     56          
     57          /**
     58           * @brief STM32L0xx HAL Driver version number
     59           */
     60          #define __STM32L0xx_HAL_VERSION_MAIN   (0x01U) /*!< [31:24] main version */
     61          #define __STM32L0xx_HAL_VERSION_SUB1   (0x0AU) /*!< [23:16] sub1 version */
     62          #define __STM32L0xx_HAL_VERSION_SUB2   (0x02U) /*!< [15:8]  sub2 version */
     63          #define __STM32L0xx_HAL_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */
     64          #define __STM32L0xx_HAL_VERSION         ((__STM32L0xx_HAL_VERSION_MAIN << 24U)\
     65                                                  |(__STM32L0xx_HAL_VERSION_SUB1 << 16U)\
     66                                                  |(__STM32L0xx_HAL_VERSION_SUB2 << 8U )\
     67                                                  |(__STM32L0xx_HAL_VERSION_RC))
     68          
     69          #define IDCODE_DEVID_MASK    ((uint32_t)0x00000FFFU)
     70          
     71          /**
     72            * @}
     73            */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /* Exported variables --------------------------------------------------------*/
     80          /** @addtogroup HAL_Exported_Variables
     81            * @{
     82            */

   \                                 In section .bss, align 4
     83          __IO uint32_t uwTick;
   \                     uwTick:
   \        0x0                      DS8 4
     84          /**
     85            * @}
     86            */
     87          
     88          /* Exported functions --------------------------------------------------------*/
     89          /** @addtogroup HAL_Exported_Functions
     90            * @{
     91            */
     92          
     93          /** @addtogroup HAL_Exported_Functions_Group1
     94           *  @brief    Initialization and de-initialization functions
     95           *
     96          @verbatim
     97           ===============================================================================
     98                        ##### Initialization and de-initialization functions #####
     99           ===============================================================================
    100             [..]  This section provides functions allowing to:
    101                (+) Initialize the Flash interface, the NVIC allocation and initial clock
    102                    configuration. It initializes the source of time base also when timeout
    103                    is needed and the backup domain when enabled.
    104                (+) De-initialize common part of the HAL.
    105                (+) Configure the time base source to have 1ms time base with a dedicated
    106                    Tick interrupt priority.
    107                  (++) SysTick timer is used by default as source of time base, but user
    108                       can eventually implement his proper time base source (a general purpose
    109                       timer for example or other time source), keeping in mind that Time base
    110                       duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
    111                       handled in milliseconds basis.
    112                  (++) Time base configuration function (HAL_InitTick ()) is called automatically
    113                       at the beginning of the program after reset by HAL_Init() or at any time
    114                       when clock is configured, by HAL_RCC_ClockConfig().
    115                  (++) Source of time base is configured  to generate interrupts at regular
    116                       time intervals. Care must be taken if HAL_Delay() is called from a
    117                       peripheral ISR process, the Tick interrupt line must have higher priority
    118                      (numerically lower) than the peripheral interrupt. Otherwise the caller
    119                      ISR process will be blocked.
    120                 (++) functions affecting time base configurations are declared as __weak
    121                       to make  override possible  in case of other  implementations in user file.
    122          
    123          @endverbatim
    124            * @{
    125            */
    126          
    127          /**
    128            * @brief This function configures the Flash prefetch, Flash preread and Buffer cache,
    129            *        Configures time base source, NVIC and Low level hardware
    130            * @note This function is called at the beginning of program after reset and before
    131            *       the clock configuration
    132            * @note The time base configuration is based on MSI clock when exiting from Reset.
    133            *       Once done, time base tick start incrementing.
    134            *        In the default implementation,Systick is used as source of time base.
    135            *        the tick variable is incremented each 1ms in its ISR.
    136            * @retval HAL status
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          HAL_StatusTypeDef HAL_Init(void)
    139          {
   \                     HAL_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    140            HAL_StatusTypeDef  status = HAL_OK;
   \        0x2   0x2400             MOVS     R4,#+0
    141          
    142            /* Configure Buffer cache, Flash prefetch,  Flash preread */
    143          #if (BUFFER_CACHE_DISABLE != 0)
    144            __HAL_FLASH_BUFFER_CACHE_DISABLE();
    145          #endif /* BUFFER_CACHE_DISABLE */
    146          
    147          #if (PREREAD_ENABLE != 0)
    148            __HAL_FLASH_PREREAD_BUFFER_ENABLE();
   \        0x4   0x....             LDR      R0,??DataTable19  ;; 0x40022000
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x2240             MOVS     R2,#+64
   \        0xA   0x430A             ORRS     R2,R2,R1
   \        0xC   0x6002             STR      R2,[R0, #+0]
    149          #endif /* PREREAD_ENABLE */
    150          
    151          #if (PREFETCH_ENABLE != 0)
    152            __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x2202             MOVS     R2,#+2
   \       0x12   0x430A             ORRS     R2,R2,R1
   \       0x14   0x6002             STR      R2,[R0, #+0]
    153          #endif /* PREFETCH_ENABLE */
    154          
    155            /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
    156            if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
   \       0x16   0x2003             MOVS     R0,#+3
   \       0x18   0x....'....        BL       HAL_InitTick
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ      ??HAL_Init_0
    157            {
    158              status = HAL_ERROR;
   \       0x20   0x2401             MOVS     R4,#+1
   \       0x22   0xE001             B        ??HAL_Init_1
    159            }
    160            else
    161            {
    162              /* Init the low level hardware */
    163              HAL_MspInit();
   \                     ??HAL_Init_0: (+1)
   \       0x24   0x....'....        BL       HAL_MspInit
    164            }
    165          
    166            /* Return function status */
    167            return status;
   \                     ??HAL_Init_1: (+1)
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0xBD10             POP      {R4,PC}          ;; return
    168          }
    169          
    170          /**
    171            * @brief This function de-initializes common part of the HAL and stops the source
    172            *        of time base.
    173            * @note This function is optional.
    174            * @retval HAL status
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          HAL_StatusTypeDef HAL_DeInit(void)
    177          {
   \                     HAL_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    178            /* Reset of all peripherals */
    179            __HAL_RCC_APB1_FORCE_RESET();
   \        0x2   0x....             LDR      R0,??DataTable19_1  ;; 0x4002101c
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x43C9             MVNS     R1,R1            ;; #-1
   \        0x8   0x60C1             STR      R1,[R0, #+12]
    180            __HAL_RCC_APB1_RELEASE_RESET();
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x60C2             STR      R2,[R0, #+12]
    181          
    182            __HAL_RCC_APB2_FORCE_RESET();
   \        0xE   0x6081             STR      R1,[R0, #+8]
    183            __HAL_RCC_APB2_RELEASE_RESET();
   \       0x10   0x6082             STR      R2,[R0, #+8]
    184          
    185            __HAL_RCC_AHB_FORCE_RESET();
   \       0x12   0x6041             STR      R1,[R0, #+4]
    186            __HAL_RCC_AHB_RELEASE_RESET();
   \       0x14   0x6042             STR      R2,[R0, #+4]
    187          
    188            __HAL_RCC_IOP_FORCE_RESET();
   \       0x16   0x6001             STR      R1,[R0, #+0]
    189            __HAL_RCC_IOP_RELEASE_RESET();
   \       0x18   0x6002             STR      R2,[R0, #+0]
    190          
    191            /* De-Init the low level hardware */
    192            HAL_MspDeInit();
   \       0x1A   0x....'....        BL       HAL_MspDeInit
    193          
    194            /* Return function status */
    195            return HAL_OK;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD02             POP      {R1,PC}          ;; return
    196          }
    197          
    198          /**
    199            * @brief  Initializes the MSP.
    200            * @retval None
    201            */

   \                                 In section .text, align 2
    202          __weak void HAL_MspInit(void)
    203          {
    204            /* NOTE : This function should not be modified, when the callback is needed,
    205                      the HAL_MspInit could be implemented in the user file
    206             */
    207          }
   \                     HAL_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    208          
    209          /**
    210            * @brief  DeInitializes the MSP.
    211            * @retval None
    212            */

   \                                 In section .text, align 2
    213          __weak void HAL_MspDeInit(void)
    214          {
    215            /* NOTE : This function should not be modified, when the callback is needed,
    216                      the HAL_MspDeInit could be implemented in the user file
    217             */
    218          }
   \                     HAL_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    219          
    220          /**
    221            * @brief This function configures the source of the time base:
    222            *        The time source is configured to have 1ms time base with a dedicated
    223            *        Tick interrupt priority.
    224            * @note This function is called  automatically at the beginning of program after
    225            *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().
    226            * @note In the default implementation, SysTick timer is the source of time base.
    227            *       It is used to generate interrupts at regular time intervals.
    228            *       Care must be taken if HAL_Delay() is called from a peripheral ISR process,
    229            *       The SysTick interrupt must have higher priority (numerically lower)
    230            *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.
    231            *       The function is declared as __weak  to be overwritten  in case of other
    232            *       implementation  in user file.
    233            * @param TickPriority Tick interrupt priority.
    234            * @retval HAL status
    235            */

   \                                 In section .text, align 4
    236          __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
    237          {
   \                     HAL_InitTick: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
    238            HAL_StatusTypeDef  status = HAL_OK;
   \        0x4   0x2400             MOVS     R4,#+0
    239          
    240            /*Configure the SysTick to have interrupt in 1ms time basis*/
    241            if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
   \        0x6   0x480A             LDR      R0,??HAL_InitTick_0
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x21FA             MOVS     R1,#+250
   \        0xC   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \        0xE   0x....'....        BL       __aeabi_uidiv
   \       0x12   0x....'....        BL       HAL_SYSTICK_Config
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ      ??HAL_InitTick_1
    242            {
    243              status = HAL_ERROR;
   \       0x1A   0x2401             MOVS     R4,#+1
   \       0x1C   0xE005             B        ??HAL_InitTick_2
    244            }
   \                     ??HAL_InitTick_1: (+1)
   \       0x1E   0x0029             MOVS     R1,R5
    245            else
    246            {
    247              /*Configure the SysTick IRQ priority */
    248              HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x26   0x....'....        BL       HAL_NVIC_SetPriority
    249            }
    250          
    251            /* Return function status */
    252            return status;
   \                     ??HAL_InitTick_2: (+1)
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \       0x2E   0xBF00             Nop
   \                     ??HAL_InitTick_0:
   \       0x30   0x....'....        DC32     SystemCoreClock
    253          }
    254          
    255          /**
    256            * @}
    257            */
    258          
    259          /** @addtogroup HAL_Exported_Functions_Group2
    260           *  @brief    HAL Control functions
    261           *
    262          @verbatim
    263           ===============================================================================
    264                                ##### HAL Control functions #####
    265           ===============================================================================
    266              [..]  This section provides functions allowing to:
    267                (+) Provide a tick value in millisecond
    268                (+) Provide a blocking delay in millisecond
    269                (+) Suspend the time base source interrupt
    270                (+) Resume the time base source interrupt
    271                (+) Get the HAL API driver version
    272                (+) Get the device identifier
    273                (+) Get the device revision identifier
    274          
    275          @endverbatim
    276            * @{
    277            */
    278          
    279          /**
    280            * @brief This function is called to increment a global variable "uwTick"
    281            *        used as application time base.
    282            * @note In the default implementation, this variable is incremented each 1ms
    283            *       in SysTick ISR.
    284           * @note This function is declared as __weak to be overwritten in case of other
    285            *      implementations in user file.
    286            * @retval None
    287            */

   \                                 In section .text, align 4
    288          __weak void HAL_IncTick(void)
    289          {
    290            uwTick++;
   \                     HAL_IncTick: (+1)
   \        0x0   0x4802             LDR      R0,??HAL_IncTick_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   \        0x6   0x6001             STR      R1,[R0, #+0]
    291          }
   \        0x8   0x4770             BX       LR               ;; return
   \        0xA   0xBF00             Nop
   \                     ??HAL_IncTick_0:
   \        0xC   0x....'....        DC32     uwTick
    292          
    293          /**
    294            * @brief Provides a tick value in millisecond.
    295            * @note This function is declared as __weak to be overwritten in case of other
    296            *       implementations in user file.
    297            * @retval tick value
    298            */

   \                                 In section .text, align 4
    299          __weak uint32_t HAL_GetTick(void)
    300          {
    301            return uwTick;
   \                     HAL_GetTick: (+1)
   \        0x0   0x4801             LDR      R0,??HAL_GetTick_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop
   \                     ??HAL_GetTick_0:
   \        0x8   0x....'....        DC32     uwTick
    302          }
    303          
    304          /**
    305            * @brief This function provides minimum delay (in milliseconds) based
    306            *        on variable incremented.
    307            * @note In the default implementation , SysTick timer is the source of time base.
    308            *       It is used to generate interrupts at regular time intervals where uwTick
    309            *       is incremented.
    310            * @note This function is declared as __weak to be overwritten in case of other
    311            *       implementations in user file.
    312            * @param Delay specifies the delay time length, in milliseconds.
    313            * @retval None
    314            */

   \                                 In section .text, align 2
    315          __weak void HAL_Delay(uint32_t Delay)
    316          {
   \                     HAL_Delay: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    317            uint32_t tickstart = HAL_GetTick();
   \        0x4   0x....'....        BL       HAL_GetTick
   \        0x8   0x0005             MOVS     R5,R0
    318            uint32_t wait = Delay;
    319          
    320            /* Add a period to guaranty minimum wait */
    321            if (wait < HAL_MAX_DELAY)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x43C0             MVNS     R0,R0            ;; #-1
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD000             BEQ      ??HAL_Delay_0
    322            {
    323              wait++;
   \       0x12   0x1C64             ADDS     R4,R4,#+1
    324            }
    325          
    326            while((HAL_GetTick() - tickstart) < wait)
   \                     ??HAL_Delay_0: (+1)
   \       0x14   0x....'....        BL       HAL_GetTick
   \       0x18   0x1B40             SUBS     R0,R0,R5
   \       0x1A   0x42A0             CMP      R0,R4
   \       0x1C   0xD3FA             BCC      ??HAL_Delay_0
    327            {
    328            }
    329          }
   \       0x1E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    330          
    331          /**
    332            * @brief Suspends the Tick increment.
    333            * @note In the default implementation , SysTick timer is the source of time base. It is
    334            *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()
    335            *       is called, the SysTick interrupt will be disabled and so Tick increment
    336            *       is suspended.
    337            * @note This function is declared as __weak to be overwritten in case of other
    338            *       implementations in user file.
    339            * @retval None
    340            */

   \                                 In section .text, align 4
    341          __weak void HAL_SuspendTick(void)
    342          {
    343            /* Disable SysTick Interrupt */
    344            SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
   \                     HAL_SuspendTick: (+1)
   \        0x0   0x4802             LDR      R0,??HAL_SuspendTick_0  ;; 0xe000e010
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x4391             BICS     R1,R1,R2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    345          }
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??HAL_SuspendTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    346          
    347          /**
    348            * @brief Resumes the Tick increment.
    349            * @note In the default implementation , SysTick timer is the source of time base. It is
    350            *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()
    351            *       is called, the SysTick interrupt will be enabled and so Tick increment
    352            *       is resumed.
    353            * @note This function is declared as __weak to be overwritten in case of other
    354            *       implementations in user file.
    355            * @retval None
    356            */

   \                                 In section .text, align 4
    357          __weak void HAL_ResumeTick(void)
    358          {
    359            /* Enable SysTick Interrupt */
    360            SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
   \                     HAL_ResumeTick: (+1)
   \        0x0   0x4802             LDR      R0,??HAL_ResumeTick_0  ;; 0xe000e010
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    361          }
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??HAL_ResumeTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    362          
    363          /**
    364            * @brief Returns the HAL revision
    365            * @retval version: 0xXYZR (8bits for each decimal, R for RC)
    366            */

   \                                 In section .text, align 2, keep-with-next
    367          uint32_t HAL_GetHalVersion(void)
    368          {
    369            return __STM32L0xx_HAL_VERSION;
   \                     HAL_GetHalVersion: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_2  ;; 0x10a0200
   \        0x2   0x4770             BX       LR               ;; return
    370          }
    371          
    372          /**
    373            * @brief Returns the device revision identifier.
    374            * @retval Device revision identifier
    375            */

   \                                 In section .text, align 2, keep-with-next
    376          uint32_t HAL_GetREVID(void)
    377          {
    378            return((DBGMCU->IDCODE) >> 16U);
   \                     HAL_GetREVID: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_3  ;; 0x40015800
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0C00             LSRS     R0,R0,#+16
   \        0x6   0x4770             BX       LR               ;; return
    379          }
    380          
    381          /**
    382            * @brief  Returns the device identifier.
    383            * @retval Device identifier
    384            */

   \                                 In section .text, align 2, keep-with-next
    385          uint32_t HAL_GetDEVID(void)
    386          {
    387             return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
   \                     HAL_GetDEVID: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_3  ;; 0x40015800
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0500             LSLS     R0,R0,#+20
   \        0x6   0x0D00             LSRS     R0,R0,#+20
   \        0x8   0x4770             BX       LR               ;; return
    388          }
    389          
    390          /**
    391            * @brief  Returns the first word of the unique device identifier (UID based on 96 bits)
    392            * @retval Device identifier
    393            */

   \                                 In section .text, align 2, keep-with-next
    394          uint32_t HAL_GetUIDw0(void)
    395          {
    396            return(READ_REG(*((uint32_t *)UID_BASE)));
   \                     HAL_GetUIDw0: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_4  ;; 0x1ff80050
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    397          }
    398          
    399          /**
    400            * @brief  Returns the second word of the unique device identifier (UID based on 96 bits)
    401            * @retval Device identifier
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          uint32_t HAL_GetUIDw1(void)
    404          {
    405            return(READ_REG(*((uint32_t *)(UID_BASE + 0x04U))));
   \                     HAL_GetUIDw1: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_5  ;; 0x1ff80054
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    406          }
    407          
    408          /**
    409            * @brief  Returns the third word of the unique device identifier (UID based on 96 bits)
    410            * @retval Device identifier
    411            */

   \                                 In section .text, align 2, keep-with-next
    412          uint32_t HAL_GetUIDw2(void)
    413          {
    414            return(READ_REG(*((uint32_t *)(UID_BASE + 0x14U))));
   \                     HAL_GetUIDw2: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_6  ;; 0x1ff80064
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    415          }
    416          
    417          /**
    418            * @}
    419            */
    420          
    421          /** @addtogroup HAL_Exported_Functions_Group2
    422           *  @brief    HAL Debug functions
    423           *
    424          @verbatim
    425           ===============================================================================
    426                                ##### HAL Debug functions #####
    427           ===============================================================================
    428              [..]  This section provides functions allowing to:
    429                (+) Enable/Disable Debug module during SLEEP mode
    430                (+) Enable/Disable Debug module during STOP mode
    431                (+) Enable/Disable Debug module during STANDBY mode
    432          
    433          @endverbatim
    434            * @{
    435            */
    436          
    437          /**
    438            * @brief  Enables the Debug Module during SLEEP mode
    439            * @retval None
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          void HAL_DBGMCU_EnableDBGSleepMode(void)
    442          {
    443            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
   \                     HAL_DBGMCU_EnableDBGSleepMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_7  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    444          }
   \        0xA   0x4770             BX       LR               ;; return
    445          
    446          /**
    447            * @brief  Disables the Debug Module during SLEEP mode
    448            * @retval None
    449            */

   \                                 In section .text, align 2, keep-with-next
    450          void HAL_DBGMCU_DisableDBGSleepMode(void)
    451          {
    452            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
   \                     HAL_DBGMCU_DisableDBGSleepMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_7  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x4391             BICS     R1,R1,R2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    453          }
   \        0xA   0x4770             BX       LR               ;; return
    454          
    455          /**
    456            * @brief  Enables the Debug Module during STOP mode
    457            * @retval None
    458            */

   \                                 In section .text, align 2, keep-with-next
    459          void HAL_DBGMCU_EnableDBGStopMode(void)
    460          {
    461            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_EnableDBGStopMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_7  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    462          }
   \        0xA   0x4770             BX       LR               ;; return
    463          
    464          /**
    465            * @brief  Disables the Debug Module during STOP mode
    466            * @retval None
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          void HAL_DBGMCU_DisableDBGStopMode(void)
    469          {
    470            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_DisableDBGStopMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_7  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x4391             BICS     R1,R1,R2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    471          }
   \        0xA   0x4770             BX       LR               ;; return
    472          
    473          /**
    474            * @brief  Enables the Debug Module during STANDBY mode
    475            * @retval None
    476            */

   \                                 In section .text, align 2, keep-with-next
    477          void HAL_DBGMCU_EnableDBGStandbyMode(void)
    478          {
    479            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_EnableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_7  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2204             MOVS     R2,#+4
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    480          }
   \        0xA   0x4770             BX       LR               ;; return
    481          
    482          /**
    483            * @brief  Disables the Debug Module during STANDBY mode
    484            * @retval None
    485            */

   \                                 In section .text, align 2, keep-with-next
    486          void HAL_DBGMCU_DisableDBGStandbyMode(void)
    487          {
    488            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_DisableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_7  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2204             MOVS     R2,#+4
   \        0x6   0x4391             BICS     R1,R1,R2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    489          }
   \        0xA   0x4770             BX       LR               ;; return
    490          
    491          /**
    492            * @brief  Enable low power mode behavior when the MCU is in Debug mode.
    493            * @param Periph: specifies the low power mode.
    494            *   This parameter can be any combination of the following values:
    495            *     @arg DBGMCU_SLEEP: Keep debugger connection during SLEEP mode
    496            *     @arg DBGMCU_STOP: Keep debugger connection during STOP mode
    497            *     @arg DBGMCU_STANDBY: Keep debugger connection during STANDBY mode
    498            * @retval None
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          void HAL_DBGMCU_DBG_EnableLowPowerConfig(uint32_t Periph)
    501          {
    502            /* Check the parameters */
    503            assert_param(IS_DBGMCU_PERIPH(Periph));
    504          
    505            DBGMCU->CR |= Periph;
   \                     HAL_DBGMCU_DBG_EnableLowPowerConfig: (+1)
   \        0x0   0x....             LDR      R1,??DataTable19_7  ;; 0x40015804
   \        0x2   0x....             B.N      ?Subroutine0
    506          
    507          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x680A             LDR      R2,[R1, #+0]
   \        0x2   0x4310             ORRS     R0,R0,R2
   \        0x4   0x6008             STR      R0,[R1, #+0]
   \        0x6   0x4770             BX       LR               ;; return
    508          /**
    509            * @brief  Disable low power mode behavior when the MCU is in Debug mode.
    510            * @param Periph: specifies the low power mode.
    511            *   This parameter can be any combination of the following values:
    512            *     @arg DBGMCU_SLEEP: Keep debugger connection during SLEEP mode
    513            *     @arg DBGMCU_STOP: Keep debugger connection during STOP mode
    514            *     @arg DBGMCU_STANDBY: Keep debugger connection during STANDBY mode
    515            * @retval None
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          void HAL_DBGMCU_DBG_DisableLowPowerConfig(uint32_t Periph)
    518          {
    519            /* Check the parameters */
    520            assert_param(IS_DBGMCU_PERIPH(Periph));
    521            {
    522              DBGMCU->CR &= ~Periph;
   \                     HAL_DBGMCU_DBG_DisableLowPowerConfig: (+1)
   \        0x0   0x....             LDR      R1,??DataTable19_7  ;; 0x40015804
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4382             BICS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
    523            }
    524          }
   \        0x8   0x4770             BX       LR               ;; return
    525          
    526          /**
    527            * @}
    528            */
    529          
    530          /** @addtogroup HAL_Exported_Functions_Group3
    531           *  @brief    HAL SYSCFG configuration functions
    532           *
    533          @verbatim
    534           ===============================================================================
    535                                ##### HAL SYSCFG configuration functions #####
    536           ===============================================================================
    537              [..]  This section provides functions allowing to:
    538                (+) Return the boot mode
    539                (+) Select the output of internal reference voltage (VREFINT)
    540                (+) Lock/Unlock the SYSCFG VREF register values
    541          
    542          @endverbatim
    543            * @{
    544            */
    545          
    546          /**
    547            * @brief  Returns the boot mode as configured by user.
    548            * @retval The boot mode as configured by user. The returned value can be one
    549            *         of the following values:
    550            *              - 0x00000000 : Boot is configured in Main Flash memory
    551            *              - 0x00000100 : Boot is configured in System Flash memory
    552            *              - 0x00000300 : Boot is configured in Embedded SRAM memory
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          uint32_t  HAL_SYSCFG_GetBootMode(void)
    555          {
    556            return (SYSCFG->CFGR1 & SYSCFG_CFGR1_BOOT_MODE);
   \                     HAL_SYSCFG_GetBootMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_8  ;; 0x40010000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x20C0             MOVS     R0,#+192
   \        0x6   0x0080             LSLS     R0,R0,#+2        ;; #+768
   \        0x8   0x4008             ANDS     R0,R0,R1
   \        0xA   0x4770             BX       LR               ;; return
    557          }
    558          
    559          /**
    560            * @brief Selects the output of internal reference voltage (VREFINT).
    561            *        The VREFINT output can be routed to(PB0) or
    562            *        (PB1) or both.
    563            * @param SYSCFG_Vrefint_OUTPUT: new state of the Vrefint output.
    564            *        This parameter can be one of the following values:
    565            *     @arg SYSCFG_VREFINT_OUT_NONE
    566            *     @arg SYSCFG_VREFINT_OUT_PB0
    567            *     @arg SYSCFG_VREFINT_OUT_PB1
    568            *     @arg SYSCFG_VREFINT_OUT_PB0_PB1
    569            * @retval None
    570            */

   \                                 In section .text, align 2, keep-with-next
    571          void HAL_SYSCFG_VREFINT_OutputSelect(uint32_t SYSCFG_Vrefint_OUTPUT)
    572          {
    573            /* Check the parameters */
    574            assert_param(IS_SYSCFG_VREFINT_OUT_SELECT(SYSCFG_Vrefint_OUTPUT));
    575          
    576            /* Set the output Vrefint pin */
    577            SYSCFG->CFGR3 &= ~(SYSCFG_CFGR3_VREF_OUT);
   \                     HAL_SYSCFG_VREFINT_OutputSelect: (+1)
   \        0x0   0x....             LDR      R1,??DataTable19_9  ;; 0x40010020
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x2330             MOVS     R3,#+48
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x600A             STR      R2,[R1, #+0]
    578            SYSCFG->CFGR3 |= (uint32_t)(SYSCFG_Vrefint_OUTPUT);
   \        0xA                      REQUIRE ?Subroutine0
   \        0xA                      ;; // Fall through to label ?Subroutine0
    579          }
    580          
    581          /**
    582            * @brief  Lock the SYSCFG VREF register values
    583            * @retval None
    584            */

   \                                 In section .text, align 2, keep-with-next
    585          void HAL_SYSCFG_Enable_Lock_VREFINT(void)
    586          {
    587              /* Enable the LOCK by setting REF_LOCK bit in the CFGR3 register */
    588              SET_BIT(SYSCFG->CFGR3, SYSCFG_CFGR3_REF_LOCK);
   \                     HAL_SYSCFG_Enable_Lock_VREFINT: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_9  ;; 0x40010020
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x0612             LSLS     R2,R2,#+24       ;; #-2147483648
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x6002             STR      R2,[R0, #+0]
    589          }
   \        0xC   0x4770             BX       LR               ;; return
    590          
    591          /**
    592            * @brief  Unlock the overall SYSCFG VREF register values
    593            * @retval None
    594            */

   \                                 In section .text, align 2, keep-with-next
    595          void HAL_SYSCFG_Disable_Lock_VREFINT(void)
    596          {
    597              /* Disable the LOCK by setting REF_LOCK bit in the CFGR3 register */
    598              CLEAR_BIT(SYSCFG->CFGR3, SYSCFG_CFGR3_REF_LOCK);
   \                     HAL_SYSCFG_Disable_Lock_VREFINT: (+1)
   \        0x0   0x....             LDR      R0,??DataTable19_9  ;; 0x40010020
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0049             LSLS     R1,R1,#+1
   \        0x6   0x0849             LSRS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    599          }
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x4002'101C        DC32     0x4002101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x010A'0200        DC32     0x10a0200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0x4001'5800        DC32     0x40015800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \        0x0   0x1FF8'0050        DC32     0x1ff80050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \        0x0   0x1FF8'0054        DC32     0x1ff80054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \        0x0   0x1FF8'0064        DC32     0x1ff80064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \        0x0   0x4001'5804        DC32     0x40015804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \        0x0   0x4001'0020        DC32     0x40010020
    600          
    601          /**
    602            * @}
    603            */
    604          
    605          /**
    606            * @}
    607            */
    608          
    609          /**
    610            * @}
    611            */
    612          #endif /* HAL_MODULE_ENABLED */
    613          /**
    614            * @}
    615            */
    616          
    617          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    618          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_DBGMCU_DBG_DisableLowPowerConfig
       0   HAL_DBGMCU_DBG_EnableLowPowerConfig
       0   HAL_DBGMCU_DisableDBGSleepMode
       0   HAL_DBGMCU_DisableDBGStandbyMode
       0   HAL_DBGMCU_DisableDBGStopMode
       0   HAL_DBGMCU_EnableDBGSleepMode
       0   HAL_DBGMCU_EnableDBGStandbyMode
       0   HAL_DBGMCU_EnableDBGStopMode
       8   HAL_DeInit
         8   -> HAL_MspDeInit
      16   HAL_Delay
        16   -> HAL_GetTick
       0   HAL_GetDEVID
       0   HAL_GetHalVersion
       0   HAL_GetREVID
       0   HAL_GetTick
       0   HAL_GetUIDw0
       0   HAL_GetUIDw1
       0   HAL_GetUIDw2
       0   HAL_IncTick
       8   HAL_Init
         8   -> HAL_InitTick
         8   -> HAL_MspInit
      16   HAL_InitTick
        16   -> HAL_NVIC_SetPriority
        16   -> HAL_SYSTICK_Config
        16 __aeabi_uidiv
       0   HAL_MspDeInit
       0   HAL_MspInit
       0   HAL_ResumeTick
       0   HAL_SYSCFG_Disable_Lock_VREFINT
       0   HAL_SYSCFG_Enable_Lock_VREFINT
       0   HAL_SYSCFG_GetBootMode
       0   HAL_SYSCFG_VREFINT_OutputSelect
       0   HAL_SuspendTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
       8  ?Subroutine0
      10  HAL_DBGMCU_DBG_DisableLowPowerConfig
       4  HAL_DBGMCU_DBG_EnableLowPowerConfig
      12  HAL_DBGMCU_DisableDBGSleepMode
      12  HAL_DBGMCU_DisableDBGStandbyMode
      12  HAL_DBGMCU_DisableDBGStopMode
      12  HAL_DBGMCU_EnableDBGSleepMode
      12  HAL_DBGMCU_EnableDBGStandbyMode
      12  HAL_DBGMCU_EnableDBGStopMode
      34  HAL_DeInit
      32  HAL_Delay
      10  HAL_GetDEVID
       4  HAL_GetHalVersion
       8  HAL_GetREVID
      12  HAL_GetTick
       6  HAL_GetUIDw0
       6  HAL_GetUIDw1
       6  HAL_GetUIDw2
      16  HAL_IncTick
      44  HAL_Init
      52  HAL_InitTick
       2  HAL_MspDeInit
       2  HAL_MspInit
      16  HAL_ResumeTick
      12  HAL_SYSCFG_Disable_Lock_VREFINT
      14  HAL_SYSCFG_Enable_Lock_VREFINT
      12  HAL_SYSCFG_GetBootMode
      10  HAL_SYSCFG_VREFINT_OutputSelect
      16  HAL_SuspendTick
       4  uwTick

 
   4 bytes in section .bss
 448 bytes in section .text
 
 300 bytes of CODE memory (+ 148 bytes shared)
   4 bytes of DATA memory

Errors: none
Warnings: none
