###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         12/Jan/2021  11:53:30
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_spi.c
#    Command line             =
#        -f C:\Users\dvone\AppData\Local\Temp\EW3446.tmp
#        (C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_spi.c
#        -D USE_STM32L0XX_NUCLEO -D USE_HAL_DRIVER -D USE_SYSTICK_DELAY -D
#        STM32L053xx -lC
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List
#        -o
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\Sigfox_Libs\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\ST_API\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\BSP\SDK_Eval_STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\MCU\CMSIS\STM32L0xx\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\S2LP_Middleware\STM32\inc\\
#        -I
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\..\..\..\..\..\Drivers\Utils\STM32\inc\\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.4\arm\CMSIS\Core\Include\\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\CMSIS\DSP\Include\\")
#    Locale                   =  C
#    List file                =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\List\stm32l0xx_hal_spi.lst
#    Object file              =
#        C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Projects_Cube\S2-LP_SigFox_DK\SigfoxDemo\STM32\EWARM\NUCLEO_L0\Obj\stm32l0xx_hal_spi.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\dvone\Desktop\Divigraph\SigfoxDemo\Projects\Drivers\MCU\STM32_HAL\STM32L0xx_HAL_Driver\src\stm32l0xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @brief   SPI HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions
     11            *           + Peripheral State functions
     12            *
     13            @verbatim
     14            ==============================================================================
     15                                  ##### How to use this driver #####
     16            ==============================================================================
     17              [..]
     18                The SPI HAL driver can be used as follows:
     19          
     20                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     21                    SPI_HandleTypeDef  hspi;
     22          
     23                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit() API:
     24                    (##) Enable the SPIx interface clock
     25                    (##) SPI pins configuration
     26                        (+++) Enable the clock for the SPI GPIOs
     27                        (+++) Configure these SPI pins as alternate function push-pull
     28                    (##) NVIC configuration if you need to use interrupt process
     29                        (+++) Configure the SPIx interrupt priority
     30                        (+++) Enable the NVIC SPI IRQ handle
     31                    (##) DMA Configuration if you need to use DMA process
     32                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive Stream/Channel
     33                        (+++) Enable the DMAx clock
     34                        (+++) Configure the DMA handle parameters
     35                        (+++) Configure the DMA Tx or Rx Stream/Channel
     36                        (+++) Associate the initialized hdma_tx(or _rx)  handle to the hspi DMA Tx or Rx handle
     37                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream/Channel
     38          
     39                (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
     40                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     41          
     42                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     43                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     44                        by calling the customized HAL_SPI_MspInit() API.
     45               [..]
     46                 Circular mode restriction:
     47                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     48                    (##) Master 2Lines RxOnly
     49                    (##) Master 1Line Rx
     50                (#) The CRC feature is not managed when the DMA circular mode is enabled
     51                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
     52                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     53               [..]
     54                 Master Receive mode restriction:
     55                (#) In Master unidirectional receive-only mode (MSTR =1, BIDIMODE=0, RXONLY=1) or
     56                    bidirectional receive mode (MSTR=1, BIDIMODE=1, BIDIOE=0), to ensure that the SPI
     57                    does not initiate a new transfer the following procedure has to be respected:
     58                    (##) HAL_SPI_DeInit()
     59                    (##) HAL_SPI_Init()
     60               [..]
     61                 Data buffer address alignment restriction:
     62                (#) In case more than 1 byte is requested to be transferred, the HAL SPI uses 16-bit access for data buffer.
     63                    But there is no support for unaligned accesses on the Cortex-M0 processor.
     64                    So, if the user wants to transfer more than 1 byte, it shall ensure that 16-bit aligned address is used for:
     65                    (##) pData parameter in HAL_SPI_Transmit(), HAL_SPI_Transmit_IT(), HAL_SPI_Receive() and HAL_SPI_Receive_IT()
     66                    (##) pTxData and pRxData parameters in HAL_SPI_TransmitReceive() and HAL_SPI_TransmitReceive_IT()
     67                (#) There is no such restriction when going through DMA by using HAL_SPI_Transmit_DMA(), HAL_SPI_Receive_DMA()
     68                    and HAL_SPI_TransmitReceive_DMA().
     69               [..]
     70                 Callback registration:
     71          
     72                (#) The compilation flag USE_HAL_SPI_REGISTER_CALLBACKS when set to 1U
     73                    allows the user to configure dynamically the driver callbacks.
     74                    Use Functions HAL_SPI_RegisterCallback() to register an interrupt callback.
     75          
     76                    Function HAL_SPI_RegisterCallback() allows to register following callbacks:
     77                      (+) TxCpltCallback        : SPI Tx Completed callback
     78                      (+) RxCpltCallback        : SPI Rx Completed callback
     79                      (+) TxRxCpltCallback      : SPI TxRx Completed callback
     80                      (+) TxHalfCpltCallback    : SPI Tx Half Completed callback
     81                      (+) RxHalfCpltCallback    : SPI Rx Half Completed callback
     82                      (+) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback
     83                      (+) ErrorCallback         : SPI Error callback
     84                      (+) AbortCpltCallback     : SPI Abort callback
     85                      (+) MspInitCallback       : SPI Msp Init callback
     86                      (+) MspDeInitCallback     : SPI Msp DeInit callback
     87                    This function takes as parameters the HAL peripheral handle, the Callback ID
     88                    and a pointer to the user callback function.
     89          
     90          
     91                (#) Use function HAL_SPI_UnRegisterCallback to reset a callback to the default
     92                    weak function.
     93                    HAL_SPI_UnRegisterCallback takes as parameters the HAL peripheral handle,
     94                    and the Callback ID.
     95                    This function allows to reset following callbacks:
     96                      (+) TxCpltCallback        : SPI Tx Completed callback
     97                      (+) RxCpltCallback        : SPI Rx Completed callback
     98                      (+) TxRxCpltCallback      : SPI TxRx Completed callback
     99                      (+) TxHalfCpltCallback    : SPI Tx Half Completed callback
    100                      (+) RxHalfCpltCallback    : SPI Rx Half Completed callback
    101                      (+) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback
    102                      (+) ErrorCallback         : SPI Error callback
    103                      (+) AbortCpltCallback     : SPI Abort callback
    104                      (+) MspInitCallback       : SPI Msp Init callback
    105                      (+) MspDeInitCallback     : SPI Msp DeInit callback
    106          
    107                 By default, after the HAL_SPI_Init() and when the state is HAL_SPI_STATE_RESET
    108                 all callbacks are set to the corresponding weak functions:
    109                 examples HAL_SPI_MasterTxCpltCallback(), HAL_SPI_MasterRxCpltCallback().
    110                 Exception done for MspInit and MspDeInit functions that are
    111                 reset to the legacy weak functions in the HAL_SPI_Init()/ HAL_SPI_DeInit() only when
    112                 these callbacks are null (not registered beforehand).
    113                 If MspInit or MspDeInit are not null, the HAL_SPI_Init()/ HAL_SPI_DeInit()
    114                 keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    115          
    116                 Callbacks can be registered/unregistered in HAL_SPI_STATE_READY state only.
    117                 Exception done MspInit/MspDeInit functions that can be registered/unregistered
    118                 in HAL_SPI_STATE_READY or HAL_SPI_STATE_RESET state,
    119                 thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    120                 Then, the user first registers the MspInit/MspDeInit user callbacks
    121                 using HAL_SPI_RegisterCallback() before calling HAL_SPI_DeInit()
    122                 or HAL_SPI_Init() function.
    123          
    124                 When The compilation define USE_HAL_PPP_REGISTER_CALLBACKS is set to 0 or
    125                 not defined, the callback registering feature is not available
    126                 and weak (surcharged) callbacks are used.
    127          
    128               [..]
    129                 Using the HAL it is not possible to reach all supported SPI frequency with the different SPI Modes,
    130                 the following table resume the max SPI frequency reached with data size 8bits/16bits,
    131                   according to frequency of the APBx Peripheral Clock (fPCLK) used by the SPI instance.
    132          
    133            @endverbatim
    134          
    135            Additional table :
    136          
    137                 DataSize = SPI_DATASIZE_8BIT:
    138                 +----------------------------------------------------------------------------------------------+
    139                 |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
    140                 | Process | Tranfert mode  |---------------------|----------------------|----------------------|
    141                 |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
    142                 |==============================================================================================|
    143                 |    T    |     Polling    | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    144                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    145                 |    /    |     Interrupt  | Fpclk/4  | Fpclk/8  |    NA     |    NA    |    NA     |   NA     |
    146                 |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
    147                 |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    148                 |=========|================|==========|==========|===========|==========|===========|==========|
    149                 |         |     Polling    | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
    150                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    151                 |    R    |     Interrupt  | Fpclk/8  | Fpclk/8  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
    152                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    153                 |         |       DMA      | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/128 | Fpclk/2  |
    154                 |=========|================|==========|==========|===========|==========|===========|==========|
    155                 |         |     Polling    | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
    156                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    157                 |    T    |     Interrupt  | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
    158                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    159                 |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/128|
    160                 +----------------------------------------------------------------------------------------------+
    161          
    162                 DataSize = SPI_DATASIZE_16BIT:
    163                 +----------------------------------------------------------------------------------------------+
    164                 |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
    165                 | Process | Tranfert mode  |---------------------|----------------------|----------------------|
    166                 |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
    167                 |==============================================================================================|
    168                 |    T    |     Polling    | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    169                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    170                 |    /    |     Interrupt  | Fpclk/4  | Fpclk/4  |    NA     |    NA    |    NA     |   NA     |
    171                 |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
    172                 |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    173                 |=========|================|==========|==========|===========|==========|===========|==========|
    174                 |         |     Polling    | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/32  | Fpclk/2  |
    175                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    176                 |    R    |     Interrupt  | Fpclk/4  | Fpclk/4  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
    177                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    178                 |         |       DMA      | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/128 | Fpclk/2  |
    179                 |=========|================|==========|==========|===========|==========|===========|==========|
    180                 |         |     Polling    | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/32 |
    181                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    182                 |    T    |     Interrupt  | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
    183                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    184                 |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/128|
    185                 +----------------------------------------------------------------------------------------------+
    186                 @note The max SPI frequency depend on SPI data size (8bits, 16bits),
    187                       SPI mode(2 Lines fullduplex, 2 lines RxOnly, 1 line TX/RX) and Process mode (Polling, IT, DMA).
    188                 @note
    189                      (#) TX/RX processes are HAL_SPI_TransmitReceive(), HAL_SPI_TransmitReceive_IT() and HAL_SPI_TransmitReceive_DMA()
    190                      (#) RX processes are HAL_SPI_Receive(), HAL_SPI_Receive_IT() and HAL_SPI_Receive_DMA()
    191                      (#) TX processes are HAL_SPI_Transmit(), HAL_SPI_Transmit_IT() and HAL_SPI_Transmit_DMA()
    192          
    193            ******************************************************************************
    194            * @attention
    195            *
    196            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    197            * All rights reserved.</center></h2>
    198            *
    199            * This software component is licensed by ST under BSD 3-Clause license,
    200            * the "License"; You may not use this file except in compliance with the
    201            * License. You may obtain a copy of the License at:
    202            *                        opensource.org/licenses/BSD-3-Clause
    203            *
    204            ******************************************************************************
    205            */
    206          
    207          /* Includes ------------------------------------------------------------------*/
    208          #include "stm32l0xx_hal.h"
    209          
    210          /** @addtogroup STM32L0xx_HAL_Driver
    211            * @{
    212            */
    213          
    214          /** @defgroup SPI SPI
    215            * @brief SPI HAL module driver
    216            * @{
    217            */
    218          #ifdef HAL_SPI_MODULE_ENABLED
    219          
    220          /* Private typedef -----------------------------------------------------------*/
    221          /* Private defines -----------------------------------------------------------*/
    222          /** @defgroup SPI_Private_Constants SPI Private Constants
    223            * @{
    224            */
    225          #define SPI_DEFAULT_TIMEOUT 100U
    226          /**
    227            * @}
    228            */
    229          
    230          /* Private macros ------------------------------------------------------------*/
    231          /* Private variables ---------------------------------------------------------*/
    232          /* Private function prototypes -----------------------------------------------*/
    233          /** @defgroup SPI_Private_Functions SPI Private Functions
    234            * @{
    235            */
    236          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    237          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    238          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    239          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    240          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    241          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    242          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    243          static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    244          static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
    245          static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
    246          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
    247                                                                 uint32_t Timeout, uint32_t Tickstart);
    248          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    249          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    250          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    251          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    252          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    253          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    254          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    255          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    256          #if (USE_SPI_CRC != 0U)
    257          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    258          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    259          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    260          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    261          #endif /* USE_SPI_CRC */
    262          static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi);
    263          static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi);
    264          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi);
    265          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi);
    266          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi);
    267          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart);
    268          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart);
    269          /**
    270            * @}
    271            */
    272          
    273          /* Exported functions --------------------------------------------------------*/
    274          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    275            * @{
    276            */
    277          
    278          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
    279           *  @brief    Initialization and Configuration functions
    280           *
    281          @verbatim
    282           ===============================================================================
    283                        ##### Initialization and de-initialization functions #####
    284           ===============================================================================
    285              [..]  This subsection provides a set of functions allowing to initialize and
    286                    de-initialize the SPIx peripheral:
    287          
    288                (+) User must implement HAL_SPI_MspInit() function in which he configures
    289                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    290          
    291                (+) Call the function HAL_SPI_Init() to configure the selected device with
    292                    the selected configuration:
    293                  (++) Mode
    294                  (++) Direction
    295                  (++) Data Size
    296                  (++) Clock Polarity and Phase
    297                  (++) NSS Management
    298                  (++) BaudRate Prescaler
    299                  (++) FirstBit
    300                  (++) TIMode
    301                  (++) CRC Calculation
    302                  (++) CRC Polynomial if CRC enabled
    303          
    304                (+) Call the function HAL_SPI_DeInit() to restore the default configuration
    305                    of the selected SPIx peripheral.
    306          
    307          @endverbatim
    308            * @{
    309            */
    310          
    311          /**
    312            * @brief  Initialize the SPI according to the specified parameters
    313            *         in the SPI_InitTypeDef and initialize the associated handle.
    314            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    315            *               the configuration information for SPI module.
    316            * @retval HAL status
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    319          {
   \                     HAL_SPI_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    320            /* Check the SPI handle allocation */
    321            if (hspi == NULL)
   \        0x4   0xD101             BNE      ??HAL_SPI_Init_0
    322            {
    323              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD70             POP      {R4-R6,PC}
    324            }
    325          
    326            /* Check the parameters */
    327            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    328            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    329            assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
    330            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    331            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    332            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    333            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    334            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    335            if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
    336            {
    337              assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    338              assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    339            }
    340          #if (USE_SPI_CRC != 0U)
    341            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    342            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    343            {
    344              assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    345            }
    346          #else
    347            hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \                     ??HAL_SPI_Init_0: (+1)
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x62A5             STR      R5,[R4, #+40]
    348          #endif /* USE_SPI_CRC */
    349          
    350            if (hspi->State == HAL_SPI_STATE_RESET)
   \        0xE   0x0026             MOVS     R6,R4
   \       0x10   0x3650             ADDS     R6,R6,#+80
   \       0x12   0x7870             LDRB     R0,[R6, #+1]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD103             BNE      ??HAL_SPI_Init_1
    351            {
    352              /* Allocate lock resource and initialize it */
    353              hspi->Lock = HAL_UNLOCKED;
   \       0x18   0x7035             STRB     R5,[R6, #+0]
    354          
    355          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    356              /* Init the SPI Callback settings */
    357              hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
    358              hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
    359              hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
    360              hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
    361              hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
    362              hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
    363              hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
    364              hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
    365          
    366              if (hspi->MspInitCallback == NULL)
    367              {
    368                hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
    369              }
    370          
    371              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    372              hspi->MspInitCallback(hspi);
    373          #else
    374              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    375              HAL_SPI_MspInit(hspi);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x....'....        BL       HAL_SPI_MspInit
    376          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    377            }
    378          
    379            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_1: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x7070             STRB     R0,[R6, #+1]
    380          
    381            /* Disable the selected SPI peripheral */
    382            __HAL_SPI_DISABLE(hspi);
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x2240             MOVS     R2,#+64
   \       0x2A   0x4391             BICS     R1,R1,R2
   \       0x2C   0x6001             STR      R1,[R0, #+0]
    383          
    384            /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
    385            /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
    386            Communication speed, First bit and CRC calculation state */
    387            WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
    388                                            hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    389                                            hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));
   \       0x2E   0x6860             LDR      R0,[R4, #+4]
   \       0x30   0x68A1             LDR      R1,[R4, #+8]
   \       0x32   0x4301             ORRS     R1,R1,R0
   \       0x34   0x68E0             LDR      R0,[R4, #+12]
   \       0x36   0x4308             ORRS     R0,R0,R1
   \       0x38   0x6921             LDR      R1,[R4, #+16]
   \       0x3A   0x4301             ORRS     R1,R1,R0
   \       0x3C   0x6960             LDR      R0,[R4, #+20]
   \       0x3E   0x4308             ORRS     R0,R0,R1
   \       0x40   0x69A1             LDR      R1,[R4, #+24]
   \       0x42   0x00D2             LSLS     R2,R2,#+3
   \       0x44   0x4011             ANDS     R1,R1,R2
   \       0x46   0x4301             ORRS     R1,R1,R0
   \       0x48   0x69E0             LDR      R0,[R4, #+28]
   \       0x4A   0x4308             ORRS     R0,R0,R1
   \       0x4C   0x6A21             LDR      R1,[R4, #+32]
   \       0x4E   0x4301             ORRS     R1,R1,R0
   \       0x50   0x6AA0             LDR      R0,[R4, #+40]
   \       0x52   0x4308             ORRS     R0,R0,R1
   \       0x54   0x6821             LDR      R1,[R4, #+0]
   \       0x56   0x6008             STR      R0,[R1, #+0]
    390          
    391            /* Configure : NSS management, TI Mode */
    392            WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
   \       0x58   0x69A0             LDR      R0,[R4, #+24]
   \       0x5A   0x0C00             LSRS     R0,R0,#+16
   \       0x5C   0x2104             MOVS     R1,#+4
   \       0x5E   0x4008             ANDS     R0,R0,R1
   \       0x60   0x6A61             LDR      R1,[R4, #+36]
   \       0x62   0x4301             ORRS     R1,R1,R0
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6041             STR      R1,[R0, #+4]
    393          
    394          #if (USE_SPI_CRC != 0U)
    395            /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
    396            /* Configure : CRC Polynomial */
    397            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    398            {
    399              WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
    400            }
    401          #endif /* USE_SPI_CRC */
    402          
    403          #if defined(SPI_I2SCFGR_I2SMOD)
    404            /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
    405            CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x69C1             LDR      R1,[R0, #+28]
   \       0x6C   0x....             LDR      R2,??DataTable0  ;; 0xfffff7ff
   \       0x6E   0x400A             ANDS     R2,R2,R1
   \       0x70   0x61C2             STR      R2,[R0, #+28]
    406          #endif /* SPI_I2SCFGR_I2SMOD */
    407          
    408            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \       0x72   0x6075             STR      R5,[R6, #+4]
    409            hspi->State     = HAL_SPI_STATE_READY;
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0x7070             STRB     R0,[R6, #+1]
    410          
    411            return HAL_OK;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0xBD70             POP      {R4-R6,PC}       ;; return
    412          }
    413          
    414          /**
    415            * @brief  De-Initialize the SPI peripheral.
    416            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    417            *               the configuration information for SPI module.
    418            * @retval HAL status
    419            */

   \                                 In section .text, align 2, keep-with-next
    420          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    421          {
   \                     HAL_SPI_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    422            /* Check the SPI handle allocation */
    423            if (hspi == NULL)
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE      ??HAL_SPI_DeInit_0
    424            {
    425              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD10             POP      {R4,PC}
    426            }
    427          
    428            /* Check SPI Instance parameter */
    429            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    430          
    431            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_DeInit_0: (+1)
   \        0xA   0x0004             MOVS     R4,R0
   \        0xC   0x3450             ADDS     R4,R4,#+80
   \        0xE   0x2102             MOVS     R1,#+2
   \       0x10   0x7061             STRB     R1,[R4, #+1]
    432          
    433            /* Disable the SPI Peripheral Clock */
    434            __HAL_SPI_DISABLE(hspi);
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0x2340             MOVS     R3,#+64
   \       0x18   0x439A             BICS     R2,R2,R3
   \       0x1A   0x600A             STR      R2,[R1, #+0]
    435          
    436          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    437            if (hspi->MspDeInitCallback == NULL)
    438            {
    439              hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */
    440            }
    441          
    442            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    443            hspi->MspDeInitCallback(hspi);
    444          #else
    445            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    446            HAL_SPI_MspDeInit(hspi);
   \       0x1C   0x....'....        BL       HAL_SPI_MspDeInit
    447          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    448          
    449            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6060             STR      R0,[R4, #+4]
    450            hspi->State = HAL_SPI_STATE_RESET;
   \       0x24   0x7060             STRB     R0,[R4, #+1]
    451          
    452            /* Release Lock */
    453            __HAL_UNLOCK(hspi);
   \       0x26   0x7020             STRB     R0,[R4, #+0]
    454          
    455            return HAL_OK;
   \       0x28   0xBD10             POP      {R4,PC}          ;; return
    456          }
    457          
    458          /**
    459            * @brief  Initialize the SPI MSP.
    460            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    461            *               the configuration information for SPI module.
    462            * @retval None
    463            */

   \                                 In section .text, align 2
    464          __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    465          {
    466            /* Prevent unused argument(s) compilation warning */
    467            UNUSED(hspi);
    468          
    469            /* NOTE : This function should not be modified, when the callback is needed,
    470                      the HAL_SPI_MspInit should be implemented in the user file
    471             */
    472          }
   \                     HAL_SPI_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    473          
    474          /**
    475            * @brief  De-Initialize the SPI MSP.
    476            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    477            *               the configuration information for SPI module.
    478            * @retval None
    479            */

   \                                 In section .text, align 2
    480          __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    481          {
    482            /* Prevent unused argument(s) compilation warning */
    483            UNUSED(hspi);
    484          
    485            /* NOTE : This function should not be modified, when the callback is needed,
    486                      the HAL_SPI_MspDeInit should be implemented in the user file
    487             */
    488          }
   \                     HAL_SPI_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    489          
    490          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    491          /**
    492            * @brief  Register a User SPI Callback
    493            *         To be used instead of the weak predefined callback
    494            * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains
    495            *                the configuration information for the specified SPI.
    496            * @param  CallbackID ID of the callback to be registered
    497            * @param  pCallback pointer to the Callback function
    498            * @retval HAL status
    499            */
    500          HAL_StatusTypeDef HAL_SPI_RegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID, pSPI_CallbackTypeDef pCallback)
    501          {
    502            HAL_StatusTypeDef status = HAL_OK;
    503          
    504            if (pCallback == NULL)
    505            {
    506              /* Update the error code */
    507              hspi->ErrorCode |= HAL_SPI_ERROR_INVALID_CALLBACK;
    508          
    509              return HAL_ERROR;
    510            }
    511            /* Process locked */
    512            __HAL_LOCK(hspi);
    513          
    514            if (HAL_SPI_STATE_READY == hspi->State)
    515            {
    516              switch (CallbackID)
    517              {
    518                case HAL_SPI_TX_COMPLETE_CB_ID :
    519                  hspi->TxCpltCallback = pCallback;
    520                  break;
    521          
    522                case HAL_SPI_RX_COMPLETE_CB_ID :
    523                  hspi->RxCpltCallback = pCallback;
    524                  break;
    525          
    526                case HAL_SPI_TX_RX_COMPLETE_CB_ID :
    527                  hspi->TxRxCpltCallback = pCallback;
    528                  break;
    529          
    530                case HAL_SPI_TX_HALF_COMPLETE_CB_ID :
    531                  hspi->TxHalfCpltCallback = pCallback;
    532                  break;
    533          
    534                case HAL_SPI_RX_HALF_COMPLETE_CB_ID :
    535                  hspi->RxHalfCpltCallback = pCallback;
    536                  break;
    537          
    538                case HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID :
    539                  hspi->TxRxHalfCpltCallback = pCallback;
    540                  break;
    541          
    542                case HAL_SPI_ERROR_CB_ID :
    543                  hspi->ErrorCallback = pCallback;
    544                  break;
    545          
    546                case HAL_SPI_ABORT_CB_ID :
    547                  hspi->AbortCpltCallback = pCallback;
    548                  break;
    549          
    550                case HAL_SPI_MSPINIT_CB_ID :
    551                  hspi->MspInitCallback = pCallback;
    552                  break;
    553          
    554                case HAL_SPI_MSPDEINIT_CB_ID :
    555                  hspi->MspDeInitCallback = pCallback;
    556                  break;
    557          
    558                default :
    559                  /* Update the error code */
    560                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    561          
    562                  /* Return error status */
    563                  status =  HAL_ERROR;
    564                  break;
    565              }
    566            }
    567            else if (HAL_SPI_STATE_RESET == hspi->State)
    568            {
    569              switch (CallbackID)
    570              {
    571                case HAL_SPI_MSPINIT_CB_ID :
    572                  hspi->MspInitCallback = pCallback;
    573                  break;
    574          
    575                case HAL_SPI_MSPDEINIT_CB_ID :
    576                  hspi->MspDeInitCallback = pCallback;
    577                  break;
    578          
    579                default :
    580                  /* Update the error code */
    581                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    582          
    583                  /* Return error status */
    584                  status =  HAL_ERROR;
    585                  break;
    586              }
    587            }
    588            else
    589            {
    590              /* Update the error code */
    591              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    592          
    593              /* Return error status */
    594              status =  HAL_ERROR;
    595            }
    596          
    597            /* Release Lock */
    598            __HAL_UNLOCK(hspi);
    599            return status;
    600          }
    601          
    602          /**
    603            * @brief  Unregister an SPI Callback
    604            *         SPI callback is redirected to the weak predefined callback
    605            * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains
    606            *                the configuration information for the specified SPI.
    607            * @param  CallbackID ID of the callback to be unregistered
    608            * @retval HAL status
    609            */
    610          HAL_StatusTypeDef HAL_SPI_UnRegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID)
    611          {
    612            HAL_StatusTypeDef status = HAL_OK;
    613          
    614            /* Process locked */
    615            __HAL_LOCK(hspi);
    616          
    617            if (HAL_SPI_STATE_READY == hspi->State)
    618            {
    619              switch (CallbackID)
    620              {
    621                case HAL_SPI_TX_COMPLETE_CB_ID :
    622                  hspi->TxCpltCallback = HAL_SPI_TxCpltCallback;             /* Legacy weak TxCpltCallback       */
    623                  break;
    624          
    625                case HAL_SPI_RX_COMPLETE_CB_ID :
    626                  hspi->RxCpltCallback = HAL_SPI_RxCpltCallback;             /* Legacy weak RxCpltCallback       */
    627                  break;
    628          
    629                case HAL_SPI_TX_RX_COMPLETE_CB_ID :
    630                  hspi->TxRxCpltCallback = HAL_SPI_TxRxCpltCallback;         /* Legacy weak TxRxCpltCallback     */
    631                  break;
    632          
    633                case HAL_SPI_TX_HALF_COMPLETE_CB_ID :
    634                  hspi->TxHalfCpltCallback = HAL_SPI_TxHalfCpltCallback;     /* Legacy weak TxHalfCpltCallback   */
    635                  break;
    636          
    637                case HAL_SPI_RX_HALF_COMPLETE_CB_ID :
    638                  hspi->RxHalfCpltCallback = HAL_SPI_RxHalfCpltCallback;     /* Legacy weak RxHalfCpltCallback   */
    639                  break;
    640          
    641                case HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID :
    642                  hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
    643                  break;
    644          
    645                case HAL_SPI_ERROR_CB_ID :
    646                  hspi->ErrorCallback = HAL_SPI_ErrorCallback;               /* Legacy weak ErrorCallback        */
    647                  break;
    648          
    649                case HAL_SPI_ABORT_CB_ID :
    650                  hspi->AbortCpltCallback = HAL_SPI_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */
    651                  break;
    652          
    653                case HAL_SPI_MSPINIT_CB_ID :
    654                  hspi->MspInitCallback = HAL_SPI_MspInit;                   /* Legacy weak MspInit              */
    655                  break;
    656          
    657                case HAL_SPI_MSPDEINIT_CB_ID :
    658                  hspi->MspDeInitCallback = HAL_SPI_MspDeInit;               /* Legacy weak MspDeInit            */
    659                  break;
    660          
    661                default :
    662                  /* Update the error code */
    663                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    664          
    665                  /* Return error status */
    666                  status =  HAL_ERROR;
    667                  break;
    668              }
    669            }
    670            else if (HAL_SPI_STATE_RESET == hspi->State)
    671            {
    672              switch (CallbackID)
    673              {
    674                case HAL_SPI_MSPINIT_CB_ID :
    675                  hspi->MspInitCallback = HAL_SPI_MspInit;                   /* Legacy weak MspInit              */
    676                  break;
    677          
    678                case HAL_SPI_MSPDEINIT_CB_ID :
    679                  hspi->MspDeInitCallback = HAL_SPI_MspDeInit;               /* Legacy weak MspDeInit            */
    680                  break;
    681          
    682                default :
    683                  /* Update the error code */
    684                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    685          
    686                  /* Return error status */
    687                  status =  HAL_ERROR;
    688                  break;
    689              }
    690            }
    691            else
    692            {
    693              /* Update the error code */
    694              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    695          
    696              /* Return error status */
    697              status =  HAL_ERROR;
    698            }
    699          
    700            /* Release Lock */
    701            __HAL_UNLOCK(hspi);
    702            return status;
    703          }
    704          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    705          /**
    706            * @}
    707            */
    708          
    709          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    710           *  @brief   Data transfers functions
    711           *
    712          @verbatim
    713            ==============================================================================
    714                                ##### IO operation functions #####
    715           ===============================================================================
    716           [..]
    717              This subsection provides a set of functions allowing to manage the SPI
    718              data transfers.
    719          
    720              [..] The SPI supports master and slave mode :
    721          
    722              (#) There are two modes of transfer:
    723                 (++) Blocking mode: The communication is performed in polling mode.
    724                      The HAL status of all data processing is returned by the same function
    725                      after finishing transfer.
    726                 (++) No-Blocking mode: The communication is performed using Interrupts
    727                      or DMA, These APIs return the HAL status.
    728                      The end of the data processing will be indicated through the
    729                      dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
    730                      using DMA mode.
    731                      The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
    732                      will be executed respectively at the end of the transmit or Receive process
    733                      The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    734          
    735              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    736                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    737          
    738          @endverbatim
    739            * @{
    740            */
    741          
    742          /**
    743            * @brief  Transmit an amount of data in blocking mode.
    744            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    745            *               the configuration information for SPI module.
    746            * @param  pData pointer to data buffer
    747            * @param  Size amount of data to be sent
    748            * @param  Timeout Timeout duration
    749            * @retval HAL status
    750            */

   \                                 In section .text, align 2, keep-with-next
    751          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    752          {
   \                     HAL_SPI_Transmit: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
    753            uint32_t tickstart;
    754            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x6   0x2700             MOVS     R7,#+0
    755            uint16_t initial_TxXferCount;
    756          
    757            if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (Size > 1U)))
    758            {
    759              /* in this case, 16-bit access is performed on Data
    760                 So, check Data is 16-bit aligned address */
    761              assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pData));
    762            }
    763          
    764            /* Check Direction parameter */
    765            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    766          
    767            /* Process Locked */
    768            __HAL_LOCK(hspi);
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_SPI_Transmit_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_SPI_Transmit_0: (+1)
   \       0x14   0x0015             MOVS     R5,R2
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x2150             MOVS     R1,#+80
   \       0x1A   0x5460             STRB     R0,[R4, R1]
    769          
    770            /* Init tickstart for timeout management*/
    771            tickstart = HAL_GetTick();
   \       0x1C   0x....'....        BL       HAL_GetTick
    772            initial_TxXferCount = Size;
   \       0x20   0x0029             MOVS     R1,R5
    773          
    774            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x22   0x0022             MOVS     R2,R4
   \       0x24   0x3250             ADDS     R2,R2,#+80
   \       0x26   0x7852             LDRB     R2,[R2, #+1]
   \       0x28   0x2A01             CMP      R2,#+1
   \       0x2A   0xD001             BEQ      ??HAL_SPI_Transmit_1
    775            {
    776              errorcode = HAL_BUSY;
   \       0x2C   0x2702             MOVS     R7,#+2
    777              goto error;
   \       0x2E   0xE0AF             B        ??HAL_SPI_Transmit_2
    778            }
    779          
    780            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Transmit_1: (+1)
   \       0x30   0x2E00             CMP      R6,#+0
   \       0x32   0xD000             BEQ      ??HAL_SPI_Transmit_3
   \       0x34   0x002A             MOVS     R2,R5
   \                     ??HAL_SPI_Transmit_3: (+1)
   \       0x36   0xD100             BNE      .+4
   \       0x38   0xE0A9             B        ??HAL_SPI_Transmit_4
    781            {
    782              errorcode = HAL_ERROR;
    783              goto error;
    784            }
    785          
    786            /* Set the transaction information */
    787            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \       0x3A   0x2203             MOVS     R2,#+3
   \       0x3C   0x0023             MOVS     R3,R4
   \       0x3E   0x3350             ADDS     R3,R3,#+80
   \       0x40   0x705A             STRB     R2,[R3, #+1]
    788            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x42   0x0023             MOVS     R3,R4
   \       0x44   0x3350             ADDS     R3,R3,#+80
   \       0x46   0x605F             STR      R7,[R3, #+4]
    789            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \       0x48   0x6326             STR      R6,[R4, #+48]
    790            hspi->TxXferSize  = Size;
   \       0x4A   0x86A5             STRH     R5,[R4, #+52]
    791            hspi->TxXferCount = Size;
   \       0x4C   0x86E5             STRH     R5,[R4, #+54]
    792          
    793            /*Init field not used in handle to zero */
    794            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \       0x4E   0x63A7             STR      R7,[R4, #+56]
    795            hspi->RxXferSize  = 0U;
   \       0x50   0x87A7             STRH     R7,[R4, #+60]
    796            hspi->RxXferCount = 0U;
   \       0x52   0x87E7             STRH     R7,[R4, #+62]
    797            hspi->TxISR       = NULL;
   \       0x54   0x6467             STR      R7,[R4, #+68]
    798            hspi->RxISR       = NULL;
   \       0x56   0x6427             STR      R7,[R4, #+64]
    799          
    800            /* Configure communication direction : 1Line */
    801            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x58   0x68A2             LDR      R2,[R4, #+8]
   \       0x5A   0x2380             MOVS     R3,#+128
   \       0x5C   0x021B             LSLS     R3,R3,#+8        ;; #+32768
   \       0x5E   0x429A             CMP      R2,R3
   \       0x60   0xD105             BNE      ??HAL_SPI_Transmit_5
    802            {
    803              SPI_1LINE_TX(hspi);
   \       0x62   0x6822             LDR      R2,[R4, #+0]
   \       0x64   0x6813             LDR      R3,[R2, #+0]
   \       0x66   0x2580             MOVS     R5,#+128
   \       0x68   0x01ED             LSLS     R5,R5,#+7        ;; #+16384
   \       0x6A   0x431D             ORRS     R5,R5,R3
   \       0x6C   0x6015             STR      R5,[R2, #+0]
    804            }
    805          
    806          #if (USE_SPI_CRC != 0U)
    807            /* Reset CRC Calculation */
    808            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    809            {
    810              SPI_RESET_CRC(hspi);
    811            }
    812          #endif /* USE_SPI_CRC */
    813          
    814            /* Check if the SPI is already enabled */
    815            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_5: (+1)
   \       0x6E   0x6822             LDR      R2,[R4, #+0]
   \       0x70   0x2340             MOVS     R3,#+64
   \       0x72   0x6815             LDR      R5,[R2, #+0]
   \       0x74   0x401D             ANDS     R5,R5,R3
   \       0x76   0xD102             BNE      ??HAL_SPI_Transmit_6
    816            {
    817              /* Enable SPI peripheral */
    818              __HAL_SPI_ENABLE(hspi);
   \       0x78   0x6815             LDR      R5,[R2, #+0]
   \       0x7A   0x432B             ORRS     R3,R3,R5
   \       0x7C   0x6013             STR      R3,[R2, #+0]
    819            }
    820          
    821            /* Transmit data in 16 Bit mode */
    822            if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_Transmit_6: (+1)
   \       0x7E   0x2200             MOVS     R2,#+0
   \       0x80   0x43D2             MVNS     R2,R2            ;; #-1
   \       0x82   0x9201             STR      R2,[SP, #+4]
   \       0x84   0x0C12             LSRS     R2,R2,#+16
   \       0x86   0x466B             MOV      R3,SP
   \       0x88   0x801A             STRH     R2,[R3, #+0]
   \       0x8A   0x9D02             LDR      R5,[SP, #+8]
   \       0x8C   0x68E2             LDR      R2,[R4, #+12]
   \       0x8E   0x2380             MOVS     R3,#+128
   \       0x90   0x011B             LSLS     R3,R3,#+4        ;; #+2048
   \       0x92   0x429A             CMP      R2,R3
   \       0x94   0x6862             LDR      R2,[R4, #+4]
   \       0x96   0xD130             BNE      ??HAL_SPI_Transmit_7
    823            {
    824              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   \       0x98   0x2A00             CMP      R2,#+0
   \       0x9A   0xD001             BEQ      ??HAL_SPI_Transmit_8
   \       0x9C   0x2901             CMP      R1,#+1
   \       0x9E   0xD10B             BNE      ??HAL_SPI_Transmit_9
    825              {
    826                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_8: (+1)
   \       0xA0   0x6B21             LDR      R1,[R4, #+48]
   \       0xA2   0x8809             LDRH     R1,[R1, #+0]
   \       0xA4   0x6822             LDR      R2,[R4, #+0]
   \       0xA6   0x60D1             STR      R1,[R2, #+12]
    827                hspi->pTxBuffPtr += sizeof(uint16_t);
   \       0xA8   0x6B21             LDR      R1,[R4, #+48]
   \       0xAA   0x1C89             ADDS     R1,R1,#+2
   \       0xAC   0x6321             STR      R1,[R4, #+48]
    828                hspi->TxXferCount--;
   \       0xAE   0x8EE1             LDRH     R1,[R4, #+54]
   \       0xB0   0x466A             MOV      R2,SP
   \       0xB2   0x8812             LDRH     R2,[R2, #+0]
   \       0xB4   0x1889             ADDS     R1,R1,R2
   \       0xB6   0x86E1             STRH     R1,[R4, #+54]
   \                     ??HAL_SPI_Transmit_9: (+1)
   \       0xB8   0x0006             MOVS     R6,R0
   \       0xBA   0xE00A             B        ??HAL_SPI_Transmit_10
    829              }
    830              /* Transmit data in 16 Bit mode */
    831              while (hspi->TxXferCount > 0U)
    832              {
    833                /* Wait until TXE flag is set to send data */
    834                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
    835                {
    836                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_11: (+1)
   \       0xBC   0x6B21             LDR      R1,[R4, #+48]
   \       0xBE   0x8809             LDRH     R1,[R1, #+0]
   \       0xC0   0x60C1             STR      R1,[R0, #+12]
    837                  hspi->pTxBuffPtr += sizeof(uint16_t);
   \       0xC2   0x6B20             LDR      R0,[R4, #+48]
   \       0xC4   0x1C80             ADDS     R0,R0,#+2
   \       0xC6   0x6320             STR      R0,[R4, #+48]
    838                  hspi->TxXferCount--;
   \       0xC8   0x8EE0             LDRH     R0,[R4, #+54]
   \       0xCA   0x4669             MOV      R1,SP
   \       0xCC   0x8809             LDRH     R1,[R1, #+0]
   \       0xCE   0x1840             ADDS     R0,R0,R1
   \       0xD0   0x86E0             STRH     R0,[R4, #+54]
    839                }
   \                     ??HAL_SPI_Transmit_10: (+1)
   \       0xD2   0x8EE0             LDRH     R0,[R4, #+54]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD040             BEQ      ??HAL_SPI_Transmit_12
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x6881             LDR      R1,[R0, #+8]
   \       0xDC   0x0789             LSLS     R1,R1,#+30
   \       0xDE   0xD4ED             BMI      ??HAL_SPI_Transmit_11
    840                else
    841                {
    842                  /* Timeout management */
    843                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   \       0xE0   0x....'....        BL       HAL_GetTick
   \       0xE4   0x1B80             SUBS     R0,R0,R6
   \       0xE6   0x42A8             CMP      R0,R5
   \       0xE8   0xD304             BCC      ??HAL_SPI_Transmit_13
   \       0xEA   0x9801             LDR      R0,[SP, #+4]
   \       0xEC   0x4285             CMP      R5,R0
   \       0xEE   0xD0F0             BEQ      ??HAL_SPI_Transmit_10
    844                  {
    845                    errorcode = HAL_TIMEOUT;
    846                    goto error;
    847                  }
    848                }
    849              }
    850            }
    851            /* Transmit data in 8 Bit mode */
    852            else
    853            {
    854              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
    855              {
    856                *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
    857                hspi->pTxBuffPtr += sizeof(uint8_t);
    858                hspi->TxXferCount--;
    859              }
    860              while (hspi->TxXferCount > 0U)
    861              {
    862                /* Wait until TXE flag is set to send data */
    863                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
    864                {
    865                  *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
    866                  hspi->pTxBuffPtr += sizeof(uint8_t);
    867                  hspi->TxXferCount--;
    868                }
    869                else
    870                {
    871                  /* Timeout management */
    872                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
    873                  {
    874                    errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_Transmit_14: (+1)
   \       0xF0   0x2703             MOVS     R7,#+3
    875                    goto error;
   \       0xF2   0xE04D             B        ??HAL_SPI_Transmit_2
    876                  }
   \                     ??HAL_SPI_Transmit_13: (+1)
   \       0xF4   0x2D00             CMP      R5,#+0
   \       0xF6   0xD1EC             BNE      ??HAL_SPI_Transmit_10
   \       0xF8   0xE7FA             B        ??HAL_SPI_Transmit_14
   \                     ??HAL_SPI_Transmit_7: (+1)
   \       0xFA   0x2A00             CMP      R2,#+0
   \       0xFC   0xD001             BEQ      ??HAL_SPI_Transmit_15
   \       0xFE   0x2901             CMP      R1,#+1
   \      0x100   0xD10B             BNE      ??HAL_SPI_Transmit_16
   \                     ??HAL_SPI_Transmit_15: (+1)
   \      0x102   0x6B21             LDR      R1,[R4, #+48]
   \      0x104   0x7809             LDRB     R1,[R1, #+0]
   \      0x106   0x6822             LDR      R2,[R4, #+0]
   \      0x108   0x7311             STRB     R1,[R2, #+12]
   \      0x10A   0x6B21             LDR      R1,[R4, #+48]
   \      0x10C   0x1C49             ADDS     R1,R1,#+1
   \      0x10E   0x6321             STR      R1,[R4, #+48]
   \      0x110   0x8EE1             LDRH     R1,[R4, #+54]
   \      0x112   0x466A             MOV      R2,SP
   \      0x114   0x8812             LDRH     R2,[R2, #+0]
   \      0x116   0x1889             ADDS     R1,R1,R2
   \      0x118   0x86E1             STRH     R1,[R4, #+54]
   \                     ??HAL_SPI_Transmit_16: (+1)
   \      0x11A   0x0006             MOVS     R6,R0
   \      0x11C   0xE00A             B        ??HAL_SPI_Transmit_17
   \                     ??HAL_SPI_Transmit_18: (+1)
   \      0x11E   0x6B21             LDR      R1,[R4, #+48]
   \      0x120   0x7809             LDRB     R1,[R1, #+0]
   \      0x122   0x7301             STRB     R1,[R0, #+12]
   \      0x124   0x6B20             LDR      R0,[R4, #+48]
   \      0x126   0x1C40             ADDS     R0,R0,#+1
   \      0x128   0x6320             STR      R0,[R4, #+48]
   \      0x12A   0x8EE0             LDRH     R0,[R4, #+54]
   \      0x12C   0x4669             MOV      R1,SP
   \      0x12E   0x8809             LDRH     R1,[R1, #+0]
   \      0x130   0x1840             ADDS     R0,R0,R1
   \      0x132   0x86E0             STRH     R0,[R4, #+54]
   \                     ??HAL_SPI_Transmit_17: (+1)
   \      0x134   0x8EE0             LDRH     R0,[R4, #+54]
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD00F             BEQ      ??HAL_SPI_Transmit_12
   \      0x13A   0x6820             LDR      R0,[R4, #+0]
   \      0x13C   0x6881             LDR      R1,[R0, #+8]
   \      0x13E   0x0789             LSLS     R1,R1,#+30
   \      0x140   0xD4ED             BMI      ??HAL_SPI_Transmit_18
   \      0x142   0x....'....        BL       HAL_GetTick
   \      0x146   0x1B80             SUBS     R0,R0,R6
   \      0x148   0x42A8             CMP      R0,R5
   \      0x14A   0xD303             BCC      ??HAL_SPI_Transmit_19
   \      0x14C   0x9801             LDR      R0,[SP, #+4]
   \      0x14E   0x4285             CMP      R5,R0
   \      0x150   0xD1CE             BNE      ??HAL_SPI_Transmit_14
   \      0x152   0xE7EF             B        ??HAL_SPI_Transmit_17
   \                     ??HAL_SPI_Transmit_19: (+1)
   \      0x154   0x2D00             CMP      R5,#+0
   \      0x156   0xD1ED             BNE      ??HAL_SPI_Transmit_17
   \      0x158   0xE7CA             B        ??HAL_SPI_Transmit_14
    877                }
    878              }
    879            }
   \                     ??HAL_SPI_Transmit_12: (+1)
   \      0x15A   0x0029             MOVS     R1,R5
   \      0x15C   0x0032             MOVS     R2,R6
    880          #if (USE_SPI_CRC != 0U)
    881            /* Enable CRC Transmission */
    882            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    883            {
    884              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    885            }
    886          #endif /* USE_SPI_CRC */
    887          
    888            /* Check the end of the transaction */
    889            if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
   \      0x15E   0x0020             MOVS     R0,R4
   \      0x160   0x....'....        BL       SPI_EndRxTxTransaction
   \      0x164   0x2800             CMP      R0,#+0
   \      0x166   0xD003             BEQ      ??HAL_SPI_Transmit_20
    890            {
    891              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \      0x168   0x2020             MOVS     R0,#+32
   \      0x16A   0x0021             MOVS     R1,R4
   \      0x16C   0x3150             ADDS     R1,R1,#+80
   \      0x16E   0x6048             STR      R0,[R1, #+4]
    892            }
    893          
    894            /* Clear overrun flag in 2 Lines communication mode because received is not read */
    895            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_20: (+1)
   \      0x170   0x68A0             LDR      R0,[R4, #+8]
   \      0x172   0x2800             CMP      R0,#+0
   \      0x174   0xD106             BNE      ??HAL_SPI_Transmit_21
    896            {
    897              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \      0x176   0x9000             STR      R0,[SP, #+0]
   \      0x178   0x6820             LDR      R0,[R4, #+0]
   \      0x17A   0x68C1             LDR      R1,[R0, #+12]
   \      0x17C   0x9100             STR      R1,[SP, #+0]
   \      0x17E   0x6880             LDR      R0,[R0, #+8]
   \      0x180   0x9000             STR      R0,[SP, #+0]
   \      0x182   0x9800             LDR      R0,[SP, #+0]
    898            }
    899          
    900            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_Transmit_21: (+1)
   \      0x184   0x0020             MOVS     R0,R4
   \      0x186   0x3050             ADDS     R0,R0,#+80
   \      0x188   0x6840             LDR      R0,[R0, #+4]
   \      0x18A   0x2800             CMP      R0,#+0
   \      0x18C   0xD000             BEQ      ??HAL_SPI_Transmit_2
    901            {
    902              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Transmit_4: (+1)
   \      0x18E   0x2701             MOVS     R7,#+1
    903            }
    904          
    905          error:
    906            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Transmit_2: (+1)
   \      0x190   0x0020             MOVS     R0,R4
   \      0x192   0x3050             ADDS     R0,R0,#+80
   \      0x194   0x2101             MOVS     R1,#+1
   \      0x196   0x7041             STRB     R1,[R0, #+1]
    907            /* Process Unlocked */
    908            __HAL_UNLOCK(hspi);
   \      0x198   0x2100             MOVS     R1,#+0
   \      0x19A   0x7001             STRB     R1,[R0, #+0]
    909            return errorcode;
   \      0x19C   0x0038             MOVS     R0,R7
   \      0x19E   0xBDFE             POP      {R1-R7,PC}       ;; return
    910          }
    911          
    912          /**
    913            * @brief  Receive an amount of data in blocking mode.
    914            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    915            *               the configuration information for SPI module.
    916            * @param  pData pointer to data buffer
    917            * @param  Size amount of data to be received
    918            * @param  Timeout Timeout duration
    919            * @retval HAL status
    920            */

   \                                 In section .text, align 2, keep-with-next
    921          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    922          {
   \                     HAL_SPI_Receive: (+1)
   \        0x0   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0016             MOVS     R6,R2
    923            uint32_t tickstart;
    924            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x6   0x2700             MOVS     R7,#+0
    925          
    926            if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (Size > 1U)))
    927            {
    928              /* in this case, 16-bit access is performed on Data
    929                 So, check Data is 16-bit aligned address */
    930              assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pData));
    931            }
    932          
    933            if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \        0x8   0x2504             MOVS     R5,#+4
   \        0xA   0x6860             LDR      R0,[R4, #+4]
   \        0xC   0x2182             MOVS     R1,#+130
   \        0xE   0x0049             LSLS     R1,R1,#+1        ;; #+260
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD10E             BNE      ??HAL_SPI_Receive_0
   \       0x14   0x68A0             LDR      R0,[R4, #+8]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD10B             BNE      ??HAL_SPI_Receive_0
    934            {
    935              hspi->State = HAL_SPI_STATE_BUSY_RX;
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x3050             ADDS     R0,R0,#+80
   \       0x1E   0x7045             STRB     R5,[R0, #+1]
    936              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    937              return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
   \       0x20   0x9802             LDR      R0,[SP, #+8]
   \       0x22   0x9000             STR      R0,[SP, #+0]
   \       0x24   0x0033             MOVS     R3,R6
   \       0x26   0x9A01             LDR      R2,[SP, #+4]
   \       0x28   0x4611             MOV      R1,R2
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x....'....        BL       HAL_SPI_TransmitReceive
   \       0x30   0xBDFE             POP      {R1-R7,PC}
    938            }
    939          
    940            /* Process Locked */
    941            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_0: (+1)
   \       0x32   0x2050             MOVS     R0,#+80
   \       0x34   0x5C20             LDRB     R0,[R4, R0]
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD101             BNE      ??HAL_SPI_Receive_1
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_SPI_Receive_1: (+1)
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x2150             MOVS     R1,#+80
   \       0x42   0x5460             STRB     R0,[R4, R1]
    942          
    943            /* Init tickstart for timeout management*/
    944            tickstart = HAL_GetTick();
   \       0x44   0x....'....        BL       HAL_GetTick
    945          
    946            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x48   0x0021             MOVS     R1,R4
   \       0x4A   0x3150             ADDS     R1,R1,#+80
   \       0x4C   0x7849             LDRB     R1,[R1, #+1]
   \       0x4E   0x2901             CMP      R1,#+1
   \       0x50   0xD001             BEQ      ??HAL_SPI_Receive_2
    947            {
    948              errorcode = HAL_BUSY;
   \       0x52   0x2702             MOVS     R7,#+2
    949              goto error;
   \       0x54   0xE07E             B        ??HAL_SPI_Receive_3
    950            }
    951          
    952            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Receive_2: (+1)
   \       0x56   0x9901             LDR      R1,[SP, #+4]
   \       0x58   0x2900             CMP      R1,#+0
   \       0x5A   0xD001             BEQ      ??HAL_SPI_Receive_4
   \       0x5C   0x0031             MOVS     R1,R6
   \       0x5E   0xD101             BNE      ??HAL_SPI_Receive_5
    953            {
    954              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Receive_4: (+1)
   \       0x60   0x2701             MOVS     R7,#+1
    955              goto error;
   \       0x62   0xE077             B        ??HAL_SPI_Receive_3
    956            }
    957          
    958            /* Set the transaction information */
    959            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \                     ??HAL_SPI_Receive_5: (+1)
   \       0x64   0x0021             MOVS     R1,R4
   \       0x66   0x3150             ADDS     R1,R1,#+80
   \       0x68   0x704D             STRB     R5,[R1, #+1]
    960            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x6A   0x0022             MOVS     R2,R4
   \       0x6C   0x3250             ADDS     R2,R2,#+80
   \       0x6E   0x6057             STR      R7,[R2, #+4]
    961            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \       0x70   0x9901             LDR      R1,[SP, #+4]
   \       0x72   0x63A1             STR      R1,[R4, #+56]
    962            hspi->RxXferSize  = Size;
   \       0x74   0x87A6             STRH     R6,[R4, #+60]
    963            hspi->RxXferCount = Size;
   \       0x76   0x87E6             STRH     R6,[R4, #+62]
    964          
    965            /*Init field not used in handle to zero */
    966            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \       0x78   0x6327             STR      R7,[R4, #+48]
    967            hspi->TxXferSize  = 0U;
   \       0x7A   0x86A7             STRH     R7,[R4, #+52]
    968            hspi->TxXferCount = 0U;
   \       0x7C   0x86E7             STRH     R7,[R4, #+54]
    969            hspi->RxISR       = NULL;
   \       0x7E   0x6427             STR      R7,[R4, #+64]
    970            hspi->TxISR       = NULL;
   \       0x80   0x6467             STR      R7,[R4, #+68]
    971          
    972          #if (USE_SPI_CRC != 0U)
    973            /* Reset CRC Calculation */
    974            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    975            {
    976              SPI_RESET_CRC(hspi);
    977              /* this is done to handle the CRCNEXT before the latest data */
    978              hspi->RxXferCount--;
    979            }
    980          #endif /* USE_SPI_CRC */
    981          
    982            /* Configure communication direction: 1Line */
    983            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x82   0x68A1             LDR      R1,[R4, #+8]
   \       0x84   0x036A             LSLS     R2,R5,#+13
   \       0x86   0x4291             CMP      R1,R2
   \       0x88   0xD104             BNE      ??HAL_SPI_Receive_6
    984            {
    985              SPI_1LINE_RX(hspi);
   \       0x8A   0x6821             LDR      R1,[R4, #+0]
   \       0x8C   0x680A             LDR      R2,[R1, #+0]
   \       0x8E   0x....             LDR      R3,??DataTable2  ;; 0xffffbfff
   \       0x90   0x4013             ANDS     R3,R3,R2
   \       0x92   0x600B             STR      R3,[R1, #+0]
    986            }
    987          
    988            /* Check if the SPI is already enabled */
    989            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_6: (+1)
   \       0x94   0x6821             LDR      R1,[R4, #+0]
   \       0x96   0x2240             MOVS     R2,#+64
   \       0x98   0x680B             LDR      R3,[R1, #+0]
   \       0x9A   0x4013             ANDS     R3,R3,R2
   \       0x9C   0xD102             BNE      ??HAL_SPI_Receive_7
    990            {
    991              /* Enable SPI peripheral */
    992              __HAL_SPI_ENABLE(hspi);
   \       0x9E   0x680B             LDR      R3,[R1, #+0]
   \       0xA0   0x431A             ORRS     R2,R2,R3
   \       0xA2   0x600A             STR      R2,[R1, #+0]
    993            }
    994          
    995            /* Receive data in 8 Bit mode */
    996            if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_7: (+1)
   \       0xA4   0x2101             MOVS     R1,#+1
   \       0xA6   0x9100             STR      R1,[SP, #+0]
   \       0xA8   0x68E1             LDR      R1,[R4, #+12]
   \       0xAA   0x2900             CMP      R1,#+0
   \       0xAC   0x9D02             LDR      R5,[SP, #+8]
   \       0xAE   0xD120             BNE      ??HAL_SPI_Receive_8
   \       0xB0   0x0006             MOVS     R6,R0
   \       0xB2   0xE008             B        ??HAL_SPI_Receive_9
    997            {
    998              /* Transfer loop */
    999              while (hspi->RxXferCount > 0U)
   1000              {
   1001                /* Check the RXNE flag */
   1002                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
   1003                {
   1004                  /* read the received data */
   1005                  (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_10: (+1)
   \       0xB4   0x7B00             LDRB     R0,[R0, #+12]
   \       0xB6   0x6BA1             LDR      R1,[R4, #+56]
   \       0xB8   0x7008             STRB     R0,[R1, #+0]
   1006                  hspi->pRxBuffPtr += sizeof(uint8_t);
   \       0xBA   0x6BA0             LDR      R0,[R4, #+56]
   \       0xBC   0x1C40             ADDS     R0,R0,#+1
   \       0xBE   0x63A0             STR      R0,[R4, #+56]
   1007                  hspi->RxXferCount--;
   \       0xC0   0x8FE0             LDRH     R0,[R4, #+62]
   \       0xC2   0x1E40             SUBS     R0,R0,#+1
   \       0xC4   0x87E0             STRH     R0,[R4, #+62]
   1008                }
   \                     ??HAL_SPI_Receive_9: (+1)
   \       0xC6   0x8FE0             LDRH     R0,[R4, #+62]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD032             BEQ      ??HAL_SPI_Receive_11
   \       0xCC   0x6820             LDR      R0,[R4, #+0]
   \       0xCE   0x6881             LDR      R1,[R0, #+8]
   \       0xD0   0x9A00             LDR      R2,[SP, #+0]
   \       0xD2   0x400A             ANDS     R2,R2,R1
   \       0xD4   0xD1EE             BNE      ??HAL_SPI_Receive_10
   1009                else
   1010                {
   1011                  /* Timeout management */
   1012                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   \       0xD6   0x....'....        BL       HAL_GetTick
   \       0xDA   0x1B80             SUBS     R0,R0,R6
   \       0xDC   0x42A8             CMP      R0,R5
   \       0xDE   0xD305             BCC      ??HAL_SPI_Receive_12
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0x43C0             MVNS     R0,R0            ;; #-1
   \       0xE4   0x4285             CMP      R5,R0
   \       0xE6   0xD0EE             BEQ      ??HAL_SPI_Receive_9
   1013                  {
   1014                    errorcode = HAL_TIMEOUT;
   1015                    goto error;
   1016                  }
   1017                }
   1018              }
   1019            }
   1020            else
   1021            {
   1022              /* Transfer loop */
   1023              while (hspi->RxXferCount > 0U)
   1024              {
   1025                /* Check the RXNE flag */
   1026                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
   1027                {
   1028                  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   1029                  hspi->pRxBuffPtr += sizeof(uint16_t);
   1030                  hspi->RxXferCount--;
   1031                }
   1032                else
   1033                {
   1034                  /* Timeout management */
   1035                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   1036                  {
   1037                    errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_Receive_13: (+1)
   \       0xE8   0x2703             MOVS     R7,#+3
   1038                    goto error;
   \       0xEA   0xE033             B        ??HAL_SPI_Receive_3
   1039                  }
   \                     ??HAL_SPI_Receive_12: (+1)
   \       0xEC   0x2D00             CMP      R5,#+0
   \       0xEE   0xD1EA             BNE      ??HAL_SPI_Receive_9
   \       0xF0   0xE7FA             B        ??HAL_SPI_Receive_13
   \                     ??HAL_SPI_Receive_8: (+1)
   \       0xF2   0x0006             MOVS     R6,R0
   \       0xF4   0xE008             B        ??HAL_SPI_Receive_14
   \                     ??HAL_SPI_Receive_15: (+1)
   \       0xF6   0x68C0             LDR      R0,[R0, #+12]
   \       0xF8   0x6BA1             LDR      R1,[R4, #+56]
   \       0xFA   0x8008             STRH     R0,[R1, #+0]
   \       0xFC   0x6BA0             LDR      R0,[R4, #+56]
   \       0xFE   0x1C80             ADDS     R0,R0,#+2
   \      0x100   0x63A0             STR      R0,[R4, #+56]
   \      0x102   0x8FE0             LDRH     R0,[R4, #+62]
   \      0x104   0x1E40             SUBS     R0,R0,#+1
   \      0x106   0x87E0             STRH     R0,[R4, #+62]
   \                     ??HAL_SPI_Receive_14: (+1)
   \      0x108   0x8FE0             LDRH     R0,[R4, #+62]
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD011             BEQ      ??HAL_SPI_Receive_11
   \      0x10E   0x6820             LDR      R0,[R4, #+0]
   \      0x110   0x6881             LDR      R1,[R0, #+8]
   \      0x112   0x9A00             LDR      R2,[SP, #+0]
   \      0x114   0x400A             ANDS     R2,R2,R1
   \      0x116   0xD1EE             BNE      ??HAL_SPI_Receive_15
   \      0x118   0x....'....        BL       HAL_GetTick
   \      0x11C   0x1B80             SUBS     R0,R0,R6
   \      0x11E   0x42A8             CMP      R0,R5
   \      0x120   0xD304             BCC      ??HAL_SPI_Receive_16
   \      0x122   0x2000             MOVS     R0,#+0
   \      0x124   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x126   0x4285             CMP      R5,R0
   \      0x128   0xD1DE             BNE      ??HAL_SPI_Receive_13
   \      0x12A   0xE7ED             B        ??HAL_SPI_Receive_14
   \                     ??HAL_SPI_Receive_16: (+1)
   \      0x12C   0x2D00             CMP      R5,#+0
   \      0x12E   0xD1EB             BNE      ??HAL_SPI_Receive_14
   \      0x130   0xE7DA             B        ??HAL_SPI_Receive_13
   1040                }
   1041              }
   1042            }
   \                     ??HAL_SPI_Receive_11: (+1)
   \      0x132   0x0029             MOVS     R1,R5
   \      0x134   0x0032             MOVS     R2,R6
   1043          
   1044          #if (USE_SPI_CRC != 0U)
   1045            /* Handle the CRC Transmission */
   1046            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1047            {
   1048              /* freeze the CRC before the latest data */
   1049              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1050          
   1051              /* Read the latest data */
   1052              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1053              {
   1054                /* the latest data has not been received */
   1055                errorcode = HAL_TIMEOUT;
   1056                goto error;
   1057              }
   1058          
   1059              /* Receive last data in 16 Bit mode */
   1060              if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   1061              {
   1062                *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   1063              }
   1064              /* Receive last data in 8 Bit mode */
   1065              else
   1066              {
   1067                (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
   1068              }
   1069          
   1070              /* Wait the CRC data */
   1071              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1072              {
   1073                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1074                errorcode = HAL_TIMEOUT;
   1075                goto error;
   1076              }
   1077          
   1078              /* Read CRC to Flush DR and RXNE flag */
   1079              READ_REG(hspi->Instance->DR);
   1080            }
   1081          #endif /* USE_SPI_CRC */
   1082          
   1083            /* Check the end of the transaction */
   1084            if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
   \      0x136   0x0020             MOVS     R0,R4
   \      0x138   0x....'....        BL       SPI_EndRxTransaction
   \      0x13C   0x2800             CMP      R0,#+0
   \      0x13E   0xD003             BEQ      ??HAL_SPI_Receive_17
   1085            {
   1086              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \      0x140   0x2020             MOVS     R0,#+32
   \      0x142   0x0021             MOVS     R1,R4
   \      0x144   0x3150             ADDS     R1,R1,#+80
   \      0x146   0x6048             STR      R0,[R1, #+4]
   1087            }
   1088          
   1089          #if (USE_SPI_CRC != 0U)
   1090            /* Check if CRC error occurred */
   1091            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   1092            {
   1093              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1094              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   1095            }
   1096          #endif /* USE_SPI_CRC */
   1097          
   1098            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_Receive_17: (+1)
   \      0x148   0x0020             MOVS     R0,R4
   \      0x14A   0x3050             ADDS     R0,R0,#+80
   \      0x14C   0x6840             LDR      R0,[R0, #+4]
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD000             BEQ      ??HAL_SPI_Receive_3
   1099            {
   1100              errorcode = HAL_ERROR;
   \      0x152   0x9F00             LDR      R7,[SP, #+0]
   1101            }
   1102          
   1103          error :
   1104            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Receive_3: (+1)
   \      0x154   0x0020             MOVS     R0,R4
   \      0x156   0x3050             ADDS     R0,R0,#+80
   \      0x158   0x2101             MOVS     R1,#+1
   \      0x15A   0x7041             STRB     R1,[R0, #+1]
   1105            __HAL_UNLOCK(hspi);
   \      0x15C   0x2100             MOVS     R1,#+0
   \      0x15E   0x7001             STRB     R1,[R0, #+0]
   1106            return errorcode;
   \      0x160   0xB2F8             UXTB     R0,R7
   \      0x162   0xBDFE             POP      {R1-R7,PC}       ;; return
   1107          }
   1108          
   1109          /**
   1110            * @brief  Transmit and Receive an amount of data in blocking mode.
   1111            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1112            *               the configuration information for SPI module.
   1113            * @param  pTxData pointer to transmission data buffer
   1114            * @param  pRxData pointer to reception data buffer
   1115            * @param  Size amount of data to be sent and received
   1116            * @param  Timeout Timeout duration
   1117            * @retval HAL status
   1118            */

   \                                 In section .text, align 2, keep-with-next
   1119          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
   1120                                                    uint32_t Timeout)
   1121          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0015             MOVS     R5,R2
   1122            uint16_t             initial_TxXferCount;
   1123            uint32_t             tmp_mode;
   1124            HAL_SPI_StateTypeDef tmp_state;
   1125            uint32_t             tickstart;
   1126          
   1127            /* Variable used to alternate Rx and Tx during transfer */
   1128            uint32_t             txallowed = 1U;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x9003             STR      R0,[SP, #+12]
   1129            HAL_StatusTypeDef    errorcode = HAL_OK;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x7008             STRB     R0,[R1, #+0]
   1130          
   1131            if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (Size > 1U)))
   1132            {
   1133              /* in this case, 16-bit access is performed on Data
   1134                 So, check Data is 16-bit aligned address */
   1135              assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pTxData));
   1136              assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pRxData));
   1137            }
   1138          
   1139            /* Check Direction parameter */
   1140            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1141          
   1142            /* Process Locked */
   1143            __HAL_LOCK(hspi);
   \       0x14   0x2050             MOVS     R0,#+80
   \       0x16   0x5C20             LDRB     R0,[R4, R0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD101             BNE      ??HAL_SPI_TransmitReceive_0
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0xE0F7             B        ??HAL_SPI_TransmitReceive_1
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \       0x20   0x001E             MOVS     R6,R3
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x2150             MOVS     R1,#+80
   \       0x26   0x5460             STRB     R0,[R4, R1]
   1144          
   1145            /* Init tickstart for timeout management*/
   1146            tickstart = HAL_GetTick();
   \       0x28   0x....'....        BL       HAL_GetTick
   \       0x2C   0x9001             STR      R0,[SP, #+4]
   1147          
   1148            /* Init temporary variables */
   1149            tmp_state           = hspi->State;
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x3050             ADDS     R0,R0,#+80
   \       0x32   0x7841             LDRB     R1,[R0, #+1]
   1150            tmp_mode            = hspi->Init.Mode;
   1151            initial_TxXferCount = Size;
   1152          
   1153            if (!((tmp_state == HAL_SPI_STATE_READY) || \
   1154                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   \       0x34   0x2901             CMP      R1,#+1
   \       0x36   0xD00B             BEQ      ??HAL_SPI_TransmitReceive_2
   \       0x38   0x6862             LDR      R2,[R4, #+4]
   \       0x3A   0x2382             MOVS     R3,#+130
   \       0x3C   0x005B             LSLS     R3,R3,#+1        ;; #+260
   \       0x3E   0x429A             CMP      R2,R3
   \       0x40   0xD104             BNE      ??HAL_SPI_TransmitReceive_3
   \       0x42   0x68A2             LDR      R2,[R4, #+8]
   \       0x44   0x2A00             CMP      R2,#+0
   \       0x46   0xD101             BNE      ??HAL_SPI_TransmitReceive_3
   \       0x48   0x2904             CMP      R1,#+4
   \       0x4A   0xD001             BEQ      ??HAL_SPI_TransmitReceive_2
   1155            {
   1156              errorcode = HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \       0x4C   0x2002             MOVS     R0,#+2
   \       0x4E   0xE072             B.N      ??HAL_SPI_TransmitReceive_4
   1157              goto error;
   1158            }
   1159          
   1160            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \       0x50   0x2F00             CMP      R7,#+0
   \       0x52   0xD003             BEQ      ??HAL_SPI_TransmitReceive_5
   \       0x54   0x2D00             CMP      R5,#+0
   \       0x56   0xD001             BEQ      ??HAL_SPI_TransmitReceive_5
   \       0x58   0x0031             MOVS     R1,R6
   \       0x5A   0xD101             BNE      ??HAL_SPI_TransmitReceive_6
   1161            {
   1162              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0xE06A             B.N      ??HAL_SPI_TransmitReceive_4
   1163              goto error;
   1164            }
   1165          
   1166            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1167            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \       0x60   0x0021             MOVS     R1,R4
   \       0x62   0x3150             ADDS     R1,R1,#+80
   \       0x64   0x7849             LDRB     R1,[R1, #+1]
   \       0x66   0x2904             CMP      R1,#+4
   \       0x68   0xD003             BEQ      ??HAL_SPI_TransmitReceive_7
   1168            {
   1169              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \       0x6A   0x2105             MOVS     R1,#+5
   \       0x6C   0x0022             MOVS     R2,R4
   \       0x6E   0x3250             ADDS     R2,R2,#+80
   \       0x70   0x7051             STRB     R1,[R2, #+1]
   1170            }
   1171          
   1172            /* Set the transaction information */
   1173            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \       0x72   0x2100             MOVS     R1,#+0
   \       0x74   0x0022             MOVS     R2,R4
   \       0x76   0x3250             ADDS     R2,R2,#+80
   \       0x78   0x6051             STR      R1,[R2, #+4]
   1174            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \       0x7A   0x63A5             STR      R5,[R4, #+56]
   1175            hspi->RxXferCount = Size;
   \       0x7C   0x87E6             STRH     R6,[R4, #+62]
   1176            hspi->RxXferSize  = Size;
   \       0x7E   0x87A6             STRH     R6,[R4, #+60]
   1177            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \       0x80   0x6327             STR      R7,[R4, #+48]
   1178            hspi->TxXferCount = Size;
   \       0x82   0x86E6             STRH     R6,[R4, #+54]
   1179            hspi->TxXferSize  = Size;
   \       0x84   0x86A6             STRH     R6,[R4, #+52]
   1180          
   1181            /*Init field not used in handle to zero */
   1182            hspi->RxISR       = NULL;
   \       0x86   0x6421             STR      R1,[R4, #+64]
   1183            hspi->TxISR       = NULL;
   \       0x88   0x6461             STR      R1,[R4, #+68]
   1184          
   1185          #if (USE_SPI_CRC != 0U)
   1186            /* Reset CRC Calculation */
   1187            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1188            {
   1189              SPI_RESET_CRC(hspi);
   1190            }
   1191          #endif /* USE_SPI_CRC */
   1192          
   1193            /* Check if the SPI is already enabled */
   1194            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \       0x8A   0x6821             LDR      R1,[R4, #+0]
   \       0x8C   0x2240             MOVS     R2,#+64
   \       0x8E   0x680B             LDR      R3,[R1, #+0]
   \       0x90   0x4013             ANDS     R3,R3,R2
   \       0x92   0xD102             BNE      ??HAL_SPI_TransmitReceive_8
   1195            {
   1196              /* Enable SPI peripheral */
   1197              __HAL_SPI_ENABLE(hspi);
   \       0x94   0x680B             LDR      R3,[R1, #+0]
   \       0x96   0x431A             ORRS     R2,R2,R3
   \       0x98   0x600A             STR      R2,[R1, #+0]
   1198            }
   1199          
   1200            /* Transmit and Receive data in 16 Bit mode */
   1201            if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \       0x9A   0x2100             MOVS     R1,#+0
   \       0x9C   0x9102             STR      R1,[SP, #+8]
   \       0x9E   0x9F0A             LDR      R7,[SP, #+40]
   \       0xA0   0x68E1             LDR      R1,[R4, #+12]
   \       0xA2   0x2280             MOVS     R2,#+128
   \       0xA4   0x0112             LSLS     R2,R2,#+4        ;; #+2048
   \       0xA6   0x4291             CMP      R1,R2
   \       0xA8   0x6861             LDR      R1,[R4, #+4]
   \       0xAA   0xD147             BNE      ??HAL_SPI_TransmitReceive_9
   1202            {
   1203              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   \       0xAC   0x2900             CMP      R1,#+0
   \       0xAE   0xD001             BEQ      ??HAL_SPI_TransmitReceive_10
   \       0xB0   0x2E01             CMP      R6,#+1
   \       0xB2   0xD109             BNE      ??HAL_SPI_TransmitReceive_11
   1204              {
   1205                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \       0xB4   0x6B20             LDR      R0,[R4, #+48]
   \       0xB6   0x8800             LDRH     R0,[R0, #+0]
   \       0xB8   0x6821             LDR      R1,[R4, #+0]
   \       0xBA   0x60C8             STR      R0,[R1, #+12]
   1206                hspi->pTxBuffPtr += sizeof(uint16_t);
   \       0xBC   0x6B20             LDR      R0,[R4, #+48]
   \       0xBE   0x1C80             ADDS     R0,R0,#+2
   \       0xC0   0x6320             STR      R0,[R4, #+48]
   1207                hspi->TxXferCount--;
   \       0xC2   0x8EE0             LDRH     R0,[R4, #+54]
   \       0xC4   0x1E40             SUBS     R0,R0,#+1
   \       0xC6   0x86E0             STRH     R0,[R4, #+54]
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \       0xC8   0x9E03             LDR      R6,[SP, #+12]
   \       0xCA   0x9D01             LDR      R5,[SP, #+4]
   1208              }
   1209              while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \       0xCC   0x8EE0             LDRH     R0,[R4, #+54]
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD102             BNE      ??HAL_SPI_TransmitReceive_13
   \       0xD2   0x8FE0             LDRH     R0,[R4, #+62]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD079             BEQ      ??HAL_SPI_TransmitReceive_14
   1210              {
   1211                /* Check TXE flag */
   1212                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
   \                     ??HAL_SPI_TransmitReceive_13: (+1)
   \       0xD8   0x6821             LDR      R1,[R4, #+0]
   \       0xDA   0x....             LDR      R0,??DataTable4  ;; 0xffff
   \       0xDC   0x688A             LDR      R2,[R1, #+8]
   \       0xDE   0x0792             LSLS     R2,R2,#+30
   \       0xE0   0xD50E             BPL      ??HAL_SPI_TransmitReceive_15
   \       0xE2   0x8EE2             LDRH     R2,[R4, #+54]
   \       0xE4   0x2A00             CMP      R2,#+0
   \       0xE6   0xD00B             BEQ      ??HAL_SPI_TransmitReceive_15
   \       0xE8   0x2E00             CMP      R6,#+0
   \       0xEA   0xD009             BEQ      ??HAL_SPI_TransmitReceive_15
   1213                {
   1214                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \       0xEC   0x6B22             LDR      R2,[R4, #+48]
   \       0xEE   0x8812             LDRH     R2,[R2, #+0]
   \       0xF0   0x60CA             STR      R2,[R1, #+12]
   1215                  hspi->pTxBuffPtr += sizeof(uint16_t);
   \       0xF2   0x6B21             LDR      R1,[R4, #+48]
   \       0xF4   0x1C89             ADDS     R1,R1,#+2
   \       0xF6   0x6321             STR      R1,[R4, #+48]
   1216                  hspi->TxXferCount--;
   \       0xF8   0x8EE1             LDRH     R1,[R4, #+54]
   \       0xFA   0x1809             ADDS     R1,R1,R0
   \       0xFC   0x86E1             STRH     R1,[R4, #+54]
   1217                  /* Next Data is a reception (Rx). Tx not allowed */
   1218                  txallowed = 0U;
   \       0xFE   0x9E02             LDR      R6,[SP, #+8]
   1219          
   1220          #if (USE_SPI_CRC != 0U)
   1221                  /* Enable CRC Transmission */
   1222                  if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   1223                  {
   1224                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1225                  }
   1226          #endif /* USE_SPI_CRC */
   1227                }
   1228          
   1229                /* Check RXNE flag */
   1230                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
   \                     ??HAL_SPI_TransmitReceive_15: (+1)
   \      0x100   0x6821             LDR      R1,[R4, #+0]
   \      0x102   0x688A             LDR      R2,[R1, #+8]
   \      0x104   0x07D2             LSLS     R2,R2,#+31
   \      0x106   0xD50C             BPL      ??HAL_SPI_TransmitReceive_16
   \      0x108   0x8FE2             LDRH     R2,[R4, #+62]
   \      0x10A   0x2A00             CMP      R2,#+0
   \      0x10C   0xD009             BEQ      ??HAL_SPI_TransmitReceive_16
   1231                {
   1232                  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   \      0x10E   0x68C9             LDR      R1,[R1, #+12]
   \      0x110   0x6BA2             LDR      R2,[R4, #+56]
   \      0x112   0x8011             STRH     R1,[R2, #+0]
   1233                  hspi->pRxBuffPtr += sizeof(uint16_t);
   \      0x114   0x6BA1             LDR      R1,[R4, #+56]
   \      0x116   0x1C89             ADDS     R1,R1,#+2
   \      0x118   0x63A1             STR      R1,[R4, #+56]
   1234                  hspi->RxXferCount--;
   \      0x11A   0x8FE1             LDRH     R1,[R4, #+62]
   \      0x11C   0x1808             ADDS     R0,R1,R0
   \      0x11E   0x87E0             STRH     R0,[R4, #+62]
   1235                  /* Next Data is a Transmission (Tx). Tx is allowed */
   1236                  txallowed = 1U;
   \      0x120   0x2601             MOVS     R6,#+1
   1237                }
   1238                if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
   \                     ??HAL_SPI_TransmitReceive_16: (+1)
   \      0x122   0x....'....        BL       HAL_GetTick
   \      0x126   0x1B40             SUBS     R0,R0,R5
   \      0x128   0x42B8             CMP      R0,R7
   \      0x12A   0xD3CF             BCC      ??HAL_SPI_TransmitReceive_12
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x130   0x4287             CMP      R7,R0
   \      0x132   0xD0CB             BEQ      ??HAL_SPI_TransmitReceive_12
   1239                {
   1240                  errorcode = HAL_TIMEOUT;
   1241                  goto error;
   1242                }
   1243              }
   1244            }
   1245            /* Transmit and Receive data in 8 Bit mode */
   1246            else
   1247            {
   1248              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   1249              {
   1250                *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
   1251                hspi->pTxBuffPtr += sizeof(uint8_t);
   1252                hspi->TxXferCount--;
   1253              }
   1254              while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
   1255              {
   1256                /* Check TXE flag */
   1257                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
   1258                {
   1259                  *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   1260                  hspi->pTxBuffPtr++;
   1261                  hspi->TxXferCount--;
   1262                  /* Next Data is a reception (Rx). Tx not allowed */
   1263                  txallowed = 0U;
   1264          
   1265          #if (USE_SPI_CRC != 0U)
   1266                  /* Enable CRC Transmission */
   1267                  if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   1268                  {
   1269                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1270                  }
   1271          #endif /* USE_SPI_CRC */
   1272                }
   1273          
   1274                /* Wait until RXNE flag is reset */
   1275                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
   1276                {
   1277                  (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
   1278                  hspi->pRxBuffPtr++;
   1279                  hspi->RxXferCount--;
   1280                  /* Next Data is a Transmission (Tx). Tx is allowed */
   1281                  txallowed = 1U;
   1282                }
   1283                if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
   1284                {
   1285                  errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_TransmitReceive_17: (+1)
   \      0x134   0x2003             MOVS     R0,#+3
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \      0x136   0x4669             MOV      R1,SP
   \      0x138   0x7008             STRB     R0,[R1, #+0]
   1286                  goto error;
   \      0x13A   0xE061             B        ??HAL_SPI_TransmitReceive_18
   1287                }
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \      0x13C   0x2900             CMP      R1,#+0
   \      0x13E   0xD001             BEQ      ??HAL_SPI_TransmitReceive_19
   \      0x140   0x2E01             CMP      R6,#+1
   \      0x142   0xD109             BNE      ??HAL_SPI_TransmitReceive_20
   \                     ??HAL_SPI_TransmitReceive_19: (+1)
   \      0x144   0x6B20             LDR      R0,[R4, #+48]
   \      0x146   0x7800             LDRB     R0,[R0, #+0]
   \      0x148   0x6821             LDR      R1,[R4, #+0]
   \      0x14A   0x7308             STRB     R0,[R1, #+12]
   \      0x14C   0x6B20             LDR      R0,[R4, #+48]
   \      0x14E   0x1C40             ADDS     R0,R0,#+1
   \      0x150   0x6320             STR      R0,[R4, #+48]
   \      0x152   0x8EE0             LDRH     R0,[R4, #+54]
   \      0x154   0x1E40             SUBS     R0,R0,#+1
   \      0x156   0x86E0             STRH     R0,[R4, #+54]
   \                     ??HAL_SPI_TransmitReceive_20: (+1)
   \      0x158   0x9E03             LDR      R6,[SP, #+12]
   \      0x15A   0x9D01             LDR      R5,[SP, #+4]
   \                     ??HAL_SPI_TransmitReceive_21: (+1)
   \      0x15C   0x8EE0             LDRH     R0,[R4, #+54]
   \      0x15E   0x2800             CMP      R0,#+0
   \      0x160   0xD102             BNE      ??HAL_SPI_TransmitReceive_22
   \      0x162   0x8FE0             LDRH     R0,[R4, #+62]
   \      0x164   0x2800             CMP      R0,#+0
   \      0x166   0xD031             BEQ      ??HAL_SPI_TransmitReceive_14
   \                     ??HAL_SPI_TransmitReceive_22: (+1)
   \      0x168   0x6821             LDR      R1,[R4, #+0]
   \      0x16A   0x....             LDR      R0,??DataTable4  ;; 0xffff
   \      0x16C   0x688A             LDR      R2,[R1, #+8]
   \      0x16E   0x0792             LSLS     R2,R2,#+30
   \      0x170   0xD50E             BPL      ??HAL_SPI_TransmitReceive_23
   \      0x172   0x8EE2             LDRH     R2,[R4, #+54]
   \      0x174   0x2A00             CMP      R2,#+0
   \      0x176   0xD00B             BEQ      ??HAL_SPI_TransmitReceive_23
   \      0x178   0x2E00             CMP      R6,#+0
   \      0x17A   0xD009             BEQ      ??HAL_SPI_TransmitReceive_23
   \      0x17C   0x6B22             LDR      R2,[R4, #+48]
   \      0x17E   0x7812             LDRB     R2,[R2, #+0]
   \      0x180   0x730A             STRB     R2,[R1, #+12]
   \      0x182   0x6B21             LDR      R1,[R4, #+48]
   \      0x184   0x1C49             ADDS     R1,R1,#+1
   \      0x186   0x6321             STR      R1,[R4, #+48]
   \      0x188   0x8EE1             LDRH     R1,[R4, #+54]
   \      0x18A   0x1809             ADDS     R1,R1,R0
   \      0x18C   0x86E1             STRH     R1,[R4, #+54]
   \      0x18E   0x9E02             LDR      R6,[SP, #+8]
   \                     ??HAL_SPI_TransmitReceive_23: (+1)
   \      0x190   0x6821             LDR      R1,[R4, #+0]
   \      0x192   0x688A             LDR      R2,[R1, #+8]
   \      0x194   0x07D2             LSLS     R2,R2,#+31
   \      0x196   0xD50C             BPL      ??HAL_SPI_TransmitReceive_24
   \      0x198   0x8FE2             LDRH     R2,[R4, #+62]
   \      0x19A   0x2A00             CMP      R2,#+0
   \      0x19C   0xD009             BEQ      ??HAL_SPI_TransmitReceive_24
   \      0x19E   0x68C9             LDR      R1,[R1, #+12]
   \      0x1A0   0x6BA2             LDR      R2,[R4, #+56]
   \      0x1A2   0x7011             STRB     R1,[R2, #+0]
   \      0x1A4   0x6BA1             LDR      R1,[R4, #+56]
   \      0x1A6   0x1C49             ADDS     R1,R1,#+1
   \      0x1A8   0x63A1             STR      R1,[R4, #+56]
   \      0x1AA   0x8FE1             LDRH     R1,[R4, #+62]
   \      0x1AC   0x1808             ADDS     R0,R1,R0
   \      0x1AE   0x87E0             STRH     R0,[R4, #+62]
   \      0x1B0   0x2601             MOVS     R6,#+1
   \                     ??HAL_SPI_TransmitReceive_24: (+1)
   \      0x1B2   0x....'....        BL       HAL_GetTick
   \      0x1B6   0x1B40             SUBS     R0,R0,R5
   \      0x1B8   0x42B8             CMP      R0,R7
   \      0x1BA   0xD304             BCC      ??HAL_SPI_TransmitReceive_25
   \      0x1BC   0x2000             MOVS     R0,#+0
   \      0x1BE   0x43C0             MVNS     R0,R0            ;; #-1
   \      0x1C0   0x4287             CMP      R7,R0
   \      0x1C2   0xD1B7             BNE      ??HAL_SPI_TransmitReceive_17
   \      0x1C4   0xE7CA             B        ??HAL_SPI_TransmitReceive_21
   \                     ??HAL_SPI_TransmitReceive_25: (+1)
   \      0x1C6   0x2F00             CMP      R7,#+0
   \      0x1C8   0xD1C8             BNE      ??HAL_SPI_TransmitReceive_21
   \      0x1CA   0xE7B3             B        ??HAL_SPI_TransmitReceive_17
   1288              }
   1289            }
   \                     ??HAL_SPI_TransmitReceive_14: (+1)
   \      0x1CC   0x0039             MOVS     R1,R7
   \      0x1CE   0x002A             MOVS     R2,R5
   1290          
   1291          #if (USE_SPI_CRC != 0U)
   1292            /* Read CRC from DR to close CRC calculation process */
   1293            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1294            {
   1295              /* Wait until TXE flag */
   1296              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1297              {
   1298                /* Error on the CRC reception */
   1299                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1300                errorcode = HAL_TIMEOUT;
   1301                goto error;
   1302              }
   1303              /* Read CRC */
   1304              READ_REG(hspi->Instance->DR);
   1305            }
   1306          
   1307            /* Check if CRC error occurred */
   1308            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   1309            {
   1310              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1311              /* Clear CRC Flag */
   1312              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   1313          
   1314              errorcode = HAL_ERROR;
   1315            }
   1316          #endif /* USE_SPI_CRC */
   1317          
   1318            /* Check the end of the transaction */
   1319            if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
   \      0x1D0   0x0020             MOVS     R0,R4
   \      0x1D2   0x....'....        BL       SPI_EndRxTxTransaction
   \      0x1D6   0x2800             CMP      R0,#+0
   \      0x1D8   0xD007             BEQ      ??HAL_SPI_TransmitReceive_26
   1320            {
   1321              errorcode = HAL_ERROR;
   \      0x1DA   0x2001             MOVS     R0,#+1
   \      0x1DC   0x4669             MOV      R1,SP
   \      0x1DE   0x7008             STRB     R0,[R1, #+0]
   1322              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \      0x1E0   0x2020             MOVS     R0,#+32
   \      0x1E2   0x0021             MOVS     R1,R4
   \      0x1E4   0x3150             ADDS     R1,R1,#+80
   \      0x1E6   0x6048             STR      R0,[R1, #+4]
   1323              goto error;
   \      0x1E8   0xE00A             B        ??HAL_SPI_TransmitReceive_18
   1324            }
   1325          
   1326            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   1327            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_TransmitReceive_26: (+1)
   \      0x1EA   0x68A0             LDR      R0,[R4, #+8]
   \      0x1EC   0x2800             CMP      R0,#+0
   \      0x1EE   0xD107             BNE      ??HAL_SPI_TransmitReceive_18
   1328            {
   1329              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \      0x1F0   0x9802             LDR      R0,[SP, #+8]
   \      0x1F2   0x9001             STR      R0,[SP, #+4]
   \      0x1F4   0x6820             LDR      R0,[R4, #+0]
   \      0x1F6   0x68C1             LDR      R1,[R0, #+12]
   \      0x1F8   0x9101             STR      R1,[SP, #+4]
   \      0x1FA   0x6880             LDR      R0,[R0, #+8]
   \      0x1FC   0x9001             STR      R0,[SP, #+4]
   \      0x1FE   0x9801             LDR      R0,[SP, #+4]
   1330            }
   1331          
   1332          error :
   1333            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_TransmitReceive_18: (+1)
   \      0x200   0x0020             MOVS     R0,R4
   \      0x202   0x3050             ADDS     R0,R0,#+80
   \      0x204   0x2101             MOVS     R1,#+1
   \      0x206   0x7041             STRB     R1,[R0, #+1]
   1334            __HAL_UNLOCK(hspi);
   \      0x208   0x2100             MOVS     R1,#+0
   \      0x20A   0x7001             STRB     R1,[R0, #+0]
   1335            return errorcode;
   \      0x20C   0x4668             MOV      R0,SP
   \      0x20E   0x7800             LDRB     R0,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \      0x210   0xB005             ADD      SP,SP,#+20
   \      0x212   0xBDF0             POP      {R4-R7,PC}       ;; return
   1336          }
   1337          
   1338          /**
   1339            * @brief  Transmit an amount of data in non-blocking mode with Interrupt.
   1340            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1341            *               the configuration information for SPI module.
   1342            * @param  pData pointer to data buffer
   1343            * @param  Size amount of data to be sent
   1344            * @retval HAL status
   1345            */

   \                                 In section .text, align 2, keep-with-next
   1346          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1347          {
   \                     HAL_SPI_Transmit_IT: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x000B             MOVS     R3,R1
   1348            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   1349          
   1350            if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (Size > 1U)))
   1351            {
   1352              /* in this case, 16-bit access is performed on Data
   1353                 So, check Data is 16-bit aligned address */
   1354              assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pData));
   1355            }
   1356          
   1357            /* Check Direction parameter */
   1358            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1359          
   1360            /* Process Locked */
   1361            __HAL_LOCK(hspi);
   \        0x8   0x2550             MOVS     R5,#+80
   \        0xA   0x5D45             LDRB     R5,[R0, R5]
   \        0xC   0x2D01             CMP      R5,#+1
   \        0xE   0xD101             BNE      ??HAL_SPI_Transmit_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \       0x14   0x0005             MOVS     R5,R0
   \       0x16   0x3550             ADDS     R5,R5,#+80
   \       0x18   0x2601             MOVS     R6,#+1
   \       0x1A   0x702E             STRB     R6,[R5, #+0]
   1362          
   1363            if ((pData == NULL) || (Size == 0U))
   \       0x1C   0x2B00             CMP      R3,#+0
   \       0x1E   0xD001             BEQ      ??HAL_SPI_Transmit_IT_1
   \       0x20   0x0017             MOVS     R7,R2
   \       0x22   0xD101             BNE      ??HAL_SPI_Transmit_IT_2
   1364            {
   1365              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \       0x24   0x2101             MOVS     R1,#+1
   1366              goto error;
   \       0x26   0xE02D             B        ??HAL_SPI_Transmit_IT_3
   1367            }
   1368          
   1369            if (hspi->State != HAL_SPI_STATE_READY)
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \       0x28   0x786E             LDRB     R6,[R5, #+1]
   \       0x2A   0x2E01             CMP      R6,#+1
   \       0x2C   0xD001             BEQ      ??HAL_SPI_Transmit_IT_4
   1370            {
   1371              errorcode = HAL_BUSY;
   \       0x2E   0x2102             MOVS     R1,#+2
   1372              goto error;
   \       0x30   0xE028             B        ??HAL_SPI_Transmit_IT_3
   1373            }
   1374          
   1375            /* Set the transaction information */
   1376            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \                     ??HAL_SPI_Transmit_IT_4: (+1)
   \       0x32   0x2603             MOVS     R6,#+3
   \       0x34   0x706E             STRB     R6,[R5, #+1]
   1377            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x36   0x606C             STR      R4,[R5, #+4]
   1378            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \       0x38   0x6303             STR      R3,[R0, #+48]
   1379            hspi->TxXferSize  = Size;
   \       0x3A   0x8682             STRH     R2,[R0, #+52]
   1380            hspi->TxXferCount = Size;
   \       0x3C   0x86C2             STRH     R2,[R0, #+54]
   1381          
   1382            /* Init field not used in handle to zero */
   1383            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \       0x3E   0x6384             STR      R4,[R0, #+56]
   1384            hspi->RxXferSize  = 0U;
   \       0x40   0x8784             STRH     R4,[R0, #+60]
   1385            hspi->RxXferCount = 0U;
   \       0x42   0x87C4             STRH     R4,[R0, #+62]
   1386            hspi->RxISR       = NULL;
   \       0x44   0x6404             STR      R4,[R0, #+64]
   1387          
   1388            /* Set the function for IT treatment */
   1389            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \       0x46   0x68C2             LDR      R2,[R0, #+12]
   \       0x48   0x2A00             CMP      R2,#+0
   \       0x4A   0xD001             BEQ      ??HAL_SPI_Transmit_IT_5
   1390            {
   1391              hspi->TxISR = SPI_TxISR_16BIT;
   \       0x4C   0x....             LDR      R2,??DataTable6
   \       0x4E   0xE000             B        ??HAL_SPI_Transmit_IT_6
   1392            }
   1393            else
   1394            {
   1395              hspi->TxISR = SPI_TxISR_8BIT;
   \                     ??HAL_SPI_Transmit_IT_5: (+1)
   \       0x50   0x....             LDR      R2,??DataTable6_1
   \                     ??HAL_SPI_Transmit_IT_6: (+1)
   \       0x52   0x6442             STR      R2,[R0, #+68]
   1396            }
   1397          
   1398            /* Configure communication direction : 1Line */
   1399            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x54   0x6882             LDR      R2,[R0, #+8]
   \       0x56   0x2380             MOVS     R3,#+128
   \       0x58   0x021B             LSLS     R3,R3,#+8        ;; #+32768
   \       0x5A   0x429A             CMP      R2,R3
   \       0x5C   0xD105             BNE      ??HAL_SPI_Transmit_IT_7
   1400            {
   1401              SPI_1LINE_TX(hspi);
   \       0x5E   0x6802             LDR      R2,[R0, #+0]
   \       0x60   0x6813             LDR      R3,[R2, #+0]
   \       0x62   0x2680             MOVS     R6,#+128
   \       0x64   0x01F6             LSLS     R6,R6,#+7        ;; #+16384
   \       0x66   0x431E             ORRS     R6,R6,R3
   \       0x68   0x6016             STR      R6,[R2, #+0]
   1402            }
   1403          
   1404          #if (USE_SPI_CRC != 0U)
   1405            /* Reset CRC Calculation */
   1406            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1407            {
   1408              SPI_RESET_CRC(hspi);
   1409            }
   1410          #endif /* USE_SPI_CRC */
   1411          
   1412            /* Enable TXE and ERR interrupt */
   1413            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \                     ??HAL_SPI_Transmit_IT_7: (+1)
   \       0x6A   0x6802             LDR      R2,[R0, #+0]
   \       0x6C   0x6853             LDR      R3,[R2, #+4]
   \       0x6E   0x26A0             MOVS     R6,#+160
   \       0x70   0x431E             ORRS     R6,R6,R3
   \       0x72   0x6056             STR      R6,[R2, #+4]
   1414          
   1415          
   1416            /* Check if the SPI is already enabled */
   1417            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \       0x74   0x6800             LDR      R0,[R0, #+0]
   \       0x76   0x2240             MOVS     R2,#+64
   \       0x78   0x6803             LDR      R3,[R0, #+0]
   \       0x7A   0x4013             ANDS     R3,R3,R2
   \       0x7C   0xD102             BNE      ??HAL_SPI_Transmit_IT_3
   1418            {
   1419              /* Enable SPI peripheral */
   1420              __HAL_SPI_ENABLE(hspi);
   \       0x7E   0x6803             LDR      R3,[R0, #+0]
   \       0x80   0x431A             ORRS     R2,R2,R3
   \       0x82   0x6002             STR      R2,[R0, #+0]
   1421            }
   1422          
   1423          error :
   1424            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_3: (+1)
   \       0x84   0x702C             STRB     R4,[R5, #+0]
   1425            return errorcode;
   \       0x86   0x0008             MOVS     R0,R1
   \       0x88   0xBDF0             POP      {R4-R7,PC}       ;; return
   1426          }
   1427          
   1428          /**
   1429            * @brief  Receive an amount of data in non-blocking mode with Interrupt.
   1430            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1431            *               the configuration information for SPI module.
   1432            * @param  pData pointer to data buffer
   1433            * @param  Size amount of data to be sent
   1434            * @retval HAL status
   1435            */

   \                                 In section .text, align 2, keep-with-next
   1436          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1437          {
   \                     HAL_SPI_Receive_IT: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   1438            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   1439          
   1440            if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (Size > 1U)))
   1441            {
   1442              /* in this case, 16-bit access is performed on Data
   1443                 So, check Data is 16-bit aligned address */
   1444              assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pData));
   1445            }
   1446          
   1447            if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   \        0x8   0x6884             LDR      R4,[R0, #+8]
   \        0xA   0x9400             STR      R4,[SP, #+0]
   \        0xC   0x0004             MOVS     R4,R0
   \        0xE   0x3450             ADDS     R4,R4,#+80
   \       0x10   0x2504             MOVS     R5,#+4
   \       0x12   0x9E00             LDR      R6,[SP, #+0]
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD10B             BNE      ??HAL_SPI_Receive_IT_0
   \       0x18   0x6846             LDR      R6,[R0, #+4]
   \       0x1A   0x2782             MOVS     R7,#+130
   \       0x1C   0x007F             LSLS     R7,R7,#+1        ;; #+260
   \       0x1E   0x42BE             CMP      R6,R7
   \       0x20   0xD106             BNE      ??HAL_SPI_Receive_IT_0
   1448            {
   1449              hspi->State = HAL_SPI_STATE_BUSY_RX;
   \       0x22   0x7065             STRB     R5,[R4, #+1]
   1450              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1451              return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
   \       0x24   0x0013             MOVS     R3,R2
   \       0x26   0x9A02             LDR      R2,[SP, #+8]
   \       0x28   0x4611             MOV      R1,R2
   \       0x2A   0x....'....        BL       HAL_SPI_TransmitReceive_IT
   \       0x2E   0xBDFE             POP      {R1-R7,PC}
   1452            }
   1453          
   1454            /* Process Locked */
   1455            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \       0x30   0x2650             MOVS     R6,#+80
   \       0x32   0x5D86             LDRB     R6,[R0, R6]
   \       0x34   0x2E01             CMP      R6,#+1
   \       0x36   0xD101             BNE      ??HAL_SPI_Receive_IT_1
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \       0x3C   0x2601             MOVS     R6,#+1
   \       0x3E   0x7026             STRB     R6,[R4, #+0]
   1456          
   1457            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x40   0x7867             LDRB     R7,[R4, #+1]
   \       0x42   0x2F01             CMP      R7,#+1
   \       0x44   0xD001             BEQ      ??HAL_SPI_Receive_IT_2
   1458            {
   1459              errorcode = HAL_BUSY;
   \       0x46   0x2102             MOVS     R1,#+2
   1460              goto error;
   \       0x48   0xE02D             B        ??HAL_SPI_Receive_IT_3
   1461            }
   1462          
   1463            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \       0x4A   0x9F02             LDR      R7,[SP, #+8]
   \       0x4C   0x2F00             CMP      R7,#+0
   \       0x4E   0xD001             BEQ      ??HAL_SPI_Receive_IT_4
   \       0x50   0x0017             MOVS     R7,R2
   \       0x52   0xD101             BNE      ??HAL_SPI_Receive_IT_5
   1464            {
   1465              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Receive_IT_4: (+1)
   \       0x54   0x2101             MOVS     R1,#+1
   1466              goto error;
   \       0x56   0xE026             B        ??HAL_SPI_Receive_IT_3
   1467            }
   1468          
   1469            /* Set the transaction information */
   1470            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \                     ??HAL_SPI_Receive_IT_5: (+1)
   \       0x58   0x7065             STRB     R5,[R4, #+1]
   1471            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x5A   0x6063             STR      R3,[R4, #+4]
   1472            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \       0x5C   0x9D02             LDR      R5,[SP, #+8]
   \       0x5E   0x6385             STR      R5,[R0, #+56]
   1473            hspi->RxXferSize  = Size;
   \       0x60   0x8782             STRH     R2,[R0, #+60]
   1474            hspi->RxXferCount = Size;
   \       0x62   0x87C2             STRH     R2,[R0, #+62]
   1475          
   1476            /* Init field not used in handle to zero */
   1477            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \       0x64   0x6303             STR      R3,[R0, #+48]
   1478            hspi->TxXferSize  = 0U;
   \       0x66   0x8683             STRH     R3,[R0, #+52]
   1479            hspi->TxXferCount = 0U;
   \       0x68   0x86C3             STRH     R3,[R0, #+54]
   1480            hspi->TxISR       = NULL;
   \       0x6A   0x6443             STR      R3,[R0, #+68]
   1481          
   1482            /* Set the function for IT treatment */
   1483            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \       0x6C   0x68C2             LDR      R2,[R0, #+12]
   \       0x6E   0x2A00             CMP      R2,#+0
   \       0x70   0xD001             BEQ      ??HAL_SPI_Receive_IT_6
   1484            {
   1485              hspi->RxISR = SPI_RxISR_16BIT;
   \       0x72   0x....             LDR      R2,??DataTable7
   \       0x74   0xE000             B        ??HAL_SPI_Receive_IT_7
   1486            }
   1487            else
   1488            {
   1489              hspi->RxISR = SPI_RxISR_8BIT;
   \                     ??HAL_SPI_Receive_IT_6: (+1)
   \       0x76   0x....             LDR      R2,??DataTable7_1
   \                     ??HAL_SPI_Receive_IT_7: (+1)
   \       0x78   0x6402             STR      R2,[R0, #+64]
   1490            }
   1491          
   1492            /* Configure communication direction : 1Line */
   1493            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x7A   0x9A00             LDR      R2,[SP, #+0]
   \       0x7C   0x03F5             LSLS     R5,R6,#+15
   \       0x7E   0x42AA             CMP      R2,R5
   \       0x80   0xD104             BNE      ??HAL_SPI_Receive_IT_8
   1494            {
   1495              SPI_1LINE_RX(hspi);
   \       0x82   0x6802             LDR      R2,[R0, #+0]
   \       0x84   0x6815             LDR      R5,[R2, #+0]
   \       0x86   0x....             LDR      R6,??DataTable7_2  ;; 0xffffbfff
   \       0x88   0x402E             ANDS     R6,R6,R5
   \       0x8A   0x6016             STR      R6,[R2, #+0]
   1496            }
   1497          
   1498          #if (USE_SPI_CRC != 0U)
   1499            /* Reset CRC Calculation */
   1500            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1501            {
   1502              SPI_RESET_CRC(hspi);
   1503            }
   1504          #endif /* USE_SPI_CRC */
   1505          
   1506            /* Enable TXE and ERR interrupt */
   1507            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_IT_8: (+1)
   \       0x8C   0x6802             LDR      R2,[R0, #+0]
   \       0x8E   0x6855             LDR      R5,[R2, #+4]
   \       0x90   0x2660             MOVS     R6,#+96
   \       0x92   0x432E             ORRS     R6,R6,R5
   \       0x94   0x6056             STR      R6,[R2, #+4]
   1508          
   1509            /* Note : The SPI must be enabled after unlocking current process
   1510                      to avoid the risk of SPI interrupt handle execution before current
   1511                      process unlock */
   1512          
   1513            /* Check if the SPI is already enabled */
   1514            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \       0x96   0x6800             LDR      R0,[R0, #+0]
   \       0x98   0x2240             MOVS     R2,#+64
   \       0x9A   0x6805             LDR      R5,[R0, #+0]
   \       0x9C   0x4015             ANDS     R5,R5,R2
   \       0x9E   0xD102             BNE      ??HAL_SPI_Receive_IT_3
   1515            {
   1516              /* Enable SPI peripheral */
   1517              __HAL_SPI_ENABLE(hspi);
   \       0xA0   0x6805             LDR      R5,[R0, #+0]
   \       0xA2   0x432A             ORRS     R2,R2,R5
   \       0xA4   0x6002             STR      R2,[R0, #+0]
   1518            }
   1519          
   1520          error :
   1521            /* Process Unlocked */
   1522            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \       0xA6   0x7023             STRB     R3,[R4, #+0]
   1523            return errorcode;
   \       0xA8   0x0008             MOVS     R0,R1
   \       0xAA   0xBDFE             POP      {R1-R7,PC}       ;; return
   1524          }
   1525          
   1526          /**
   1527            * @brief  Transmit and Receive an amount of data in non-blocking mode with Interrupt.
   1528            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1529            *               the configuration information for SPI module.
   1530            * @param  pTxData pointer to transmission data buffer
   1531            * @param  pRxData pointer to reception data buffer
   1532            * @param  Size amount of data to be sent and received
   1533            * @retval HAL status
   1534            */

   \                                 In section .text, align 2, keep-with-next
   1535          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1536          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \        0x0   0xB5F6             PUSH     {R1,R2,R4-R7,LR}
   1537            uint32_t             tmp_mode;
   1538            HAL_SPI_StateTypeDef tmp_state;
   1539            HAL_StatusTypeDef    errorcode = HAL_OK;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2100             MOVS     R1,#+0
   1540          
   1541            if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (Size > 1U)))
   1542            {
   1543              /* in this case, 16-bit access is performed on Data
   1544                 So, check Data is 16-bit aligned address */
   1545              assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pTxData));
   1546              assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pRxData));
   1547            }
   1548          
   1549            /* Check Direction parameter */
   1550            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1551          
   1552            /* Process locked */
   1553            __HAL_LOCK(hspi);
   \        0x6   0x2450             MOVS     R4,#+80
   \        0x8   0x5D04             LDRB     R4,[R0, R4]
   \        0xA   0x2C01             CMP      R4,#+1
   \        0xC   0xD101             BNE      ??HAL_SPI_TransmitReceive_IT_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xBDF6             POP      {R1,R2,R4-R7,PC}
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \       0x12   0x2401             MOVS     R4,#+1
   \       0x14   0x2650             MOVS     R6,#+80
   \       0x16   0x5584             STRB     R4,[R0, R6]
   1554          
   1555            /* Init temporary variables */
   1556            tmp_state           = hspi->State;
   \       0x18   0x0005             MOVS     R5,R0
   \       0x1A   0x3550             ADDS     R5,R5,#+80
   \       0x1C   0x786D             LDRB     R5,[R5, #+1]
   1557            tmp_mode            = hspi->Init.Mode;
   1558          
   1559            if (!((tmp_state == HAL_SPI_STATE_READY) || \
   1560                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   \       0x1E   0x2D01             CMP      R5,#+1
   \       0x20   0xD00B             BEQ      ??HAL_SPI_TransmitReceive_IT_1
   \       0x22   0x6846             LDR      R6,[R0, #+4]
   \       0x24   0x2782             MOVS     R7,#+130
   \       0x26   0x007F             LSLS     R7,R7,#+1        ;; #+260
   \       0x28   0x42BE             CMP      R6,R7
   \       0x2A   0xD104             BNE      ??HAL_SPI_TransmitReceive_IT_2
   \       0x2C   0x6886             LDR      R6,[R0, #+8]
   \       0x2E   0x2E00             CMP      R6,#+0
   \       0x30   0xD101             BNE      ??HAL_SPI_TransmitReceive_IT_2
   \       0x32   0x2D04             CMP      R5,#+4
   \       0x34   0xD001             BEQ      ??HAL_SPI_TransmitReceive_IT_1
   1561            {
   1562              errorcode = HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \       0x36   0x2102             MOVS     R1,#+2
   1563              goto error;
   \       0x38   0xE033             B        ??HAL_SPI_TransmitReceive_IT_3
   1564            }
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \       0x3A   0x9D00             LDR      R5,[SP, #+0]
   1565          
   1566            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \       0x3C   0x2D00             CMP      R5,#+0
   \       0x3E   0xD004             BEQ      ??HAL_SPI_TransmitReceive_IT_4
   \       0x40   0x9E01             LDR      R6,[SP, #+4]
   \       0x42   0x2E00             CMP      R6,#+0
   \       0x44   0xD001             BEQ      ??HAL_SPI_TransmitReceive_IT_4
   \       0x46   0x001F             MOVS     R7,R3
   \       0x48   0xD101             BNE      ??HAL_SPI_TransmitReceive_IT_5
   1567            {
   1568              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \       0x4A   0x2101             MOVS     R1,#+1
   1569              goto error;
   \       0x4C   0xE029             B        ??HAL_SPI_TransmitReceive_IT_3
   1570            }
   1571          
   1572            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1573            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \       0x4E   0x0004             MOVS     R4,R0
   \       0x50   0x3450             ADDS     R4,R4,#+80
   \       0x52   0x7864             LDRB     R4,[R4, #+1]
   \       0x54   0x2C04             CMP      R4,#+4
   \       0x56   0xD003             BEQ      ??HAL_SPI_TransmitReceive_IT_6
   1574            {
   1575              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \       0x58   0x2405             MOVS     R4,#+5
   \       0x5A   0x0007             MOVS     R7,R0
   \       0x5C   0x3750             ADDS     R7,R7,#+80
   \       0x5E   0x707C             STRB     R4,[R7, #+1]
   1576            }
   1577          
   1578            /* Set the transaction information */
   1579            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \       0x60   0x0004             MOVS     R4,R0
   \       0x62   0x3450             ADDS     R4,R4,#+80
   \       0x64   0x6062             STR      R2,[R4, #+4]
   1580            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \       0x66   0x6305             STR      R5,[R0, #+48]
   1581            hspi->TxXferSize  = Size;
   \       0x68   0x8683             STRH     R3,[R0, #+52]
   1582            hspi->TxXferCount = Size;
   \       0x6A   0x86C3             STRH     R3,[R0, #+54]
   1583            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \       0x6C   0x6386             STR      R6,[R0, #+56]
   1584            hspi->RxXferSize  = Size;
   \       0x6E   0x8783             STRH     R3,[R0, #+60]
   1585            hspi->RxXferCount = Size;
   \       0x70   0x87C3             STRH     R3,[R0, #+62]
   1586          
   1587            /* Set the function for IT treatment */
   1588            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \       0x72   0x68C3             LDR      R3,[R0, #+12]
   \       0x74   0x2B00             CMP      R3,#+0
   \       0x76   0xD003             BEQ      ??HAL_SPI_TransmitReceive_IT_7
   1589            {
   1590              hspi->RxISR     = SPI_2linesRxISR_16BIT;
   \       0x78   0x....             LDR      R3,??DataTable7_3
   \       0x7A   0x6403             STR      R3,[R0, #+64]
   1591              hspi->TxISR     = SPI_2linesTxISR_16BIT;
   \       0x7C   0x....             LDR      R3,??DataTable7_4
   \       0x7E   0xE002             B        ??HAL_SPI_TransmitReceive_IT_8
   1592            }
   1593            else
   1594            {
   1595              hspi->RxISR     = SPI_2linesRxISR_8BIT;
   \                     ??HAL_SPI_TransmitReceive_IT_7: (+1)
   \       0x80   0x....             LDR      R3,??DataTable7_5
   \       0x82   0x6403             STR      R3,[R0, #+64]
   1596              hspi->TxISR     = SPI_2linesTxISR_8BIT;
   \       0x84   0x....             LDR      R3,??DataTable8
   \                     ??HAL_SPI_TransmitReceive_IT_8: (+1)
   \       0x86   0x6443             STR      R3,[R0, #+68]
   1597            }
   1598          
   1599          #if (USE_SPI_CRC != 0U)
   1600            /* Reset CRC Calculation */
   1601            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1602            {
   1603              SPI_RESET_CRC(hspi);
   1604            }
   1605          #endif /* USE_SPI_CRC */
   1606          
   1607            /* Enable TXE, RXNE and ERR interrupt */
   1608            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \       0x88   0x6803             LDR      R3,[R0, #+0]
   \       0x8A   0x685C             LDR      R4,[R3, #+4]
   \       0x8C   0x25E0             MOVS     R5,#+224
   \       0x8E   0x4325             ORRS     R5,R5,R4
   \       0x90   0x605D             STR      R5,[R3, #+4]
   1609          
   1610            /* Check if the SPI is already enabled */
   1611            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \       0x92   0x6803             LDR      R3,[R0, #+0]
   \       0x94   0x2440             MOVS     R4,#+64
   \       0x96   0x681D             LDR      R5,[R3, #+0]
   \       0x98   0x4025             ANDS     R5,R5,R4
   \       0x9A   0xD102             BNE      ??HAL_SPI_TransmitReceive_IT_3
   1612            {
   1613              /* Enable SPI peripheral */
   1614              __HAL_SPI_ENABLE(hspi);
   \       0x9C   0x681D             LDR      R5,[R3, #+0]
   \       0x9E   0x432C             ORRS     R4,R4,R5
   \       0xA0   0x601C             STR      R4,[R3, #+0]
   1615            }
   1616          
   1617          error :
   1618            /* Process Unlocked */
   1619            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \       0xA2   0x2350             MOVS     R3,#+80
   \       0xA4   0x54C2             STRB     R2,[R0, R3]
   1620            return errorcode;
   \       0xA6   0x0008             MOVS     R0,R1
   \       0xA8   0xBDF6             POP      {R1,R2,R4-R7,PC}  ;; return
   1621          }
   1622          
   1623          /**
   1624            * @brief  Transmit an amount of data in non-blocking mode with DMA.
   1625            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1626            *               the configuration information for SPI module.
   1627            * @param  pData pointer to data buffer
   1628            * @param  Size amount of data to be sent
   1629            * @retval HAL status
   1630            */

   \                                 In section .text, align 2, keep-with-next
   1631          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1632          {
   \                     HAL_SPI_Transmit_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1633            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2600             MOVS     R6,#+0
   1634          
   1635            /* Check tx dma handle */
   1636            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   1637          
   1638            /* Check Direction parameter */
   1639            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1640          
   1641            /* Process Locked */
   1642            __HAL_LOCK(hspi);
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0x5C28             LDRB     R0,[R5, R0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_SPI_Transmit_DMA_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \       0x14   0x2701             MOVS     R7,#+1
   \       0x16   0x2050             MOVS     R0,#+80
   \       0x18   0x542F             STRB     R7,[R5, R0]
   1643          
   1644            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0x3050             ADDS     R0,R0,#+80
   \       0x1E   0x7840             LDRB     R0,[R0, #+1]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD001             BEQ      ??HAL_SPI_Transmit_DMA_1
   1645            {
   1646              errorcode = HAL_BUSY;
   \       0x24   0x2602             MOVS     R6,#+2
   1647              goto error;
   \       0x26   0xE04A             B        ??HAL_SPI_Transmit_DMA_2
   1648            }
   1649          
   1650            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD001             BEQ      ??HAL_SPI_Transmit_DMA_3
   \       0x2C   0x0010             MOVS     R0,R2
   \       0x2E   0xD101             BNE      ??HAL_SPI_Transmit_DMA_4
   1651            {
   1652              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \       0x30   0x2601             MOVS     R6,#+1
   1653              goto error;
   \       0x32   0xE044             B        ??HAL_SPI_Transmit_DMA_2
   1654            }
   1655          
   1656            /* Set the transaction information */
   1657            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \                     ??HAL_SPI_Transmit_DMA_4: (+1)
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0x3050             ADDS     R0,R0,#+80
   \       0x38   0x2303             MOVS     R3,#+3
   \       0x3A   0x7043             STRB     R3,[R0, #+1]
   1658            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x3C   0x6044             STR      R4,[R0, #+4]
   1659            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \       0x3E   0x6329             STR      R1,[R5, #+48]
   1660            hspi->TxXferSize  = Size;
   \       0x40   0x86AA             STRH     R2,[R5, #+52]
   1661            hspi->TxXferCount = Size;
   \       0x42   0x86EA             STRH     R2,[R5, #+54]
   1662          
   1663            /* Init field not used in handle to zero */
   1664            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \       0x44   0x63AC             STR      R4,[R5, #+56]
   1665            hspi->TxISR       = NULL;
   \       0x46   0x646C             STR      R4,[R5, #+68]
   1666            hspi->RxISR       = NULL;
   \       0x48   0x642C             STR      R4,[R5, #+64]
   1667            hspi->RxXferSize  = 0U;
   \       0x4A   0x87AC             STRH     R4,[R5, #+60]
   1668            hspi->RxXferCount = 0U;
   \       0x4C   0x87EC             STRH     R4,[R5, #+62]
   1669          
   1670            /* Configure communication direction : 1Line */
   1671            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x4E   0x68A8             LDR      R0,[R5, #+8]
   \       0x50   0x03F9             LSLS     R1,R7,#+15
   \       0x52   0x4288             CMP      R0,R1
   \       0x54   0xD104             BNE      ??HAL_SPI_Transmit_DMA_5
   1672            {
   1673              SPI_1LINE_TX(hspi);
   \       0x56   0x6828             LDR      R0,[R5, #+0]
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0x03BA             LSLS     R2,R7,#+14
   \       0x5C   0x430A             ORRS     R2,R2,R1
   \       0x5E   0x6002             STR      R2,[R0, #+0]
   1674            }
   1675          
   1676          #if (USE_SPI_CRC != 0U)
   1677            /* Reset CRC Calculation */
   1678            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1679            {
   1680              SPI_RESET_CRC(hspi);
   1681            }
   1682          #endif /* USE_SPI_CRC */
   1683          
   1684            /* Set the SPI TxDMA Half transfer complete callback */
   1685            hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_5: (+1)
   \       0x60   0x....             LDR      R0,??DataTable8_1
   \       0x62   0x6CA9             LDR      R1,[R5, #+72]
   \       0x64   0x6308             STR      R0,[R1, #+48]
   1686          
   1687            /* Set the SPI TxDMA transfer complete callback */
   1688            hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \       0x66   0x....             LDR      R0,??DataTable8_2
   \       0x68   0x6CA9             LDR      R1,[R5, #+72]
   \       0x6A   0x62C8             STR      R0,[R1, #+44]
   1689          
   1690            /* Set the DMA error callback */
   1691            hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \       0x6C   0x....             LDR      R0,??DataTable8_3
   \       0x6E   0x6CA9             LDR      R1,[R5, #+72]
   \       0x70   0x6348             STR      R0,[R1, #+52]
   1692          
   1693            /* Set the DMA AbortCpltCallback */
   1694            hspi->hdmatx->XferAbortCallback = NULL;
   \       0x72   0x6CA8             LDR      R0,[R5, #+72]
   \       0x74   0x6384             STR      R4,[R0, #+56]
   1695          
   1696            /* Enable the Tx DMA Stream/Channel */
   1697            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount))
   \       0x76   0x8EEB             LDRH     R3,[R5, #+54]
   \       0x78   0x682A             LDR      R2,[R5, #+0]
   \       0x7A   0x320C             ADDS     R2,R2,#+12
   \       0x7C   0x6B29             LDR      R1,[R5, #+48]
   \       0x7E   0x6CA8             LDR      R0,[R5, #+72]
   \       0x80   0x....'....        BL       HAL_DMA_Start_IT
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD008             BEQ      ??HAL_SPI_Transmit_DMA_6
   1698            {
   1699              /* Update SPI error code */
   1700              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0x88   0x0028             MOVS     R0,R5
   \       0x8A   0x3050             ADDS     R0,R0,#+80
   \       0x8C   0x6841             LDR      R1,[R0, #+4]
   \       0x8E   0x2210             MOVS     R2,#+16
   \       0x90   0x430A             ORRS     R2,R2,R1
   \       0x92   0x6042             STR      R2,[R0, #+4]
   1701              errorcode = HAL_ERROR;
   \       0x94   0x2601             MOVS     R6,#+1
   1702          
   1703              hspi->State = HAL_SPI_STATE_READY;
   \       0x96   0x7047             STRB     R7,[R0, #+1]
   1704              goto error;
   \       0x98   0xE011             B        ??HAL_SPI_Transmit_DMA_2
   1705            }
   1706          
   1707            /* Check if the SPI is already enabled */
   1708            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_DMA_6: (+1)
   \       0x9A   0x6828             LDR      R0,[R5, #+0]
   \       0x9C   0x2140             MOVS     R1,#+64
   \       0x9E   0x6802             LDR      R2,[R0, #+0]
   \       0xA0   0x400A             ANDS     R2,R2,R1
   \       0xA2   0xD102             BNE      ??HAL_SPI_Transmit_DMA_7
   1709            {
   1710              /* Enable SPI peripheral */
   1711              __HAL_SPI_ENABLE(hspi);
   \       0xA4   0x6802             LDR      R2,[R0, #+0]
   \       0xA6   0x4311             ORRS     R1,R1,R2
   \       0xA8   0x6001             STR      R1,[R0, #+0]
   1712            }
   1713          
   1714            /* Enable the SPI Error Interrupt Bit */
   1715            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   \                     ??HAL_SPI_Transmit_DMA_7: (+1)
   \       0xAA   0x6828             LDR      R0,[R5, #+0]
   \       0xAC   0x6841             LDR      R1,[R0, #+4]
   \       0xAE   0x2220             MOVS     R2,#+32
   \       0xB0   0x430A             ORRS     R2,R2,R1
   \       0xB2   0x6042             STR      R2,[R0, #+4]
   1716          
   1717            /* Enable Tx DMA Request */
   1718            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0xB4   0x6828             LDR      R0,[R5, #+0]
   \       0xB6   0x6841             LDR      R1,[R0, #+4]
   \       0xB8   0x2202             MOVS     R2,#+2
   \       0xBA   0x430A             ORRS     R2,R2,R1
   \       0xBC   0x6042             STR      R2,[R0, #+4]
   1719          
   1720          error :
   1721            /* Process Unlocked */
   1722            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \       0xBE   0x2050             MOVS     R0,#+80
   \       0xC0   0x542C             STRB     R4,[R5, R0]
   1723            return errorcode;
   \       0xC2   0x0030             MOVS     R0,R6
   \       0xC4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1724          }
   1725          
   1726          /**
   1727            * @brief  Receive an amount of data in non-blocking mode with DMA.
   1728            * @note   In case of MASTER mode and SPI_DIRECTION_2LINES direction, hdmatx shall be defined.
   1729            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1730            *               the configuration information for SPI module.
   1731            * @param  pData pointer to data buffer
   1732            * @note   When the CRC feature is enabled the pData Length must be Size + 1.
   1733            * @param  Size amount of data to be sent
   1734            * @retval HAL status
   1735            */

   \                                 In section .text, align 2, keep-with-next
   1736          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1737          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x0005             MOVS     R5,R0
   1738            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x2600             MOVS     R6,#+0
   1739          
   1740            /* Check rx dma handle */
   1741            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
   1742          
   1743            if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   \        0xA   0x68A8             LDR      R0,[R5, #+8]
   \        0xC   0x9000             STR      R0,[SP, #+0]
   \        0xE   0x2004             MOVS     R0,#+4
   \       0x10   0x9900             LDR      R1,[SP, #+0]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10E             BNE      ??HAL_SPI_Receive_DMA_0
   \       0x16   0x6869             LDR      R1,[R5, #+4]
   \       0x18   0x2382             MOVS     R3,#+130
   \       0x1A   0x005B             LSLS     R3,R3,#+1        ;; #+260
   \       0x1C   0x4299             CMP      R1,R3
   \       0x1E   0xD109             BNE      ??HAL_SPI_Receive_DMA_0
   1744            {
   1745              hspi->State = HAL_SPI_STATE_BUSY_RX;
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x3150             ADDS     R1,R1,#+80
   \       0x24   0x7048             STRB     R0,[R1, #+1]
   1746          
   1747              /* Check tx dma handle */
   1748              assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   1749          
   1750              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1751              return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
   \       0x26   0x0013             MOVS     R3,R2
   \       0x28   0x9A02             LDR      R2,[SP, #+8]
   \       0x2A   0x4611             MOV      R1,R2
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0x....'....        BL       HAL_SPI_TransmitReceive_DMA
   \       0x32   0xBDFE             POP      {R1-R7,PC}
   1752            }
   1753          
   1754            /* Process Locked */
   1755            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \       0x34   0x2150             MOVS     R1,#+80
   \       0x36   0x5C69             LDRB     R1,[R5, R1]
   \       0x38   0x2901             CMP      R1,#+1
   \       0x3A   0xD101             BNE      ??HAL_SPI_Receive_DMA_1
   \       0x3C   0x2002             MOVS     R0,#+2
   \       0x3E   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \       0x40   0x2701             MOVS     R7,#+1
   \       0x42   0x2350             MOVS     R3,#+80
   \       0x44   0x54EF             STRB     R7,[R5, R3]
   1756          
   1757            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x46   0x0029             MOVS     R1,R5
   \       0x48   0x3150             ADDS     R1,R1,#+80
   \       0x4A   0x7849             LDRB     R1,[R1, #+1]
   \       0x4C   0x2901             CMP      R1,#+1
   \       0x4E   0xD001             BEQ      ??HAL_SPI_Receive_DMA_2
   1758            {
   1759              errorcode = HAL_BUSY;
   \       0x50   0x2602             MOVS     R6,#+2
   1760              goto error;
   \       0x52   0xE049             B        ??HAL_SPI_Receive_DMA_3
   1761            }
   1762          
   1763            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \       0x54   0x9902             LDR      R1,[SP, #+8]
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD001             BEQ      ??HAL_SPI_Receive_DMA_4
   \       0x5A   0x0011             MOVS     R1,R2
   \       0x5C   0xD101             BNE      ??HAL_SPI_Receive_DMA_5
   1764            {
   1765              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \       0x5E   0x2601             MOVS     R6,#+1
   1766              goto error;
   \       0x60   0xE042             B        ??HAL_SPI_Receive_DMA_3
   1767            }
   1768          
   1769            /* Set the transaction information */
   1770            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \                     ??HAL_SPI_Receive_DMA_5: (+1)
   \       0x62   0x0029             MOVS     R1,R5
   \       0x64   0x3150             ADDS     R1,R1,#+80
   \       0x66   0x7048             STRB     R0,[R1, #+1]
   1771            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x68   0x604C             STR      R4,[R1, #+4]
   1772            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \       0x6A   0x9802             LDR      R0,[SP, #+8]
   \       0x6C   0x63A8             STR      R0,[R5, #+56]
   1773            hspi->RxXferSize  = Size;
   \       0x6E   0x87AA             STRH     R2,[R5, #+60]
   1774            hspi->RxXferCount = Size;
   \       0x70   0x87EA             STRH     R2,[R5, #+62]
   1775          
   1776            /*Init field not used in handle to zero */
   1777            hspi->RxISR       = NULL;
   \       0x72   0x642C             STR      R4,[R5, #+64]
   1778            hspi->TxISR       = NULL;
   \       0x74   0x646C             STR      R4,[R5, #+68]
   1779            hspi->TxXferSize  = 0U;
   \       0x76   0x86AC             STRH     R4,[R5, #+52]
   1780            hspi->TxXferCount = 0U;
   \       0x78   0x86EC             STRH     R4,[R5, #+54]
   1781          
   1782            /* Configure communication direction : 1Line */
   1783            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x7A   0x9800             LDR      R0,[SP, #+0]
   \       0x7C   0x03F9             LSLS     R1,R7,#+15
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xD104             BNE      ??HAL_SPI_Receive_DMA_6
   1784            {
   1785              SPI_1LINE_RX(hspi);
   \       0x82   0x6828             LDR      R0,[R5, #+0]
   \       0x84   0x6801             LDR      R1,[R0, #+0]
   \       0x86   0x....             LDR      R2,??DataTable7_2  ;; 0xffffbfff
   \       0x88   0x400A             ANDS     R2,R2,R1
   \       0x8A   0x6002             STR      R2,[R0, #+0]
   1786            }
   1787          
   1788          #if (USE_SPI_CRC != 0U)
   1789            /* Reset CRC Calculation */
   1790            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1791            {
   1792              SPI_RESET_CRC(hspi);
   1793            }
   1794          #endif /* USE_SPI_CRC */
   1795          
   1796            /* Set the SPI RxDMA Half transfer complete callback */
   1797            hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \                     ??HAL_SPI_Receive_DMA_6: (+1)
   \       0x8C   0x....             LDR      R0,??DataTable9
   \       0x8E   0x6CE9             LDR      R1,[R5, #+76]
   \       0x90   0x6308             STR      R0,[R1, #+48]
   1798          
   1799            /* Set the SPI Rx DMA transfer complete callback */
   1800            hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \       0x92   0x....             LDR      R0,??DataTable9_1
   \       0x94   0x6CE9             LDR      R1,[R5, #+76]
   \       0x96   0x62C8             STR      R0,[R1, #+44]
   1801          
   1802            /* Set the DMA error callback */
   1803            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \       0x98   0x....             LDR      R0,??DataTable9_2
   \       0x9A   0x6CE9             LDR      R1,[R5, #+76]
   \       0x9C   0x6348             STR      R0,[R1, #+52]
   1804          
   1805            /* Set the DMA AbortCpltCallback */
   1806            hspi->hdmarx->XferAbortCallback = NULL;
   \       0x9E   0x6CE8             LDR      R0,[R5, #+76]
   \       0xA0   0x6384             STR      R4,[R0, #+56]
   1807          
   1808            /* Enable the Rx DMA Stream/Channel  */
   1809            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount))
   \       0xA2   0x8FEB             LDRH     R3,[R5, #+62]
   \       0xA4   0x6BAA             LDR      R2,[R5, #+56]
   \       0xA6   0x6829             LDR      R1,[R5, #+0]
   \       0xA8   0x310C             ADDS     R1,R1,#+12
   \       0xAA   0x6CE8             LDR      R0,[R5, #+76]
   \       0xAC   0x....'....        BL       HAL_DMA_Start_IT
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD008             BEQ      ??HAL_SPI_Receive_DMA_7
   1810            {
   1811              /* Update SPI error code */
   1812              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0xB4   0x0028             MOVS     R0,R5
   \       0xB6   0x3050             ADDS     R0,R0,#+80
   \       0xB8   0x6841             LDR      R1,[R0, #+4]
   \       0xBA   0x2210             MOVS     R2,#+16
   \       0xBC   0x430A             ORRS     R2,R2,R1
   \       0xBE   0x6042             STR      R2,[R0, #+4]
   1813              errorcode = HAL_ERROR;
   \       0xC0   0x2601             MOVS     R6,#+1
   1814          
   1815              hspi->State = HAL_SPI_STATE_READY;
   \       0xC2   0x7047             STRB     R7,[R0, #+1]
   1816              goto error;
   \       0xC4   0xE010             B        ??HAL_SPI_Receive_DMA_3
   1817            }
   1818          
   1819            /* Check if the SPI is already enabled */
   1820            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_DMA_7: (+1)
   \       0xC6   0x6828             LDR      R0,[R5, #+0]
   \       0xC8   0x2140             MOVS     R1,#+64
   \       0xCA   0x6802             LDR      R2,[R0, #+0]
   \       0xCC   0x400A             ANDS     R2,R2,R1
   \       0xCE   0xD102             BNE      ??HAL_SPI_Receive_DMA_8
   1821            {
   1822              /* Enable SPI peripheral */
   1823              __HAL_SPI_ENABLE(hspi);
   \       0xD0   0x6802             LDR      R2,[R0, #+0]
   \       0xD2   0x4311             ORRS     R1,R1,R2
   \       0xD4   0x6001             STR      R1,[R0, #+0]
   1824            }
   1825          
   1826            /* Enable the SPI Error Interrupt Bit */
   1827            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_DMA_8: (+1)
   \       0xD6   0x6828             LDR      R0,[R5, #+0]
   \       0xD8   0x6841             LDR      R1,[R0, #+4]
   \       0xDA   0x2220             MOVS     R2,#+32
   \       0xDC   0x430A             ORRS     R2,R2,R1
   \       0xDE   0x6042             STR      R2,[R0, #+4]
   1828          
   1829            /* Enable Rx DMA Request */
   1830            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \       0xE0   0x6828             LDR      R0,[R5, #+0]
   \       0xE2   0x6841             LDR      R1,[R0, #+4]
   \       0xE4   0x430F             ORRS     R7,R7,R1
   \       0xE6   0x6047             STR      R7,[R0, #+4]
   1831          
   1832          error:
   1833            /* Process Unlocked */
   1834            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \       0xE8   0x....             B.N      ?Subroutine1
   1835            return errorcode;
   1836          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2050             MOVS     R0,#+80
   \        0x2   0x542C             STRB     R4,[R5, R0]
   \        0x4   0x0030             MOVS     R0,R6
   \        0x6   0xBDFE             POP      {R1-R7,PC}       ;; return
   1837          
   1838          /**
   1839            * @brief  Transmit and Receive an amount of data in non-blocking mode with DMA.
   1840            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1841            *               the configuration information for SPI module.
   1842            * @param  pTxData pointer to transmission data buffer
   1843            * @param  pRxData pointer to reception data buffer
   1844            * @note   When the CRC feature is enabled the pRxData Length must be Size + 1
   1845            * @param  Size amount of data to be sent
   1846            * @retval HAL status
   1847            */

   \                                 In section .text, align 2, keep-with-next
   1848          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
   1849                                                        uint16_t Size)
   1850          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x0005             MOVS     R5,R0
   1851            uint32_t             tmp_mode;
   1852            HAL_SPI_StateTypeDef tmp_state;
   1853            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x2600             MOVS     R6,#+0
   1854          
   1855            /* Check rx & tx dma handles */
   1856            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
   1857            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   1858          
   1859            /* Check Direction parameter */
   1860            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1861          
   1862            /* Process locked */
   1863            __HAL_LOCK(hspi);
   \        0xA   0x2050             MOVS     R0,#+80
   \        0xC   0x5C28             LDRB     R0,[R5, R0]
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD101             BNE      ??HAL_SPI_TransmitReceive_DMA_0
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \       0x16   0x2701             MOVS     R7,#+1
   \       0x18   0x2150             MOVS     R1,#+80
   \       0x1A   0x546F             STRB     R7,[R5, R1]
   1864          
   1865            /* Init temporary variables */
   1866            tmp_state           = hspi->State;
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0x3050             ADDS     R0,R0,#+80
   \       0x20   0x7840             LDRB     R0,[R0, #+1]
   \       0x22   0x9000             STR      R0,[SP, #+0]
   1867            tmp_mode            = hspi->Init.Mode;
   1868          
   1869            if (!((tmp_state == HAL_SPI_STATE_READY) ||
   1870                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD00B             BEQ      ??HAL_SPI_TransmitReceive_DMA_1
   \       0x28   0x6868             LDR      R0,[R5, #+4]
   \       0x2A   0x31B4             ADDS     R1,R1,#+180
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD105             BNE      ??HAL_SPI_TransmitReceive_DMA_2
   \       0x30   0x68A8             LDR      R0,[R5, #+8]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE      ??HAL_SPI_TransmitReceive_DMA_2
   \       0x36   0x9800             LDR      R0,[SP, #+0]
   \       0x38   0x2804             CMP      R0,#+4
   \       0x3A   0xD001             BEQ      ??HAL_SPI_TransmitReceive_DMA_1
   1871            {
   1872              errorcode = HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \       0x3C   0x2602             MOVS     R6,#+2
   1873              goto error;
   \       0x3E   0xE069             B        ??HAL_SPI_TransmitReceive_DMA_3
   1874            }
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \       0x40   0x9802             LDR      R0,[SP, #+8]
   1875          
   1876            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD004             BEQ      ??HAL_SPI_TransmitReceive_DMA_4
   \       0x46   0x9200             STR      R2,[SP, #+0]
   \       0x48   0x2A00             CMP      R2,#+0
   \       0x4A   0xD001             BEQ      ??HAL_SPI_TransmitReceive_DMA_4
   \       0x4C   0x0019             MOVS     R1,R3
   \       0x4E   0xD101             BNE      ??HAL_SPI_TransmitReceive_DMA_5
   1877            {
   1878              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \       0x50   0x2601             MOVS     R6,#+1
   1879              goto error;
   \       0x52   0xE05F             B        ??HAL_SPI_TransmitReceive_DMA_3
   1880            }
   1881          
   1882            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1883            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x3150             ADDS     R1,R1,#+80
   \       0x58   0x784A             LDRB     R2,[R1, #+1]
   \       0x5A   0x2A04             CMP      R2,#+4
   \       0x5C   0xD001             BEQ      ??HAL_SPI_TransmitReceive_DMA_6
   1884            {
   1885              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \       0x5E   0x2205             MOVS     R2,#+5
   \       0x60   0x704A             STRB     R2,[R1, #+1]
   1886            }
   1887          
   1888            /* Set the transaction information */
   1889            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \       0x62   0x0029             MOVS     R1,R5
   \       0x64   0x3150             ADDS     R1,R1,#+80
   \       0x66   0x604C             STR      R4,[R1, #+4]
   1890            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \       0x68   0x6328             STR      R0,[R5, #+48]
   1891            hspi->TxXferSize  = Size;
   \       0x6A   0x86AB             STRH     R3,[R5, #+52]
   1892            hspi->TxXferCount = Size;
   \       0x6C   0x86EB             STRH     R3,[R5, #+54]
   1893            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \       0x6E   0x9800             LDR      R0,[SP, #+0]
   \       0x70   0x63A8             STR      R0,[R5, #+56]
   1894            hspi->RxXferSize  = Size;
   \       0x72   0x87AB             STRH     R3,[R5, #+60]
   1895            hspi->RxXferCount = Size;
   \       0x74   0x87EB             STRH     R3,[R5, #+62]
   1896          
   1897            /* Init field not used in handle to zero */
   1898            hspi->RxISR       = NULL;
   \       0x76   0x642C             STR      R4,[R5, #+64]
   1899            hspi->TxISR       = NULL;
   \       0x78   0x646C             STR      R4,[R5, #+68]
   1900          
   1901          #if (USE_SPI_CRC != 0U)
   1902            /* Reset CRC Calculation */
   1903            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1904            {
   1905              SPI_RESET_CRC(hspi);
   1906            }
   1907          #endif /* USE_SPI_CRC */
   1908          
   1909            /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
   1910            if (hspi->State == HAL_SPI_STATE_BUSY_RX)
   \       0x7A   0x6CE8             LDR      R0,[R5, #+76]
   \       0x7C   0x0029             MOVS     R1,R5
   \       0x7E   0x3150             ADDS     R1,R1,#+80
   \       0x80   0x7849             LDRB     R1,[R1, #+1]
   \       0x82   0x2904             CMP      R1,#+4
   \       0x84   0xD103             BNE      ??HAL_SPI_TransmitReceive_DMA_7
   1911            {
   1912              /* Set the SPI Rx DMA Half transfer complete callback */
   1913              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \       0x86   0x....             LDR      R1,??DataTable9
   \       0x88   0x6301             STR      R1,[R0, #+48]
   1914              hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
   \       0x8A   0x....             LDR      R0,??DataTable9_1
   \       0x8C   0xE002             B        ??HAL_SPI_TransmitReceive_DMA_8
   1915            }
   1916            else
   1917            {
   1918              /* Set the SPI Tx/Rx DMA Half transfer complete callback */
   1919              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \       0x8E   0x....             LDR      R1,??DataTable9_3
   \       0x90   0x6301             STR      R1,[R0, #+48]
   1920              hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
   \       0x92   0x....             LDR      R0,??DataTable9_4
   \                     ??HAL_SPI_TransmitReceive_DMA_8: (+1)
   \       0x94   0x6CE9             LDR      R1,[R5, #+76]
   \       0x96   0x62C8             STR      R0,[R1, #+44]
   1921            }
   1922          
   1923            /* Set the DMA error callback */
   1924            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \       0x98   0x....             LDR      R0,??DataTable8_3
   \       0x9A   0x6CE9             LDR      R1,[R5, #+76]
   \       0x9C   0x6348             STR      R0,[R1, #+52]
   1925          
   1926            /* Set the DMA AbortCpltCallback */
   1927            hspi->hdmarx->XferAbortCallback = NULL;
   \       0x9E   0x6CE8             LDR      R0,[R5, #+76]
   \       0xA0   0x6384             STR      R4,[R0, #+56]
   1928          
   1929            /* Enable the Rx DMA Stream/Channel  */
   1930            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount))
   \       0xA2   0x8FEB             LDRH     R3,[R5, #+62]
   \       0xA4   0x6BAA             LDR      R2,[R5, #+56]
   \       0xA6   0x6829             LDR      R1,[R5, #+0]
   \       0xA8   0x310C             ADDS     R1,R1,#+12
   \       0xAA   0x6CE8             LDR      R0,[R5, #+76]
   \       0xAC   0x....'....        BL       HAL_DMA_Start_IT
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD114             BNE      ??HAL_SPI_TransmitReceive_DMA_9
   1931            {
   1932              /* Update SPI error code */
   1933              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   1934              errorcode = HAL_ERROR;
   1935          
   1936              hspi->State = HAL_SPI_STATE_READY;
   1937              goto error;
   1938            }
   1939          
   1940            /* Enable Rx DMA Request */
   1941            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \       0xB4   0x6828             LDR      R0,[R5, #+0]
   \       0xB6   0x6841             LDR      R1,[R0, #+4]
   \       0xB8   0x4339             ORRS     R1,R1,R7
   \       0xBA   0x6041             STR      R1,[R0, #+4]
   1942          
   1943            /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1944            is performed in DMA reception complete callback  */
   1945            hspi->hdmatx->XferHalfCpltCallback = NULL;
   \       0xBC   0x6CA8             LDR      R0,[R5, #+72]
   \       0xBE   0x6304             STR      R4,[R0, #+48]
   1946            hspi->hdmatx->XferCpltCallback     = NULL;
   \       0xC0   0x6CA8             LDR      R0,[R5, #+72]
   \       0xC2   0x62C4             STR      R4,[R0, #+44]
   1947            hspi->hdmatx->XferErrorCallback    = NULL;
   \       0xC4   0x6CA8             LDR      R0,[R5, #+72]
   \       0xC6   0x6344             STR      R4,[R0, #+52]
   1948            hspi->hdmatx->XferAbortCallback    = NULL;
   \       0xC8   0x6CA8             LDR      R0,[R5, #+72]
   \       0xCA   0x6384             STR      R4,[R0, #+56]
   1949          
   1950            /* Enable the Tx DMA Stream/Channel  */
   1951            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount))
   \       0xCC   0x8EEB             LDRH     R3,[R5, #+54]
   \       0xCE   0x682A             LDR      R2,[R5, #+0]
   \       0xD0   0x320C             ADDS     R2,R2,#+12
   \       0xD2   0x6B29             LDR      R1,[R5, #+48]
   \       0xD4   0x6CA8             LDR      R0,[R5, #+72]
   \       0xD6   0x....'....        BL       HAL_DMA_Start_IT
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD008             BEQ      ??HAL_SPI_TransmitReceive_DMA_10
   1952            {
   1953              /* Update SPI error code */
   1954              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \                     ??HAL_SPI_TransmitReceive_DMA_9: (+1)
   \       0xDE   0x0028             MOVS     R0,R5
   \       0xE0   0x3050             ADDS     R0,R0,#+80
   \       0xE2   0x6841             LDR      R1,[R0, #+4]
   \       0xE4   0x2210             MOVS     R2,#+16
   \       0xE6   0x430A             ORRS     R2,R2,R1
   \       0xE8   0x6042             STR      R2,[R0, #+4]
   1955              errorcode = HAL_ERROR;
   \       0xEA   0x2601             MOVS     R6,#+1
   1956          
   1957              hspi->State = HAL_SPI_STATE_READY;
   \       0xEC   0x7047             STRB     R7,[R0, #+1]
   1958              goto error;
   \       0xEE   0xE011             B        ??HAL_SPI_TransmitReceive_DMA_3
   1959            }
   1960          
   1961            /* Check if the SPI is already enabled */
   1962            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_TransmitReceive_DMA_10: (+1)
   \       0xF0   0x6828             LDR      R0,[R5, #+0]
   \       0xF2   0x2140             MOVS     R1,#+64
   \       0xF4   0x6802             LDR      R2,[R0, #+0]
   \       0xF6   0x400A             ANDS     R2,R2,R1
   \       0xF8   0xD102             BNE      ??HAL_SPI_TransmitReceive_DMA_11
   1963            {
   1964              /* Enable SPI peripheral */
   1965              __HAL_SPI_ENABLE(hspi);
   \       0xFA   0x6802             LDR      R2,[R0, #+0]
   \       0xFC   0x4311             ORRS     R1,R1,R2
   \       0xFE   0x6001             STR      R1,[R0, #+0]
   1966            }
   1967            /* Enable the SPI Error Interrupt Bit */
   1968            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   \                     ??HAL_SPI_TransmitReceive_DMA_11: (+1)
   \      0x100   0x6828             LDR      R0,[R5, #+0]
   \      0x102   0x6841             LDR      R1,[R0, #+4]
   \      0x104   0x2220             MOVS     R2,#+32
   \      0x106   0x430A             ORRS     R2,R2,R1
   \      0x108   0x6042             STR      R2,[R0, #+4]
   1969          
   1970            /* Enable Tx DMA Request */
   1971            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \      0x10A   0x6828             LDR      R0,[R5, #+0]
   \      0x10C   0x6841             LDR      R1,[R0, #+4]
   \      0x10E   0x2202             MOVS     R2,#+2
   \      0x110   0x430A             ORRS     R2,R2,R1
   \      0x112   0x6042             STR      R2,[R0, #+4]
   1972          
   1973          error :
   1974            /* Process Unlocked */
   1975            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \      0x114                      REQUIRE ?Subroutine1
   \      0x114                      ;; // Fall through to label ?Subroutine1
   1976            return errorcode;
   1977          }
   1978          
   1979          /**
   1980            * @brief  Abort ongoing transfer (blocking mode).
   1981            * @param  hspi SPI handle.
   1982            * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
   1983            *         started in Interrupt or DMA mode.
   1984            *         This procedure performs following operations :
   1985            *           - Disable SPI Interrupts (depending of transfer direction)
   1986            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1987            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1988            *           - Set handle State to READY
   1989            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1990            * @retval HAL status
   1991          */

   \                                 In section .text, align 2, keep-with-next
   1992          HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
   1993          {
   \                     HAL_SPI_Abort: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1994            HAL_StatusTypeDef errorcode;
   1995            __IO uint32_t count, resetcount;
   1996          
   1997            /* Initialized local variable  */
   1998            errorcode = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x710D             STRB     R5,[R1, #+4]
   1999            resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0xA   0x....             LDR      R0,??DataTable10
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x2118             MOVS     R1,#+24
   \       0x10   0x....'....        BL       __aeabi_uidiv
   \       0x14   0x21FA             MOVS     R1,#+250
   \       0x16   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x18   0x....'....        BL       __aeabi_uidiv
   \       0x1C   0x2164             MOVS     R1,#+100
   \       0x1E   0x4348             MULS     R0,R1,R0
   \       0x20   0x9002             STR      R0,[SP, #+8]
   2000            count = resetcount;
   \       0x22   0x9802             LDR      R0,[SP, #+8]
   \       0x24   0x9000             STR      R0,[SP, #+0]
   2001          
   2002            /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
   2003            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6841             LDR      R1,[R0, #+4]
   \       0x2A   0x2220             MOVS     R2,#+32
   \       0x2C   0x4391             BICS     R1,R1,R2
   \       0x2E   0x6041             STR      R1,[R0, #+4]
   2004          
   2005            /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
   2006            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x2640             MOVS     R6,#+64
   \       0x34   0x6841             LDR      R1,[R0, #+4]
   \       0x36   0x0609             LSLS     R1,R1,#+24
   \       0x38   0xD511             BPL      ??HAL_SPI_Abort_0
   2007            {
   2008              hspi->TxISR = SPI_AbortTx_ISR;
   \       0x3A   0x....             LDR      R1,??DataTable10_1
   \       0x3C   0x6461             STR      R1,[R4, #+68]
   2009              /* Wait HAL_SPI_STATE_ABORT state */
   2010              do
   2011              {
   2012                if (count == 0U)
   \                     ??HAL_SPI_Abort_1: (+1)
   \       0x3E   0x9900             LDR      R1,[SP, #+0]
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD007             BEQ      ??HAL_SPI_Abort_2
   2013                {
   2014                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2015                  break;
   2016                }
   2017                count--;
   \       0x44   0x9900             LDR      R1,[SP, #+0]
   \       0x46   0x1E49             SUBS     R1,R1,#+1
   \       0x48   0x9100             STR      R1,[SP, #+0]
   2018              }
   2019              while (hspi->State != HAL_SPI_STATE_ABORT);
   \       0x4A   0x2151             MOVS     R1,#+81
   \       0x4C   0x5C61             LDRB     R1,[R4, R1]
   \       0x4E   0x2907             CMP      R1,#+7
   \       0x50   0xD1F5             BNE      ??HAL_SPI_Abort_1
   \       0x52   0xE002             B        ??HAL_SPI_Abort_3
   \                     ??HAL_SPI_Abort_2: (+1)
   \       0x54   0x6D61             LDR      R1,[R4, #+84]
   \       0x56   0x4331             ORRS     R1,R1,R6
   \       0x58   0x6561             STR      R1,[R4, #+84]
   2020              /* Reset Timeout Counter */
   2021              count = resetcount;
   \                     ??HAL_SPI_Abort_3: (+1)
   \       0x5A   0x9902             LDR      R1,[SP, #+8]
   \       0x5C   0x9100             STR      R1,[SP, #+0]
   2022            }
   2023          
   2024            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   \                     ??HAL_SPI_Abort_0: (+1)
   \       0x5E   0x6841             LDR      R1,[R0, #+4]
   \       0x60   0x4031             ANDS     R1,R1,R6
   \       0x62   0xD011             BEQ      ??HAL_SPI_Abort_4
   2025            {
   2026              hspi->RxISR = SPI_AbortRx_ISR;
   \       0x64   0x....             LDR      R1,??DataTable10_2
   \       0x66   0x6421             STR      R1,[R4, #+64]
   2027              /* Wait HAL_SPI_STATE_ABORT state */
   2028              do
   2029              {
   2030                if (count == 0U)
   \                     ??HAL_SPI_Abort_5: (+1)
   \       0x68   0x9900             LDR      R1,[SP, #+0]
   \       0x6A   0x2900             CMP      R1,#+0
   \       0x6C   0xD007             BEQ      ??HAL_SPI_Abort_6
   2031                {
   2032                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2033                  break;
   2034                }
   2035                count--;
   \       0x6E   0x9900             LDR      R1,[SP, #+0]
   \       0x70   0x1E49             SUBS     R1,R1,#+1
   \       0x72   0x9100             STR      R1,[SP, #+0]
   2036              }
   2037              while (hspi->State != HAL_SPI_STATE_ABORT);
   \       0x74   0x2151             MOVS     R1,#+81
   \       0x76   0x5C61             LDRB     R1,[R4, R1]
   \       0x78   0x2907             CMP      R1,#+7
   \       0x7A   0xD1F5             BNE      ??HAL_SPI_Abort_5
   \       0x7C   0xE002             B        ??HAL_SPI_Abort_7
   \                     ??HAL_SPI_Abort_6: (+1)
   \       0x7E   0x6D61             LDR      R1,[R4, #+84]
   \       0x80   0x4331             ORRS     R1,R1,R6
   \       0x82   0x6561             STR      R1,[R4, #+84]
   2038              /* Reset Timeout Counter */
   2039              count = resetcount;
   \                     ??HAL_SPI_Abort_7: (+1)
   \       0x84   0x9902             LDR      R1,[SP, #+8]
   \       0x86   0x9100             STR      R1,[SP, #+0]
   2040            }
   2041          
   2042            /* Disable the SPI DMA Tx request if enabled */
   2043            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   \                     ??HAL_SPI_Abort_4: (+1)
   \       0x88   0x2702             MOVS     R7,#+2
   \       0x8A   0x6840             LDR      R0,[R0, #+4]
   \       0x8C   0x4038             ANDS     R0,R0,R7
   \       0x8E   0xD01B             BEQ      ??HAL_SPI_Abort_8
   2044            {
   2045              /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */
   2046              if (hspi->hdmatx != NULL)
   \       0x90   0x6CA0             LDR      R0,[R4, #+72]
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD018             BEQ      ??HAL_SPI_Abort_8
   2047              {
   2048                /* Set the SPI DMA Abort callback :
   2049                will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
   2050                hspi->hdmatx->XferAbortCallback = NULL;
   \       0x96   0x6385             STR      R5,[R0, #+56]
   2051          
   2052                /* Abort DMA Tx Handle linked to SPI Peripheral */
   2053                if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)
   \       0x98   0x6CA0             LDR      R0,[R4, #+72]
   \       0x9A   0x....'....        BL       HAL_DMA_Abort
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD000             BEQ      ??HAL_SPI_Abort_9
   2054                {
   2055                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   \       0xA2   0x6566             STR      R6,[R4, #+84]
   2056                }
   2057          
   2058                /* Disable Tx DMA Request */
   2059                CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
   \                     ??HAL_SPI_Abort_9: (+1)
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6841             LDR      R1,[R0, #+4]
   \       0xA8   0x43B9             BICS     R1,R1,R7
   \       0xAA   0x6041             STR      R1,[R0, #+4]
   2060          
   2061                /* Wait until TXE flag is set */
   2062                do
   2063                {
   2064                  if (count == 0U)
   \                     ??HAL_SPI_Abort_10: (+1)
   \       0xAC   0x9800             LDR      R0,[SP, #+0]
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD007             BEQ      ??HAL_SPI_Abort_11
   2065                  {
   2066                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2067                    break;
   2068                  }
   2069                  count--;
   \       0xB2   0x9800             LDR      R0,[SP, #+0]
   \       0xB4   0x1E40             SUBS     R0,R0,#+1
   \       0xB6   0x9000             STR      R0,[SP, #+0]
   2070                }
   2071                while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x6880             LDR      R0,[R0, #+8]
   \       0xBC   0x4038             ANDS     R0,R0,R7
   \       0xBE   0xD0F5             BEQ      ??HAL_SPI_Abort_10
   \       0xC0   0xE002             B        ??HAL_SPI_Abort_8
   \                     ??HAL_SPI_Abort_11: (+1)
   \       0xC2   0x6D60             LDR      R0,[R4, #+84]
   \       0xC4   0x4330             ORRS     R0,R0,R6
   \       0xC6   0x6560             STR      R0,[R4, #+84]
   2072              }
   2073            }
   2074          
   2075            /* Disable the SPI DMA Rx request if enabled */
   2076            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   \                     ??HAL_SPI_Abort_8: (+1)
   \       0xC8   0x2701             MOVS     R7,#+1
   \       0xCA   0x6820             LDR      R0,[R4, #+0]
   \       0xCC   0x6840             LDR      R0,[R0, #+4]
   \       0xCE   0x4038             ANDS     R0,R0,R7
   \       0xD0   0xD011             BEQ      ??HAL_SPI_Abort_12
   2077            {
   2078              /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */
   2079              if (hspi->hdmarx != NULL)
   \       0xD2   0x6CE0             LDR      R0,[R4, #+76]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD00E             BEQ      ??HAL_SPI_Abort_12
   2080              {
   2081                /* Set the SPI DMA Abort callback :
   2082                will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
   2083                hspi->hdmarx->XferAbortCallback = NULL;
   \       0xD8   0x6385             STR      R5,[R0, #+56]
   2084          
   2085                /* Abort DMA Rx Handle linked to SPI Peripheral */
   2086                if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)
   \       0xDA   0x6CE0             LDR      R0,[R4, #+76]
   \       0xDC   0x....'....        BL       HAL_DMA_Abort
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD000             BEQ      ??HAL_SPI_Abort_13
   2087                {
   2088                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   \       0xE4   0x6566             STR      R6,[R4, #+84]
   2089                }
   2090          
   2091                /* Disable peripheral */
   2092                __HAL_SPI_DISABLE(hspi);
   \                     ??HAL_SPI_Abort_13: (+1)
   \       0xE6   0x6820             LDR      R0,[R4, #+0]
   \       0xE8   0x6801             LDR      R1,[R0, #+0]
   \       0xEA   0x43B1             BICS     R1,R1,R6
   \       0xEC   0x6001             STR      R1,[R0, #+0]
   2093          
   2094                /* Disable Rx DMA Request */
   2095                CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
   \       0xEE   0x6820             LDR      R0,[R4, #+0]
   \       0xF0   0x6841             LDR      R1,[R0, #+4]
   \       0xF2   0x43B9             BICS     R1,R1,R7
   \       0xF4   0x6041             STR      R1,[R0, #+4]
   2096              }
   2097            }
   2098            /* Reset Tx and Rx transfer counters */
   2099            hspi->RxXferCount = 0U;
   \                     ??HAL_SPI_Abort_12: (+1)
   \       0xF6   0x87E5             STRH     R5,[R4, #+62]
   2100            hspi->TxXferCount = 0U;
   \       0xF8   0x86E5             STRH     R5,[R4, #+54]
   2101          
   2102            /* Check error during Abort procedure */
   2103            if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
   \       0xFA   0x6D60             LDR      R0,[R4, #+84]
   \       0xFC   0x2840             CMP      R0,#+64
   \       0xFE   0xD102             BNE      ??HAL_SPI_Abort_14
   2104            {
   2105              /* return HAL_Error in case of error during Abort procedure */
   2106              errorcode = HAL_ERROR;
   \      0x100   0x4669             MOV      R1,SP
   \      0x102   0x710F             STRB     R7,[R1, #+4]
   \      0x104   0xE000             B        ??HAL_SPI_Abort_15
   2107            }
   2108            else
   2109            {
   2110              /* Reset errorCode */
   2111              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_Abort_14: (+1)
   \      0x106   0x6565             STR      R5,[R4, #+84]
   2112            }
   2113          
   2114            /* Clear the Error flags in the SR register */
   2115            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??HAL_SPI_Abort_15: (+1)
   \      0x108   0x9500             STR      R5,[SP, #+0]
   \      0x10A   0x6820             LDR      R0,[R4, #+0]
   \      0x10C   0x68C1             LDR      R1,[R0, #+12]
   \      0x10E   0x9100             STR      R1,[SP, #+0]
   \      0x110   0x6881             LDR      R1,[R0, #+8]
   \      0x112   0x9100             STR      R1,[SP, #+0]
   \      0x114   0x9900             LDR      R1,[SP, #+0]
   2116            __HAL_SPI_CLEAR_FREFLAG(hspi);
   \      0x116   0x9500             STR      R5,[SP, #+0]
   \      0x118   0x6880             LDR      R0,[R0, #+8]
   \      0x11A   0x9000             STR      R0,[SP, #+0]
   \      0x11C   0x9800             LDR      R0,[SP, #+0]
   2117          
   2118            /* Restore hspi->state to ready */
   2119            hspi->State = HAL_SPI_STATE_READY;
   \      0x11E   0x2051             MOVS     R0,#+81
   \      0x120   0x5427             STRB     R7,[R4, R0]
   2120          
   2121            return errorcode;
   \      0x122   0x4668             MOV      R0,SP
   \      0x124   0x7900             LDRB     R0,[R0, #+4]
   \      0x126   0xBDFE             POP      {R1-R7,PC}       ;; return
   2122          }
   2123          
   2124          /**
   2125            * @brief  Abort ongoing transfer (Interrupt mode).
   2126            * @param  hspi SPI handle.
   2127            * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
   2128            *         started in Interrupt or DMA mode.
   2129            *         This procedure performs following operations :
   2130            *           - Disable SPI Interrupts (depending of transfer direction)
   2131            *           - Disable the DMA transfer in the peripheral register (if enabled)
   2132            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   2133            *           - Set handle State to READY
   2134            *           - At abort completion, call user abort complete callback
   2135            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   2136            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   2137            * @retval HAL status
   2138          */

   \                                 In section .text, align 2, keep-with-next
   2139          HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
   2140          {
   \                     HAL_SPI_Abort_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   2141            HAL_StatusTypeDef errorcode;
   2142            uint32_t abortcplt ;
   2143            __IO uint32_t count, resetcount;
   2144          
   2145            /* Initialized local variable  */
   2146            errorcode = HAL_OK;
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x710C             STRB     R4,[R1, #+4]
   2147            abortcplt = 1U;
   \        0xC   0x2701             MOVS     R7,#+1
   \        0xE   0x9703             STR      R7,[SP, #+12]
   2148            resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \       0x10   0x....             LDR      R0,??DataTable10
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x2118             MOVS     R1,#+24
   \       0x16   0x....'....        BL       __aeabi_uidiv
   \       0x1A   0x21FA             MOVS     R1,#+250
   \       0x1C   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x1E   0x....'....        BL       __aeabi_uidiv
   \       0x22   0x2164             MOVS     R1,#+100
   \       0x24   0x4348             MULS     R0,R1,R0
   \       0x26   0x9002             STR      R0,[SP, #+8]
   2149            count = resetcount;
   \       0x28   0x9802             LDR      R0,[SP, #+8]
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   2150          
   2151            /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
   2152            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x6841             LDR      R1,[R0, #+4]
   \       0x30   0x2220             MOVS     R2,#+32
   \       0x32   0x4391             BICS     R1,R1,R2
   \       0x34   0x6041             STR      R1,[R0, #+4]
   2153          
   2154            /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
   2155            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
   \       0x36   0x6828             LDR      R0,[R5, #+0]
   \       0x38   0x2640             MOVS     R6,#+64
   \       0x3A   0x6841             LDR      R1,[R0, #+4]
   \       0x3C   0x0609             LSLS     R1,R1,#+24
   \       0x3E   0xD511             BPL      ??HAL_SPI_Abort_IT_0
   2156            {
   2157              hspi->TxISR = SPI_AbortTx_ISR;
   \       0x40   0x....             LDR      R1,??DataTable10_1
   \       0x42   0x6469             STR      R1,[R5, #+68]
   2158              /* Wait HAL_SPI_STATE_ABORT state */
   2159              do
   2160              {
   2161                if (count == 0U)
   \                     ??HAL_SPI_Abort_IT_1: (+1)
   \       0x44   0x9900             LDR      R1,[SP, #+0]
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD007             BEQ      ??HAL_SPI_Abort_IT_2
   2162                {
   2163                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2164                  break;
   2165                }
   2166                count--;
   \       0x4A   0x9900             LDR      R1,[SP, #+0]
   \       0x4C   0x1E49             SUBS     R1,R1,#+1
   \       0x4E   0x9100             STR      R1,[SP, #+0]
   2167              }
   2168              while (hspi->State != HAL_SPI_STATE_ABORT);
   \       0x50   0x2151             MOVS     R1,#+81
   \       0x52   0x5C69             LDRB     R1,[R5, R1]
   \       0x54   0x2907             CMP      R1,#+7
   \       0x56   0xD1F5             BNE      ??HAL_SPI_Abort_IT_1
   \       0x58   0xE002             B        ??HAL_SPI_Abort_IT_3
   \                     ??HAL_SPI_Abort_IT_2: (+1)
   \       0x5A   0x6D69             LDR      R1,[R5, #+84]
   \       0x5C   0x4331             ORRS     R1,R1,R6
   \       0x5E   0x6569             STR      R1,[R5, #+84]
   2169              /* Reset Timeout Counter */
   2170              count = resetcount;
   \                     ??HAL_SPI_Abort_IT_3: (+1)
   \       0x60   0x9902             LDR      R1,[SP, #+8]
   \       0x62   0x9100             STR      R1,[SP, #+0]
   2171            }
   2172          
   2173            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   \                     ??HAL_SPI_Abort_IT_0: (+1)
   \       0x64   0x6841             LDR      R1,[R0, #+4]
   \       0x66   0x4031             ANDS     R1,R1,R6
   \       0x68   0xD011             BEQ      ??HAL_SPI_Abort_IT_4
   2174            {
   2175              hspi->RxISR = SPI_AbortRx_ISR;
   \       0x6A   0x....             LDR      R1,??DataTable10_2
   \       0x6C   0x6429             STR      R1,[R5, #+64]
   2176              /* Wait HAL_SPI_STATE_ABORT state */
   2177              do
   2178              {
   2179                if (count == 0U)
   \                     ??HAL_SPI_Abort_IT_5: (+1)
   \       0x6E   0x9900             LDR      R1,[SP, #+0]
   \       0x70   0x2900             CMP      R1,#+0
   \       0x72   0xD007             BEQ      ??HAL_SPI_Abort_IT_6
   2180                {
   2181                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2182                  break;
   2183                }
   2184                count--;
   \       0x74   0x9900             LDR      R1,[SP, #+0]
   \       0x76   0x1E49             SUBS     R1,R1,#+1
   \       0x78   0x9100             STR      R1,[SP, #+0]
   2185              }
   2186              while (hspi->State != HAL_SPI_STATE_ABORT);
   \       0x7A   0x2151             MOVS     R1,#+81
   \       0x7C   0x5C69             LDRB     R1,[R5, R1]
   \       0x7E   0x2907             CMP      R1,#+7
   \       0x80   0xD1F5             BNE      ??HAL_SPI_Abort_IT_5
   \       0x82   0xE002             B        ??HAL_SPI_Abort_IT_7
   \                     ??HAL_SPI_Abort_IT_6: (+1)
   \       0x84   0x6D69             LDR      R1,[R5, #+84]
   \       0x86   0x4331             ORRS     R1,R1,R6
   \       0x88   0x6569             STR      R1,[R5, #+84]
   2187              /* Reset Timeout Counter */
   2188              count = resetcount;
   \                     ??HAL_SPI_Abort_IT_7: (+1)
   \       0x8A   0x9902             LDR      R1,[SP, #+8]
   \       0x8C   0x9100             STR      R1,[SP, #+0]
   2189            }
   2190          
   2191            /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
   2192               before any call to DMA Abort functions */
   2193            /* DMA Tx Handle is valid */
   2194            if (hspi->hdmatx != NULL)
   \                     ??HAL_SPI_Abort_IT_4: (+1)
   \       0x8E   0x6CAA             LDR      R2,[R5, #+72]
   \       0x90   0x2102             MOVS     R1,#+2
   \       0x92   0x2A00             CMP      R2,#+0
   \       0x94   0xD006             BEQ      ??HAL_SPI_Abort_IT_8
   2195            {
   2196              /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
   2197                 Otherwise, set it to NULL */
   2198              if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   \       0x96   0x6840             LDR      R0,[R0, #+4]
   \       0x98   0x4008             ANDS     R0,R0,R1
   \       0x9A   0xD002             BEQ      ??HAL_SPI_Abort_IT_9
   2199              {
   2200                hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
   \       0x9C   0x....             LDR      R0,??DataTable11
   \       0x9E   0x6390             STR      R0,[R2, #+56]
   \       0xA0   0xE000             B        ??HAL_SPI_Abort_IT_8
   2201              }
   2202              else
   2203              {
   2204                hspi->hdmatx->XferAbortCallback = NULL;
   \                     ??HAL_SPI_Abort_IT_9: (+1)
   \       0xA2   0x6394             STR      R4,[R2, #+56]
   2205              }
   2206            }
   2207            /* DMA Rx Handle is valid */
   2208            if (hspi->hdmarx != NULL)
   \                     ??HAL_SPI_Abort_IT_8: (+1)
   \       0xA4   0x6CE8             LDR      R0,[R5, #+76]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD007             BEQ      ??HAL_SPI_Abort_IT_10
   2209            {
   2210              /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
   2211                 Otherwise, set it to NULL */
   2212              if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   \       0xAA   0x682A             LDR      R2,[R5, #+0]
   \       0xAC   0x6852             LDR      R2,[R2, #+4]
   \       0xAE   0x403A             ANDS     R2,R2,R7
   \       0xB0   0xD002             BEQ      ??HAL_SPI_Abort_IT_11
   2213              {
   2214                hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
   \       0xB2   0x....             LDR      R2,??DataTable11_1
   \       0xB4   0x6382             STR      R2,[R0, #+56]
   \       0xB6   0xE000             B        ??HAL_SPI_Abort_IT_10
   2215              }
   2216              else
   2217              {
   2218                hspi->hdmarx->XferAbortCallback = NULL;
   \                     ??HAL_SPI_Abort_IT_11: (+1)
   \       0xB8   0x6384             STR      R4,[R0, #+56]
   2219              }
   2220            }
   2221          
   2222            /* Disable the SPI DMA Tx request if enabled */
   2223            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   \                     ??HAL_SPI_Abort_IT_10: (+1)
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0x6840             LDR      R0,[R0, #+4]
   \       0xBE   0x4001             ANDS     R1,R1,R0
   \       0xC0   0xD00B             BEQ      ??HAL_SPI_Abort_IT_12
   2224            {
   2225              /* Abort the SPI DMA Tx Stream/Channel */
   2226              if (hspi->hdmatx != NULL)
   \       0xC2   0x6CA8             LDR      R0,[R5, #+72]
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD008             BEQ      ??HAL_SPI_Abort_IT_12
   2227              {
   2228                /* Abort DMA Tx Handle linked to SPI Peripheral */
   2229                if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
   \       0xC8   0x....'....        BL       HAL_DMA_Abort_IT
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD003             BEQ      ??HAL_SPI_Abort_IT_13
   2230                {
   2231                  hspi->hdmatx->XferAbortCallback = NULL;
   \       0xD0   0x6CA8             LDR      R0,[R5, #+72]
   \       0xD2   0x6384             STR      R4,[R0, #+56]
   2232                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   \       0xD4   0x656E             STR      R6,[R5, #+84]
   \       0xD6   0xE000             B        ??HAL_SPI_Abort_IT_12
   2233                }
   2234                else
   2235                {
   2236                  abortcplt = 0U;
   \                     ??HAL_SPI_Abort_IT_13: (+1)
   \       0xD8   0x9403             STR      R4,[SP, #+12]
   2237                }
   2238              }
   2239            }
   2240            /* Disable the SPI DMA Rx request if enabled */
   2241            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   \                     ??HAL_SPI_Abort_IT_12: (+1)
   \       0xDA   0x6828             LDR      R0,[R5, #+0]
   \       0xDC   0x6840             LDR      R0,[R0, #+4]
   \       0xDE   0x4038             ANDS     R0,R0,R7
   \       0xE0   0xD009             BEQ      ??HAL_SPI_Abort_IT_14
   2242            {
   2243              /* Abort the SPI DMA Rx Stream/Channel */
   2244              if (hspi->hdmarx != NULL)
   \       0xE2   0x6CE8             LDR      R0,[R5, #+76]
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD006             BEQ      ??HAL_SPI_Abort_IT_14
   2245              {
   2246                /* Abort DMA Rx Handle linked to SPI Peripheral */
   2247                if (HAL_DMA_Abort_IT(hspi->hdmarx) !=  HAL_OK)
   \       0xE8   0x....'....        BL       HAL_DMA_Abort_IT
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD01E             BEQ      ??HAL_SPI_Abort_IT_15
   2248                {
   2249                  hspi->hdmarx->XferAbortCallback = NULL;
   \       0xF0   0x6CE8             LDR      R0,[R5, #+76]
   \       0xF2   0x6384             STR      R4,[R0, #+56]
   2250                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   \       0xF4   0x656E             STR      R6,[R5, #+84]
   2251                }
   2252                else
   2253                {
   2254                  abortcplt = 0U;
   2255                }
   2256              }
   2257            }
   2258          
   2259            if (abortcplt == 1U)
   \                     ??HAL_SPI_Abort_IT_14: (+1)
   \       0xF6   0x9803             LDR      R0,[SP, #+12]
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD018             BEQ      ??HAL_SPI_Abort_IT_15
   2260            {
   2261              /* Reset Tx and Rx transfer counters */
   2262              hspi->RxXferCount = 0U;
   \       0xFC   0x87EC             STRH     R4,[R5, #+62]
   2263              hspi->TxXferCount = 0U;
   \       0xFE   0x86EC             STRH     R4,[R5, #+54]
   2264          
   2265              /* Check error during Abort procedure */
   2266              if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
   \      0x100   0x6D68             LDR      R0,[R5, #+84]
   \      0x102   0x2840             CMP      R0,#+64
   \      0x104   0xD102             BNE      ??HAL_SPI_Abort_IT_16
   2267              {
   2268                /* return HAL_Error in case of error during Abort procedure */
   2269                errorcode = HAL_ERROR;
   \      0x106   0x4669             MOV      R1,SP
   \      0x108   0x710F             STRB     R7,[R1, #+4]
   \      0x10A   0xE000             B        ??HAL_SPI_Abort_IT_17
   2270              }
   2271              else
   2272              {
   2273                /* Reset errorCode */
   2274                hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_Abort_IT_16: (+1)
   \      0x10C   0x656C             STR      R4,[R5, #+84]
   2275              }
   2276          
   2277              /* Clear the Error flags in the SR register */
   2278              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??HAL_SPI_Abort_IT_17: (+1)
   \      0x10E   0x9400             STR      R4,[SP, #+0]
   \      0x110   0x6828             LDR      R0,[R5, #+0]
   \      0x112   0x68C1             LDR      R1,[R0, #+12]
   \      0x114   0x9100             STR      R1,[SP, #+0]
   \      0x116   0x6881             LDR      R1,[R0, #+8]
   \      0x118   0x9100             STR      R1,[SP, #+0]
   \      0x11A   0x9900             LDR      R1,[SP, #+0]
   2279              __HAL_SPI_CLEAR_FREFLAG(hspi);
   \      0x11C   0x9400             STR      R4,[SP, #+0]
   \      0x11E   0x6880             LDR      R0,[R0, #+8]
   \      0x120   0x9000             STR      R0,[SP, #+0]
   \      0x122   0x9800             LDR      R0,[SP, #+0]
   2280          
   2281              /* Restore hspi->State to Ready */
   2282              hspi->State = HAL_SPI_STATE_READY;
   \      0x124   0x2051             MOVS     R0,#+81
   \      0x126   0x542F             STRB     R7,[R5, R0]
   2283          
   2284              /* As no DMA to be aborted, call directly user Abort complete callback */
   2285          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2286              hspi->AbortCpltCallback(hspi);
   2287          #else
   2288              HAL_SPI_AbortCpltCallback(hspi);
   \      0x128   0x0028             MOVS     R0,R5
   \      0x12A   0x....'....        BL       HAL_SPI_AbortCpltCallback
   2289          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2290            }
   2291          
   2292            return errorcode;
   \                     ??HAL_SPI_Abort_IT_15: (+1)
   \      0x12E   0x4668             MOV      R0,SP
   \      0x130   0x7900             LDRB     R0,[R0, #+4]
   \      0x132   0xB005             ADD      SP,SP,#+20
   \      0x134   0xBDF0             POP      {R4-R7,PC}       ;; return
   2293          }
   2294          
   2295          /**
   2296            * @brief  Pause the DMA Transfer.
   2297            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2298            *               the configuration information for the specified SPI module.
   2299            * @retval HAL status
   2300            */

   \                                 In section .text, align 2, keep-with-next
   2301          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   2302          {
   2303            /* Process Locked */
   2304            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAPause: (+1)
   \        0x0   0x2150             MOVS     R1,#+80
   \        0x2   0x5C41             LDRB     R1,[R0, R1]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE      ??HAL_SPI_DMAPause_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0x4770             BX       LR
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x2250             MOVS     R2,#+80
   \       0x10   0x5481             STRB     R1,[R0, R2]
   2305          
   2306            /* Disable the SPI DMA Tx & Rx requests */
   2307            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x684A             LDR      R2,[R1, #+4]
   \       0x16   0x2303             MOVS     R3,#+3
   \       0x18   0x439A             BICS     R2,R2,R3
   \       0x1A   0x604A             STR      R2,[R1, #+4]
   2308          
   2309            /* Process Unlocked */
   2310            __HAL_UNLOCK(hspi);
   \       0x1C   0x....             B.N      ?Subroutine2
   2311          
   2312            return HAL_OK;
   2313          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x2250             MOVS     R2,#+80
   \        0x4   0x5481             STRB     R1,[R0, R2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x4770             BX       LR               ;; return
   2314          
   2315          /**
   2316            * @brief  Resume the DMA Transfer.
   2317            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2318            *               the configuration information for the specified SPI module.
   2319            * @retval HAL status
   2320            */

   \                                 In section .text, align 2, keep-with-next
   2321          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   2322          {
   2323            /* Process Locked */
   2324            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAResume: (+1)
   \        0x0   0x2150             MOVS     R1,#+80
   \        0x2   0x5C41             LDRB     R1,[R0, R1]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE      ??HAL_SPI_DMAResume_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0x4770             BX       LR
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x2250             MOVS     R2,#+80
   \       0x10   0x5481             STRB     R1,[R0, R2]
   2325          
   2326            /* Enable the SPI DMA Tx & Rx requests */
   2327            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x684A             LDR      R2,[R1, #+4]
   \       0x16   0x2303             MOVS     R3,#+3
   \       0x18   0x4313             ORRS     R3,R3,R2
   \       0x1A   0x604B             STR      R3,[R1, #+4]
   2328          
   2329            /* Process Unlocked */
   2330            __HAL_UNLOCK(hspi);
   \       0x1C                      REQUIRE ?Subroutine2
   \       0x1C                      ;; // Fall through to label ?Subroutine2
   2331          
   2332            return HAL_OK;
   2333          }
   2334          
   2335          /**
   2336            * @brief  Stop the DMA Transfer.
   2337            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2338            *               the configuration information for the specified SPI module.
   2339            * @retval HAL status
   2340            */

   \                                 In section .text, align 2, keep-with-next
   2341          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   2342          {
   \                     HAL_SPI_DMAStop: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2343            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x4   0x2700             MOVS     R7,#+0
   2344            /* The Lock is not implemented on this API to allow the user application
   2345               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   2346               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   2347               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   2348               */
   2349          
   2350            /* Abort the SPI DMA tx Stream/Channel  */
   2351            if (hspi->hdmatx != NULL)
   \        0x6   0x6CA0             LDR      R0,[R4, #+72]
   \        0x8   0x2501             MOVS     R5,#+1
   \        0xA   0x2610             MOVS     R6,#+16
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD007             BEQ      ??HAL_SPI_DMAStop_0
   2352            {
   2353              if (HAL_OK != HAL_DMA_Abort(hspi->hdmatx))
   \       0x10   0x....'....        BL       HAL_DMA_Abort
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD003             BEQ      ??HAL_SPI_DMAStop_0
   2354              {
   2355                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0x18   0x6D60             LDR      R0,[R4, #+84]
   \       0x1A   0x4330             ORRS     R0,R0,R6
   \       0x1C   0x6560             STR      R0,[R4, #+84]
   2356                errorcode = HAL_ERROR;
   \       0x1E   0x2701             MOVS     R7,#+1
   2357              }
   2358            }
   2359            /* Abort the SPI DMA rx Stream/Channel  */
   2360            if (hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \       0x20   0x6CE0             LDR      R0,[R4, #+76]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD007             BEQ      ??HAL_SPI_DMAStop_1
   2361            {
   2362              if (HAL_OK != HAL_DMA_Abort(hspi->hdmarx))
   \       0x26   0x....'....        BL       HAL_DMA_Abort
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD003             BEQ      ??HAL_SPI_DMAStop_1
   2363              {
   2364                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0x2E   0x6D60             LDR      R0,[R4, #+84]
   \       0x30   0x4306             ORRS     R6,R6,R0
   \       0x32   0x6566             STR      R6,[R4, #+84]
   2365                errorcode = HAL_ERROR;
   \       0x34   0x2701             MOVS     R7,#+1
   2366              }
   2367            }
   2368          
   2369            /* Disable the SPI DMA Tx & Rx requests */
   2370            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x6841             LDR      R1,[R0, #+4]
   \       0x3A   0x2203             MOVS     R2,#+3
   \       0x3C   0x4391             BICS     R1,R1,R2
   \       0x3E   0x6041             STR      R1,[R0, #+4]
   2371            hspi->State = HAL_SPI_STATE_READY;
   \       0x40   0x2051             MOVS     R0,#+81
   \       0x42   0x5425             STRB     R5,[R4, R0]
   2372            return errorcode;
   \       0x44   0x0038             MOVS     R0,R7
   \       0x46   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2373          }
   2374          
   2375          /**
   2376            * @brief  Handle SPI interrupt request.
   2377            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2378            *               the configuration information for the specified SPI module.
   2379            * @retval None
   2380            */

   \                                 In section .text, align 2, keep-with-next
   2381          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   2382          {
   \                     HAL_SPI_IRQHandler: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2383            uint32_t itsource = hspi->Instance->CR2;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0x9100             STR      R1,[SP, #+0]
   2384            uint32_t itflag   = hspi->Instance->SR;
   \        0xA   0x6881             LDR      R1,[R0, #+8]
   2385          
   2386            /* SPI in mode Receiver ----------------------------------------------------*/
   2387            if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
   2388                (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
   \        0xC   0x2540             MOVS     R5,#+64
   \        0xE   0x2241             MOVS     R2,#+65
   \       0x10   0x400A             ANDS     R2,R2,R1
   \       0x12   0x2A01             CMP      R2,#+1
   \       0x14   0xD106             BNE      ??HAL_SPI_IRQHandler_0
   \       0x16   0x9A00             LDR      R2,[SP, #+0]
   \       0x18   0x402A             ANDS     R2,R2,R5
   \       0x1A   0xD003             BEQ      ??HAL_SPI_IRQHandler_0
   2389            {
   2390              hspi->RxISR(hspi);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x6C21             LDR      R1,[R4, #+64]
   \       0x20   0x4788             BLX      R1
   2391              return;
   \       0x22   0xBDF7             POP      {R0-R2,R4-R7,PC}
   2392            }
   2393          
   2394            /* SPI in mode Transmitter -------------------------------------------------*/
   2395            if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \       0x24   0x078A             LSLS     R2,R1,#+30
   \       0x26   0xD506             BPL      ??HAL_SPI_IRQHandler_1
   \       0x28   0x9A00             LDR      R2,[SP, #+0]
   \       0x2A   0x0612             LSLS     R2,R2,#+24
   \       0x2C   0xD503             BPL      ??HAL_SPI_IRQHandler_1
   2396            {
   2397              hspi->TxISR(hspi);
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x6C61             LDR      R1,[R4, #+68]
   \       0x32   0x4788             BLX      R1
   2398              return;
   \       0x34   0xBDF7             POP      {R0-R2,R4-R7,PC}
   2399            }
   2400          
   2401            /* SPI in Error Treatment --------------------------------------------------*/
   2402            if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \       0x36   0x22B0             MOVS     R2,#+176
   \       0x38   0x0052             LSLS     R2,R2,#+1        ;; #+352
   \       0x3A   0x400A             ANDS     R2,R2,R1
   \       0x3C   0xD064             BEQ      ??HAL_SPI_IRQHandler_2
   \       0x3E   0x2220             MOVS     R2,#+32
   \       0x40   0x9B00             LDR      R3,[SP, #+0]
   \       0x42   0x4013             ANDS     R3,R3,R2
   \       0x44   0xD060             BEQ      ??HAL_SPI_IRQHandler_2
   2403            {
   2404              /* SPI Overrun error interrupt occurred ----------------------------------*/
   2405              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
   \       0x46   0x2300             MOVS     R3,#+0
   \       0x48   0x4229             TST      R1,R5
   \       0x4A   0xD00D             BEQ      ??HAL_SPI_IRQHandler_3
   2406              {
   2407                if (hspi->State != HAL_SPI_STATE_BUSY_TX)
   \       0x4C   0x2651             MOVS     R6,#+81
   \       0x4E   0x5DA6             LDRB     R6,[R4, R6]
   \       0x50   0x2E03             CMP      R6,#+3
   \       0x52   0xD04F             BEQ      ??HAL_SPI_IRQHandler_4
   2408                {
   2409                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
   \       0x54   0x6D66             LDR      R6,[R4, #+84]
   \       0x56   0x2704             MOVS     R7,#+4
   \       0x58   0x4337             ORRS     R7,R7,R6
   \       0x5A   0x6567             STR      R7,[R4, #+84]
   2410                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x5C   0x9301             STR      R3,[SP, #+4]
   \       0x5E   0x68C6             LDR      R6,[R0, #+12]
   \       0x60   0x9601             STR      R6,[SP, #+4]
   \       0x62   0x6886             LDR      R6,[R0, #+8]
   \       0x64   0x9601             STR      R6,[SP, #+4]
   \       0x66   0x9E01             LDR      R6,[SP, #+4]
   2411                }
   2412                else
   2413                {
   2414                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   2415                  return;
   2416                }
   2417              }
   2418          
   2419              /* SPI Mode Fault error interrupt occurred -------------------------------*/
   2420              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \       0x68   0x2601             MOVS     R6,#+1
   \       0x6A   0x400A             ANDS     R2,R2,R1
   \       0x6C   0xD00B             BEQ      ??HAL_SPI_IRQHandler_5
   2421              {
   2422                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
   \       0x6E   0x6D62             LDR      R2,[R4, #+84]
   \       0x70   0x4332             ORRS     R2,R2,R6
   \       0x72   0x6562             STR      R2,[R4, #+84]
   2423                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \       0x74   0x9301             STR      R3,[SP, #+4]
   \       0x76   0x6880             LDR      R0,[R0, #+8]
   \       0x78   0x9001             STR      R0,[SP, #+4]
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6800             LDR      R0,[R0, #+0]
   \       0x7E   0x43A8             BICS     R0,R0,R5
   \       0x80   0x6822             LDR      R2,[R4, #+0]
   \       0x82   0x6010             STR      R0,[R2, #+0]
   \       0x84   0x9801             LDR      R0,[SP, #+4]
   2424              }
   2425          
   2426              /* SPI Frame error interrupt occurred ------------------------------------*/
   2427              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \       0x86   0x05C8             LSLS     R0,R1,#+23
   \       0x88   0xD508             BPL      ??HAL_SPI_IRQHandler_6
   2428              {
   2429                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
   \       0x8A   0x6D60             LDR      R0,[R4, #+84]
   \       0x8C   0x2108             MOVS     R1,#+8
   \       0x8E   0x4301             ORRS     R1,R1,R0
   \       0x90   0x6561             STR      R1,[R4, #+84]
   2430                __HAL_SPI_CLEAR_FREFLAG(hspi);
   \       0x92   0x9301             STR      R3,[SP, #+4]
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6880             LDR      R0,[R0, #+8]
   \       0x98   0x9001             STR      R0,[SP, #+4]
   \       0x9A   0x9801             LDR      R0,[SP, #+4]
   2431              }
   2432          
   2433              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_IRQHandler_6: (+1)
   \       0x9C   0x6D60             LDR      R0,[R4, #+84]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD032             BEQ      ??HAL_SPI_IRQHandler_2
   2434              {
   2435                /* Disable all interrupts */
   2436                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x6841             LDR      R1,[R0, #+4]
   \       0xA6   0x22E0             MOVS     R2,#+224
   \       0xA8   0x4391             BICS     R1,R1,R2
   \       0xAA   0x6041             STR      R1,[R0, #+4]
   2437          
   2438                hspi->State = HAL_SPI_STATE_READY;
   \       0xAC   0x2051             MOVS     R0,#+81
   \       0xAE   0x5426             STRB     R6,[R4, R0]
   2439                /* Disable the SPI DMA requests if enabled */
   2440                if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
   \       0xB0   0x9800             LDR      R0,[SP, #+0]
   \       0xB2   0x0780             LSLS     R0,R0,#+30
   \       0xB4   0xD025             BEQ      ??HAL_SPI_IRQHandler_7
   2441                {
   2442                  CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x6841             LDR      R1,[R0, #+4]
   \       0xBA   0x2203             MOVS     R2,#+3
   \       0xBC   0x4391             BICS     R1,R1,R2
   \       0xBE   0x6041             STR      R1,[R0, #+4]
   2443          
   2444                  /* Abort the SPI DMA Rx channel */
   2445                  if (hspi->hdmarx != NULL)
   \       0xC0   0x6CE0             LDR      R0,[R4, #+76]
   \       0xC2   0x....             LDR      R6,??DataTable12
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD008             BEQ      ??HAL_SPI_IRQHandler_8
   2446                  {
   2447                    /* Set the SPI DMA Abort callback :
   2448                    will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
   2449                    hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
   \       0xC8   0x6386             STR      R6,[R0, #+56]
   2450                    if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
   \       0xCA   0x6CE0             LDR      R0,[R4, #+76]
   \       0xCC   0x....'....        BL       HAL_DMA_Abort_IT
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD002             BEQ      ??HAL_SPI_IRQHandler_8
   2451                    {
   2452                      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0xD4   0x6D60             LDR      R0,[R4, #+84]
   \       0xD6   0x4328             ORRS     R0,R0,R5
   \       0xD8   0x6560             STR      R0,[R4, #+84]
   2453                    }
   2454                  }
   2455                  /* Abort the SPI DMA Tx channel */
   2456                  if (hspi->hdmatx != NULL)
   \                     ??HAL_SPI_IRQHandler_8: (+1)
   \       0xDA   0x6CA0             LDR      R0,[R4, #+72]
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD013             BEQ      ??HAL_SPI_IRQHandler_2
   2457                  {
   2458                    /* Set the SPI DMA Abort callback :
   2459                    will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
   2460                    hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
   \       0xE0   0x6386             STR      R6,[R0, #+56]
   2461                    if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
   \       0xE2   0x6CA0             LDR      R0,[R4, #+72]
   \       0xE4   0x....'....        BL       HAL_DMA_Abort_IT
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD00D             BEQ      ??HAL_SPI_IRQHandler_2
   2462                    {
   2463                      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0xEC   0x6D60             LDR      R0,[R4, #+84]
   \       0xEE   0x4305             ORRS     R5,R5,R0
   \       0xF0   0x6565             STR      R5,[R4, #+84]
   \       0xF2   0xBDF7             POP      {R0-R2,R4-R7,PC}
   2464                    }
   2465                  }
   2466                }
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \       0xF4   0x9300             STR      R3,[SP, #+0]
   \       0xF6   0x68C1             LDR      R1,[R0, #+12]
   \       0xF8   0x9100             STR      R1,[SP, #+0]
   \       0xFA   0x6880             LDR      R0,[R0, #+8]
   \       0xFC   0x9000             STR      R0,[SP, #+0]
   \       0xFE   0x9800             LDR      R0,[SP, #+0]
   \      0x100   0xBDF7             POP      {R0-R2,R4-R7,PC}
   2467                else
   2468                {
   2469                  /* Call user error callback */
   2470          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2471                  hspi->ErrorCallback(hspi);
   2472          #else
   2473                  HAL_SPI_ErrorCallback(hspi);
   \                     ??HAL_SPI_IRQHandler_7: (+1)
   \      0x102   0x0020             MOVS     R0,R4
   \      0x104   0x....'....        BL       HAL_SPI_ErrorCallback
   2474          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2475                }
   2476              }
   2477              return;
   2478            }
   2479          }
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \      0x108   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   2480          
   2481          /**
   2482            * @brief  Tx Transfer completed callback.
   2483            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2484            *               the configuration information for SPI module.
   2485            * @retval None
   2486            */

   \                                 In section .text, align 2
   2487          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   2488          {
   2489            /* Prevent unused argument(s) compilation warning */
   2490            UNUSED(hspi);
   2491          
   2492            /* NOTE : This function should not be modified, when the callback is needed,
   2493                      the HAL_SPI_TxCpltCallback should be implemented in the user file
   2494             */
   2495          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2496          
   2497          /**
   2498            * @brief  Rx Transfer completed callback.
   2499            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2500            *               the configuration information for SPI module.
   2501            * @retval None
   2502            */

   \                                 In section .text, align 2
   2503          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   2504          {
   2505            /* Prevent unused argument(s) compilation warning */
   2506            UNUSED(hspi);
   2507          
   2508            /* NOTE : This function should not be modified, when the callback is needed,
   2509                      the HAL_SPI_RxCpltCallback should be implemented in the user file
   2510             */
   2511          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2512          
   2513          /**
   2514            * @brief  Tx and Rx Transfer completed callback.
   2515            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2516            *               the configuration information for SPI module.
   2517            * @retval None
   2518            */

   \                                 In section .text, align 2
   2519          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   2520          {
   2521            /* Prevent unused argument(s) compilation warning */
   2522            UNUSED(hspi);
   2523          
   2524            /* NOTE : This function should not be modified, when the callback is needed,
   2525                      the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   2526             */
   2527          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2528          
   2529          /**
   2530            * @brief  Tx Half Transfer completed callback.
   2531            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2532            *               the configuration information for SPI module.
   2533            * @retval None
   2534            */

   \                                 In section .text, align 2
   2535          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2536          {
   2537            /* Prevent unused argument(s) compilation warning */
   2538            UNUSED(hspi);
   2539          
   2540            /* NOTE : This function should not be modified, when the callback is needed,
   2541                      the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   2542             */
   2543          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2544          
   2545          /**
   2546            * @brief  Rx Half Transfer completed callback.
   2547            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2548            *               the configuration information for SPI module.
   2549            * @retval None
   2550            */

   \                                 In section .text, align 2
   2551          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2552          {
   2553            /* Prevent unused argument(s) compilation warning */
   2554            UNUSED(hspi);
   2555          
   2556            /* NOTE : This function should not be modified, when the callback is needed,
   2557                      the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   2558             */
   2559          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2560          
   2561          /**
   2562            * @brief  Tx and Rx Half Transfer callback.
   2563            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2564            *               the configuration information for SPI module.
   2565            * @retval None
   2566            */

   \                                 In section .text, align 2
   2567          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2568          {
   2569            /* Prevent unused argument(s) compilation warning */
   2570            UNUSED(hspi);
   2571          
   2572            /* NOTE : This function should not be modified, when the callback is needed,
   2573                      the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   2574             */
   2575          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2576          
   2577          /**
   2578            * @brief  SPI error callback.
   2579            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2580            *               the configuration information for SPI module.
   2581            * @retval None
   2582            */

   \                                 In section .text, align 2
   2583          __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   2584          {
   2585            /* Prevent unused argument(s) compilation warning */
   2586            UNUSED(hspi);
   2587          
   2588            /* NOTE : This function should not be modified, when the callback is needed,
   2589                      the HAL_SPI_ErrorCallback should be implemented in the user file
   2590             */
   2591            /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
   2592                      and user can use HAL_SPI_GetError() API to check the latest error occurred
   2593             */
   2594          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2595          
   2596          /**
   2597            * @brief  SPI Abort Complete callback.
   2598            * @param  hspi SPI handle.
   2599            * @retval None
   2600            */

   \                                 In section .text, align 2
   2601          __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
   2602          {
   2603            /* Prevent unused argument(s) compilation warning */
   2604            UNUSED(hspi);
   2605          
   2606            /* NOTE : This function should not be modified, when the callback is needed,
   2607                      the HAL_SPI_AbortCpltCallback can be implemented in the user file.
   2608             */
   2609          }
   \                     HAL_SPI_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2610          
   2611          /**
   2612            * @}
   2613            */
   2614          
   2615          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
   2616            * @brief   SPI control functions
   2617            *
   2618          @verbatim
   2619           ===============================================================================
   2620                                ##### Peripheral State and Errors functions #####
   2621           ===============================================================================
   2622              [..]
   2623              This subsection provides a set of functions allowing to control the SPI.
   2624               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   2625               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   2626          @endverbatim
   2627            * @{
   2628            */
   2629          
   2630          /**
   2631            * @brief  Return the SPI handle state.
   2632            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2633            *               the configuration information for SPI module.
   2634            * @retval SPI state
   2635            */

   \                                 In section .text, align 2, keep-with-next
   2636          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   2637          {
   2638            /* Return SPI handle state */
   2639            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \        0x0   0x2151             MOVS     R1,#+81
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   2640          }
   2641          
   2642          /**
   2643            * @brief  Return the SPI error code.
   2644            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2645            *               the configuration information for SPI module.
   2646            * @retval SPI error code in bitmap format
   2647            */

   \                                 In section .text, align 2, keep-with-next
   2648          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   2649          {
   2650            /* Return SPI ErrorCode */
   2651            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \        0x0   0x6D40             LDR      R0,[R0, #+84]
   \        0x2   0x4770             BX       LR               ;; return
   2652          }
   2653          
   2654          /**
   2655            * @}
   2656            */
   2657          
   2658          /**
   2659            * @}
   2660            */
   2661          
   2662          /** @addtogroup SPI_Private_Functions
   2663            * @brief   Private functions
   2664            * @{
   2665            */
   2666          
   2667          /**
   2668            * @brief  DMA SPI transmit process complete callback.
   2669            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2670            *               the configuration information for the specified DMA module.
   2671            * @retval None
   2672            */

   \                                 In section .text, align 2, keep-with-next
   2673          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   2674          {
   \                     SPI_DMATransmitCplt: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   2675            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6AB4             LDR      R4,[R6, #+40]
   2676            uint32_t tickstart;
   2677          
   2678            /* Init tickstart for timeout management*/
   2679            tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   2680          
   2681            /* DMA Normal Mode */
   2682            if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
   \        0xA   0x2520             MOVS     R5,#+32
   \        0xC   0x6831             LDR      R1,[R6, #+0]
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x4029             ANDS     R1,R1,R5
   \       0x12   0xD128             BNE      ??SPI_DMATransmitCplt_0
   2683            {
   2684              /* Disable ERR interrupt */
   2685              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \       0x14   0x6821             LDR      R1,[R4, #+0]
   \       0x16   0x684A             LDR      R2,[R1, #+4]
   \       0x18   0x43AA             BICS     R2,R2,R5
   \       0x1A   0x604A             STR      R2,[R1, #+4]
   2686          
   2687              /* Disable Tx DMA Request */
   2688              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x684A             LDR      R2,[R1, #+4]
   \       0x20   0x2302             MOVS     R3,#+2
   \       0x22   0x439A             BICS     R2,R2,R3
   \       0x24   0x604A             STR      R2,[R1, #+4]
   2689          
   2690              /* Check the end of the transaction */
   2691              if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \       0x26   0x0002             MOVS     R2,R0
   \       0x28   0x2164             MOVS     R1,#+100
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x....'....        BL       SPI_EndRxTxTransaction
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD002             BEQ      ??SPI_DMATransmitCplt_1
   2692              {
   2693                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x34   0x6D60             LDR      R0,[R4, #+84]
   \       0x36   0x4305             ORRS     R5,R5,R0
   \       0x38   0x6565             STR      R5,[R4, #+84]
   2694              }
   2695          
   2696              /* Clear overrun flag in 2 Lines communication mode because received data is not read */
   2697              if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_DMATransmitCplt_1: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x68A1             LDR      R1,[R4, #+8]
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0xD106             BNE      ??SPI_DMATransmitCplt_2
   2698              {
   2699                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x42   0x9000             STR      R0,[SP, #+0]
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x68CA             LDR      R2,[R1, #+12]
   \       0x48   0x9200             STR      R2,[SP, #+0]
   \       0x4A   0x6889             LDR      R1,[R1, #+8]
   \       0x4C   0x9100             STR      R1,[SP, #+0]
   \       0x4E   0x9900             LDR      R1,[SP, #+0]
   2700              }
   2701          
   2702              hspi->TxXferCount = 0U;
   \                     ??SPI_DMATransmitCplt_2: (+1)
   \       0x50   0x86E0             STRH     R0,[R4, #+54]
   2703              hspi->State = HAL_SPI_STATE_READY;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0x2151             MOVS     R1,#+81
   \       0x56   0x5460             STRB     R0,[R4, R1]
   2704          
   2705              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \       0x58   0x6D60             LDR      R0,[R4, #+84]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD003             BEQ      ??SPI_DMATransmitCplt_0
   2706              {
   2707                /* Call user error callback */
   2708          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2709                hspi->ErrorCallback(hspi);
   2710          #else
   2711                HAL_SPI_ErrorCallback(hspi);
   \       0x5E   0x0020             MOVS     R0,R4
   \       0x60   0x....'....        BL       HAL_SPI_ErrorCallback
   2712          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2713                return;
   \       0x64   0xBD73             POP      {R0,R1,R4-R6,PC}
   2714              }
   2715            }
   2716            /* Call user Tx complete callback */
   2717          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2718            hspi->TxCpltCallback(hspi);
   2719          #else
   2720            HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x....'....        BL       HAL_SPI_TxCpltCallback
   2721          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2722          }
   \       0x6C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   2723          
   2724          /**
   2725            * @brief  DMA SPI receive process complete callback.
   2726            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2727            *               the configuration information for the specified DMA module.
   2728            * @retval None
   2729            */

   \                                 In section .text, align 2, keep-with-next
   2730          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   2731          {
   \                     SPI_DMAReceiveCplt: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   2732            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6AB5             LDR      R5,[R6, #+40]
   2733            uint32_t tickstart;
   2734          
   2735            /* Init tickstart for timeout management*/
   2736            tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   2737          
   2738            /* DMA Normal Mode */
   2739            if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
   \        0xA   0x2420             MOVS     R4,#+32
   \        0xC   0x6831             LDR      R1,[R6, #+0]
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x4021             ANDS     R1,R1,R4
   \       0x12   0xD119             BNE      ??SPI_DMAReceiveCplt_0
   2740            {
   2741              /* Disable ERR interrupt */
   2742              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \       0x14   0x6829             LDR      R1,[R5, #+0]
   \       0x16   0x684A             LDR      R2,[R1, #+4]
   \       0x18   0x43A2             BICS     R2,R2,R4
   \       0x1A   0x604A             STR      R2,[R1, #+4]
   2743          
   2744          #if (USE_SPI_CRC != 0U)
   2745              /* CRC handling */
   2746              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2747              {
   2748                /* Wait until RXNE flag */
   2749                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   2750                {
   2751                  /* Error on the CRC reception */
   2752                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2753                }
   2754                /* Read CRC */
   2755                READ_REG(hspi->Instance->DR);
   2756              }
   2757          #endif /* USE_SPI_CRC */
   2758          
   2759              /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
   2760              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x684A             LDR      R2,[R1, #+4]
   \       0x20   0x2303             MOVS     R3,#+3
   \       0x22   0x439A             BICS     R2,R2,R3
   \       0x24   0x604A             STR      R2,[R1, #+4]
   2761          
   2762              /* Check the end of the transaction */
   2763              if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \       0x26   0x0002             MOVS     R2,R0
   \       0x28   0x2164             MOVS     R1,#+100
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x....'....        BL       SPI_EndRxTransaction
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD000             BEQ      ??SPI_DMAReceiveCplt_1
   2764              {
   2765                hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \       0x34   0x656C             STR      R4,[R5, #+84]
   2766              }
   2767          
   2768              hspi->RxXferCount = 0U;
   \                     ??SPI_DMAReceiveCplt_1: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x87E8             STRH     R0,[R5, #+62]
   2769              hspi->State = HAL_SPI_STATE_READY;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x2151             MOVS     R1,#+81
   \       0x3E   0x5468             STRB     R0,[R5, R1]
   2770          
   2771          #if (USE_SPI_CRC != 0U)
   2772              /* Check if CRC error occurred */
   2773              if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   2774              {
   2775                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2776                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2777              }
   2778          #endif /* USE_SPI_CRC */
   2779          
   2780              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \       0x40   0x6D68             LDR      R0,[R5, #+84]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD000             BEQ      ??SPI_DMAReceiveCplt_0
   2781              {
   2782                /* Call user error callback */
   2783          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2784                hspi->ErrorCallback(hspi);
   2785          #else
   2786                HAL_SPI_ErrorCallback(hspi);
   \       0x46   0x....             B.N      ?Subroutine0
   2787          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2788                return;
   2789              }
   2790            }
   2791            /* Call user Rx complete callback */
   2792          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2793            hspi->RxCpltCallback(hspi);
   2794          #else
   2795            HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0x....'....        BL       HAL_SPI_RxCpltCallback
   2796          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2797          }
   \       0x4E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x0028             MOVS     R0,R5
   \        0x2   0x....'....        BL       HAL_SPI_ErrorCallback
   \        0x6   0xBD70             POP      {R4-R6,PC}
   2798          
   2799          /**
   2800            * @brief  DMA SPI transmit receive process complete callback.
   2801            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2802            *               the configuration information for the specified DMA module.
   2803            * @retval None
   2804            */

   \                                 In section .text, align 2, keep-with-next
   2805          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2806          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   2807            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6AB5             LDR      R5,[R6, #+40]
   2808            uint32_t tickstart;
   2809          
   2810            /* Init tickstart for timeout management*/
   2811            tickstart = HAL_GetTick();
   \        0x6   0x....'....        BL       HAL_GetTick
   2812          
   2813            /* DMA Normal Mode */
   2814            if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
   \        0xA   0x2420             MOVS     R4,#+32
   \        0xC   0x6831             LDR      R1,[R6, #+0]
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x4021             ANDS     R1,R1,R4
   \       0x12   0xD11C             BNE      ??SPI_DMATransmitReceiveCplt_0
   2815            {
   2816              /* Disable ERR interrupt */
   2817              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \       0x14   0x6829             LDR      R1,[R5, #+0]
   \       0x16   0x684A             LDR      R2,[R1, #+4]
   \       0x18   0x43A2             BICS     R2,R2,R4
   \       0x1A   0x604A             STR      R2,[R1, #+4]
   2818          
   2819          #if (USE_SPI_CRC != 0U)
   2820              /* CRC handling */
   2821              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2822              {
   2823                /* Wait the CRC data */
   2824                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   2825                {
   2826                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2827                }
   2828                /* Read CRC to Flush DR and RXNE flag */
   2829                READ_REG(hspi->Instance->DR);
   2830              }
   2831          #endif /* USE_SPI_CRC */
   2832          
   2833              /* Check the end of the transaction */
   2834              if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \       0x1C   0x0002             MOVS     R2,R0
   \       0x1E   0x2164             MOVS     R1,#+100
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x....'....        BL       SPI_EndRxTxTransaction
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ      ??SPI_DMATransmitReceiveCplt_1
   2835              {
   2836                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x2A   0x6D68             LDR      R0,[R5, #+84]
   \       0x2C   0x4304             ORRS     R4,R4,R0
   \       0x2E   0x656C             STR      R4,[R5, #+84]
   2837              }
   2838          
   2839              /* Disable Rx/Tx DMA Request */
   2840              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x6841             LDR      R1,[R0, #+4]
   \       0x34   0x2203             MOVS     R2,#+3
   \       0x36   0x4391             BICS     R1,R1,R2
   \       0x38   0x6041             STR      R1,[R0, #+4]
   2841          
   2842              hspi->TxXferCount = 0U;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x86E8             STRH     R0,[R5, #+54]
   2843              hspi->RxXferCount = 0U;
   \       0x3E   0x87E8             STRH     R0,[R5, #+62]
   2844              hspi->State = HAL_SPI_STATE_READY;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x2151             MOVS     R1,#+81
   \       0x44   0x5468             STRB     R0,[R5, R1]
   2845          
   2846          #if (USE_SPI_CRC != 0U)
   2847              /* Check if CRC error occurred */
   2848              if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   2849              {
   2850                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2851                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2852              }
   2853          #endif /* USE_SPI_CRC */
   2854          
   2855              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \       0x46   0x6D68             LDR      R0,[R5, #+84]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD000             BEQ      ??SPI_DMATransmitReceiveCplt_0
   2856              {
   2857                /* Call user error callback */
   2858          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2859                hspi->ErrorCallback(hspi);
   2860          #else
   2861                HAL_SPI_ErrorCallback(hspi);
   \       0x4C   0x....             B.N      ?Subroutine0
   2862          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2863                return;
   2864              }
   2865            }
   2866            /* Call user TxRx complete callback */
   2867          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2868            hspi->TxRxCpltCallback(hspi);
   2869          #else
   2870            HAL_SPI_TxRxCpltCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0x....'....        BL       HAL_SPI_TxRxCpltCallback
   2871          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2872          }
   \       0x54   0xBD70             POP      {R4-R6,PC}       ;; return
   2873          
   2874          /**
   2875            * @brief  DMA SPI half transmit process complete callback.
   2876            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2877            *               the configuration information for the specified DMA module.
   2878            * @retval None
   2879            */

   \                                 In section .text, align 2, keep-with-next
   2880          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2881          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2882            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   2883          
   2884            /* Call user Tx half complete callback */
   2885          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2886            hspi->TxHalfCpltCallback(hspi);
   2887          #else
   2888            HAL_SPI_TxHalfCpltCallback(hspi);
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   \        0x4   0x....'....        BL       HAL_SPI_TxHalfCpltCallback
   2889          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2890          }
   \        0x8   0xBD01             POP      {R0,PC}          ;; return
   2891          
   2892          /**
   2893            * @brief  DMA SPI half receive process complete callback
   2894            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2895            *               the configuration information for the specified DMA module.
   2896            * @retval None
   2897            */

   \                                 In section .text, align 2, keep-with-next
   2898          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2899          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2900            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   2901          
   2902            /* Call user Rx half complete callback */
   2903          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2904            hspi->RxHalfCpltCallback(hspi);
   2905          #else
   2906            HAL_SPI_RxHalfCpltCallback(hspi);
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   \        0x4   0x....'....        BL       HAL_SPI_RxHalfCpltCallback
   2907          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2908          }
   \        0x8   0xBD01             POP      {R0,PC}          ;; return
   2909          
   2910          /**
   2911            * @brief  DMA SPI half transmit receive process complete callback.
   2912            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2913            *               the configuration information for the specified DMA module.
   2914            * @retval None
   2915            */

   \                                 In section .text, align 2, keep-with-next
   2916          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2917          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2918            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   2919          
   2920            /* Call user TxRx half complete callback */
   2921          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2922            hspi->TxRxHalfCpltCallback(hspi);
   2923          #else
   2924            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   \        0x4   0x....'....        BL       HAL_SPI_TxRxHalfCpltCallback
   2925          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2926          }
   \        0x8   0xBD01             POP      {R0,PC}          ;; return
   2927          
   2928          /**
   2929            * @brief  DMA SPI communication error callback.
   2930            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2931            *               the configuration information for the specified DMA module.
   2932            * @retval None
   2933            */

   \                                 In section .text, align 2, keep-with-next
   2934          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2935          {
   \                     SPI_DMAError: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2936            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   2937          
   2938            /* Stop the disable DMA transfer on SPI side */
   2939            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x684A             LDR      R2,[R1, #+4]
   \        0x8   0x2303             MOVS     R3,#+3
   \        0xA   0x439A             BICS     R2,R2,R3
   \        0xC   0x604A             STR      R2,[R1, #+4]
   2940          
   2941            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \        0xE   0x6D41             LDR      R1,[R0, #+84]
   \       0x10   0x2210             MOVS     R2,#+16
   \       0x12   0x430A             ORRS     R2,R2,R1
   \       0x14   0x6542             STR      R2,[R0, #+84]
   2942            hspi->State = HAL_SPI_STATE_READY;
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x2251             MOVS     R2,#+81
   \       0x1A   0x5481             STRB     R1,[R0, R2]
   2943            /* Call user error callback */
   2944          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2945            hspi->ErrorCallback(hspi);
   2946          #else
   2947            HAL_SPI_ErrorCallback(hspi);
   \       0x1C   0x....'....        BL       HAL_SPI_ErrorCallback
   2948          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2949          }
   \       0x20   0xBD01             POP      {R0,PC}          ;; return
   2950          
   2951          /**
   2952            * @brief  DMA SPI communication abort callback, when initiated by HAL services on Error
   2953            *         (To be called at end of DMA Abort procedure following error occurrence).
   2954            * @param  hdma DMA handle.
   2955            * @retval None
   2956            */

   \                                 In section .text, align 2, keep-with-next
   2957          static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   2958          {
   \                     SPI_DMAAbortOnError: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2959            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   2960            hspi->RxXferCount = 0U;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x87C1             STRH     R1,[R0, #+62]
   2961            hspi->TxXferCount = 0U;
   \        0x8   0x86C1             STRH     R1,[R0, #+54]
   2962          
   2963            /* Call user error callback */
   2964          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2965            hspi->ErrorCallback(hspi);
   2966          #else
   2967            HAL_SPI_ErrorCallback(hspi);
   \        0xA   0x....'....        BL       HAL_SPI_ErrorCallback
   2968          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2969          }
   \        0xE   0xBD01             POP      {R0,PC}          ;; return
   2970          
   2971          /**
   2972            * @brief  DMA SPI Tx communication abort callback, when initiated by user
   2973            *         (To be called at end of DMA Tx Abort procedure following user abort request).
   2974            * @note   When this callback is executed, User Abort complete call back is called only if no
   2975            *         Abort still ongoing for Rx DMA Handle.
   2976            * @param  hdma DMA handle.
   2977            * @retval None
   2978            */

   \                                 In section .text, align 2, keep-with-next
   2979          static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
   2980          {
   \                     SPI_DMATxAbortCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2981            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6A84             LDR      R4,[R0, #+40]
   2982            __IO uint32_t count;
   2983          
   2984            hspi->hdmatx->XferAbortCallback = NULL;
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x6CA0             LDR      R0,[R4, #+72]
   \        0x8   0x6385             STR      R5,[R0, #+56]
   2985            count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0xA   0x....             LDR      R0,??DataTable13
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x2118             MOVS     R1,#+24
   \       0x10   0x....'....        BL       __aeabi_uidiv
   \       0x14   0x21FA             MOVS     R1,#+250
   \       0x16   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x18   0x....'....        BL       __aeabi_uidiv
   \       0x1C   0x2164             MOVS     R1,#+100
   \       0x1E   0x4348             MULS     R0,R1,R0
   \       0x20   0x9000             STR      R0,[SP, #+0]
   2986          
   2987            /* Disable Tx DMA Request */
   2988            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6841             LDR      R1,[R0, #+4]
   \       0x26   0x2202             MOVS     R2,#+2
   \       0x28   0x4391             BICS     R1,R1,R2
   \       0x2A   0x6041             STR      R1,[R0, #+4]
   2989          
   2990            /* Wait until TXE flag is set */
   2991            do
   2992            {
   2993              if (count == 0U)
   \                     ??SPI_DMATxAbortCallback_0: (+1)
   \       0x2C   0x9800             LDR      R0,[SP, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD007             BEQ      ??SPI_DMATxAbortCallback_1
   2994              {
   2995                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   2996                break;
   2997              }
   2998              count--;
   \       0x32   0x9800             LDR      R0,[SP, #+0]
   \       0x34   0x1E40             SUBS     R0,R0,#+1
   \       0x36   0x9000             STR      R0,[SP, #+0]
   2999            }
   3000            while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6880             LDR      R0,[R0, #+8]
   \       0x3C   0x0780             LSLS     R0,R0,#+30
   \       0x3E   0xD5F5             BPL      ??SPI_DMATxAbortCallback_0
   \       0x40   0xE003             B        ??SPI_DMATxAbortCallback_2
   \                     ??SPI_DMATxAbortCallback_1: (+1)
   \       0x42   0x6D60             LDR      R0,[R4, #+84]
   \       0x44   0x2140             MOVS     R1,#+64
   \       0x46   0x4301             ORRS     R1,R1,R0
   \       0x48   0x6561             STR      R1,[R4, #+84]
   3001          
   3002            /* Check if an Abort process is still ongoing */
   3003            if (hspi->hdmarx != NULL)
   \                     ??SPI_DMATxAbortCallback_2: (+1)
   \       0x4A   0x6CE0             LDR      R0,[R4, #+76]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD002             BEQ      ??SPI_DMATxAbortCallback_3
   3004            {
   3005              if (hspi->hdmarx->XferAbortCallback != NULL)
   \       0x50   0x6B80             LDR      R0,[R0, #+56]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD116             BNE      ??SPI_DMATxAbortCallback_4
   3006              {
   3007                return;
   3008              }
   3009            }
   3010          
   3011            /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
   3012            hspi->RxXferCount = 0U;
   \                     ??SPI_DMATxAbortCallback_3: (+1)
   \       0x56   0x87E5             STRH     R5,[R4, #+62]
   3013            hspi->TxXferCount = 0U;
   \       0x58   0x86E5             STRH     R5,[R4, #+54]
   3014          
   3015            /* Check no error during Abort procedure */
   3016            if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
   \       0x5A   0x6D60             LDR      R0,[R4, #+84]
   \       0x5C   0x2840             CMP      R0,#+64
   \       0x5E   0xD000             BEQ      ??SPI_DMATxAbortCallback_5
   3017            {
   3018              /* Reset errorCode */
   3019              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \       0x60   0x6565             STR      R5,[R4, #+84]
   3020            }
   3021          
   3022            /* Clear the Error flags in the SR register */
   3023            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??SPI_DMATxAbortCallback_5: (+1)
   \       0x62   0x9500             STR      R5,[SP, #+0]
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x68C1             LDR      R1,[R0, #+12]
   \       0x68   0x9100             STR      R1,[SP, #+0]
   \       0x6A   0x6881             LDR      R1,[R0, #+8]
   \       0x6C   0x9100             STR      R1,[SP, #+0]
   \       0x6E   0x9900             LDR      R1,[SP, #+0]
   3024            __HAL_SPI_CLEAR_FREFLAG(hspi);
   \       0x70   0x9500             STR      R5,[SP, #+0]
   \       0x72   0x6880             LDR      R0,[R0, #+8]
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0x9800             LDR      R0,[SP, #+0]
   3025          
   3026            /* Restore hspi->State to Ready */
   3027            hspi->State  = HAL_SPI_STATE_READY;
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0x2151             MOVS     R1,#+81
   \       0x7C   0x5460             STRB     R0,[R4, R1]
   3028          
   3029            /* Call user Abort complete callback */
   3030          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3031            hspi->AbortCpltCallback(hspi);
   3032          #else
   3033            HAL_SPI_AbortCpltCallback(hspi);
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x....'....        BL       HAL_SPI_AbortCpltCallback
   3034          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3035          }
   \                     ??SPI_DMATxAbortCallback_4: (+1)
   \       0x84   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3036          
   3037          /**
   3038            * @brief  DMA SPI Rx communication abort callback, when initiated by user
   3039            *         (To be called at end of DMA Rx Abort procedure following user abort request).
   3040            * @note   When this callback is executed, User Abort complete call back is called only if no
   3041            *         Abort still ongoing for Tx DMA Handle.
   3042            * @param  hdma DMA handle.
   3043            * @retval None
   3044            */

   \                                 In section .text, align 2, keep-with-next
   3045          static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
   3046          {
   \                     SPI_DMARxAbortCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3047            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6A85             LDR      R5,[R0, #+40]
   3048          
   3049            /* Disable SPI Peripheral */
   3050            __HAL_SPI_DISABLE(hspi);
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x2240             MOVS     R2,#+64
   \        0xA   0x4391             BICS     R1,R1,R2
   \        0xC   0x6001             STR      R1,[R0, #+0]
   3051          
   3052            hspi->hdmarx->XferAbortCallback = NULL;
   \        0xE   0x2400             MOVS     R4,#+0
   \       0x10   0x6CE8             LDR      R0,[R5, #+76]
   \       0x12   0x6384             STR      R4,[R0, #+56]
   3053          
   3054            /* Disable Rx DMA Request */
   3055            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6841             LDR      R1,[R0, #+4]
   \       0x18   0x2201             MOVS     R2,#+1
   \       0x1A   0x4391             BICS     R1,R1,R2
   \       0x1C   0x6041             STR      R1,[R0, #+4]
   3056          
   3057            /* Check Busy flag */
   3058            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   \       0x1E   0x....'....        BL       HAL_GetTick
   \       0x22   0x0002             MOVS     R2,R0
   \       0x24   0x2164             MOVS     R1,#+100
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x....'....        BL       SPI_EndRxTxTransaction
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD003             BEQ      ??SPI_DMARxAbortCallback_0
   3059            {
   3060              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0x30   0x6D68             LDR      R0,[R5, #+84]
   \       0x32   0x2140             MOVS     R1,#+64
   \       0x34   0x4301             ORRS     R1,R1,R0
   \       0x36   0x6569             STR      R1,[R5, #+84]
   3061            }
   3062          
   3063            /* Check if an Abort process is still ongoing */
   3064            if (hspi->hdmatx != NULL)
   \                     ??SPI_DMARxAbortCallback_0: (+1)
   \       0x38   0x6CA8             LDR      R0,[R5, #+72]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD002             BEQ      ??SPI_DMARxAbortCallback_1
   3065            {
   3066              if (hspi->hdmatx->XferAbortCallback != NULL)
   \       0x3E   0x6B80             LDR      R0,[R0, #+56]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD116             BNE      ??SPI_DMARxAbortCallback_2
   3067              {
   3068                return;
   3069              }
   3070            }
   3071          
   3072            /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
   3073            hspi->RxXferCount = 0U;
   \                     ??SPI_DMARxAbortCallback_1: (+1)
   \       0x44   0x87EC             STRH     R4,[R5, #+62]
   3074            hspi->TxXferCount = 0U;
   \       0x46   0x86EC             STRH     R4,[R5, #+54]
   3075          
   3076            /* Check no error during Abort procedure */
   3077            if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
   \       0x48   0x6D68             LDR      R0,[R5, #+84]
   \       0x4A   0x2840             CMP      R0,#+64
   \       0x4C   0xD000             BEQ      ??SPI_DMARxAbortCallback_3
   3078            {
   3079              /* Reset errorCode */
   3080              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \       0x4E   0x656C             STR      R4,[R5, #+84]
   3081            }
   3082          
   3083            /* Clear the Error flags in the SR register */
   3084            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??SPI_DMARxAbortCallback_3: (+1)
   \       0x50   0x9400             STR      R4,[SP, #+0]
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x68C1             LDR      R1,[R0, #+12]
   \       0x56   0x9100             STR      R1,[SP, #+0]
   \       0x58   0x6881             LDR      R1,[R0, #+8]
   \       0x5A   0x9100             STR      R1,[SP, #+0]
   \       0x5C   0x9900             LDR      R1,[SP, #+0]
   3085            __HAL_SPI_CLEAR_FREFLAG(hspi);
   \       0x5E   0x9400             STR      R4,[SP, #+0]
   \       0x60   0x6880             LDR      R0,[R0, #+8]
   \       0x62   0x9000             STR      R0,[SP, #+0]
   \       0x64   0x9800             LDR      R0,[SP, #+0]
   3086          
   3087            /* Restore hspi->State to Ready */
   3088            hspi->State  = HAL_SPI_STATE_READY;
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0x2151             MOVS     R1,#+81
   \       0x6A   0x5468             STRB     R0,[R5, R1]
   3089          
   3090            /* Call user Abort complete callback */
   3091          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3092            hspi->AbortCpltCallback(hspi);
   3093          #else
   3094            HAL_SPI_AbortCpltCallback(hspi);
   \       0x6C   0x0028             MOVS     R0,R5
   \       0x6E   0x....'....        BL       HAL_SPI_AbortCpltCallback
   3095          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3096          }
   \                     ??SPI_DMARxAbortCallback_2: (+1)
   \       0x72   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3097          
   3098          /**
   3099            * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
   3100            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3101            *               the configuration information for SPI module.
   3102            * @retval None
   3103            */

   \                                 In section .text, align 2, keep-with-next
   3104          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3105          {
   \                     SPI_2linesRxISR_8BIT: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x7B09             LDRB     R1,[R1, #+12]
   \        0x4   0x6B82             LDR      R2,[R0, #+56]
   \        0x6   0x7011             STRB     R1,[R2, #+0]
   \        0x8   0x6B81             LDR      R1,[R0, #+56]
   \        0xA   0x1C49             ADDS     R1,R1,#+1
   \        0xC   0x6381             STR      R1,[R0, #+56]
   \        0xE   0x8FC1             LDRH     R1,[R0, #+62]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x87C1             STRH     R1,[R0, #+62]
   \       0x14   0x8FC1             LDRH     R1,[R0, #+62]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD000             BEQ      ??SPI_2linesRxISR_8BIT_0
   \       0x1A   0x4770             BX       LR
   \                     ??SPI_2linesRxISR_8BIT_0: (+1)
   \       0x1C   0xB580             PUSH     {R7,LR}
   3106            /* Receive data in 8bit mode */
   3107            *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
   3108            hspi->pRxBuffPtr++;
   3109            hspi->RxXferCount--;
   3110          
   3111            /* Check end of the reception */
   3112            if (hspi->RxXferCount == 0U)
   3113            {
   3114          #if (USE_SPI_CRC != 0U)
   3115              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3116              {
   3117                hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
   3118                return;
   3119              }
   3120          #endif /* USE_SPI_CRC */
   3121          
   3122              /* Disable RXNE  and ERR interrupt */
   3123              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x684A             LDR      R2,[R1, #+4]
   \       0x22   0x2360             MOVS     R3,#+96
   \       0x24   0x439A             BICS     R2,R2,R3
   \       0x26   0x604A             STR      R2,[R1, #+4]
   3124          
   3125              if (hspi->TxXferCount == 0U)
   \       0x28   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x2A   0x....             B.N      ??Subroutine3_0
   3126              {
   3127                SPI_CloseRxTx_ISR(hspi);
   3128              }
   3129            }
   3130          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x684A             LDR      R2,[R1, #+4]
   \        0x4   0x2380             MOVS     R3,#+128
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x604A             STR      R2,[R1, #+4]
   \        0xA   0x8FC1             LDRH     R1,[R0, #+62]
   \                     ??Subroutine3_0: (+1)
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD101             BNE      ??Subroutine3_1
   \       0x10   0x....'....        BL       SPI_CloseRxTx_ISR
   \                     ??Subroutine3_1: (+1)
   \       0x14   0xBD01             POP      {R0,PC}          ;; return
   3131          
   3132          #if (USE_SPI_CRC != 0U)
   3133          /**
   3134            * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
   3135            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3136            *               the configuration information for SPI module.
   3137            * @retval None
   3138            */
   3139          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   3140          {
   3141            /* Read 8bit CRC to flush Data Regsiter */
   3142            READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
   3143          
   3144            /* Disable RXNE and ERR interrupt */
   3145            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   3146          
   3147            if (hspi->TxXferCount == 0U)
   3148            {
   3149              SPI_CloseRxTx_ISR(hspi);
   3150            }
   3151          }
   3152          #endif /* USE_SPI_CRC */
   3153          
   3154          /**
   3155            * @brief  Tx 8-bit handler for Transmit and Receive in Interrupt mode.
   3156            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3157            *               the configuration information for SPI module.
   3158            * @retval None
   3159            */

   \                                 In section .text, align 2, keep-with-next
   3160          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3161          {
   \                     SPI_2linesTxISR_8BIT: (+1)
   \        0x0   0x6B01             LDR      R1,[R0, #+48]
   \        0x2   0x7809             LDRB     R1,[R1, #+0]
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0x7311             STRB     R1,[R2, #+12]
   \        0x8   0x6B01             LDR      R1,[R0, #+48]
   \        0xA   0x1C49             ADDS     R1,R1,#+1
   \        0xC   0x6301             STR      R1,[R0, #+48]
   \        0xE   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x86C1             STRH     R1,[R0, #+54]
   \       0x14   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD000             BEQ      ??SPI_2linesTxISR_8BIT_0
   \       0x1A   0x4770             BX       LR
   \                     ??SPI_2linesTxISR_8BIT_0: (+1)
   \       0x1C   0xB580             PUSH     {R7,LR}
   3162            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   3163            hspi->pTxBuffPtr++;
   3164            hspi->TxXferCount--;
   3165          
   3166            /* Check the end of the transmission */
   3167            if (hspi->TxXferCount == 0U)
   3168            {
   3169          #if (USE_SPI_CRC != 0U)
   3170              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3171              {
   3172                /* Set CRC Next Bit to send CRC */
   3173                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3174                /* Disable TXE interrupt */
   3175                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   3176                return;
   3177              }
   3178          #endif /* USE_SPI_CRC */
   3179          
   3180              /* Disable TXE interrupt */
   3181              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \       0x1E   0x....             B.N      ?Subroutine3
   3182          
   3183              if (hspi->RxXferCount == 0U)
   3184              {
   3185                SPI_CloseRxTx_ISR(hspi);
   3186              }
   3187            }
   3188          }
   3189          
   3190          /**
   3191            * @brief  Rx 16-bit handler for Transmit and Receive in Interrupt mode.
   3192            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3193            *               the configuration information for SPI module.
   3194            * @retval None
   3195            */

   \                                 In section .text, align 2, keep-with-next
   3196          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3197          {
   \                     SPI_2linesRxISR_16BIT: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x68C9             LDR      R1,[R1, #+12]
   \        0x4   0x6B82             LDR      R2,[R0, #+56]
   \        0x6   0x8011             STRH     R1,[R2, #+0]
   \        0x8   0x6B81             LDR      R1,[R0, #+56]
   \        0xA   0x1C89             ADDS     R1,R1,#+2
   \        0xC   0x6381             STR      R1,[R0, #+56]
   \        0xE   0x8FC1             LDRH     R1,[R0, #+62]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x87C1             STRH     R1,[R0, #+62]
   \       0x14   0x8FC1             LDRH     R1,[R0, #+62]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD000             BEQ      ??SPI_2linesRxISR_16BIT_0
   \       0x1A   0x4770             BX       LR
   \                     ??SPI_2linesRxISR_16BIT_0: (+1)
   \       0x1C   0xB580             PUSH     {R7,LR}
   3198            /* Receive data in 16 Bit mode */
   3199            *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
   3200            hspi->pRxBuffPtr += sizeof(uint16_t);
   3201            hspi->RxXferCount--;
   3202          
   3203            if (hspi->RxXferCount == 0U)
   3204            {
   3205          #if (USE_SPI_CRC != 0U)
   3206              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3207              {
   3208                hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
   3209                return;
   3210              }
   3211          #endif /* USE_SPI_CRC */
   3212          
   3213              /* Disable RXNE interrupt */
   3214              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x684A             LDR      R2,[R1, #+4]
   \       0x22   0x2340             MOVS     R3,#+64
   \       0x24   0x439A             BICS     R2,R2,R3
   \       0x26   0x604A             STR      R2,[R1, #+4]
   3215          
   3216              if (hspi->TxXferCount == 0U)
   \       0x28   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x2A   0x....             B.N      ??Subroutine3_0
   3217              {
   3218                SPI_CloseRxTx_ISR(hspi);
   3219              }
   3220            }
   3221          }
   3222          
   3223          #if (USE_SPI_CRC != 0U)
   3224          /**
   3225            * @brief  Manage the CRC 16-bit receive for Transmit and Receive in Interrupt mode.
   3226            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3227            *               the configuration information for SPI module.
   3228            * @retval None
   3229            */
   3230          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   3231          {
   3232            /* Read 16bit CRC to flush Data Regsiter */
   3233            READ_REG(hspi->Instance->DR);
   3234          
   3235            /* Disable RXNE interrupt */
   3236            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   3237          
   3238            SPI_CloseRxTx_ISR(hspi);
   3239          }
   3240          #endif /* USE_SPI_CRC */
   3241          
   3242          /**
   3243            * @brief  Tx 16-bit handler for Transmit and Receive in Interrupt mode.
   3244            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3245            *               the configuration information for SPI module.
   3246            * @retval None
   3247            */

   \                                 In section .text, align 2, keep-with-next
   3248          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3249          {
   \                     SPI_2linesTxISR_16BIT: (+1)
   \        0x0   0x6B01             LDR      R1,[R0, #+48]
   \        0x2   0x8809             LDRH     R1,[R1, #+0]
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0x60D1             STR      R1,[R2, #+12]
   \        0x8   0x6B01             LDR      R1,[R0, #+48]
   \        0xA   0x1C89             ADDS     R1,R1,#+2
   \        0xC   0x6301             STR      R1,[R0, #+48]
   \        0xE   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x86C1             STRH     R1,[R0, #+54]
   \       0x14   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD000             BEQ      ??SPI_2linesTxISR_16BIT_0
   \       0x1A   0x4770             BX       LR
   \                     ??SPI_2linesTxISR_16BIT_0: (+1)
   \       0x1C   0xB580             PUSH     {R7,LR}
   3250            /* Transmit data in 16 Bit mode */
   3251            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   3252            hspi->pTxBuffPtr += sizeof(uint16_t);
   3253            hspi->TxXferCount--;
   3254          
   3255            /* Enable CRC Transmission */
   3256            if (hspi->TxXferCount == 0U)
   3257            {
   3258          #if (USE_SPI_CRC != 0U)
   3259              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3260              {
   3261                /* Set CRC Next Bit to send CRC */
   3262                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3263                /* Disable TXE interrupt */
   3264                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   3265                return;
   3266              }
   3267          #endif /* USE_SPI_CRC */
   3268          
   3269              /* Disable TXE interrupt */
   3270              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \       0x1E                      REQUIRE ?Subroutine3
   \       0x1E                      ;; // Fall through to label ?Subroutine3
   3271          
   3272              if (hspi->RxXferCount == 0U)
   3273              {
   3274                SPI_CloseRxTx_ISR(hspi);
   3275              }
   3276            }
   3277          }
   3278          
   3279          #if (USE_SPI_CRC != 0U)
   3280          /**
   3281            * @brief  Manage the CRC 8-bit receive in Interrupt context.
   3282            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3283            *               the configuration information for SPI module.
   3284            * @retval None
   3285            */
   3286          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   3287          {
   3288            /* Read 8bit CRC to flush Data Register */
   3289            READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
   3290          
   3291            SPI_CloseRx_ISR(hspi);
   3292          }
   3293          #endif /* USE_SPI_CRC */
   3294          
   3295          /**
   3296            * @brief  Manage the receive 8-bit in Interrupt context.
   3297            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3298            *               the configuration information for SPI module.
   3299            * @retval None
   3300            */

   \                                 In section .text, align 2, keep-with-next
   3301          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3302          {
   \                     SPI_RxISR_8BIT: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x7B09             LDRB     R1,[R1, #+12]
   \        0x4   0x6B82             LDR      R2,[R0, #+56]
   \        0x6   0x7011             STRB     R1,[R2, #+0]
   \        0x8   0x6B81             LDR      R1,[R0, #+56]
   \        0xA   0x1C49             ADDS     R1,R1,#+1
   \        0xC   0x6381             STR      R1,[R0, #+56]
   \        0xE   0x8FC1             LDRH     R1,[R0, #+62]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x87C1             STRH     R1,[R0, #+62]
   \       0x14   0x8FC1             LDRH     R1,[R0, #+62]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD000             BEQ      ??SPI_RxISR_8BIT_0
   \       0x1A   0x4770             BX       LR
   \                     ??SPI_RxISR_8BIT_0: (+1)
   \       0x1C   0xB580             PUSH     {R7,LR}
   3303            *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
   3304            hspi->pRxBuffPtr++;
   3305            hspi->RxXferCount--;
   3306          
   3307          #if (USE_SPI_CRC != 0U)
   3308            /* Enable CRC Transmission */
   3309            if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   3310            {
   3311              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3312            }
   3313          #endif /* USE_SPI_CRC */
   3314          
   3315            if (hspi->RxXferCount == 0U)
   3316            {
   3317          #if (USE_SPI_CRC != 0U)
   3318              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3319              {
   3320                hspi->RxISR =  SPI_RxISR_8BITCRC;
   3321                return;
   3322              }
   3323          #endif /* USE_SPI_CRC */
   3324              SPI_CloseRx_ISR(hspi);
   \       0x1E   0x....'....        BL       SPI_CloseRx_ISR
   3325            }
   3326          }
   \       0x22   0xBD01             POP      {R0,PC}          ;; return
   3327          
   3328          #if (USE_SPI_CRC != 0U)
   3329          /**
   3330            * @brief  Manage the CRC 16-bit receive in Interrupt context.
   3331            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3332            *               the configuration information for SPI module.
   3333            * @retval None
   3334            */
   3335          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   3336          {
   3337            /* Read 16bit CRC to flush Data Register */
   3338            READ_REG(hspi->Instance->DR);
   3339          
   3340            /* Disable RXNE and ERR interrupt */
   3341            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   3342          
   3343            SPI_CloseRx_ISR(hspi);
   3344          }
   3345          #endif /* USE_SPI_CRC */
   3346          
   3347          /**
   3348            * @brief  Manage the 16-bit receive in Interrupt context.
   3349            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3350            *               the configuration information for SPI module.
   3351            * @retval None
   3352            */

   \                                 In section .text, align 2, keep-with-next
   3353          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3354          {
   \                     SPI_RxISR_16BIT: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x68C9             LDR      R1,[R1, #+12]
   \        0x4   0x6B82             LDR      R2,[R0, #+56]
   \        0x6   0x8011             STRH     R1,[R2, #+0]
   \        0x8   0x6B81             LDR      R1,[R0, #+56]
   \        0xA   0x1C89             ADDS     R1,R1,#+2
   \        0xC   0x6381             STR      R1,[R0, #+56]
   \        0xE   0x8FC1             LDRH     R1,[R0, #+62]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x87C1             STRH     R1,[R0, #+62]
   \       0x14   0x8FC1             LDRH     R1,[R0, #+62]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD000             BEQ      ??SPI_RxISR_16BIT_0
   \       0x1A   0x4770             BX       LR
   \                     ??SPI_RxISR_16BIT_0: (+1)
   \       0x1C   0xB580             PUSH     {R7,LR}
   3355            *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
   3356            hspi->pRxBuffPtr += sizeof(uint16_t);
   3357            hspi->RxXferCount--;
   3358          
   3359          #if (USE_SPI_CRC != 0U)
   3360            /* Enable CRC Transmission */
   3361            if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   3362            {
   3363              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3364            }
   3365          #endif /* USE_SPI_CRC */
   3366          
   3367            if (hspi->RxXferCount == 0U)
   3368            {
   3369          #if (USE_SPI_CRC != 0U)
   3370              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3371              {
   3372                hspi->RxISR = SPI_RxISR_16BITCRC;
   3373                return;
   3374              }
   3375          #endif /* USE_SPI_CRC */
   3376              SPI_CloseRx_ISR(hspi);
   \       0x1E   0x....'....        BL       SPI_CloseRx_ISR
   3377            }
   3378          }
   \       0x22   0xBD01             POP      {R0,PC}          ;; return
   3379          
   3380          /**
   3381            * @brief  Handle the data 8-bit transmit in Interrupt mode.
   3382            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3383            *               the configuration information for SPI module.
   3384            * @retval None
   3385            */

   \                                 In section .text, align 2, keep-with-next
   3386          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3387          {
   \                     SPI_TxISR_8BIT: (+1)
   \        0x0   0x6B01             LDR      R1,[R0, #+48]
   \        0x2   0x7809             LDRB     R1,[R1, #+0]
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0x7311             STRB     R1,[R2, #+12]
   \        0x8   0x6B01             LDR      R1,[R0, #+48]
   \        0xA   0x1C49             ADDS     R1,R1,#+1
   \        0xC   0x6301             STR      R1,[R0, #+48]
   \        0xE   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x86C1             STRH     R1,[R0, #+54]
   \       0x14   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD000             BEQ      ??SPI_TxISR_8BIT_0
   \       0x1A   0x4770             BX       LR
   \                     ??SPI_TxISR_8BIT_0: (+1)
   \       0x1C   0xB580             PUSH     {R7,LR}
   3388            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   3389            hspi->pTxBuffPtr++;
   3390            hspi->TxXferCount--;
   3391          
   3392            if (hspi->TxXferCount == 0U)
   3393            {
   3394          #if (USE_SPI_CRC != 0U)
   3395              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3396              {
   3397                /* Enable CRC Transmission */
   3398                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3399              }
   3400          #endif /* USE_SPI_CRC */
   3401              SPI_CloseTx_ISR(hspi);
   \       0x1E   0x....'....        BL       SPI_CloseTx_ISR
   3402            }
   3403          }
   \       0x22   0xBD01             POP      {R0,PC}          ;; return
   3404          
   3405          /**
   3406            * @brief  Handle the data 16-bit transmit in Interrupt mode.
   3407            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3408            *               the configuration information for SPI module.
   3409            * @retval None
   3410            */

   \                                 In section .text, align 2, keep-with-next
   3411          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3412          {
   \                     SPI_TxISR_16BIT: (+1)
   \        0x0   0x6B01             LDR      R1,[R0, #+48]
   \        0x2   0x8809             LDRH     R1,[R1, #+0]
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0x60D1             STR      R1,[R2, #+12]
   \        0x8   0x6B01             LDR      R1,[R0, #+48]
   \        0xA   0x1C89             ADDS     R1,R1,#+2
   \        0xC   0x6301             STR      R1,[R0, #+48]
   \        0xE   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0x86C1             STRH     R1,[R0, #+54]
   \       0x14   0x8EC1             LDRH     R1,[R0, #+54]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD000             BEQ      ??SPI_TxISR_16BIT_0
   \       0x1A   0x4770             BX       LR
   \                     ??SPI_TxISR_16BIT_0: (+1)
   \       0x1C   0xB580             PUSH     {R7,LR}
   3413            /* Transmit data in 16 Bit mode */
   3414            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   3415            hspi->pTxBuffPtr += sizeof(uint16_t);
   3416            hspi->TxXferCount--;
   3417          
   3418            if (hspi->TxXferCount == 0U)
   3419            {
   3420          #if (USE_SPI_CRC != 0U)
   3421              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3422              {
   3423                /* Enable CRC Transmission */
   3424                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3425              }
   3426          #endif /* USE_SPI_CRC */
   3427              SPI_CloseTx_ISR(hspi);
   \       0x1E   0x....'....        BL       SPI_CloseTx_ISR
   3428            }
   3429          }
   \       0x22   0xBD01             POP      {R0,PC}          ;; return
   3430          
   3431          /**
   3432            * @brief  Handle SPI Communication Timeout.
   3433            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3434            *              the configuration information for SPI module.
   3435            * @param  Flag SPI flag to check
   3436            * @param  State flag state to check
   3437            * @param  Timeout Timeout duration
   3438            * @param  Tickstart tick start value
   3439            * @retval HAL status
   3440            */

   \                                 In section .text, align 2, keep-with-next
   3441          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
   3442                                                                 uint32_t Timeout, uint32_t Tickstart)
   3443          {
   \                     SPI_WaitFlagStateUntilTimeout: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2501             MOVS     R5,#+1
   \        0x6   0x0006             MOVS     R6,R0
   \        0x8   0x9101             STR      R1,[SP, #+4]
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x7002             STRB     R2,[R0, #+0]
   \        0xE   0x001F             MOVS     R7,R3
   3444            while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
   \                     ??SPI_WaitFlagStateUntilTimeout_0: (+1)
   \       0x10   0x6830             LDR      R0,[R6, #+0]
   \       0x12   0x6880             LDR      R0,[R0, #+8]
   \       0x14   0x9901             LDR      R1,[SP, #+4]
   \       0x16   0x4001             ANDS     R1,R1,R0
   \       0x18   0x9801             LDR      R0,[SP, #+4]
   \       0x1A   0x4281             CMP      R1,R0
   \       0x1C   0xD101             BNE      ??SPI_WaitFlagStateUntilTimeout_1
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE000             B        ??SPI_WaitFlagStateUntilTimeout_2
   \                     ??SPI_WaitFlagStateUntilTimeout_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitFlagStateUntilTimeout_2: (+1)
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x7809             LDRB     R1,[R1, #+0]
   \       0x28   0x4288             CMP      R0,R1
   \       0x2A   0xD034             BEQ      ??SPI_WaitFlagStateUntilTimeout_3
   3445            {
   3446              if (Timeout != HAL_MAX_DELAY)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x30   0x4287             CMP      R7,R0
   \       0x32   0xD0ED             BEQ      ??SPI_WaitFlagStateUntilTimeout_0
   3447              {
   3448                if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
   \       0x34   0x....'....        BL       HAL_GetTick
   \       0x38   0x9908             LDR      R1,[SP, #+32]
   \       0x3A   0x1A40             SUBS     R0,R0,R1
   \       0x3C   0x42B8             CMP      R0,R7
   \       0x3E   0xD201             BCS      ??SPI_WaitFlagStateUntilTimeout_4
   \       0x40   0x2F00             CMP      R7,#+0
   \       0x42   0xD1E5             BNE      ??SPI_WaitFlagStateUntilTimeout_0
   3449                {
   3450                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   3451                  on both master and slave sides in order to resynchronize the master
   3452                  and slave for their respective CRC calculation */
   3453          
   3454                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   3455                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFlagStateUntilTimeout_4: (+1)
   \       0x44   0x6830             LDR      R0,[R6, #+0]
   \       0x46   0x6841             LDR      R1,[R0, #+4]
   \       0x48   0x22E0             MOVS     R2,#+224
   \       0x4A   0x4391             BICS     R1,R1,R2
   \       0x4C   0x6041             STR      R1,[R0, #+4]
   3456          
   3457                  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
   3458                                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \       0x4E   0x6870             LDR      R0,[R6, #+4]
   \       0x50   0x2182             MOVS     R1,#+130
   \       0x52   0x0049             LSLS     R1,R1,#+1        ;; #+260
   \       0x54   0x4288             CMP      R0,R1
   \       0x56   0xD10B             BNE      ??SPI_WaitFlagStateUntilTimeout_5
   \       0x58   0x68B0             LDR      R0,[R6, #+8]
   \       0x5A   0x03E9             LSLS     R1,R5,#+15
   \       0x5C   0x4288             CMP      R0,R1
   \       0x5E   0xD002             BEQ      ??SPI_WaitFlagStateUntilTimeout_6
   \       0x60   0x0949             LSRS     R1,R1,#+5
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xD104             BNE      ??SPI_WaitFlagStateUntilTimeout_5
   3459                  {
   3460                    /* Disable SPI peripheral */
   3461                    __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_WaitFlagStateUntilTimeout_6: (+1)
   \       0x66   0x6830             LDR      R0,[R6, #+0]
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0x2240             MOVS     R2,#+64
   \       0x6C   0x4391             BICS     R1,R1,R2
   \       0x6E   0x6001             STR      R1,[R0, #+0]
   3462                  }
   3463          
   3464                  /* Reset CRC Calculation */
   3465                  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??SPI_WaitFlagStateUntilTimeout_5: (+1)
   \       0x70   0x0368             LSLS     R0,R5,#+13
   \       0x72   0x6AB1             LDR      R1,[R6, #+40]
   \       0x74   0x4281             CMP      R1,R0
   \       0x76   0xD108             BNE      ??SPI_WaitFlagStateUntilTimeout_7
   3466                  {
   3467                    SPI_RESET_CRC(hspi);
   \       0x78   0x6831             LDR      R1,[R6, #+0]
   \       0x7A   0x680A             LDR      R2,[R1, #+0]
   \       0x7C   0x....             LDR      R3,??DataTable16  ;; 0xffffdfff
   \       0x7E   0x4013             ANDS     R3,R3,R2
   \       0x80   0x600B             STR      R3,[R1, #+0]
   \       0x82   0x6831             LDR      R1,[R6, #+0]
   \       0x84   0x680A             LDR      R2,[R1, #+0]
   \       0x86   0x4310             ORRS     R0,R0,R2
   \       0x88   0x6008             STR      R0,[R1, #+0]
   3468                  }
   3469          
   3470                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_WaitFlagStateUntilTimeout_7: (+1)
   \       0x8A   0x0030             MOVS     R0,R6
   \       0x8C   0x3050             ADDS     R0,R0,#+80
   \       0x8E   0x7045             STRB     R5,[R0, #+1]
   3471          
   3472                  /* Process Unlocked */
   3473                  __HAL_UNLOCK(hspi);
   \       0x90   0x7004             STRB     R4,[R0, #+0]
   3474          
   3475                  return HAL_TIMEOUT;
   \       0x92   0x2003             MOVS     R0,#+3
   \       0x94   0xBDFE             POP      {R1-R7,PC}
   3476                }
   3477              }
   3478            }
   3479          
   3480            return HAL_OK;
   \                     ??SPI_WaitFlagStateUntilTimeout_3: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xBDFE             POP      {R1-R7,PC}       ;; return
   3481          }
   3482          
   3483          /**
   3484            * @brief  Handle the check of the RX transaction complete.
   3485            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3486            *               the configuration information for SPI module.
   3487            * @param  Timeout Timeout duration
   3488            * @param  Tickstart tick start value
   3489            * @retval HAL status
   3490            */

   \                                 In section .text, align 2, keep-with-next
   3491          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
   3492          {
   \                     SPI_EndRxTransaction: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x0004             MOVS     R4,R0
   3493            if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
   3494                                                         || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \        0x6   0x2520             MOVS     R5,#+32
   \        0x8   0x0168             LSLS     R0,R5,#+5
   \        0xA   0x2182             MOVS     R1,#+130
   \        0xC   0x0049             LSLS     R1,R1,#+1        ;; #+260
   \        0xE   0x6863             LDR      R3,[R4, #+4]
   \       0x10   0x428B             CMP      R3,R1
   \       0x12   0xD10A             BNE      ??SPI_EndRxTransaction_0
   \       0x14   0x68A3             LDR      R3,[R4, #+8]
   \       0x16   0x0146             LSLS     R6,R0,#+5
   \       0x18   0x42B3             CMP      R3,R6
   \       0x1A   0xD001             BEQ      ??SPI_EndRxTransaction_1
   \       0x1C   0x4283             CMP      R3,R0
   \       0x1E   0xD107             BNE      ??SPI_EndRxTransaction_2
   3495            {
   3496              /* Disable SPI peripheral */
   3497              __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_EndRxTransaction_1: (+1)
   \       0x20   0x6823             LDR      R3,[R4, #+0]
   \       0x22   0x681E             LDR      R6,[R3, #+0]
   \       0x24   0x2740             MOVS     R7,#+64
   \       0x26   0x43BE             BICS     R6,R6,R7
   \       0x28   0x601E             STR      R6,[R3, #+0]
   3498            }
   3499          
   3500            /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
   3501            if (hspi->Init.Mode == SPI_MODE_MASTER)
   \                     ??SPI_EndRxTransaction_0: (+1)
   \       0x2A   0x6863             LDR      R3,[R4, #+4]
   \       0x2C   0x428B             CMP      R3,R1
   \       0x2E   0xD107             BNE      ??SPI_EndRxTransaction_3
   3502            {
   3503              if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
   \                     ??SPI_EndRxTransaction_2: (+1)
   \       0x30   0x68A1             LDR      R1,[R4, #+8]
   \       0x32   0x4281             CMP      R1,R0
   \       0x34   0x9200             STR      R2,[SP, #+0]
   \       0x36   0x9B02             LDR      R3,[SP, #+8]
   \       0x38   0xD004             BEQ      ??SPI_EndRxTransaction_4
   3504              {
   3505                /* Control the BSY flag */
   3506                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x2180             MOVS     R1,#+128
   \       0x3E   0xE003             B.N      ??SPI_EndRxTransaction_5
   3507                {
   3508                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3509                  return HAL_TIMEOUT;
   3510                }
   3511              }
   3512              else
   3513              {
   3514                /* Wait the RXNE reset */
   3515                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
   3516                {
   3517                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3518                  return HAL_TIMEOUT;
   3519                }
   3520              }
   3521            }
   3522            else
   3523            {
   3524              /* Wait the RXNE reset */
   3525              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??SPI_EndRxTransaction_3: (+1)
   \       0x40   0x9200             STR      R2,[SP, #+0]
   \       0x42   0x9B02             LDR      R3,[SP, #+8]
   \                     ??SPI_EndRxTransaction_4: (+1)
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x2101             MOVS     R1,#+1
   \                     ??SPI_EndRxTransaction_5: (+1)
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x....'....        BL       SPI_WaitFlagStateUntilTimeout
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD004             BEQ      ??SPI_EndRxTransaction_6
   3526              {
   3527                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x52   0x6D60             LDR      R0,[R4, #+84]
   \       0x54   0x4305             ORRS     R5,R5,R0
   \       0x56   0x6565             STR      R5,[R4, #+84]
   3528                return HAL_TIMEOUT;
   \       0x58   0x2003             MOVS     R0,#+3
   \       0x5A   0xBDFE             POP      {R1-R7,PC}
   3529              }
   3530            }
   3531            return HAL_OK;
   \                     ??SPI_EndRxTransaction_6: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xBDFE             POP      {R1-R7,PC}       ;; return
   3532          }
   3533          
   3534          /**
   3535            * @brief  Handle the check of the RXTX or TX transaction complete.
   3536            * @param  hspi SPI handle
   3537            * @param  Timeout Timeout duration
   3538            * @param  Tickstart tick start value
   3539            * @retval HAL status
   3540            */

   \                                 In section .text, align 2, keep-with-next
   3541          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
   3542          {
   \                     SPI_EndRxTxTransaction: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000B             MOVS     R3,R1
   3543            /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
   3544            if (hspi->Init.Mode == SPI_MODE_MASTER)
   \        0x6   0x2520             MOVS     R5,#+32
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0x2182             MOVS     R1,#+130
   \        0xC   0x0049             LSLS     R1,R1,#+1        ;; #+260
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD103             BNE      ??SPI_EndRxTxTransaction_0
   3545            {
   3546              /* Control the BSY flag */
   3547              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x12   0x9200             STR      R2,[SP, #+0]
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x2180             MOVS     R1,#+128
   \       0x18   0xE006             B.N      ??SPI_EndRxTxTransaction_1
   3548              {
   3549                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3550                return HAL_TIMEOUT;
   3551              }
   3552            }
   3553            else
   3554            {
   3555              /* Control RXNE flag in case of Full-Duplex transfer */
   3556              if (hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \                     ??SPI_EndRxTxTransaction_0: (+1)
   \       0x1A   0x2051             MOVS     R0,#+81
   \       0x1C   0x5C20             LDRB     R0,[R4, R0]
   \       0x1E   0x2805             CMP      R0,#+5
   \       0x20   0xD10C             BNE      ??SPI_EndRxTxTransaction_2
   3557              {
   3558                /* Wait the RXNE reset */
   3559                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x22   0x9200             STR      R2,[SP, #+0]
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x2101             MOVS     R1,#+1
   \                     ??SPI_EndRxTxTransaction_1: (+1)
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x....'....        BL       SPI_WaitFlagStateUntilTimeout
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD004             BEQ      ??SPI_EndRxTxTransaction_2
   3560                {
   3561                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x32   0x6D60             LDR      R0,[R4, #+84]
   \       0x34   0x4305             ORRS     R5,R5,R0
   \       0x36   0x6565             STR      R5,[R4, #+84]
   3562                  return HAL_TIMEOUT;
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
   3563                }
   3564              }
   3565            }
   3566            return HAL_OK;
   \                     ??SPI_EndRxTxTransaction_2: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3567          }
   3568          
   3569          /**
   3570            * @brief  Handle the end of the RXTX transaction.
   3571            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3572            *               the configuration information for SPI module.
   3573            * @retval None
   3574            */

   \                                 In section .text, align 2, keep-with-next
   3575          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
   3576          {
   \                     SPI_CloseRxTx_ISR: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3577            uint32_t tickstart;
   3578            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0x4   0x....             LDR      R0,??DataTable16_1
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x2118             MOVS     R1,#+24
   \        0xA   0x....'....        BL       __aeabi_uidiv
   \        0xE   0x21FA             MOVS     R1,#+250
   \       0x10   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x12   0x....'....        BL       __aeabi_uidiv
   \       0x16   0x2164             MOVS     R1,#+100
   \       0x18   0x4348             MULS     R0,R1,R0
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   3579          
   3580            /* Init tickstart for timeout managment*/
   3581            tickstart = HAL_GetTick();
   \       0x1C   0x....'....        BL       HAL_GetTick
   3582          
   3583            /* Disable ERR interrupt */
   3584            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x684A             LDR      R2,[R1, #+4]
   \       0x24   0x2320             MOVS     R3,#+32
   \       0x26   0x439A             BICS     R2,R2,R3
   \       0x28   0x604A             STR      R2,[R1, #+4]
   3585          
   3586            /* Wait until TXE flag is set */
   3587            do
   3588            {
   3589              if (count == 0U)
   \                     ??SPI_CloseRxTx_ISR_0: (+1)
   \       0x2A   0x9900             LDR      R1,[SP, #+0]
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD007             BEQ      ??SPI_CloseRxTx_ISR_1
   3590              {
   3591                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3592                break;
   3593              }
   3594              count--;
   \       0x30   0x9900             LDR      R1,[SP, #+0]
   \       0x32   0x1E49             SUBS     R1,R1,#+1
   \       0x34   0x9100             STR      R1,[SP, #+0]
   3595            }
   3596            while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6889             LDR      R1,[R1, #+8]
   \       0x3A   0x0789             LSLS     R1,R1,#+30
   \       0x3C   0xD5F5             BPL      ??SPI_CloseRxTx_ISR_0
   \       0x3E   0xE003             B        ??SPI_CloseRxTx_ISR_2
   \                     ??SPI_CloseRxTx_ISR_1: (+1)
   \       0x40   0x6D61             LDR      R1,[R4, #+84]
   \       0x42   0x2220             MOVS     R2,#+32
   \       0x44   0x430A             ORRS     R2,R2,R1
   \       0x46   0x6562             STR      R2,[R4, #+84]
   3597          
   3598            /* Check the end of the transaction */
   3599            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \                     ??SPI_CloseRxTx_ISR_2: (+1)
   \       0x48   0x0002             MOVS     R2,R0
   \       0x4A   0x2164             MOVS     R1,#+100
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x....'....        BL       SPI_EndRxTxTransaction
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD003             BEQ      ??SPI_CloseRxTx_ISR_3
   3600            {
   3601              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x56   0x6D60             LDR      R0,[R4, #+84]
   \       0x58   0x2120             MOVS     R1,#+32
   \       0x5A   0x4301             ORRS     R1,R1,R0
   \       0x5C   0x6561             STR      R1,[R4, #+84]
   3602            }
   3603          
   3604            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   3605            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_CloseRxTx_ISR_3: (+1)
   \       0x5E   0x68A0             LDR      R0,[R4, #+8]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD106             BNE      ??SPI_CloseRxTx_ISR_4
   3606            {
   3607              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x64   0x9000             STR      R0,[SP, #+0]
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x68C1             LDR      R1,[R0, #+12]
   \       0x6A   0x9100             STR      R1,[SP, #+0]
   \       0x6C   0x6880             LDR      R0,[R0, #+8]
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   3608            }
   3609          
   3610          #if (USE_SPI_CRC != 0U)
   3611            /* Check if CRC error occurred */
   3612            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   3613            {
   3614              hspi->State = HAL_SPI_STATE_READY;
   3615              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3616              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   3617              /* Call user error callback */
   3618          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3619              hspi->ErrorCallback(hspi);
   3620          #else
   3621              HAL_SPI_ErrorCallback(hspi);
   3622          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3623            }
   3624            else
   3625            {
   3626          #endif /* USE_SPI_CRC */
   3627              if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRxTx_ISR_4: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x6D61             LDR      R1,[R4, #+84]
   \       0x76   0x2900             CMP      R1,#+0
   \       0x78   0xD10C             BNE      ??SPI_CloseRxTx_ISR_5
   3628              {
   3629                if (hspi->State == HAL_SPI_STATE_BUSY_RX)
   \       0x7A   0x2151             MOVS     R1,#+81
   \       0x7C   0x5C61             LDRB     R1,[R4, R1]
   \       0x7E   0x2904             CMP      R1,#+4
   \       0x80   0xD102             BNE      ??SPI_CloseRxTx_ISR_6
   3630                {
   3631                  hspi->State = HAL_SPI_STATE_READY;
   \       0x82   0x2151             MOVS     R1,#+81
   \       0x84   0x5460             STRB     R0,[R4, R1]
   3632                  /* Call user Rx complete callback */
   3633          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3634                  hspi->RxCpltCallback(hspi);
   3635          #else
   3636                  HAL_SPI_RxCpltCallback(hspi);
   \       0x86   0x....             B.N      ?Subroutine5
   3637          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3638                }
   3639                else
   3640                {
   3641                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_6: (+1)
   \       0x88   0x2151             MOVS     R1,#+81
   \       0x8A   0x5460             STRB     R0,[R4, R1]
   3642                  /* Call user TxRx complete callback */
   3643          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3644                  hspi->TxRxCpltCallback(hspi);
   3645          #else
   3646                  HAL_SPI_TxRxCpltCallback(hspi);
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0x....'....        BL       HAL_SPI_TxRxCpltCallback
   \       0x92   0xBD13             POP      {R0,R1,R4,PC}
   3647          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3648                }
   3649              }
   3650              else
   3651              {
   3652                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_5: (+1)
   \       0x94   0x2151             MOVS     R1,#+81
   \       0x96   0x5460             STRB     R0,[R4, R1]
   3653                /* Call user error callback */
   3654          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3655                hspi->ErrorCallback(hspi);
   3656          #else
   3657                HAL_SPI_ErrorCallback(hspi);
   \       0x98   0x....             B.N      ?Subroutine4
   3658          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3659              }
   3660          #if (USE_SPI_CRC != 0U)
   3661            }
   3662          #endif /* USE_SPI_CRC */
   3663          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x0020             MOVS     R0,R4
   \        0x2   0x....'....        BL       HAL_SPI_RxCpltCallback
   \        0x6   0xBD13             POP      {R0,R1,R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x0020             MOVS     R0,R4
   \        0x2   0x....'....        BL       HAL_SPI_ErrorCallback
   \        0x6   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   3664          
   3665          /**
   3666            * @brief  Handle the end of the RX transaction.
   3667            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3668            *               the configuration information for SPI module.
   3669            * @retval None
   3670            */

   \                                 In section .text, align 2, keep-with-next
   3671          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
   3672          {
   \                     SPI_CloseRx_ISR: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3673            /* Disable RXNE and ERR interrupt */
   3674            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0x2260             MOVS     R2,#+96
   \        0xA   0x4391             BICS     R1,R1,R2
   \        0xC   0x6041             STR      R1,[R0, #+4]
   3675          
   3676            /* Check the end of the transaction */
   3677            if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   \        0xE   0x....'....        BL       HAL_GetTick
   \       0x12   0x0002             MOVS     R2,R0
   \       0x14   0x2164             MOVS     R1,#+100
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x....'....        BL       SPI_EndRxTransaction
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD003             BEQ      ??SPI_CloseRx_ISR_0
   3678            {
   3679              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x20   0x6D60             LDR      R0,[R4, #+84]
   \       0x22   0x2120             MOVS     R1,#+32
   \       0x24   0x4301             ORRS     R1,R1,R0
   \       0x26   0x6561             STR      R1,[R4, #+84]
   3680            }
   3681          
   3682            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   3683            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_CloseRx_ISR_0: (+1)
   \       0x28   0x68A0             LDR      R0,[R4, #+8]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD106             BNE      ??SPI_CloseRx_ISR_1
   3684            {
   3685              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x68C1             LDR      R1,[R0, #+12]
   \       0x34   0x9100             STR      R1,[SP, #+0]
   \       0x36   0x6880             LDR      R0,[R0, #+8]
   \       0x38   0x9000             STR      R0,[SP, #+0]
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   3686            }
   3687            hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRx_ISR_1: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x2151             MOVS     R1,#+81
   \       0x40   0x5460             STRB     R0,[R4, R1]
   3688          
   3689          #if (USE_SPI_CRC != 0U)
   3690            /* Check if CRC error occurred */
   3691            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   3692            {
   3693              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3694              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   3695              /* Call user error callback */
   3696          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3697              hspi->ErrorCallback(hspi);
   3698          #else
   3699              HAL_SPI_ErrorCallback(hspi);
   3700          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3701            }
   3702            else
   3703            {
   3704          #endif /* USE_SPI_CRC */
   3705              if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \       0x42   0x6D60             LDR      R0,[R4, #+84]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD100             BNE      ??SPI_CloseRx_ISR_2
   3706              {
   3707                /* Call user Rx complete callback */
   3708          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3709                hspi->RxCpltCallback(hspi);
   3710          #else
   3711                HAL_SPI_RxCpltCallback(hspi);
   \       0x48   0x....             B.N      ?Subroutine5
   3712          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3713              }
   3714              else
   3715              {
   3716                /* Call user error callback */
   3717          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3718                hspi->ErrorCallback(hspi);
   3719          #else
   3720                HAL_SPI_ErrorCallback(hspi);
   \                     ??SPI_CloseRx_ISR_2: (+1)
   \       0x4A   0x....             B.N      ?Subroutine4
   3721          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3722              }
   3723          #if (USE_SPI_CRC != 0U)
   3724            }
   3725          #endif /* USE_SPI_CRC */
   3726          }
   3727          
   3728          /**
   3729            * @brief  Handle the end of the TX transaction.
   3730            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3731            *               the configuration information for SPI module.
   3732            * @retval None
   3733            */

   \                                 In section .text, align 2, keep-with-next
   3734          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
   3735          {
   \                     SPI_CloseTx_ISR: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3736            uint32_t tickstart;
   3737            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0x4   0x....             LDR      R0,??DataTable16_1
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x2118             MOVS     R1,#+24
   \        0xA   0x....'....        BL       __aeabi_uidiv
   \        0xE   0x21FA             MOVS     R1,#+250
   \       0x10   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x12   0x....'....        BL       __aeabi_uidiv
   \       0x16   0x2164             MOVS     R1,#+100
   \       0x18   0x4348             MULS     R0,R1,R0
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   3738          
   3739            /* Init tickstart for timeout management*/
   3740            tickstart = HAL_GetTick();
   \       0x1C   0x....'....        BL       HAL_GetTick
   3741          
   3742            /* Wait until TXE flag is set */
   3743            do
   3744            {
   3745              if (count == 0U)
   \                     ??SPI_CloseTx_ISR_0: (+1)
   \       0x20   0x9900             LDR      R1,[SP, #+0]
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD007             BEQ      ??SPI_CloseTx_ISR_1
   3746              {
   3747                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3748                break;
   3749              }
   3750              count--;
   \       0x26   0x9900             LDR      R1,[SP, #+0]
   \       0x28   0x1E49             SUBS     R1,R1,#+1
   \       0x2A   0x9100             STR      R1,[SP, #+0]
   3751            }
   3752            while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6889             LDR      R1,[R1, #+8]
   \       0x30   0x0789             LSLS     R1,R1,#+30
   \       0x32   0xD5F5             BPL      ??SPI_CloseTx_ISR_0
   \       0x34   0xE003             B        ??SPI_CloseTx_ISR_2
   \                     ??SPI_CloseTx_ISR_1: (+1)
   \       0x36   0x6D61             LDR      R1,[R4, #+84]
   \       0x38   0x2220             MOVS     R2,#+32
   \       0x3A   0x430A             ORRS     R2,R2,R1
   \       0x3C   0x6562             STR      R2,[R4, #+84]
   3753          
   3754            /* Disable TXE and ERR interrupt */
   3755            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \                     ??SPI_CloseTx_ISR_2: (+1)
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x684A             LDR      R2,[R1, #+4]
   \       0x42   0x23A0             MOVS     R3,#+160
   \       0x44   0x439A             BICS     R2,R2,R3
   \       0x46   0x604A             STR      R2,[R1, #+4]
   3756          
   3757            /* Check the end of the transaction */
   3758            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \       0x48   0x0002             MOVS     R2,R0
   \       0x4A   0x2164             MOVS     R1,#+100
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x....'....        BL       SPI_EndRxTxTransaction
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD003             BEQ      ??SPI_CloseTx_ISR_3
   3759            {
   3760              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x56   0x6D60             LDR      R0,[R4, #+84]
   \       0x58   0x2120             MOVS     R1,#+32
   \       0x5A   0x4301             ORRS     R1,R1,R0
   \       0x5C   0x6561             STR      R1,[R4, #+84]
   3761            }
   3762          
   3763            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   3764            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_CloseTx_ISR_3: (+1)
   \       0x5E   0x68A0             LDR      R0,[R4, #+8]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD106             BNE      ??SPI_CloseTx_ISR_4
   3765            {
   3766              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x64   0x9000             STR      R0,[SP, #+0]
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x68C1             LDR      R1,[R0, #+12]
   \       0x6A   0x9100             STR      R1,[SP, #+0]
   \       0x6C   0x6880             LDR      R0,[R0, #+8]
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   3767            }
   3768          
   3769            hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseTx_ISR_4: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x2151             MOVS     R1,#+81
   \       0x76   0x5460             STRB     R0,[R4, R1]
   3770            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \       0x78   0x6D60             LDR      R0,[R4, #+84]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD000             BEQ      ??SPI_CloseTx_ISR_5
   3771            {
   3772              /* Call user error callback */
   3773          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3774              hspi->ErrorCallback(hspi);
   3775          #else
   3776              HAL_SPI_ErrorCallback(hspi);
   \       0x7E   0x....             B.N      ?Subroutine4
   3777          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3778            }
   3779            else
   3780            {
   3781              /* Call user Rx complete callback */
   3782          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3783              hspi->TxCpltCallback(hspi);
   3784          #else
   3785              HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_CloseTx_ISR_5: (+1)
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x....'....        BL       HAL_SPI_TxCpltCallback
   3786          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3787            }
   3788          }
   \       0x86   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   3789          
   3790          /**
   3791            * @brief  Handle abort a Rx transaction.
   3792            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3793            *               the configuration information for SPI module.
   3794            * @retval None
   3795            */

   \                                 In section .text, align 2, keep-with-next
   3796          static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
   3797          {
   \                     SPI_AbortRx_ISR: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3798            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0x4   0x....             LDR      R0,??DataTable16_1
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x2118             MOVS     R1,#+24
   \        0xA   0x....'....        BL       __aeabi_uidiv
   \        0xE   0x21FA             MOVS     R1,#+250
   \       0x10   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x12   0x....'....        BL       __aeabi_uidiv
   \       0x16   0x2164             MOVS     R1,#+100
   \       0x18   0x4348             MULS     R0,R1,R0
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   3799          
   3800            /* Wait until TXE flag is set */
   3801            do
   3802            {
   3803              if (count == 0U)
   \                     ??SPI_AbortRx_ISR_0: (+1)
   \       0x1C   0x9800             LDR      R0,[SP, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD007             BEQ      ??SPI_AbortRx_ISR_1
   3804              {
   3805                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   3806                break;
   3807              }
   3808              count--;
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x9000             STR      R0,[SP, #+0]
   3809            }
   3810            while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x6880             LDR      R0,[R0, #+8]
   \       0x2C   0x0780             LSLS     R0,R0,#+30
   \       0x2E   0xD5F5             BPL      ??SPI_AbortRx_ISR_0
   \       0x30   0xE003             B        ??SPI_AbortRx_ISR_2
   \                     ??SPI_AbortRx_ISR_1: (+1)
   \       0x32   0x6D60             LDR      R0,[R4, #+84]
   \       0x34   0x2140             MOVS     R1,#+64
   \       0x36   0x4301             ORRS     R1,R1,R0
   \       0x38   0x6561             STR      R1,[R4, #+84]
   3811          
   3812            /* Disable SPI Peripheral */
   3813            __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_AbortRx_ISR_2: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x2240             MOVS     R2,#+64
   \       0x40   0x4391             BICS     R1,R1,R2
   \       0x42   0x6001             STR      R1,[R0, #+0]
   3814          
   3815            /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
   3816            CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6841             LDR      R1,[R0, #+4]
   \       0x48   0x22E0             MOVS     R2,#+224
   \       0x4A   0x4391             BICS     R1,R1,R2
   \       0x4C   0x6041             STR      R1,[R0, #+4]
   3817          
   3818            /* Read CRC to flush Data Register */
   3819            READ_REG(hspi->Instance->DR);
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x68C0             LDR      R0,[R0, #+12]
   3820          
   3821            hspi->State = HAL_SPI_STATE_ABORT;
   \       0x52   0x2007             MOVS     R0,#+7
   \       0x54   0x2151             MOVS     R1,#+81
   \       0x56   0x5460             STRB     R0,[R4, R1]
   3822          }
   \       0x58   0xBD11             POP      {R0,R4,PC}       ;; return
   3823          
   3824          /**
   3825            * @brief  Handle abort a Tx or Rx/Tx transaction.
   3826            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3827            *               the configuration information for SPI module.
   3828            * @retval None
   3829            */

   \                                 In section .text, align 2, keep-with-next
   3830          static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
   3831          {
   3832            /* Disable TXEIE interrupt */
   3833            CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE));
   \                     SPI_AbortTx_ISR: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x684A             LDR      R2,[R1, #+4]
   \        0x4   0x2380             MOVS     R3,#+128
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x604A             STR      R2,[R1, #+4]
   3834          
   3835            /* Disable SPI Peripheral */
   3836            __HAL_SPI_DISABLE(hspi);
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0x2340             MOVS     R3,#+64
   \       0x10   0x439A             BICS     R2,R2,R3
   \       0x12   0x600A             STR      R2,[R1, #+0]
   3837          
   3838            hspi->State = HAL_SPI_STATE_ABORT;
   \       0x14   0x2107             MOVS     R1,#+7
   \       0x16   0x2251             MOVS     R2,#+81
   \       0x18   0x5481             STRB     R1,[R0, R2]
   3839          }
   \       0x1A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xFFFF'BFFF        DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x0000'FFFF        DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     SPI_TxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     SPI_TxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     SPI_RxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     SPI_RxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0xFFFF'BFFF        DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x....'....        DC32     SPI_2linesRxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x....'....        DC32     SPI_2linesTxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x....'....        DC32     SPI_2linesRxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     SPI_2linesTxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     SPI_DMAHalfTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     SPI_DMATransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     SPI_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     SPI_DMAHalfReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     SPI_DMAReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     SPI_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x....'....        DC32     SPI_DMAHalfTransmitReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x....'....        DC32     SPI_DMATransmitReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     SPI_AbortTx_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     SPI_AbortRx_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     SPI_DMATxAbortCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     SPI_DMARxAbortCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     SPI_DMAAbortOnError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xFFFF'DFFF        DC32     0xffffdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     SystemCoreClock
   3840          
   3841          /**
   3842            * @}
   3843            */
   3844          
   3845          #endif /* HAL_SPI_MODULE_ENABLED */
   3846          
   3847          /**
   3848            * @}
   3849            */
   3850          
   3851          /**
   3852            * @}
   3853            */
   3854          
   3855          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   HAL_SPI_Abort
        32   -> HAL_DMA_Abort
        32 __aeabi_uidiv
       0   HAL_SPI_AbortCpltCallback
      40   HAL_SPI_Abort_IT
        40   -> HAL_DMA_Abort_IT
        40   -> HAL_SPI_AbortCpltCallback
        40 __aeabi_uidiv
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
      24   HAL_SPI_DMAStop
        24   -> HAL_DMA_Abort
       8   HAL_SPI_DeInit
         8   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
      32   HAL_SPI_IRQHandler
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_SPI_ErrorCallback
      16   HAL_SPI_Init
        16   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      32   HAL_SPI_Receive
        32   -> HAL_GetTick
        32   -> HAL_SPI_TransmitReceive
        32   -> SPI_EndRxTransaction
      32   HAL_SPI_Receive_DMA
        32   -> HAL_DMA_Start_IT
        32   -> HAL_SPI_TransmitReceive_DMA
      32   HAL_SPI_Receive_IT
        32   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      32   HAL_SPI_Transmit
        32   -> HAL_GetTick
        32   -> SPI_EndRxTxTransaction
      40   HAL_SPI_TransmitReceive
        40   -> HAL_GetTick
        40   -> SPI_EndRxTxTransaction
      32   HAL_SPI_TransmitReceive_DMA
        32   -> HAL_DMA_Start_IT
      28   HAL_SPI_TransmitReceive_IT
      24   HAL_SPI_Transmit_DMA
        24   -> HAL_DMA_Start_IT
      20   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       8   SPI_2linesRxISR_16BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_8BIT
         8   -> SPI_CloseRxTx_ISR
       0   SPI_2linesTxISR_16BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_2linesTxISR_8BIT
         8   -> SPI_CloseRxTx_ISR
      12   SPI_AbortRx_ISR
        12 __aeabi_uidiv
       0   SPI_AbortTx_ISR
      16   SPI_CloseRxTx_ISR
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_EndRxTxTransaction
        16 __aeabi_uidiv
      16   SPI_CloseRx_ISR
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_EndRxTransaction
      16   SPI_CloseTx_ISR
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> SPI_EndRxTxTransaction
        16 __aeabi_uidiv
       8   SPI_DMAAbortOnError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_EndRxTransaction
      16   SPI_DMARxAbortCallback
        16   -> HAL_GetTick
        16   -> HAL_SPI_AbortCpltCallback
        16   -> SPI_EndRxTxTransaction
      24   SPI_DMATransmitCplt
        24   -> HAL_GetTick
        24   -> HAL_SPI_ErrorCallback
        24   -> HAL_SPI_TxCpltCallback
        24   -> SPI_EndRxTxTransaction
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_EndRxTxTransaction
      16   SPI_DMATxAbortCallback
        16   -> HAL_SPI_AbortCpltCallback
        16 __aeabi_uidiv
      32   SPI_EndRxTransaction
        32   -> SPI_WaitFlagStateUntilTimeout
      16   SPI_EndRxTxTransaction
        16   -> SPI_WaitFlagStateUntilTimeout
       8   SPI_RxISR_16BIT
         8   -> SPI_CloseRx_ISR
       8   SPI_RxISR_8BIT
         8   -> SPI_CloseRx_ISR
       8   SPI_TxISR_16BIT
         8   -> SPI_CloseTx_ISR
       8   SPI_TxISR_8BIT
         8   -> SPI_CloseTx_ISR
      32   SPI_WaitFlagStateUntilTimeout
        32   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable2
       4  ??DataTable4
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       8  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine2
      22  ?Subroutine3
       8  ?Subroutine4
       8  ?Subroutine5
     296  HAL_SPI_Abort
       2  HAL_SPI_AbortCpltCallback
     310  HAL_SPI_Abort_IT
      30  HAL_SPI_DMAPause
      28  HAL_SPI_DMAResume
      72  HAL_SPI_DMAStop
      42  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     266  HAL_SPI_IRQHandler
     124  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     356  HAL_SPI_Receive
     234  HAL_SPI_Receive_DMA
     172  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     416  HAL_SPI_Transmit
     532  HAL_SPI_TransmitReceive
     276  HAL_SPI_TransmitReceive_DMA
     170  HAL_SPI_TransmitReceive_IT
     198  HAL_SPI_Transmit_DMA
     138  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      44  SPI_2linesRxISR_16BIT
      44  SPI_2linesRxISR_8BIT
      30  SPI_2linesTxISR_16BIT
      32  SPI_2linesTxISR_8BIT
      90  SPI_AbortRx_ISR
      28  SPI_AbortTx_ISR
     154  SPI_CloseRxTx_ISR
      76  SPI_CloseRx_ISR
     136  SPI_CloseTx_ISR
      16  SPI_DMAAbortOnError
      34  SPI_DMAError
      10  SPI_DMAHalfReceiveCplt
      10  SPI_DMAHalfTransmitCplt
      10  SPI_DMAHalfTransmitReceiveCplt
      80  SPI_DMAReceiveCplt
     116  SPI_DMARxAbortCallback
     110  SPI_DMATransmitCplt
      86  SPI_DMATransmitReceiveCplt
     134  SPI_DMATxAbortCallback
      96  SPI_EndRxTransaction
      64  SPI_EndRxTxTransaction
      36  SPI_RxISR_16BIT
      36  SPI_RxISR_8BIT
      36  SPI_TxISR_16BIT
      36  SPI_TxISR_8BIT
     154  SPI_WaitFlagStateUntilTimeout

 
 5'568 bytes in section .text
 
 5'548 bytes of CODE memory (+ 20 bytes shared)

Errors: none
Warnings: none
